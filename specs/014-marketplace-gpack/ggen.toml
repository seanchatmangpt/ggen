# ============================================================================
# ggen v6 Configuration: Spec-Kit Feature - we now need to work on command 2 'ggen marketplace' there is already a lot of code for this that needs to be completely retrofitted. The core issue was that I was reinventing the wheel by creating my own distribution method. Instead we will have '*-gpack' which can be publish to crates.io. Consider all JTBDs after searching the entire project for the word 'marketplace'
# ============================================================================
# Generated by: vendors/spec-kit/scripts/bash/generate-ggen-config.sh
# Branch: 014-marketplace-gpack
# ============================================================================

[project]
name = "we-now-need-to-work-on-command-2-'ggen-marketplace'-there-is-already-a-lot-of-code-for-this-that-needs-to-be-completely-retrofitted.-the-core-issue-was-that-i-was-reinventing-the-wheel-by-creating-my-own-distribution-method.-instead-we-will-have-'*-gpack'-which-can-be-publish-to-crates.io.-consider-all-jtbds-after-searching-the-entire-project-for-the-word-'marketplace'"
version = "1.0.0"
description = "we now need to work on command 2 'ggen marketplace' there is already a lot of code for this that needs to be completely retrofitted. The core issue was that I was reinventing the wheel by creating my own distribution method. Instead we will have '*-gpack' which can be publish to crates.io. Consider all JTBDs after searching the entire project for the word 'marketplace' specification"

# ----------------------------------------------------------------------------
# v6 Pipeline Configuration
# ----------------------------------------------------------------------------

[v6]
enabled = true
ontology = "ontology/spec-kit-schema.ttl,ontology/feature-content.ttl"
output_dir = "generated"

# Five-stage pipeline (μ₁ → μ₂ → μ₃ → μ₄ → μ₅)
[v6.passes]
normalization = { order = 1, type = "construct", enabled = true }
extraction = { order = 2, type = "select", enabled = true }
emission = { order = 3, type = "tera", enabled = true }
canonicalization = { order = 4, type = "format", enabled = true }
receipt = { order = 5, type = "hash", enabled = true }

# Constitutional invariants enforcement
[v6.invariants]
idempotence = true       # μ∘μ = μ (running twice produces zero changes)
determinism = true       # Same ontology → same output (cross-platform)
provenance = true        # Cryptographic receipt proves spec.md = μ(ontology)
no_edit = true          # Generated files never manually edited
substrate_only = true   # Only .ttl files version-controlled as truth

# Vocabulary governance (allowed RDF namespaces)
[v6.vocabulary]
allowed = [
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "http://www.w3.org/2000/01/rdf-schema#",
    "http://www.w3.org/2001/XMLSchema#",
    "http://www.w3.org/ns/shacl#",
    "http://github.com/github/spec-kit#",
]

# ----------------------------------------------------------------------------
# Generation Rules (SPARQL → Tera → Markdown)
# ----------------------------------------------------------------------------

# Complete Specification (Single File)
[[generation]]
name = "spec"
description = "Generate complete specification from RDF ontology"
query = """
PREFIX sk: <http://github.com/github/spec-kit#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?featureBranch ?featureName ?created ?status ?userInput
       ?storyIndex ?title ?priority ?description ?priorityRationale ?independentTest
       ?scenarioIndex ?given ?when ?then
       ?requirementId ?reqDescription ?category
       ?criterionId ?scDescription ?measurable ?metric ?target
       ?entityName ?definition ?keyAttributes
       ?edgeScenario ?expectedBehavior
       ?assumption
WHERE {
    # Feature metadata
    ?feature a sk:Feature ;
             sk:featureBranch ?featureBranch ;
             sk:featureName ?featureName ;
             sk:created ?created ;
             sk:status ?status .
    OPTIONAL { ?feature sk:userInput ?userInput }

    # User stories with nested acceptance scenarios
    OPTIONAL {
        ?feature sk:hasUserStory ?story .
        ?story sk:storyIndex ?storyIndex ;
               sk:title ?title ;
               sk:priority ?priority ;
               sk:description ?description ;
               sk:priorityRationale ?priorityRationale ;
               sk:independentTest ?independentTest ;
               sk:hasAcceptanceScenario ?scenario .
        ?scenario sk:scenarioIndex ?scenarioIndex ;
                  sk:given ?given ;
                  sk:when ?when ;
                  sk:then ?then .
    }

    # Functional requirements
    OPTIONAL {
        ?feature sk:hasFunctionalRequirement ?req .
        ?req sk:requirementId ?requirementId ;
             sk:description ?reqDescription .
        OPTIONAL { ?req sk:category ?category }
    }

    # Success criteria
    OPTIONAL {
        ?feature sk:hasSuccessCriterion ?criterion .
        ?criterion sk:criterionId ?criterionId ;
                   sk:description ?scDescription ;
                   sk:measurable ?measurable .
        OPTIONAL { ?criterion sk:metric ?metric }
        OPTIONAL { ?criterion sk:target ?target }
    }

    # Entities
    OPTIONAL {
        ?feature sk:hasEntity ?entity .
        ?entity sk:entityName ?entityName ;
                sk:definition ?definition .
        OPTIONAL { ?entity sk:keyAttributes ?keyAttributes }
    }

    # Edge cases
    OPTIONAL {
        ?feature sk:hasEdgeCase ?edgeCase .
        ?edgeCase sk:scenario ?edgeScenario ;
                  sk:expectedBehavior ?expectedBehavior .
    }

    # Assumptions
    OPTIONAL {
        ?feature sk:hasAssumption ?assumption .
        ?assumption sk:description ?assumption .
    }
}
ORDER BY ?storyIndex ?scenarioIndex ?requirementId ?criterionId ?entityName
"""
template = "templates/spec.tera"
output = "generated/spec.md"

# ----------------------------------------------------------------------------
# SHACL Validation Configuration (μ₁ Pass)
# ----------------------------------------------------------------------------

[v6.validation]
enabled = true
shapes_file = "ontology/spec-kit-schema.ttl"
fail_on_violation = true

# ----------------------------------------------------------------------------
# Guards (Forbidden Output Patterns)
# ----------------------------------------------------------------------------

[v6.guards]
enabled = true

[[v6.guards.patterns]]
pattern = 'ghp_[a-zA-Z0-9]{36}'
description = "GitHub personal access token"

[[v6.guards.patterns]]
pattern = 'sk-[a-zA-Z0-9]{48}'
description = "OpenAI API key"

[[v6.guards.patterns]]
pattern = '/Users/[a-zA-Z0-9_-]+/'
description = "macOS absolute path"

[[v6.guards.patterns]]
pattern = 'C:\\\\Users\\\\'
description = "Windows absolute path"

# ----------------------------------------------------------------------------
# Canonicalization Rules (μ₄ Pass)
# ----------------------------------------------------------------------------

[v6.canonicalization]
line_endings = "lf"
trim_trailing_whitespace = true
ensure_final_newline = true
max_line_length = 0

# ----------------------------------------------------------------------------
# Receipt Configuration (μ₅ Pass)
# ----------------------------------------------------------------------------

[v6.receipt]
enabled = true
algorithm = "SHA-256"
output_file = "generated/.receipt.json"
