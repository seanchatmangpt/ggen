# ggen v6 - 80/20 Implementation Plan

**Goal**: Prove RDF-first methodology works with 20% effort delivering 80% value

**Target**: 8 developer-days → Working demo of `code = μ(spec.ttl)`

---

## The Core 20% (Must Have)

### One Workflow to Rule Them All

```
TTL file → SPARQL query → Tera template → Generated code
```

If this works deterministically, we've proven the concept. Everything else is optimization.

---

## 5 Core Capabilities (8 days)

| # | Capability | Days | Why Essential |
|---|------------|------|---------------|
| 1 | **Parse TTL → RDF Graph** | 2 | Foundation. Without this, nothing works. |
| 2 | **Execute SPARQL SELECT** | 2 | Extract data from RDF. Heart of μ₂ stage. |
| 3 | **Render Tera Template** | 1 | Transform data to code. Heart of μ₃ stage. |
| 4 | **Deterministic Output** | 1 | SHA256 hashes match. Proves constitutional equation. |
| 5 | **`ggen sync` Command** | 2 | User-facing CLI. Makes it usable. |

**Total**: 8 days = 20% of full 40-day implementation

---

## Implementation Details

### CAP-001: Parse TTL (2 days)

**What**: Load `feature-content.ttl` into RDF graph

**Code**:
```rust
use oxigraph::store::Store;

let store = Store::new()?;
store.load_from_path("ontology/feature-content.ttl", GraphFormat::Turtle)?;
// Done. No multi-file, no streaming, no optimization.
```

**Not Implementing**:
- ❌ Multiple file loading
- ❌ Remote file fetching
- ❌ Format auto-detection
- ❌ Streaming for large files

---

### CAP-002: Execute SPARQL (2 days)

**What**: Run SELECT query, get structured results

**Code**:
```rust
let query = "SELECT ?title ?priority WHERE { ?s sk:title ?title ; sk:priority ?priority }";
let results = store.query(query)?;

let mut data = Vec::new();
for result in results {
    let binding = result?;
    data.push(binding); // Convert to JSON for Tera
}
```

**Not Implementing**:
- ❌ CONSTRUCT queries
- ❌ Query optimization
- ❌ Query validation beyond syntax
- ❌ Streaming results

---

### CAP-003: Render Tera (1 day)

**What**: Load template, render with SPARQL results

**Code**:
```rust
use tera::Tera;

let tera = Tera::new("templates/*.tera")?;
let context = tera::Context::from_serialize(sparql_results)?;
let output = tera.render("spec.tera", &context)?;

std::fs::write("generated/spec.md", output)?;
```

**Not Implementing**:
- ❌ Template inheritance
- ❌ Custom filters
- ❌ Template caching
- ❌ Error recovery

---

### CAP-004: Determinism (1 day)

**What**: Ensure identical inputs → identical outputs

**Implementation**:
- Sort RDF triples before querying (stable order)
- Use `ORDER BY` in SPARQL queries
- Remove timestamps from templates
- No randomness anywhere

**Test**:
```rust
#[test]
fn test_determinism() {
    let output1 = generate_from_ttl("feature.ttl");
    let output2 = generate_from_ttl("feature.ttl");

    assert_eq!(
        sha256(&output1),
        sha256(&output2),
        "Outputs must be byte-for-byte identical"
    );
}
```

---

### CAP-005: ggen sync (2 days)

**What**: CLI command reading ggen.toml

**Code**:
```rust
#[derive(Parser)]
enum Command {
    Sync,
}

fn sync() -> Result<()> {
    let config: GgenConfig = toml::from_str(&fs::read_to_string("ggen.toml")?)?;

    for gen in config.generation {
        let store = load_ttl(&gen.source)?;
        let results = execute_sparql(&store, &gen.query)?;
        let output = render_template(&gen.template, results)?;
        fs::write(&gen.output, output)?;
    }

    Ok(())
}
```

**Minimal ggen.toml**:
```toml
[[generation]]
source = "ontology/feature-content.ttl"
query = "SELECT ?title WHERE { ?s sk:title ?title }"
template = "templates/spec.tera"
output = "generated/spec.md"
```

**Not Implementing**:
- ❌ Dependency ordering
- ❌ Parallel execution
- ❌ Watch mode
- ❌ Partial regeneration

---

## Deferred 80% (Nice to Have)

| # | Feature | Why Deferred | Workaround |
|---|---------|--------------|------------|
| 1 | SHACL Validation | Can validate manually | Use external validator |
| 2 | Cryptographic Receipts | Not blocking generation | Use git commit hashes |
| 3 | Idempotence Checks | Determinism is enough initially | Regenerate everything |
| 4 | Multi-File Loading | Single file works for MVP | Concatenate files |
| 5 | CONSTRUCT Queries | SELECT covers 95% of cases | Creative SELECT patterns |
| 6 | Template Inheritance | Can duplicate code initially | Copy/paste template blocks |
| 7 | Error Recovery | Fail-fast is acceptable | Fix and re-run |
| 8 | Performance Optimization | Specs are small | Wait a few seconds |

---

## MVP Success Criteria

**Can you**:
1. ✅ Write `feature-content.ttl` (RDF spec)
2. ✅ Write `spec.tera` (Tera template)
3. ✅ Define SPARQL query in `ggen.toml`
4. ✅ Run `ggen sync`
5. ✅ Get `spec.md` generated from TTL
6. ✅ Run `ggen sync` again → Same output (deterministic)
7. ✅ Change TTL → Run `ggen sync` → Updated spec.md

**If YES to all → MVP is complete!**

---

## Implementation Schedule (8 days)

### Week 1

**Day 1-2**: TTL Parsing
- Integrate oxigraph
- Load feature-content.ttl
- Count triples to verify
- Unit tests for parsing

**Day 3-4**: SPARQL Execution
- Execute SELECT queries
- Convert results to JSON
- Unit tests for query execution

**Day 5**: Tera Rendering
- Load templates
- Render with SPARQL results
- Write to output file

### Week 2

**Day 1**: Determinism
- Implement stable ordering
- Hash comparison tests
- Cross-platform test

**Day 2-3**: ggen sync Command
- CLI argument parsing (clap)
- ggen.toml parsing
- Pipeline orchestration

**Day 4**: End-to-End Test
- Full workflow test
- Generate spec.md from feature-content.ttl
- Verify output correctness

**Day 5**: Documentation
- README with usage example
- Inline code comments
- Architecture doc

---

## Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| oxigraph API issues | HIGH | Test early, pin version, have fallback lib |
| SPARQL too complex | MEDIUM | Test with real queries early, simplify if needed |
| Tera limitations | LOW | Pre-process SPARQL results if needed |

---

## Validation (How to Know MVP is Done)

**Demo Script**:
```bash
# 1. Start with this TTL spec
cat specs/005-ttl-shacl-validation/ontology/feature-content.ttl

# 2. Run generation
cd specs/005-ttl-shacl-validation
ggen sync

# 3. Verify output exists
ls generated/spec.md

# 4. Verify determinism
ggen sync
git status  # Should show no changes

# 5. Modify spec, regenerate
# Edit feature-content.ttl, change priority
ggen sync
git diff generated/spec.md  # Shows updated priority

# 6. Success! RDF-first works!
```

---

## What This Proves

**With just 20% effort (8 days)**:

✅ **RDF-first methodology works**
- Specs in machine-readable format
- Code generated automatically
- No manual interpretation gap

✅ **Constitutional equation proven**
- code = μ(spec.ttl)
- Deterministic transformation
- Cryptographically verifiable

✅ **Zero drift**
- Spec changes → Code regenerates
- No manual sync needed
- Impossible for spec and code to diverge

---

## Beyond MVP (When to Add Deferred Features)

**SHACL Validation**: When handling untrusted specs or need automated validation

**Cryptographic Receipts**: When compliance/audit requirements demand proof

**Idempotence**: When developers complain about git noise

**Multi-File**: When specs grow > 1000 lines

**Performance**: When generation takes > 30 seconds

**Advanced Features**: When MVP proves value and adoption grows

---

## The 80/20 Philosophy

**Focus on**:
- Does it work?
- Is it deterministic?
- Can I generate code from specs?

**Ignore (initially)**:
- Is it fast?
- Is it perfect?
- Does it handle edge cases?

**8 days to prove concept > 40 days to build perfect tool that nobody uses**

---

## Next Steps After MVP

1. **Dogfood**: Use ggen v6 to regenerate its own specs
2. **Showcase**: Demo to 5 developers, get feedback
3. **Iterate**: Add most-requested deferred feature
4. **Scale**: Apply to larger project (ggen itself)
5. **Refine**: Based on real usage, optimize bottlenecks

---

**Remember**: The goal isn't to build the perfect tool. The goal is to **prove RDF-first methodology eliminates drift**. MVP accomplishes that with 20% effort.
