# Quickstart: N3/CONSTRUCT Semantic Code Generator

**Branch**: `008-n3-code-gen` | **Date**: 2024-12-14

---

## Overview

This guide walks through creating your first semantic code generation project. You'll define a domain ontology, configure generation rules, and produce Rust code.

**Time**: ~10 minutes

---

## Prerequisites

- ggen v5.0.0+ installed (`cargo install ggen`)
- Rust toolchain (for validating generated code)

---

## Step 1: Initialize Project

```bash
mkdir my-domain && cd my-domain
ggen init --template basic
```

This creates:
```
my-domain/
├── ggen.toml           # Generation manifest
├── domain/
│   └── model.ttl       # Domain ontology
├── templates/
│   └── struct.tera     # Rust struct template
├── queries/
│   └── structs.sparql  # Entity extraction query
└── src/generated/      # Output directory
```

---

## Step 2: Define Domain Ontology

Edit `domain/model.ttl`:

```turtle
@prefix : <http://example.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# Define a User entity
:User a rdfs:Class ;
    rdfs:label "User" ;
    rdfs:comment "A system user with authentication" ;
    :auditable true .  # Will infer created_at, updated_at

# User properties
:User :hasField :userId, :userName, :email .

:userId a :Field ;
    rdfs:label "id" ;
    :fieldType "Uuid" .

:userName a :Field ;
    rdfs:label "name" ;
    :fieldType "String" .

:email a :Field ;
    rdfs:label "email" ;
    :fieldType "String" .

# Define an Order entity
:Order a rdfs:Class ;
    rdfs:label "Order" ;
    rdfs:comment "A customer order" .

:Order :hasField :orderId, :total, :status .

:orderId a :Field ;
    rdfs:label "id" ;
    :fieldType "Uuid" .

:total a :Field ;
    rdfs:label "total" ;
    :fieldType "f64" .

:status a :Field ;
    rdfs:label "status" ;
    :fieldType "OrderStatus" .

# Relationship: User has many Orders
:User :has_many :Order .
```

---

## Step 3: Configure Generation

Edit `ggen.toml`:

```toml
[project]
name = "my-domain"
version = "0.1.0"

[ontology]
source = "domain/model.ttl"
base_iri = "http://example.org/"

[ontology.prefixes]
code = "http://ggen.dev/code#"
rdfs = "http://www.w3.org/2000/01/rdf-schema#"
"" = "http://example.org/"

# Inference rule: Add audit fields to auditable entities
[[inference.rules]]
name = "auditable_fields"
description = "Add created_at and updated_at to auditable entities"
construct = """
PREFIX : <http://example.org/>
PREFIX code: <http://ggen.dev/code#>

CONSTRUCT {
  ?entity :hasField ?createdField, ?updatedField .
  ?createdField a :Field ;
                rdfs:label "created_at" ;
                :fieldType "DateTime<Utc>" .
  ?updatedField a :Field ;
                rdfs:label "updated_at" ;
                :fieldType "DateTime<Utc>" .
}
WHERE {
  ?entity a rdfs:Class ;
          :auditable true .
  BIND(IRI(CONCAT(STR(?entity), "_created_at")) AS ?createdField)
  BIND(IRI(CONCAT(STR(?entity), "_updated_at")) AS ?updatedField)
}
"""
order = 1

# Inference rule: Add Serialize/Deserialize to structs with Uuid
[[inference.rules]]
name = "uuid_derives"
description = "Add serde derives to structs with Uuid fields"
construct = """
PREFIX : <http://example.org/>
PREFIX code: <http://ggen.dev/code#>

CONSTRUCT {
  ?entity :derives "Serialize", "Deserialize" .
}
WHERE {
  ?entity a rdfs:Class ;
          :hasField ?field .
  ?field :fieldType "Uuid" .
}
"""
order = 2

# Generation rule: Create Rust structs
[[generation.rules]]
name = "structs"
query = { file = "queries/structs.sparql" }
template = { file = "templates/struct.tera" }
output_file = "src/generated/models/{{name | lower}}.rs"
skip_empty = true

[generation]
max_sparql_timeout_ms = 5000
require_audit_trail = true
output_dir = "src/generated"

[validation]
validate_syntax = true
no_unsafe = true
```

---

## Step 4: Create SPARQL Query

Edit `queries/structs.sparql`:

```sparql
PREFIX : <http://example.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?name ?docstring ?derives (GROUP_CONCAT(?fieldName; separator=",") AS ?fields)
       (GROUP_CONCAT(?fieldType; separator=",") AS ?types)
WHERE {
  ?entity a rdfs:Class ;
          rdfs:label ?name .

  OPTIONAL { ?entity rdfs:comment ?docstring }
  OPTIONAL { ?entity :derives ?derives }

  ?entity :hasField ?field .
  ?field rdfs:label ?fieldName ;
         :fieldType ?fieldType .
}
GROUP BY ?entity ?name ?docstring ?derives
ORDER BY ?name
```

---

## Step 5: Create Tera Template

Edit `templates/struct.tera`:

```jinja
//! Generated by ggen - DO NOT EDIT
//! Source: domain/model.ttl

{% if docstring %}/// {{ docstring }}{% endif %}
#[derive(Debug, Clone{% if derives %}, {{ derives | join(sep=", ") }}{% endif %})]
pub struct {{ name }} {
{% for i in range(end=fields | split(pat=",") | length) %}
{% set field = fields | split(pat=",") | nth(n=i) %}
{% set type = types | split(pat=",") | nth(n=i) %}
    pub {{ field }}: {{ type }},
{% endfor %}
}

impl {{ name }} {
    /// Create a new {{ name }}
    pub fn new({% for i in range(end=fields | split(pat=",") | length) %}{% set field = fields | split(pat=",") | nth(n=i) %}{% set type = types | split(pat=",") | nth(n=i) %}{{ field }}: {{ type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> Self {
        Self {
{% for i in range(end=fields | split(pat=",") | length) %}
{% set field = fields | split(pat=",") | nth(n=i) %}
            {{ field }},
{% endfor %}
        }
    }
}
```

---

## Step 6: Generate Code

```bash
# Validate first
ggen validate

# Generate with verbose output
ggen generate -v
```

**Expected output**:
```
Loading manifest: ./ggen.toml
Loading ontology: domain/model.ttl (15 triples)
Executing inference rules:
  [1/2] auditable_fields: +6 triples (3ms)
  [2/2] uuid_derives: +4 triples (2ms)
Building code graph:
  [1/1] structs: 2 entities (8ms)
Writing output:
  src/generated/models/user.rs (1.2KB)
  src/generated/models/order.rs (0.9KB)
Validation: PASSED
Audit trail: ./audit.json
Generated 2 files in 0.234s
```

---

## Step 7: Review Generated Code

`src/generated/models/user.rs`:

```rust
//! Generated by ggen - DO NOT EDIT
//! Source: domain/model.ttl

/// A system user with authentication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: Uuid,
    pub name: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl User {
    /// Create a new User
    pub fn new(id: Uuid, name: String, email: String, created_at: DateTime<Utc>, updated_at: DateTime<Utc>) -> Self {
        Self {
            id,
            name,
            email,
            created_at,
            updated_at,
        }
    }
}
```

**Notice**: The `created_at` and `updated_at` fields were **inferred** from the `:auditable true` annotation via the N3-style inference rule!

---

## Step 8: Verify Determinism

```bash
# Generate again to /tmp
ggen generate --output-dir /tmp/gen2

# Compare outputs
diff -r src/generated /tmp/gen2
# Should show no differences
```

---

## What's Happening

1. **Ontology Loading**: `domain/model.ttl` is parsed into an RDF graph
2. **Inference**: CONSTRUCT rules add derived triples (audit fields, derives)
3. **Query**: SPARQL SELECT extracts entities from the enriched graph
4. **Template**: Tera renders the query results into Rust code
5. **Validation**: Generated code is checked for syntax errors
6. **Audit**: `audit.json` records all inputs and outputs for reproducibility

---

## Next Steps

### Add Relationships

```turtle
# In domain/model.ttl
:User :has_many :Order .
```

Add a generation rule to create accessor methods:

```toml
[[generation.rules]]
name = "accessors"
query = { inline = """
  SELECT ?from ?to ?methodName
  WHERE {
    ?from :has_many ?to .
    ?to rdfs:label ?toName .
    BIND(CONCAT("get_", LCASE(?toName), "s") AS ?methodName)
  }
""" }
template = { file = "templates/accessor.tera" }
output_file = "src/generated/impls/{{from | lower}}_accessors.rs"
```

### Add SHACL Validation

Create `shapes/domain.ttl`:

```turtle
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix : <http://example.org/> .

:EntityShape a sh:NodeShape ;
    sh:targetClass rdfs:Class ;
    sh:property [
        sh:path rdfs:label ;
        sh:minCount 1 ;
        sh:datatype xsd:string ;
    ] .

:FieldShape a sh:NodeShape ;
    sh:targetClass :Field ;
    sh:property [
        sh:path :fieldType ;
        sh:minCount 1 ;
    ] .
```

Add to `ggen.toml`:

```toml
[validation]
shacl = ["shapes/domain.ttl"]
```

### Enable Dry-Run for Testing

```bash
# Preview without writing
ggen generate --dry-run
```

---

## Troubleshooting

### "Ontology not found"
```bash
# Check path in ggen.toml
ls domain/model.ttl
```

### "SPARQL syntax error"
```bash
# Validate query separately
ggen validate --queries
```

### "Field missing type"
Ensure every `:Field` has a `:fieldType` property:
```turtle
:myField a :Field ;
    rdfs:label "my_field" ;
    :fieldType "String" .  # Required!
```

### "Non-deterministic output"
Check for:
- Missing `ORDER BY` in SPARQL queries
- HashMap iteration (use BTreeMap)
- Timestamps in output (remove or use fixed epoch)

---

## Reference

- [Full Specification](./spec.md)
- [Data Model](./data-model.md)
- [CLI Contract](./contracts/cli-contract.md)
- [Research Notes](./research.md)
