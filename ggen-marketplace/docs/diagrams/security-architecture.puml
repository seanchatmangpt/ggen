@startuml ggen-marketplace-security
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

title Security Architecture - ggen-marketplace Cryptographic Trust Model

actor Publisher as "Package Publisher"
actor Consumer as "Package Consumer"
participant "Ggen CLI" as CLI
participant "MarketplaceClient" as Client
participant "Ed25519CryptoVerifier" as Crypto
participant "KeyManager" as KeyMgr
participant "TrustStore" as Trust
participant "SignatureVerifier" as Verifier
participant "ChecksumValidator" as Checksum
participant "WASM Sandbox" as Sandbox
participant "AuditLogger" as Audit

== Key Generation & Management ==

Publisher -> CLI: ggen market key generate
CLI -> Client: generate_keypair()
Client -> Crypto: generate_ed25519_keypair()
Crypto --> Client: KeyPair { public_key, private_key }

note over Client: Store private key securely
Client -> KeyMgr: store_private_key(private_key, passphrase)
KeyMgr --> Client: KeyStored

note over Client: Export public key for sharing
Client -> Crypto: export_public_key_pem(public_key)
Crypto --> Client: PEM string
Client --> CLI: Public key for distribution
CLI --> Publisher: Public key saved to file

== Package Signing ==

Publisher -> CLI: ggen market sign ./my-package
CLI -> Client: sign_package(package_path)

note over Client: 1. Load private key
Client -> KeyMgr: load_private_key(passphrase)
KeyMgr --> Client: PrivateKey

note over Client: 2. Create package manifest
Client -> Client: create_package_manifest(package_path)
Client --> Client: PackageManifest

note over Client: 3. Compute content hash
Client -> Checksum: sha256_hash(package_bytes)
Checksum --> Client: ContentHash

note over Client: 4. Sign manifest
Client -> Crypto: sign_manifest(manifest, private_key)
Crypto --> Client: DigitalSignature

note over Client: 5. Create signed package
Client -> Client: create_signed_package(manifest, signature)
Client --> CLI: SignedPackage
CLI --> Publisher: Package signed successfully

== Trust Chain Management ==

Publisher -> CLI: ggen market trust add alice@example.com
CLI -> Client: add_trusted_key(public_key, trust_level)

note over Client: 1. Validate public key format
Client -> Crypto: validate_public_key(public_key)
Crypto --> Client: ValidationResult { valid: true }

note over Client: 2. Add to trust store
Client -> Trust: add_trusted_key(public_key, TrustLevel::Full)
Trust --> Client: TrustAdded

note over Client: 3. Log trust operation
Client -> Audit: log_trust_operation("add", public_key, trust_level)
Audit --> Client: Logged

Client --> CLI: TrustAdded
CLI --> Publisher: Key added to trust store

== Package Verification ==

Consumer -> CLI: ggen market install web-framework
CLI -> Client: install_package(package_name)

note over Client: 1. Download package
Client -> Client: download_package(package_id)
Client --> Client: SignedPackage

note over Client: 2. Extract signature and manifest
Client -> Client: extract_signature_and_manifest(signed_package)
Client --> Client: { manifest, signature }

note over Client: 3. Verify signature
Client -> Verifier: verify_signature(manifest, signature)
Verifier -> Crypto: ed25519_verify(manifest, signature, public_key)
Crypto --> Verifier: VerificationResult { valid: true }
Verifier --> Client: SignatureValid

note over Client: 4. Check trust chain
Client -> Trust: is_trusted_key(public_key)
Trust --> Client: TrustResult { trusted: true, level: Full }

note over Client: 5. Verify content integrity
Client -> Checksum: verify_checksum(package_bytes, manifest.content_hash)
Checksum --> Client: ChecksumValid

note over Client: 6. Log verification
Client -> Audit: log_verification(package_id, public_key, result)
Audit --> Client: Logged

Client --> CLI: VerificationSuccess
CLI --> Consumer: Package verified and installed

== WASM Plugin Security ==

Consumer -> CLI: ggen market validate ./my-package
CLI -> Client: validate_package(package_path)

note over Client: 1. Load plugin in sandbox
Client -> Sandbox: create_sandbox()
Sandbox --> Client: SandboxInstance

note over Client: 2. Configure security policies
Client -> Sandbox: set_security_policy(
    allow_filesystem: false,
    allow_network: false,
    allow_system_calls: false,
    memory_limit: 64MB,
    cpu_limit: 1000ms
)
Sandbox --> Client: PolicySet

note over Client: 3. Load and validate WASM
Client -> Sandbox: load_wasm_module(validator.wasm)
Sandbox -> Sandbox: validate_wasm_bytecode()
Sandbox --> Client: ModuleLoaded

note over Client: 4. Execute in sandbox
Client -> Sandbox: execute_plugin(module, package_data)
Sandbox --> Client: ValidationResult

note over Client: 5. Clean up sandbox
Client -> Sandbox: destroy_sandbox()
Sandbox --> Client: Cleaned

Client --> CLI: ValidationResult
CLI --> Consumer: Validation completed safely

== Security Monitoring ==

note over Audit: Continuous security monitoring

Audit -> Audit: monitor_signature_verifications()
Audit -> Audit: detect_suspicious_patterns()
Audit -> Audit: alert_on_security_events()

alt Suspicious Activity Detected
    Audit -> Audit: trigger_security_alert(
        event: "Multiple failed verifications",
        source: "malicious_node",
        severity: "HIGH"
    )
    Audit -> Client: SecurityAlert
    Client -> Trust: revoke_trusted_key(malicious_key)
    Trust --> Client: KeyRevoked
end

== Key Revocation ==

Publisher -> CLI: ggen market trust revoke alice@example.com
CLI -> Client: revoke_trusted_key(public_key, reason)

note over Client: 1. Verify revocation authority
Client -> Trust: check_revocation_permission(public_key)
Trust --> Client: PermissionGranted

note over Client: 2. Revoke key
Client -> Trust: revoke_key(public_key, reason)
Trust --> Client: KeyRevoked

note over Client: 3. Broadcast revocation
Client -> Client: broadcast_revocation(public_key, reason)
Client --> Client: RevocationBroadcast

note over Client: 4. Log revocation
Client -> Audit: log_revocation(public_key, reason, timestamp)
Audit --> Client: Logged

Client --> CLI: KeyRevoked
CLI --> Publisher: Key revoked and broadcast

== Security Error Handling ==

alt Invalid Signature
    Verifier --> Client: InvalidSignature
    Client -> Audit: log_security_event("invalid_signature", package_id)
    Audit --> Client: Logged
    Client --> CLI: SecurityError("Invalid signature")
    CLI --> Consumer: Package verification failed
end

alt Untrusted Key
    Trust --> Client: UntrustedKey
    Client -> Audit: log_security_event("untrusted_key", public_key)
    Audit --> Client: Logged
    Client --> CLI: SecurityError("Untrusted publisher")
    CLI --> Consumer: Publisher not trusted
end

alt Checksum Mismatch
    Checksum --> Client: ChecksumMismatch
    Client -> Audit: log_security_event("checksum_mismatch", package_id)
    Audit --> Client: Logged
    Client --> CLI: SecurityError("Package corrupted")
    CLI --> Consumer: Package integrity check failed
end

alt WASM Security Violation
    Sandbox --> Client: SecurityViolation
    Client -> Audit: log_security_event("wasm_violation", plugin_id)
    Audit --> Client: Logged
    Client --> CLI: SecurityError("Plugin security violation")
    CLI --> Consumer: Plugin execution blocked
end

note over Publisher, Audit
  **Security Model:**
  • Ed25519 digital signatures
  • Content-addressed storage (IPFS)
  • Cryptographic checksums (SHA256)
  • Trust chain management
  • WASM sandboxing
  • Comprehensive audit logging
  • Key revocation and rotation
  • Zero-trust architecture
end note

@enduml


