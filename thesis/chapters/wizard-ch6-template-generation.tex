\chapter{Automated Template Generation}
\label{ch:template-generation}

\section{The Template Selection Problem}

Given a user's natural language description, the wizard must select appropriate code generation templates from the pack ecosystem. This chapter presents the AI-powered template recommendation system.

\section{Pack Ecosystem Overview}

\subsection{Pack Structure}

Each pack contains:

\begin{lstlisting}[language=TOML,caption={Pack Manifest Structure}]
[pack]
name = "rust-rest-api"
version = "1.2.0"
description = "REST API generation for Rust/Axum"

[capabilities]
entities = true
repositories = true
controllers = true
authentication = ["jwt", "session", "oauth"]

[templates]
entity = "templates/entity.tera"
repository = "templates/repository.tera"
controller = "templates/controller.tera"
\end{lstlisting}

\subsection{Pack Categories}

\begin{table}[h]
\centering
\begin{tabular}{lp{7cm}}
\toprule
\textbf{Category} & \textbf{Description} \\
\midrule
Language & Rust, TypeScript, Python, Go targets \\
Framework & Axum, Actix, Express, FastAPI \\
Pattern & CRUD, CQRS, Event Sourcing \\
Infrastructure & Docker, Kubernetes, Terraform \\
\bottomrule
\end{tabular}
\caption{Pack categories}
\label{tab:pack-categories}
\end{table}

\section{Template Recommendation Algorithm}

\subsection{Feature Vector Construction}

User descriptions are converted to feature vectors:

\begin{equation}
\vec{v}_{desc} = \text{Embed}(\text{description}) \in \mathbb{R}^{768}
\end{equation}

Pack capabilities are similarly embedded:

\begin{equation}
\vec{v}_{pack} = \text{Embed}(\text{pack.capabilities}) \in \mathbb{R}^{768}
\end{equation}

\subsection{Similarity Scoring}

Packs are ranked by cosine similarity:

\begin{equation}
\text{score}(pack) = \frac{\vec{v}_{desc} \cdot \vec{v}_{pack}}{||\vec{v}_{desc}|| \cdot ||\vec{v}_{pack}||}
\end{equation}

\subsection{Constraint Filtering}

Before similarity ranking, packs are filtered by hard constraints:

\begin{algorithm}
\caption{Pack Selection}
\begin{algorithmic}[1]
\Require Description $D$, Pack catalog $P$
\Ensure Ranked pack list
\State $constraints \gets \text{ExtractConstraints}(D)$
\State $candidates \gets \{p \in P : \text{Satisfies}(p, constraints)\}$
\State $\vec{v}_{desc} \gets \text{Embed}(D)$
\For{each $p \in candidates$}
    \State $p.score \gets \text{CosineSim}(\vec{v}_{desc}, \text{Embed}(p))$
\EndFor
\State \textbf{return} $\text{SortByScore}(candidates)$
\end{algorithmic}
\end{algorithm}

\section{Semantic Pack Matching}

\subsection{Capability Ontology}

Pack capabilities are organized in a semantic hierarchy:

\begin{lstlisting}[language=SPARQL,caption={Capability Ontology}]
ggen:Authentication a owl:Class .
ggen:JWTAuth rdfs:subClassOf ggen:Authentication .
ggen:OAuth rdfs:subClassOf ggen:Authentication .
ggen:SessionAuth rdfs:subClassOf ggen:Authentication .

ggen:Storage a owl:Class .
ggen:PostgresStorage rdfs:subClassOf ggen:SQLStorage .
ggen:SQLStorage rdfs:subClassOf ggen:Storage .
\end{lstlisting}

\subsection{Semantic Reasoning}

SPARQL queries enable semantic matching:

\begin{lstlisting}[language=SPARQL,caption={Capability Query}]
SELECT ?pack WHERE {
  ?pack ggen:provides ?cap .
  ?cap rdfs:subClassOf* ggen:Authentication .
  FILTER NOT EXISTS {
    ?pack ggen:requires ?req .
    FILTER NOT EXISTS { :project ggen:has ?req }
  }
}
\end{lstlisting}

\section{Template Composition}

\subsection{Multi-Pack Generation}

Complex projects require multiple packs:

\begin{enumerate}
\item Identify required capabilities from description
\item Select primary pack for core functionality
\item Add supplementary packs for additional features
\item Resolve conflicts through composition rules
\end{enumerate}

\subsection{Composition Algebra}

Pack composition follows a formal algebra:

\begin{definition}[Pack Composition]
Given packs $P_1$ and $P_2$:
\[
P_1 \oplus P_2 = (O_1 \cup O_2, T_1 \cup_{\text{override}} T_2, M_1 \triangleleft M_2)
\]
Where $\triangleleft$ denotes left-biased merge for conflicts.
\end{definition}

\section{AI-Assisted Template Creation}

\subsection{Template Synthesis}

When no existing pack matches, the wizard can synthesize templates:

\begin{lstlisting}[language=Python,caption={Template Synthesis}]
def synthesize_template(entity_spec: dict, target: str) -> str:
    prompt = f"""
    Generate a Tera template for {target} that:
    - Produces {entity_spec['language']} code
    - Implements {entity_spec['pattern']} pattern
    - Uses fields: {entity_spec['fields']}

    Template must use Tera syntax with ggen context variables.
    """
    return llm.complete(prompt)
\end{lstlisting}

\subsection{Template Validation}

Synthesized templates undergo validation:

\begin{enumerate}
\item \textbf{Syntax check}: Parse as valid Tera
\item \textbf{Variable check}: All referenced variables exist in context
\item \textbf{Output check}: Generated code compiles
\item \textbf{Semantic check}: Output matches specification
\end{enumerate}

\section{The 25 Pack Verbs}

The pack system provides 25 CLI verbs organized into 8 categories:

\subsection{Discovery Commands}
\begin{itemize}
\item \texttt{pack list} -- List available packs
\item \texttt{pack search} -- Search packs by keyword
\item \texttt{pack show} -- Display pack details
\item \texttt{pack info} -- Show pack metadata
\end{itemize}

\subsection{Management Commands}
\begin{itemize}
\item \texttt{pack install} -- Install pack
\item \texttt{pack uninstall} -- Remove pack
\item \texttt{pack update} -- Update packs
\item \texttt{pack clean} -- Remove unused packs
\end{itemize}

\subsection{Generation Commands}
\begin{itemize}
\item \texttt{pack generate} -- Generate from pack
\item \texttt{pack regenerate} -- Refresh generation
\end{itemize}

\subsection{Composition Commands}
\begin{itemize}
\item \texttt{pack compose} -- Combine multiple packs
\item \texttt{pack merge} -- Merge pack outputs
\item \texttt{pack plan} -- Preview composition
\end{itemize}

\section{Recommendation Accuracy}

\subsection{Evaluation Methodology}

We evaluated template recommendation on 200 project descriptions:

\begin{table}[h]
\centering
\begin{tabular}{lc}
\toprule
\textbf{Metric} & \textbf{Score} \\
\midrule
Top-1 Accuracy & 72\% \\
Top-3 Accuracy & 87\% \\
Top-5 Accuracy & 94\% \\
Mean Reciprocal Rank & 0.81 \\
\bottomrule
\end{tabular}
\caption{Template recommendation accuracy}
\label{tab:recommendation-accuracy}
\end{table}

\subsection{Error Analysis}

Recommendation failures cluster in three categories:

\begin{enumerate}
\item \textbf{Ambiguous descriptions} (45\%): Description matches multiple packs
\item \textbf{Novel requirements} (35\%): No pack covers the capability
\item \textbf{Implicit assumptions} (20\%): User assumes context not stated
\end{enumerate}

\section{Summary}

The template generation system enables wizard commands to automatically select and compose appropriate code generation templates. By combining semantic matching with AI-assisted synthesis, the system achieves 87\% accuracy in selecting relevant packs from the first three recommendations.
