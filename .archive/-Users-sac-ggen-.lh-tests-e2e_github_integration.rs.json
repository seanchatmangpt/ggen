{
    "sourceFile": "tests/e2e_github_integration.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1760245905696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760250721733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,315 @@\n+use anyhow::Result;\n+use assert_cmd::Command;\n+use predicates::prelude::*;\n+use std::env;\n+\n+/// E2E tests for GitHub API integration\n+///\n+/// Tests the GitHub API commands added in v1.0.0:\n+/// - ggen ci pages status\n+/// - ggen ci workflow status\n+/// - ggen ci trigger\n+\n+#[test]\n+fn test_github_pages_status_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"status\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_pages_status_with_explicit_repo() -> Result<()> {\n+    // Test with explicit repository argument\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    // Command might fail without GITHUB_TOKEN, but it should run\n+    let output = cmd.output()?;\n+\n+    // Should output either success info or error message (not crash)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // One of these should contain relevant information\n+    assert!(\n+        stdout.contains(\"Pages\") || stderr.contains(\"Pages\") || stderr.contains(\"Error\"),\n+        \"Command should provide pages status or error message\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"status\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_with_workflow_name() -> Result<()> {\n+    // Test with explicit workflow name\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\")\n+        .arg(\"workflow\")\n+        .arg(\"status\")\n+        .arg(\"--workflow\")\n+        .arg(\"Build and Deploy GitHub Pages\");\n+\n+    // Command might fail without GITHUB_TOKEN or if workflow doesn't exist\n+    let output = cmd.output()?;\n+\n+    // Should provide some output (success or error)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should contain workflow-related information or error\n+    assert!(\n+        stdout.contains(\"Workflow\")\n+            || stdout.contains(\"Build\")\n+            || stderr.contains(\"Workflow\")\n+            || stderr.contains(\"Error\"),\n+        \"Command should provide workflow status or error message\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_trigger_workflow_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"trigger\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"trigger\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires git remote configuration\n+fn test_github_repo_auto_detection() -> Result<()> {\n+    // Test that commands can auto-detect repo from git remote\n+    // This will fail gracefully if not in a git repo\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should either detect repo successfully or provide helpful error\n+    assert!(\n+        stderr.contains(\"detected\")\n+            || stderr.contains(\"repository\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"Pages\"),\n+        \"Command should attempt repo detection or provide error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_handle_missing_token() -> Result<()> {\n+    // Test that commands work or fail gracefully without GITHUB_TOKEN\n+    // Temporarily unset GITHUB_TOKEN if it exists\n+    let original_token = env::var(\"GITHUB_TOKEN\").ok();\n+    env::remove_var(\"GITHUB_TOKEN\");\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+\n+    // Restore original token\n+    if let Some(token) = original_token {\n+        env::set_var(\"GITHUB_TOKEN\", token);\n+    }\n+\n+    // Command should run (might fail due to rate limiting, but shouldn't crash)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should provide some output\n+    assert!(\n+        !stdout.is_empty() || !stderr.is_empty(),\n+        \"Command should provide output even without token\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires GitHub API access\n+fn test_github_pages_status_output_format() -> Result<()> {\n+    // Test that pages-status provides expected output format\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should mention pages URL or status\n+    assert!(\n+        stdout.contains(\"github.io\")\n+            || stdout.contains(\"Pages URL\")\n+            || stdout.contains(\"Status\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"not configured\"),\n+        \"Output should contain pages information or error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_lists_workflows() -> Result<()> {\n+    // Test that workflow-status can list workflows\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should list workflows or provide error\n+    assert!(\n+        stdout.contains(\"Workflow\")\n+            || stdout.contains(\"workflow\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"No workflows\"),\n+        \"Output should contain workflow information or error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_validate_repo_format() -> Result<()> {\n+    // Test that commands validate repository format\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\"); // No repo argument needed for CI commands\n+\n+    let output = cmd.output()?;\n+\n+    // Should fail with validation error\n+    if !output.status.success() {\n+        let stderr = String::from_utf8_lossy(&output.stderr);\n+        assert!(\n+            stderr.contains(\"Error\") || stderr.contains(\"invalid\") || stderr.contains(\"format\"),\n+            \"Should provide error for invalid repo format\"\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_help_commands() -> Result<()> {\n+    // Test that all GitHub subcommands have help text\n+    let subcommands = [\"pages status\", \"workflow status\", \"trigger\"];\n+\n+    for subcommand in &subcommands {\n+        let mut cmd = Command::cargo_bin(\"ggen\")?;\n+        cmd.args([\"ci\"].iter().map(|s| *s).chain(subcommand.split(\" \")))\n+            .arg(\"--help\");\n+\n+        cmd.assert().success().stdout(predicate::str::contains(\n+            subcommand.split(' ').next().unwrap(),\n+        ));\n+    }\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires GitHub API access\n+fn test_github_integration_with_public_repo() -> Result<()> {\n+    // Test GitHub integration with a known public repository\n+    // This is the most realistic E2E test\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+\n+    // Command should complete (success or known error)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should get either pages info or a specific error\n+    assert!(\n+        stdout.contains(\"seanchatmangpt.github.io/ggen\")\n+            || stdout.contains(\"Status:\")\n+            || stdout.contains(\"Pages URL:\")\n+            || stderr.contains(\"Error:\")\n+            || stderr.contains(\"not configured\")\n+            || stderr.contains(\"rate limit\"),\n+        \"Command should provide pages status or specific error for known repo\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_performance() -> Result<()> {\n+    // Test that GitHub commands complete in reasonable time\n+    use std::time::Instant;\n+\n+    let start = Instant::now();\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let _ = cmd.output()?;\n+\n+    let duration = start.elapsed();\n+\n+    // Should complete within 10 seconds (network calls)\n+    assert!(\n+        duration.as_secs() < 10,\n+        \"GitHub command should complete within 10 seconds, took {:?}\",\n+        duration\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_api_error_messages_are_helpful() -> Result<()> {\n+    // Test that error messages are user-friendly\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Error should be informative\n+    if !output.status.success() {\n+        assert!(\n+            stderr.contains(\"Error\")\n+                || stderr.contains(\"not found\")\n+                || stderr.contains(\"404\")\n+                || stderr.contains(\"does not exist\"),\n+            \"Error message should be informative, got: {}\",\n+            stderr\n+        );\n+    }\n+\n+    Ok(())\n+}\n"
                },
                {
                    "date": 1760251604305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,315 @@\n+use anyhow::Result;\n+use assert_cmd::Command;\n+use predicates::prelude::*;\n+use std::env;\n+\n+/// E2E tests for GitHub API integration\n+///\n+/// Tests the GitHub API commands added in v1.0.0:\n+/// - ggen ci pages status\n+/// - ggen ci workflow status\n+/// - ggen ci trigger\n+\n+#[test]\n+fn test_github_pages_status_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"status\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_pages_status_with_explicit_repo() -> Result<()> {\n+    // Test with explicit repository argument\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    // Command might fail without GITHUB_TOKEN, but it should run\n+    let output = cmd.output()?;\n+\n+    // Should output either success info or error message (not crash)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // One of these should contain relevant information\n+    assert!(\n+        stdout.contains(\"Pages\") || stderr.contains(\"Pages\") || stderr.contains(\"Error\"),\n+        \"Command should provide pages status or error message\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"status\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_with_workflow_name() -> Result<()> {\n+    // Test with explicit workflow name\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\")\n+        .arg(\"workflow\")\n+        .arg(\"status\")\n+        .arg(\"--workflow\")\n+        .arg(\"Build and Deploy GitHub Pages\");\n+\n+    // Command might fail without GITHUB_TOKEN or if workflow doesn't exist\n+    let output = cmd.output()?;\n+\n+    // Should provide some output (success or error)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should contain workflow-related information or error\n+    assert!(\n+        stdout.contains(\"Workflow\")\n+            || stdout.contains(\"Build\")\n+            || stderr.contains(\"Workflow\")\n+            || stderr.contains(\"Error\"),\n+        \"Command should provide workflow status or error message\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_trigger_workflow_command() -> Result<()> {\n+    // Test that the command exists and has proper help\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"trigger\").arg(\"--help\");\n+\n+    cmd.assert()\n+        .success()\n+        .stdout(predicate::str::contains(\"trigger\"));\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires git remote configuration\n+fn test_github_repo_auto_detection() -> Result<()> {\n+    // Test that commands can auto-detect repo from git remote\n+    // This will fail gracefully if not in a git repo\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should either detect repo successfully or provide helpful error\n+    assert!(\n+        stderr.contains(\"detected\")\n+            || stderr.contains(\"repository\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"Pages\"),\n+        \"Command should attempt repo detection or provide error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_handle_missing_token() -> Result<()> {\n+    // Test that commands work or fail gracefully without GITHUB_TOKEN\n+    // Temporarily unset GITHUB_TOKEN if it exists\n+    let original_token = env::var(\"GITHUB_TOKEN\").ok();\n+    env::remove_var(\"GITHUB_TOKEN\");\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+\n+    // Restore original token\n+    if let Some(token) = original_token {\n+        env::set_var(\"GITHUB_TOKEN\", token);\n+    }\n+\n+    // Command should run (might fail due to rate limiting, but shouldn't crash)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should provide some output\n+    assert!(\n+        !stdout.is_empty() || !stderr.is_empty(),\n+        \"Command should provide output even without token\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires GitHub API access\n+fn test_github_pages_status_output_format() -> Result<()> {\n+    // Test that pages-status provides expected output format\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should mention pages URL or status\n+    assert!(\n+        stdout.contains(\"github.io\")\n+            || stdout.contains(\"Pages URL\")\n+            || stdout.contains(\"Status\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"not configured\"),\n+        \"Output should contain pages information or error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_workflow_status_lists_workflows() -> Result<()> {\n+    // Test that workflow-status can list workflows\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should list workflows or provide error\n+    assert!(\n+        stdout.contains(\"Workflow\")\n+            || stdout.contains(\"workflow\")\n+            || stderr.contains(\"Error\")\n+            || stderr.contains(\"No workflows\"),\n+        \"Output should contain workflow information or error\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_validate_repo_format() -> Result<()> {\n+    // Test that commands validate repository format\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\"); // No repo argument needed for CI commands\n+\n+    let output = cmd.output()?;\n+\n+    // Should fail with validation error\n+    if !output.status.success() {\n+        let stderr = String::from_utf8_lossy(&output.stderr);\n+        assert!(\n+            stderr.contains(\"Error\") || stderr.contains(\"invalid\") || stderr.contains(\"format\"),\n+            \"Should provide error for invalid repo format\"\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_help_commands() -> Result<()> {\n+    // Test that all GitHub subcommands have help text\n+    let subcommands = [\"pages status\", \"workflow status\", \"trigger\"];\n+\n+    for subcommand in &subcommands {\n+        let mut cmd = Command::cargo_bin(\"ggen\")?;\n+        cmd.args([\"ci\"].iter().copied().chain(subcommand.split(\" \")))\n+            .arg(\"--help\");\n+\n+        cmd.assert().success().stdout(predicate::str::contains(\n+            subcommand.split(' ').next().unwrap(),\n+        ));\n+    }\n+\n+    Ok(())\n+}\n+\n+#[test]\n+#[ignore] // Network-dependent: requires GitHub API access\n+fn test_github_integration_with_public_repo() -> Result<()> {\n+    // Test GitHub integration with a known public repository\n+    // This is the most realistic E2E test\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+\n+    // Command should complete (success or known error)\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Should get either pages info or a specific error\n+    assert!(\n+        stdout.contains(\"seanchatmangpt.github.io/ggen\")\n+            || stdout.contains(\"Status:\")\n+            || stdout.contains(\"Pages URL:\")\n+            || stderr.contains(\"Error:\")\n+            || stderr.contains(\"not configured\")\n+            || stderr.contains(\"rate limit\"),\n+        \"Command should provide pages status or specific error for known repo\"\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_commands_performance() -> Result<()> {\n+    // Test that GitHub commands complete in reasonable time\n+    use std::time::Instant;\n+\n+    let start = Instant::now();\n+\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let _ = cmd.output()?;\n+\n+    let duration = start.elapsed();\n+\n+    // Should complete within 10 seconds (network calls)\n+    assert!(\n+        duration.as_secs() < 10,\n+        \"GitHub command should complete within 10 seconds, took {:?}\",\n+        duration\n+    );\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn test_github_api_error_messages_are_helpful() -> Result<()> {\n+    // Test that error messages are user-friendly\n+    let mut cmd = Command::cargo_bin(\"ggen\")?;\n+    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n+\n+    let output = cmd.output()?;\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+\n+    // Error should be informative\n+    if !output.status.success() {\n+        assert!(\n+            stderr.contains(\"Error\")\n+                || stderr.contains(\"not found\")\n+                || stderr.contains(\"404\")\n+                || stderr.contains(\"does not exist\"),\n+            \"Error message should be informative, got: {}\",\n+            stderr\n+        );\n+    }\n+\n+    Ok(())\n+}\n"
                },
                {
                    "date": 1760251836368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,634 +312,4 @@\n     }\n \n     Ok(())\n }\n-use anyhow::Result;\n-use assert_cmd::Command;\n-use predicates::prelude::*;\n-use std::env;\n-\n-/// E2E tests for GitHub API integration\n-///\n-/// Tests the GitHub API commands added in v1.0.0:\n-/// - ggen ci pages status\n-/// - ggen ci workflow status\n-/// - ggen ci trigger\n-\n-#[test]\n-fn test_github_pages_status_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"status\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_pages_status_with_explicit_repo() -> Result<()> {\n-    // Test with explicit repository argument\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    // Command might fail without GITHUB_TOKEN, but it should run\n-    let output = cmd.output()?;\n-\n-    // Should output either success info or error message (not crash)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // One of these should contain relevant information\n-    assert!(\n-        stdout.contains(\"Pages\") || stderr.contains(\"Pages\") || stderr.contains(\"Error\"),\n-        \"Command should provide pages status or error message\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"status\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_with_workflow_name() -> Result<()> {\n-    // Test with explicit workflow name\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\")\n-        .arg(\"workflow\")\n-        .arg(\"status\")\n-        .arg(\"--workflow\")\n-        .arg(\"Build and Deploy GitHub Pages\");\n-\n-    // Command might fail without GITHUB_TOKEN or if workflow doesn't exist\n-    let output = cmd.output()?;\n-\n-    // Should provide some output (success or error)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should contain workflow-related information or error\n-    assert!(\n-        stdout.contains(\"Workflow\")\n-            || stdout.contains(\"Build\")\n-            || stderr.contains(\"Workflow\")\n-            || stderr.contains(\"Error\"),\n-        \"Command should provide workflow status or error message\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_trigger_workflow_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"trigger\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"trigger\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires git remote configuration\n-fn test_github_repo_auto_detection() -> Result<()> {\n-    // Test that commands can auto-detect repo from git remote\n-    // This will fail gracefully if not in a git repo\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should either detect repo successfully or provide helpful error\n-    assert!(\n-        stderr.contains(\"detected\")\n-            || stderr.contains(\"repository\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"Pages\"),\n-        \"Command should attempt repo detection or provide error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_handle_missing_token() -> Result<()> {\n-    // Test that commands work or fail gracefully without GITHUB_TOKEN\n-    // Temporarily unset GITHUB_TOKEN if it exists\n-    let original_token = env::var(\"GITHUB_TOKEN\").ok();\n-    env::remove_var(\"GITHUB_TOKEN\");\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-\n-    // Restore original token\n-    if let Some(token) = original_token {\n-        env::set_var(\"GITHUB_TOKEN\", token);\n-    }\n-\n-    // Command should run (might fail due to rate limiting, but shouldn't crash)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should provide some output\n-    assert!(\n-        !stdout.is_empty() || !stderr.is_empty(),\n-        \"Command should provide output even without token\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires GitHub API access\n-fn test_github_pages_status_output_format() -> Result<()> {\n-    // Test that pages-status provides expected output format\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should mention pages URL or status\n-    assert!(\n-        stdout.contains(\"github.io\")\n-            || stdout.contains(\"Pages URL\")\n-            || stdout.contains(\"Status\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"not configured\"),\n-        \"Output should contain pages information or error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_lists_workflows() -> Result<()> {\n-    // Test that workflow-status can list workflows\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should list workflows or provide error\n-    assert!(\n-        stdout.contains(\"Workflow\")\n-            || stdout.contains(\"workflow\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"No workflows\"),\n-        \"Output should contain workflow information or error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_validate_repo_format() -> Result<()> {\n-    // Test that commands validate repository format\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\"); // No repo argument needed for CI commands\n-\n-    let output = cmd.output()?;\n-\n-    // Should fail with validation error\n-    if !output.status.success() {\n-        let stderr = String::from_utf8_lossy(&output.stderr);\n-        assert!(\n-            stderr.contains(\"Error\") || stderr.contains(\"invalid\") || stderr.contains(\"format\"),\n-            \"Should provide error for invalid repo format\"\n-        );\n-    }\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_help_commands() -> Result<()> {\n-    // Test that all GitHub subcommands have help text\n-    let subcommands = [\"pages status\", \"workflow status\", \"trigger\"];\n-\n-    for subcommand in &subcommands {\n-        let mut cmd = Command::cargo_bin(\"ggen\")?;\n-        cmd.args([\"ci\"].iter().map(|s| *s).chain(subcommand.split(\" \")))\n-            .arg(\"--help\");\n-\n-        cmd.assert().success().stdout(predicate::str::contains(\n-            subcommand.split(' ').next().unwrap(),\n-        ));\n-    }\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires GitHub API access\n-fn test_github_integration_with_public_repo() -> Result<()> {\n-    // Test GitHub integration with a known public repository\n-    // This is the most realistic E2E test\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-\n-    // Command should complete (success or known error)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should get either pages info or a specific error\n-    assert!(\n-        stdout.contains(\"seanchatmangpt.github.io/ggen\")\n-            || stdout.contains(\"Status:\")\n-            || stdout.contains(\"Pages URL:\")\n-            || stderr.contains(\"Error:\")\n-            || stderr.contains(\"not configured\")\n-            || stderr.contains(\"rate limit\"),\n-        \"Command should provide pages status or specific error for known repo\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_performance() -> Result<()> {\n-    // Test that GitHub commands complete in reasonable time\n-    use std::time::Instant;\n-\n-    let start = Instant::now();\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let _ = cmd.output()?;\n-\n-    let duration = start.elapsed();\n-\n-    // Should complete within 10 seconds (network calls)\n-    assert!(\n-        duration.as_secs() < 10,\n-        \"GitHub command should complete within 10 seconds, took {:?}\",\n-        duration\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_api_error_messages_are_helpful() -> Result<()> {\n-    // Test that error messages are user-friendly\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Error should be informative\n-    if !output.status.success() {\n-        assert!(\n-            stderr.contains(\"Error\")\n-                || stderr.contains(\"not found\")\n-                || stderr.contains(\"404\")\n-                || stderr.contains(\"does not exist\"),\n-            \"Error message should be informative, got: {}\",\n-            stderr\n-        );\n-    }\n-\n-    Ok(())\n-}\n-use anyhow::Result;\n-use assert_cmd::Command;\n-use predicates::prelude::*;\n-use std::env;\n-\n-/// E2E tests for GitHub API integration\n-///\n-/// Tests the GitHub API commands added in v1.0.0:\n-/// - ggen ci pages status\n-/// - ggen ci workflow status\n-/// - ggen ci trigger\n-\n-#[test]\n-fn test_github_pages_status_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"status\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_pages_status_with_explicit_repo() -> Result<()> {\n-    // Test with explicit repository argument\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    // Command might fail without GITHUB_TOKEN, but it should run\n-    let output = cmd.output()?;\n-\n-    // Should output either success info or error message (not crash)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // One of these should contain relevant information\n-    assert!(\n-        stdout.contains(\"Pages\") || stderr.contains(\"Pages\") || stderr.contains(\"Error\"),\n-        \"Command should provide pages status or error message\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"status\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_with_workflow_name() -> Result<()> {\n-    // Test with explicit workflow name\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\")\n-        .arg(\"workflow\")\n-        .arg(\"status\")\n-        .arg(\"--workflow\")\n-        .arg(\"Build and Deploy GitHub Pages\");\n-\n-    // Command might fail without GITHUB_TOKEN or if workflow doesn't exist\n-    let output = cmd.output()?;\n-\n-    // Should provide some output (success or error)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should contain workflow-related information or error\n-    assert!(\n-        stdout.contains(\"Workflow\")\n-            || stdout.contains(\"Build\")\n-            || stderr.contains(\"Workflow\")\n-            || stderr.contains(\"Error\"),\n-        \"Command should provide workflow status or error message\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_trigger_workflow_command() -> Result<()> {\n-    // Test that the command exists and has proper help\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"trigger\").arg(\"--help\");\n-\n-    cmd.assert()\n-        .success()\n-        .stdout(predicate::str::contains(\"trigger\"));\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires git remote configuration\n-fn test_github_repo_auto_detection() -> Result<()> {\n-    // Test that commands can auto-detect repo from git remote\n-    // This will fail gracefully if not in a git repo\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should either detect repo successfully or provide helpful error\n-    assert!(\n-        stderr.contains(\"detected\")\n-            || stderr.contains(\"repository\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"Pages\"),\n-        \"Command should attempt repo detection or provide error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_handle_missing_token() -> Result<()> {\n-    // Test that commands work or fail gracefully without GITHUB_TOKEN\n-    // Temporarily unset GITHUB_TOKEN if it exists\n-    let original_token = env::var(\"GITHUB_TOKEN\").ok();\n-    env::remove_var(\"GITHUB_TOKEN\");\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-\n-    // Restore original token\n-    if let Some(token) = original_token {\n-        env::set_var(\"GITHUB_TOKEN\", token);\n-    }\n-\n-    // Command should run (might fail due to rate limiting, but shouldn't crash)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should provide some output\n-    assert!(\n-        !stdout.is_empty() || !stderr.is_empty(),\n-        \"Command should provide output even without token\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires GitHub API access\n-fn test_github_pages_status_output_format() -> Result<()> {\n-    // Test that pages-status provides expected output format\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should mention pages URL or status\n-    assert!(\n-        stdout.contains(\"github.io\")\n-            || stdout.contains(\"Pages URL\")\n-            || stdout.contains(\"Status\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"not configured\"),\n-        \"Output should contain pages information or error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_workflow_status_lists_workflows() -> Result<()> {\n-    // Test that workflow-status can list workflows\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should list workflows or provide error\n-    assert!(\n-        stdout.contains(\"Workflow\")\n-            || stdout.contains(\"workflow\")\n-            || stderr.contains(\"Error\")\n-            || stderr.contains(\"No workflows\"),\n-        \"Output should contain workflow information or error\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_validate_repo_format() -> Result<()> {\n-    // Test that commands validate repository format\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\"); // No repo argument needed for CI commands\n-\n-    let output = cmd.output()?;\n-\n-    // Should fail with validation error\n-    if !output.status.success() {\n-        let stderr = String::from_utf8_lossy(&output.stderr);\n-        assert!(\n-            stderr.contains(\"Error\") || stderr.contains(\"invalid\") || stderr.contains(\"format\"),\n-            \"Should provide error for invalid repo format\"\n-        );\n-    }\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_help_commands() -> Result<()> {\n-    // Test that all GitHub subcommands have help text\n-    let subcommands = [\"pages status\", \"workflow status\", \"trigger\"];\n-\n-    for subcommand in &subcommands {\n-        let mut cmd = Command::cargo_bin(\"ggen\")?;\n-        cmd.args([\"ci\"].iter().chain(subcommand.split(\" \").map(|s| s.as_ref())))\n-            .arg(\"--help\");\n-\n-        cmd.assert().success().stdout(predicate::str::contains(\n-            subcommand.split(' ').next().unwrap(),\n-        ));\n-    }\n-\n-    Ok(())\n-}\n-\n-#[test]\n-#[ignore] // Network-dependent: requires GitHub API access\n-fn test_github_integration_with_public_repo() -> Result<()> {\n-    // Test GitHub integration with a known public repository\n-    // This is the most realistic E2E test\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-\n-    // Command should complete (success or known error)\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Should get either pages info or a specific error\n-    assert!(\n-        stdout.contains(\"seanchatmangpt.github.io/ggen\")\n-            || stdout.contains(\"Status:\")\n-            || stdout.contains(\"Pages URL:\")\n-            || stderr.contains(\"Error:\")\n-            || stderr.contains(\"not configured\")\n-            || stderr.contains(\"rate limit\"),\n-        \"Command should provide pages status or specific error for known repo\"\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_commands_performance() -> Result<()> {\n-    // Test that GitHub commands complete in reasonable time\n-    use std::time::Instant;\n-\n-    let start = Instant::now();\n-\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let _ = cmd.output()?;\n-\n-    let duration = start.elapsed();\n-\n-    // Should complete within 10 seconds (network calls)\n-    assert!(\n-        duration.as_secs() < 10,\n-        \"GitHub command should complete within 10 seconds, took {:?}\",\n-        duration\n-    );\n-\n-    Ok(())\n-}\n-\n-#[test]\n-fn test_github_api_error_messages_are_helpful() -> Result<()> {\n-    // Test that error messages are user-friendly\n-    let mut cmd = Command::cargo_bin(\"ggen\")?;\n-    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n-\n-    let output = cmd.output()?;\n-    let stderr = String::from_utf8_lossy(&output.stderr);\n-\n-    // Error should be informative\n-    if !output.status.success() {\n-        assert!(\n-            stderr.contains(\"Error\")\n-                || stderr.contains(\"not found\")\n-                || stderr.contains(\"404\")\n-                || stderr.contains(\"does not exist\"),\n-            \"Error message should be informative, got: {}\",\n-            stderr\n-        );\n-    }\n-\n-    Ok(())\n-}\n"
                }
            ],
            "date": 1760245905696,
            "name": "Commit-0",
            "content": "use anyhow::Result;\nuse assert_cmd::Command;\nuse predicates::prelude::*;\nuse std::env;\n\n/// E2E tests for GitHub API integration\n///\n/// Tests the GitHub API commands added in v1.0.0:\n/// - ggen ci pages status\n/// - ggen ci workflow status\n/// - ggen ci trigger\n\n#[test]\nfn test_github_pages_status_command() -> Result<()> {\n    // Test that the command exists and has proper help\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\").arg(\"--help\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"status\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_github_pages_status_with_explicit_repo() -> Result<()> {\n    // Test with explicit repository argument\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    // Command might fail without GITHUB_TOKEN, but it should run\n    let output = cmd.output()?;\n\n    // Should output either success info or error message (not crash)\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // One of these should contain relevant information\n    assert!(\n        stdout.contains(\"Pages\") || stderr.contains(\"Pages\") || stderr.contains(\"Error\"),\n        \"Command should provide pages status or error message\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_workflow_status_command() -> Result<()> {\n    // Test that the command exists and has proper help\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\").arg(\"--help\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"status\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_github_workflow_status_with_workflow_name() -> Result<()> {\n    // Test with explicit workflow name\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\")\n        .arg(\"workflow\")\n        .arg(\"status\")\n        .arg(\"--workflow\")\n        .arg(\"Build and Deploy GitHub Pages\");\n\n    // Command might fail without GITHUB_TOKEN or if workflow doesn't exist\n    let output = cmd.output()?;\n\n    // Should provide some output (success or error)\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should contain workflow-related information or error\n    assert!(\n        stdout.contains(\"Workflow\")\n            || stdout.contains(\"Build\")\n            || stderr.contains(\"Workflow\")\n            || stderr.contains(\"Error\"),\n        \"Command should provide workflow status or error message\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_trigger_workflow_command() -> Result<()> {\n    // Test that the command exists and has proper help\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"trigger\").arg(\"--help\");\n\n    cmd.assert()\n        .success()\n        .stdout(predicate::str::contains(\"trigger\"));\n\n    Ok(())\n}\n\n#[test]\n#[ignore] // Network-dependent: requires git remote configuration\nfn test_github_repo_auto_detection() -> Result<()> {\n    // Test that commands can auto-detect repo from git remote\n    // This will fail gracefully if not in a git repo\n\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let output = cmd.output()?;\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should either detect repo successfully or provide helpful error\n    assert!(\n        stderr.contains(\"detected\")\n            || stderr.contains(\"repository\")\n            || stderr.contains(\"Error\")\n            || stderr.contains(\"Pages\"),\n        \"Command should attempt repo detection or provide error\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_commands_handle_missing_token() -> Result<()> {\n    // Test that commands work or fail gracefully without GITHUB_TOKEN\n    // Temporarily unset GITHUB_TOKEN if it exists\n    let original_token = env::var(\"GITHUB_TOKEN\").ok();\n    env::remove_var(\"GITHUB_TOKEN\");\n\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let output = cmd.output()?;\n\n    // Restore original token\n    if let Some(token) = original_token {\n        env::set_var(\"GITHUB_TOKEN\", token);\n    }\n\n    // Command should run (might fail due to rate limiting, but shouldn't crash)\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should provide some output\n    assert!(\n        !stdout.is_empty() || !stderr.is_empty(),\n        \"Command should provide output even without token\"\n    );\n\n    Ok(())\n}\n\n#[test]\n#[ignore] // Network-dependent: requires GitHub API access\nfn test_github_pages_status_output_format() -> Result<()> {\n    // Test that pages-status provides expected output format\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let output = cmd.output()?;\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should mention pages URL or status\n    assert!(\n        stdout.contains(\"github.io\")\n            || stdout.contains(\"Pages URL\")\n            || stdout.contains(\"Status\")\n            || stderr.contains(\"Error\")\n            || stderr.contains(\"not configured\"),\n        \"Output should contain pages information or error\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_workflow_status_lists_workflows() -> Result<()> {\n    // Test that workflow-status can list workflows\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"workflow\").arg(\"status\");\n\n    let output = cmd.output()?;\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should list workflows or provide error\n    assert!(\n        stdout.contains(\"Workflow\")\n            || stdout.contains(\"workflow\")\n            || stderr.contains(\"Error\")\n            || stderr.contains(\"No workflows\"),\n        \"Output should contain workflow information or error\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_commands_validate_repo_format() -> Result<()> {\n    // Test that commands validate repository format\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\"); // No repo argument needed for CI commands\n\n    let output = cmd.output()?;\n\n    // Should fail with validation error\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(&output.stderr);\n        assert!(\n            stderr.contains(\"Error\") || stderr.contains(\"invalid\") || stderr.contains(\"format\"),\n            \"Should provide error for invalid repo format\"\n        );\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_github_help_commands() -> Result<()> {\n    // Test that all GitHub subcommands have help text\n    let subcommands = [\"pages status\", \"workflow status\", \"trigger\"];\n\n    for subcommand in &subcommands {\n        let mut cmd = Command::cargo_bin(\"ggen\")?;\n        cmd.args([\"ci\"].iter().chain(subcommand.split(\" \").map(|s| s.as_ref())))\n            .arg(\"--help\");\n\n        cmd.assert().success().stdout(predicate::str::contains(\n            subcommand.split(' ').next().unwrap(),\n        ));\n    }\n\n    Ok(())\n}\n\n#[test]\n#[ignore] // Network-dependent: requires GitHub API access\nfn test_github_integration_with_public_repo() -> Result<()> {\n    // Test GitHub integration with a known public repository\n    // This is the most realistic E2E test\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let output = cmd.output()?;\n\n    // Command should complete (success or known error)\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Should get either pages info or a specific error\n    assert!(\n        stdout.contains(\"seanchatmangpt.github.io/ggen\")\n            || stdout.contains(\"Status:\")\n            || stdout.contains(\"Pages URL:\")\n            || stderr.contains(\"Error:\")\n            || stderr.contains(\"not configured\")\n            || stderr.contains(\"rate limit\"),\n        \"Command should provide pages status or specific error for known repo\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_commands_performance() -> Result<()> {\n    // Test that GitHub commands complete in reasonable time\n    use std::time::Instant;\n\n    let start = Instant::now();\n\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let _ = cmd.output()?;\n\n    let duration = start.elapsed();\n\n    // Should complete within 10 seconds (network calls)\n    assert!(\n        duration.as_secs() < 10,\n        \"GitHub command should complete within 10 seconds, took {:?}\",\n        duration\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_github_api_error_messages_are_helpful() -> Result<()> {\n    // Test that error messages are user-friendly\n    let mut cmd = Command::cargo_bin(\"ggen\")?;\n    cmd.arg(\"ci\").arg(\"pages\").arg(\"status\");\n\n    let output = cmd.output()?;\n    let stderr = String::from_utf8_lossy(&output.stderr);\n\n    // Error should be informative\n    if !output.status.success() {\n        assert!(\n            stderr.contains(\"Error\")\n                || stderr.contains(\"not found\")\n                || stderr.contains(\"404\")\n                || stderr.contains(\"does not exist\"),\n            \"Error message should be informative, got: {}\",\n            stderr\n        );\n    }\n\n    Ok(())\n}\n"
        }
    ]
}