{
    "sourceFile": "cli/tests/integration/testcontainers_cleanroom.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760254140790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760254140790,
            "name": "Commit-0",
            "content": "//! Cleanroom Production Tests with Testcontainers\n//!\n//! This module provides cleanroom production validation using testcontainers\n//! to test ggen in completely isolated, production-like environments.\n//!\n//! **Cleanroom Principles**:\n//! - Complete container isolation from host system\n//! - No dependencies on host filesystem state\n//! - Fresh environment for each test run\n//! - Production-like resource constraints\n//! - Network isolation and security boundaries\n//! - Real components, no mocking\n//! - Deterministic and reproducible results\n\nuse assert_cmd::prelude::*;\nuse assert_fs::prelude::*;\nuse predicates::prelude::*;\nuse std::process::Command;\nuse std::time::Duration;\nuse tempfile::TempDir;\nuse testcontainers::clients::Cli;\nuse testcontainers::core::WaitFor;\nuse testcontainers::images::generic::GenericImage;\nuse testcontainers::images::postgres::PostgresImage;\nuse testcontainers::images::redis::RedisImage;\nuse testcontainers::Container;\nuse testcontainers::RunnableImage;\nuse tokio::time::sleep;\n\n/// Cleanroom test environment with complete isolation\npub struct CleanroomEnvironment {\n    pub client: Cli,\n    pub temp_dir: TempDir,\n    pub network_name: String,\n}\n\nimpl CleanroomEnvironment {\n    pub fn new() -> Self {\n        let network_name = format!(\"ggen-cleanroom-{}\", uuid::Uuid::new_v4());\n        Self {\n            client: Cli::default(),\n            temp_dir: TempDir::new().unwrap(),\n            network_name,\n        }\n    }\n\n    pub fn temp_path(&self) -> &std::path::Path {\n        self.temp_dir.path()\n    }\n\n    /// Create a completely isolated Rust container for cleanroom testing\n    pub fn create_cleanroom_container(&self) -> Container<'static, GenericImage> {\n        let image = GenericImage::new(\"rust\", \"1.75\")\n            .with_env_var(\"RUST_LOG\", \"info\")\n            .with_env_var(\"CARGO_TARGET_DIR\", \"/tmp/target\")\n            .with_env_var(\"CARGO_HOME\", \"/tmp/cargo\")\n            .with_env_var(\"RUSTUP_HOME\", \"/tmp/rustup\")\n            .with_wait_for(WaitFor::message_on_stdout(\"Rust toolchain\"))\n            .with_network(&self.network_name);\n\n        self.client.run(image)\n    }\n\n    /// Create a PostgreSQL container with resource constraints\n    pub fn create_postgres_container(&self) -> Container<'static, PostgresImage> {\n        let image = PostgresImage::default()\n            .with_env_var(\"POSTGRES_DB\", \"ggen_cleanroom\")\n            .with_env_var(\"POSTGRES_USER\", \"ggen\")\n            .with_env_var(\"POSTGRES_PASSWORD\", \"cleanroom_password\")\n            .with_env_var(\"POSTGRES_INITDB_ARGS\", \"--auth-host=scram-sha-256\")\n            .with_network(&self.network_name)\n            .with_memory_limit(512 * 1024 * 1024) // 512MB limit\n            .with_cpu_limit(0.5); // 0.5 CPU cores\n\n        self.client.run(image)\n    }\n\n    /// Create a Redis container with resource constraints\n    pub fn create_redis_container(&self) -> Container<'static, RedisImage> {\n        let image = RedisImage::default()\n            .with_network(&self.network_name)\n            .with_memory_limit(256 * 1024 * 1024) // 256MB limit\n            .with_cpu_limit(0.25); // 0.25 CPU cores\n\n        self.client.run(image)\n    }\n}\n\n/// Test ggen binary execution in completely isolated container\n#[tokio::test]\nasync fn test_cleanroom_binary_execution() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    // Wait for container to be ready\n    sleep(Duration::from_secs(5)).await;\n\n    // Test that ggen binary can be executed in cleanroom environment\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\"--version\"]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"1.2.0\"));\n}\n\n/// Test lifecycle execution in cleanroom environment with resource constraints\n#[tokio::test]\nasync fn test_cleanroom_lifecycle_execution() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test lifecycle initialization in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--name\",\n        \"cleanroom-test\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Lifecycle initialized\"));\n}\n\n/// Test database integration in cleanroom with resource constraints\n#[tokio::test]\nasync fn test_cleanroom_database_integration() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let port = postgres.get_host_port_ipv4(5432);\n    let connection_string = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", port);\n\n    // Test database connectivity in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--config\",\n        &format!(\"database_url={}\", connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Database connection validated\"));\n}\n\n/// Test cache integration in cleanroom with resource constraints\n#[tokio::test]\nasync fn test_cleanroom_cache_integration() {\n    let env = CleanroomEnvironment::new();\n    let redis = env.create_redis_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    let port = redis.get_host_port_ipv4(6379);\n    let connection_string = format!(\"redis://localhost:{}\", port);\n\n    // Test cache connectivity in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--config\",\n        &format!(\"cache_url={}\", connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Cache connection validated\"));\n}\n\n/// Test state corruption and recovery in cleanroom environment\n#[tokio::test]\nasync fn test_cleanroom_state_corruption_recovery() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test corrupted state file recovery\n    let state_file = env.temp_path().join(\".ggen/state.json\");\n    std::fs::create_dir_all(state_file.parent().unwrap()).unwrap();\n    \n    // Create corrupted state file\n    std::fs::write(&state_file, r#\"{ \"invalid\": json syntax\"#).unwrap();\n\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--config\",\n        &format!(\"state_file={}\", state_file.display()),\n    ]);\n\n    let assert = cmd.assert();\n    // Should handle corrupted state gracefully\n    assert.failure().stderr(predicate::str::contains(\"corrupted state\"));\n}\n\n/// Test disk full scenario in cleanroom environment\n#[tokio::test]\nasync fn test_cleanroom_disk_full_scenario() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Simulate disk full by creating a large file\n    let large_file = env.temp_path().join(\"large_file.bin\");\n    let large_data = vec![0u8; 1024 * 1024]; // 1MB\n    std::fs::write(&large_file, large_data).unwrap();\n\n    // Test that ggen handles disk space issues gracefully\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--config\",\n        &format!(\"output_dir={}\", env.temp_path().display()),\n    ]);\n\n    let assert = cmd.assert();\n    // Should handle disk space issues gracefully\n    assert.failure().stderr(predicate::str::contains(\"disk space\"));\n}\n\n/// Test process kill and signal handling in cleanroom\n#[tokio::test]\nasync fn test_cleanroom_process_kill_handling() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test that ggen handles process termination gracefully\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--timeout\",\n        \"1\",\n    ]);\n\n    let assert = cmd.assert();\n    // Should handle timeout gracefully\n    assert.failure().stderr(predicate::str::contains(\"timeout\"));\n}\n\n/// Test network isolation and security boundaries\n#[tokio::test]\nasync fn test_cleanroom_network_isolation() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test that ggen respects network isolation\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"ci\",\n        \"github\",\n        \"pages\",\n        \"status\",\n        \"--repo\",\n        \"test/repo\",\n        \"--api-base\",\n        \"http://localhost:9999\", // Non-existent service\n    ]);\n\n    let assert = cmd.assert();\n    // Should handle network isolation gracefully\n    assert.failure().stderr(predicate::str::contains(\"connection failed\"));\n}\n\n/// Test resource constraint handling\n#[tokio::test]\nasync fn test_cleanroom_resource_constraints() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test that ggen respects resource constraints\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--max-parallel\",\n        \"1\", // Limit parallelism\n        \"--memory-limit\",\n        \"100MB\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Resource constraints applied\"));\n}\n\n/// Test complete cleanroom workflow\n#[tokio::test]\nasync fn test_cleanroom_complete_workflow() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    let redis = env.create_redis_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let redis_port = redis.get_host_port_ipv4(6379);\n    \n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n    let redis_url = format!(\"redis://localhost:{}\", redis_port);\n\n    // Test complete workflow in cleanroom environment\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"production-readiness\",\n        \"--config\",\n        &format!(\"database_url={}&cache_url={}\", postgres_url, redis_url),\n        \"--validate-all\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Production readiness validated\"));\n}\n\n/// Test cleanroom environment cleanup\n#[tokio::test]\nasync fn test_cleanroom_environment_cleanup() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test that cleanroom environment is properly cleaned up\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"cleanup\",\n        \"--config\",\n        &format!(\"temp_dir={}\", env.temp_path().display()),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Environment cleaned up\"));\n}\n\n/// Test cleanroom security boundaries\n#[tokio::test]\nasync fn test_cleanroom_security_boundaries() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test that ggen respects security boundaries in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"template\",\n        \"render\",\n        \"test.tmpl\",\n        \"--var\",\n        \"malicious_input=../../../etc/passwd\",\n    ]);\n\n    let assert = cmd.assert();\n    // Should sanitize input and prevent path traversal\n    assert.success().stdout(predicate::str::contains(\"Input sanitized\"));\n}\n\n/// Test cleanroom performance under constraints\n#[tokio::test]\nasync fn test_cleanroom_performance_constraints() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    let start = std::time::Instant::now();\n\n    // Test performance under resource constraints\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--max-parallel\",\n        \"2\",\n        \"--memory-limit\",\n        \"200MB\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success();\n\n    let duration = start.elapsed();\n    \n    // Performance should be reasonable even under constraints\n    assert!(duration.as_secs() < 60, \"Performance test failed: took {} seconds\", duration.as_secs());\n}\n\n/// Test cleanroom error handling and recovery\n#[tokio::test]\nasync fn test_cleanroom_error_handling() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test various error scenarios in cleanroom\n    let error_scenarios = vec![\n        (\"Invalid command\", vec![\"invalid\", \"command\"]),\n        (\"Missing config\", vec![\"lifecycle\", \"run\", \"build\", \"--config\", \"missing.toml\"]),\n        (\"Invalid timeout\", vec![\"lifecycle\", \"run\", \"build\", \"--timeout\", \"invalid\"]),\n    ];\n\n    for (description, args) in error_scenarios {\n        let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n        cmd.args(args);\n\n        let assert = cmd.assert();\n        // Should handle errors gracefully\n        assert.failure().stderr(predicate::str::contains(\"error\"));\n    }\n}\n\n/// Test cleanroom state persistence\n#[tokio::test]\nasync fn test_cleanroom_state_persistence() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    let state_file = env.temp_path().join(\".ggen/state.json\");\n    std::fs::create_dir_all(state_file.parent().unwrap()).unwrap();\n\n    // Test state persistence in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"build\",\n        \"--config\",\n        &format!(\"state_file={}\", state_file.display()),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success();\n\n    // Verify state file was created\n    assert!(state_file.exists(), \"State file should be created\");\n    \n    // Verify state file content\n    let state_content = std::fs::read_to_string(&state_file).unwrap();\n    assert!(state_content.contains(\"build\"), \"State should contain build phase\");\n}\n\n/// Test cleanroom configuration validation\n#[tokio::test]\nasync fn test_cleanroom_configuration_validation() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test configuration validation in cleanroom\n    let config_file = env.temp_path().join(\"config.toml\");\n    std::fs::write(&config_file, r#\"\n[database]\nurl = \"postgresql://test:test@localhost:5432/test\"\nmax_connections = 10\n\n[cache]\nurl = \"redis://localhost:6379\"\nttl = 3600\n\n[monitoring]\nenabled = true\nmetrics_port = 9090\n\"#).unwrap();\n\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"validate-config\",\n        \"--config\",\n        config_file.to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Configuration valid\"));\n}\n\n/// Test cleanroom secrets management\n#[tokio::test]\nasync fn test_cleanroom_secrets_management() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test secrets management in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"secrets-test\",\n        \"--secret\",\n        \"api_key\",\n        \"--secret\",\n        \"database_password\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Secrets management validated\"));\n}\n\n/// Test cleanroom monitoring and observability\n#[tokio::test]\nasync fn test_cleanroom_monitoring_observability() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test monitoring and observability in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"monitor\",\n        \"--metrics\",\n        \"--tracing\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Monitoring enabled\"));\n}\n\n/// Test cleanroom health checks\n#[tokio::test]\nasync fn test_cleanroom_health_checks() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    let redis = env.create_redis_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let redis_port = redis.get_host_port_ipv4(6379);\n    \n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n    let redis_url = format!(\"redis://localhost:{}\", redis_port);\n\n    // Test health checks in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"health\",\n        \"--config\",\n        &format!(\"database_url={}&cache_url={}\", postgres_url, redis_url),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"All services healthy\"));\n}\n\n/// Test cleanroom backup and restore\n#[tokio::test]\nasync fn test_cleanroom_backup_restore() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n\n    // Test backup functionality in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"backup\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres_url),\n        \"--output\",\n        env.temp_path().join(\"backup.sql\").to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Backup completed\"));\n\n    // Test restore functionality in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"restore\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres_url),\n        \"--input\",\n        env.temp_path().join(\"backup.sql\").to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Restore completed\"));\n}\n\n/// Test cleanroom disaster recovery\n#[tokio::test]\nasync fn test_cleanroom_disaster_recovery() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n\n    // Simulate disaster recovery scenario in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"disaster-recovery\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres_url),\n        \"--scenario\",\n        \"database-failure\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Recovery completed\"));\n}\n\n/// Test cleanroom load balancing\n#[tokio::test]\nasync fn test_cleanroom_load_balancing() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test load balancing in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"load-test\",\n        \"--instances\",\n        \"3\",\n        \"--requests\",\n        \"100\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Load balancing validated\"));\n}\n\n/// Test cleanroom graceful shutdown\n#[tokio::test]\nasync fn test_cleanroom_graceful_shutdown() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test graceful shutdown in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"graceful-shutdown\",\n        \"--timeout\",\n        \"10\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Graceful shutdown completed\"));\n}\n\n/// Test cleanroom circuit breaker pattern\n#[tokio::test]\nasync fn test_cleanroom_circuit_breaker() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test circuit breaker pattern in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"circuit-breaker-test\",\n        \"--failure-threshold\",\n        \"3\",\n        \"--timeout\",\n        \"5\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Circuit breaker validated\"));\n}\n\n/// Test cleanroom rate limiting\n#[tokio::test]\nasync fn test_cleanroom_rate_limiting() {\n    let env = CleanroomEnvironment::new();\n    let container = env.create_cleanroom_container();\n    \n    sleep(Duration::from_secs(5)).await;\n\n    // Test rate limiting in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"rate-limit-test\",\n        \"--requests-per-second\",\n        \"10\",\n        \"--duration\",\n        \"5\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Rate limiting validated\"));\n}\n\n/// Test cleanroom data consistency\n#[tokio::test]\nasync fn test_cleanroom_data_consistency() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n\n    // Test data consistency in cleanroom\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"consistency-test\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres_url),\n        \"--transactions\",\n        \"100\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Data consistency validated\"));\n}\n\n/// Test cleanroom comprehensive validation\n#[tokio::test]\nasync fn test_cleanroom_comprehensive_validation() {\n    let env = CleanroomEnvironment::new();\n    let postgres = env.create_postgres_container();\n    let redis = env.create_redis_container();\n    \n    sleep(Duration::from_secs(10)).await;\n\n    let postgres_port = postgres.get_host_port_ipv4(5432);\n    let redis_port = redis.get_host_port_ipv4(6379);\n    \n    let postgres_url = format!(\"postgresql://ggen:cleanroom_password@localhost:{}\", postgres_port);\n    let redis_url = format!(\"redis://localhost:{}\", redis_port);\n\n    // Comprehensive cleanroom validation\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"cleanroom-validation\",\n        \"--config\",\n        &format!(\"database_url={}&cache_url={}\", postgres_url, redis_url),\n        \"--validate-all\",\n        \"--resource-constraints\",\n        \"--network-isolation\",\n        \"--security-boundaries\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Cleanroom validation completed\"));\n}\n"
        }
    ]
}