{
    "sourceFile": "cleanroom/tests/integration_tests.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1760266637917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760268144277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,543 +1,426 @@\n //! Integration tests for cleanroom testing framework\n //!\n-//! These tests verify the complete cleanroom functionality following core team best practices:\n-//! - End-to-end cleanroom environment testing\n-//! - Container lifecycle management\n-//! - Resource monitoring and limits\n-//! - Performance validation\n-//! - Error handling and recovery\n+//! These tests verify the complete cleanroom environment functionality\n+//! including container lifecycle, service integration, and error handling.\n \n use cleanroom::{\n     CleanroomEnvironment, CleanroomConfig, CleanroomGuard,\n     PostgresContainer, RedisContainer, GenericContainer,\n-    SecurityPolicy, PerformanceMonitoringConfig, PerformanceThresholds,\n-    ResourceLimits, ContainerCustomizer, VolumeMount, PortMapping,\n-    ContainerResourceLimits, HealthCheckConfig,\n+    ContainerWrapper, ServiceContainer,\n+    Policy, SecurityLevel,\n+    ResourceLimits, DeterministicManager,\n+    CoverageTracker, SnapshotManager, TracingManager,\n+    TestReport, CleanroomError,\n };\n use std::sync::Arc;\n use std::time::Duration;\n-use tokio::time::sleep;\n+use tokio::time::timeout;\n+use uuid::Uuid;\n \n-/// Test cleanroom environment creation and basic functionality\n+/// Test basic cleanroom environment creation and configuration\n #[tokio::test]\n-async fn test_cleanroom_environment_creation() {\n+async fn test_cleanroom_environment_creation() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let env = environment.unwrap();\n-    assert!(env.session_id != uuid::Uuid::nil());\n-}\n-\n-/// Test cleanroom environment with custom configuration\n-#[tokio::test]\n-async fn test_cleanroom_environment_custom_config() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_singleton_containers = true;\n-    config.container_startup_timeout = Duration::from_secs(60);\n-    config.test_execution_timeout = Duration::from_secs(600);\n-    config.enable_deterministic_execution = true;\n-    config.deterministic_seed = Some(12345);\n+    // Verify environment is properly initialized\n+    assert!(environment.is_initialized().await);\n     \n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n-}\n-\n-/// Test cleanroom environment with security policy\n-#[tokio::test]\n-async fn test_cleanroom_environment_security_policy() {\n-    let mut config = CleanroomConfig::default();\n-    config.security_policy.enable_network_isolation = true;\n-    config.security_policy.enable_filesystem_isolation = true;\n-    config.security_policy.enable_process_isolation = true;\n-    config.security_policy.allowed_ports = vec![5432, 6379, 8080];\n-    config.security_policy.blocked_addresses = vec![\"127.0.0.1\".to_string()];\n+    // Verify configuration is set correctly\n+    let env_config = environment.config();\n+    assert!(env_config.enable_singleton_containers);\n+    assert_eq!(env_config.container_startup_timeout, Duration::from_secs(30));\n     \n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n+    Ok(())\n }\n \n-/// Test cleanroom environment with performance monitoring\n-#[tokio::test]\n-async fn test_cleanroom_environment_performance_monitoring() {\n-    let mut config = CleanroomConfig::default();\n-    config.performance_monitoring.enable_monitoring = true;\n-    config.performance_monitoring.metrics_interval = Duration::from_secs(5);\n-    config.performance_monitoring.thresholds.max_cpu_usage_percent = 70.0;\n-    config.performance_monitoring.thresholds.max_memory_usage_bytes = 512 * 1024 * 1024;\n-    config.performance_monitoring.thresholds.max_test_execution_time = Duration::from_secs(120);\n-    \n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n-}\n-\n-/// Test cleanroom environment with resource limits\n-#[tokio::test]\n-async fn test_cleanroom_environment_resource_limits() {\n-    let mut config = CleanroomConfig::default();\n-    config.resource_limits.max_cpu_usage_percent = 50.0;\n-    config.resource_limits.max_memory_usage_bytes = 256 * 1024 * 1024;\n-    config.resource_limits.max_disk_usage_bytes = 5 * 1024 * 1024 * 1024;\n-    config.resource_limits.max_network_bandwidth_bytes_per_sec = 50 * 1024 * 1024;\n-    config.resource_limits.max_container_count = 5;\n-    \n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n-}\n-\n-/// Test cleanroom environment with container customizers\n-#[tokio::test]\n-async fn test_cleanroom_environment_container_customizers() {\n-    let mut config = CleanroomConfig::default();\n-    \n-    let customizer = ContainerCustomizer {\n-        name: \"postgres_customizer\".to_string(),\n-        env_vars: std::collections::HashMap::from([\n-            (\"POSTGRES_DB\".to_string(), \"testdb\".to_string()),\n-            (\"POSTGRES_USER\".to_string(), \"testuser\".to_string()),\n-            (\"POSTGRES_PASSWORD\".to_string(), \"testpass\".to_string()),\n-        ]),\n-        volume_mounts: vec![\n-            VolumeMount {\n-                host_path: \"/tmp/test\".to_string(),\n-                container_path: \"/data\".to_string(),\n-                read_only: false,\n-            },\n-        ],\n-        port_mappings: vec![\n-            PortMapping {\n-                container_port: 5432,\n-                host_port: Some(5433),\n-                protocol: \"tcp\".to_string(),\n-            },\n-        ],\n-        resource_limits: ContainerResourceLimits {\n-            cpu_limit: 0.5,\n-            memory_limit_bytes: 512 * 1024 * 1024,\n-            disk_limit_bytes: 1024 * 1024 * 1024,\n-            network_bandwidth_limit: 100 * 1024 * 1024,\n-        },\n-        health_check: HealthCheckConfig {\n-            command: \"pg_isready -U testuser -d testdb\".to_string(),\n-            interval: Duration::from_secs(10),\n-            timeout: Duration::from_secs(5),\n-            retries: 3,\n-            start_period: Duration::from_secs(30),\n-        },\n-        init_commands: vec![\n-            \"psql -U testuser -d testdb -c 'CREATE TABLE IF NOT EXISTS test_table (id SERIAL PRIMARY KEY);'\".to_string(),\n-        ],\n-    };\n-    \n-    config.container_customizers.insert(\"postgres\".to_string(), customizer);\n-    \n-    let environment = CleanroomEnvironment::new(config).await;\n-    assert!(environment.is_ok());\n-}\n-\n /// Test cleanroom guard for automatic cleanup\n #[tokio::test]\n-async fn test_cleanroom_guard() {\n+async fn test_cleanroom_guard() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     let environment_arc = Arc::new(environment);\n     \n+    // Create guard\n     let _guard = CleanroomGuard::new(environment_arc.clone());\n     \n-    // Guard should be dropped automatically\n-    sleep(Duration::from_millis(100)).await;\n+    // Verify environment is still accessible\n+    assert!(environment_arc.is_initialized().await);\n+    \n+    // Guard will automatically cleanup when dropped\n+    Ok(())\n }\n \n-/// Test cleanroom metrics collection\n+/// Test container lifecycle management\n #[tokio::test]\n-async fn test_cleanroom_metrics_collection() {\n+async fn test_container_lifecycle() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute a test\n-    let result = environment.execute_test(\"test_metrics\", || {\n-        Ok(\"test_result\")\n-    }).await;\n+    // Test Postgres container\n+    let postgres_container = PostgresContainer::new(\"postgres:15\")\n+        .with_env(\"POSTGRES_PASSWORD\", \"test\")\n+        .with_env(\"POSTGRES_DB\", \"testdb\");\n     \n-    assert!(result.is_ok());\n+    let container_id = environment.start_container(postgres_container).await?;\n+    assert!(environment.is_container_running(&container_id).await?);\n     \n-    let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 1);\n-    assert_eq!(metrics.tests_passed, 1);\n-    assert_eq!(metrics.tests_failed, 0);\n-}\n-\n-/// Test cleanroom resource limits checking\n-#[tokio::test]\n-async fn test_cleanroom_resource_limits() {\n-    let mut config = CleanroomConfig::default();\n-    config.performance_monitoring.thresholds.max_cpu_usage_percent = 50.0;\n-    config.performance_monitoring.thresholds.max_memory_usage_bytes = 256 * 1024 * 1024;\n+    // Test container access\n+    let connection_info = environment.get_container_info(&container_id).await?;\n+    assert!(connection_info.is_some());\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test container stop\n+    environment.stop_container(&container_id).await?;\n+    assert!(!environment.is_container_running(&container_id).await?);\n     \n-    // Check resource limits (should pass initially)\n-    let result = environment.check_resource_limits().await;\n-    assert!(result.is_ok());\n+    Ok(())\n }\n \n-/// Test cleanroom error handling\n+/// Test service container integration\n #[tokio::test]\n-async fn test_cleanroom_error_handling() {\n+async fn test_service_container_integration() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute a failing test\n-    let result = environment.execute_test(\"test_error\", || {\n-        Err(cleanroom::CleanroomError::internal_error(\"Test error\"))\n-    }).await;\n+    // Test Postgres service\n+    let postgres_service = environment.create_postgres_service(\"postgres:15\").await?;\n+    assert!(postgres_service.is_ready().await?);\n     \n-    assert!(result.is_err());\n+    let connection_string = postgres_service.connection_string();\n+    assert!(connection_string.contains(\"postgresql://\"));\n     \n-    let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 1);\n-    assert_eq!(metrics.tests_passed, 0);\n-    assert_eq!(metrics.tests_failed, 1);\n-    assert_eq!(metrics.error_count, 1);\n+    // Test Redis service\n+    let redis_service = environment.create_redis_service(\"redis:7\").await?;\n+    assert!(redis_service.is_ready().await?);\n+    \n+    let redis_url = redis_service.redis_url();\n+    assert!(redis_url.starts_with(\"redis://\"));\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom timeout handling\n+/// Test policy enforcement\n #[tokio::test]\n-async fn test_cleanroom_timeout_handling() {\n+async fn test_policy_enforcement() -> Result<(), Box<dyn std::error::Error>> {\n     let mut config = CleanroomConfig::default();\n-    config.test_execution_timeout = Duration::from_millis(100);\n+    config.enable_security_policy = true;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute a test that should timeout\n-    let result = environment.execute_test(\"test_timeout\", || {\n-        sleep(Duration::from_millis(200)).await;\n-        Ok(\"should_not_reach_here\")\n-    }).await;\n+    // Test locked policy\n+    let locked_policy = Policy::locked();\n+    environment.set_policy(locked_policy).await?;\n     \n-    assert!(result.is_err());\n+    // Verify policy is enforced\n+    let current_policy = environment.get_policy().await?;\n+    assert_eq!(current_policy.security_level, SecurityLevel::Locked);\n+    assert!(!current_policy.allows_network());\n     \n-    let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 1);\n-    assert_eq!(metrics.tests_failed, 1);\n-    assert_eq!(metrics.error_count, 1);\n+    // Test custom policy\n+    let custom_policy = Policy::with_security_level(SecurityLevel::Strict)\n+        .with_network_isolation(false);\n+    \n+    environment.set_policy(custom_policy).await?;\n+    \n+    let updated_policy = environment.get_policy().await?;\n+    assert_eq!(updated_policy.security_level, SecurityLevel::Strict);\n+    assert!(updated_policy.allows_network());\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom deterministic execution\n+/// Test resource limits and monitoring\n #[tokio::test]\n-async fn test_cleanroom_deterministic_execution() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_deterministic_execution = true;\n-    config.deterministic_seed = Some(42);\n+async fn test_resource_limits() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test resource limits\n+    let limits = ResourceLimits::new()\n+        .with_max_memory_mb(512)\n+        .with_max_cpu_percent(50.0)\n+        .with_max_disk_mb(1024);\n     \n-    // Test deterministic execution\n-    let result1 = environment.execute_test(\"test_deterministic\", || {\n-        Ok(environment.deterministic_manager.random().await)\n-    }).await;\n+    environment.set_resource_limits(limits).await?;\n     \n-    let result2 = environment.execute_test(\"test_deterministic_2\", || {\n-        Ok(environment.deterministic_manager.random().await)\n-    }).await;\n+    // Verify limits are set\n+    let current_limits = environment.get_resource_limits().await?;\n+    assert_eq!(current_limits.max_memory_mb, 512);\n+    assert_eq!(current_limits.max_cpu_percent, 50.0);\n     \n-    assert!(result1.is_ok());\n-    assert!(result2.is_ok());\n+    // Test resource monitoring\n+    let usage = environment.get_resource_usage().await?;\n+    assert!(usage.memory_usage_mb >= 0.0);\n+    assert!(usage.cpu_usage_percent >= 0.0);\n     \n-    // Results should be deterministic (same seed)\n-    let value1 = result1.unwrap();\n-    let value2 = result2.unwrap();\n-    \n-    // Note: In a real test, you'd reset the deterministic manager between tests\n-    // to ensure true determinism. This is a simplified test.\n-    assert!(value1 != value2); // Different calls in sequence\n+    Ok(())\n }\n \n-/// Test cleanroom coverage tracking\n+/// Test deterministic execution\n #[tokio::test]\n-async fn test_cleanroom_coverage_tracking() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_coverage_tracking = true;\n+async fn test_deterministic_execution() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test deterministic manager\n+    let deterministic_manager = DeterministicManager::new();\n+    environment.set_deterministic_manager(deterministic_manager).await?;\n     \n-    // Execute tests with coverage tracking\n-    let _result1 = environment.execute_test(\"test_coverage_1\", || {\n-        Ok(\"test1\")\n-    }).await;\n+    // Test fixed seed\n+    let seed = 12345u64;\n+    environment.set_fixed_seed(seed).await?;\n     \n-    let _result2 = environment.execute_test(\"test_coverage_2\", || {\n-        Ok(\"test2\")\n-    }).await;\n+    // Verify seed is set\n+    let current_seed = environment.get_current_seed().await?;\n+    assert_eq!(current_seed, seed);\n     \n-    let coverage_data = environment.coverage_tracker.get_coverage_data().await;\n-    assert_eq!(coverage_data.test_coverage.len(), 2);\n-}\n-\n-/// Test cleanroom snapshot testing\n-#[tokio::test]\n-async fn test_cleanroom_snapshot_testing() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_snapshot_testing = true;\n+    // Test deterministic test execution\n+    let result1 = environment.execute_deterministic_test(\"test1\", || {\n+        Ok(\"deterministic_result\")\n+    }).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let result2 = environment.execute_deterministic_test(\"test1\", || {\n+        Ok(\"deterministic_result\")\n+    }).await?;\n     \n-    // Capture snapshot\n-    environment.snapshot_manager.capture_snapshot(\n-        \"test_snapshot\".to_string(),\n-        \"test content\".to_string(),\n-        cleanroom::SnapshotType::Text,\n-        std::collections::HashMap::new(),\n-    ).await.unwrap();\n+    assert_eq!(result1, result2);\n     \n-    // Validate snapshot\n-    let result = environment.snapshot_manager.validate_snapshot(\"test_snapshot\", \"test content\").await;\n-    assert!(result.is_ok());\n-    assert!(result.unwrap());\n+    Ok(())\n }\n \n-/// Test cleanroom tracing\n+/// Test coverage tracking\n #[tokio::test]\n-async fn test_cleanroom_tracing() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_tracing = true;\n+async fn test_coverage_tracking() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test coverage tracker\n+    let coverage_tracker = CoverageTracker::new();\n+    environment.set_coverage_tracker(coverage_tracker).await?;\n     \n-    // Start span\n-    let span_id = environment.tracing_manager.start_span(\"test_span\".to_string(), None).await.unwrap();\n-    assert!(span_id != uuid::Uuid::nil());\n+    // Execute test with coverage\n+    let result = environment.execute_test_with_coverage(\"coverage_test\", || {\n+        println!(\"Test execution\");\n+        Ok(\"coverage_result\")\n+    }).await?;\n     \n-    // Add event\n-    environment.tracing_manager.add_span_event(\n-        \"test_span\",\n-        \"test_event\".to_string(),\n-        std::collections::HashMap::from([(\"key\".to_string(), \"value\".to_string())]),\n-    ).await.unwrap();\n+    assert_eq!(result, \"coverage_result\");\n     \n-    // End span\n-    environment.tracing_manager.end_span(\"test_span\", cleanroom::SpanStatus::Completed).await.unwrap();\n+    // Get coverage report\n+    let coverage_report = environment.get_coverage_report().await?;\n+    assert!(coverage_report.total_tests >= 1);\n     \n-    let tracing_data = environment.tracing_manager.get_tracing_data().await;\n-    assert_eq!(tracing_data.spans.len(), 1);\n-    assert!(tracing_data.spans.contains_key(\"test_span\"));\n+    Ok(())\n }\n \n-/// Test cleanroom redaction\n+/// Test snapshot management\n #[tokio::test]\n-async fn test_cleanroom_redaction() {\n-    let mut config = CleanroomConfig::default();\n-    config.security_policy.enable_data_redaction = true;\n-    config.security_policy.redaction_patterns = vec![\n-        r\"password\\s*=\\s*[^\\s]+\".to_string(),\n-        r\"token\\s*=\\s*[^\\s]+\".to_string(),\n-    ];\n+async fn test_snapshot_management() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test snapshot manager\n+    let snapshot_manager = SnapshotManager::new();\n+    environment.set_snapshot_manager(snapshot_manager).await?;\n     \n-    // Test redaction\n-    let content = \"password=secret123 token=abc456\";\n-    let redacted = environment.redaction_manager.redact(content).await.unwrap();\n+    // Create snapshot\n+    let snapshot_data = serde_json::json!({\n+        \"test_data\": \"snapshot_value\",\n+        \"timestamp\": \"2024-01-01T00:00:00Z\"\n+    });\n     \n-    assert!(redacted.contains(\"[REDACTED]\"));\n-    assert!(!redacted.contains(\"secret123\"));\n-    assert!(!redacted.contains(\"abc456\"));\n+    let snapshot_id = environment.create_snapshot(\"test_snapshot\", &snapshot_data).await?;\n+    assert!(!snapshot_id.is_nil());\n+    \n+    // Verify snapshot\n+    let is_valid = environment.verify_snapshot(\"test_snapshot\", &snapshot_data).await?;\n+    assert!(is_valid);\n+    \n+    // Get snapshot\n+    let retrieved_snapshot = environment.get_snapshot(\"test_snapshot\").await?;\n+    assert!(retrieved_snapshot.is_some());\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom report generation\n+/// Test tracing and logging\n #[tokio::test]\n-async fn test_cleanroom_report_generation() {\n+async fn test_tracing_and_logging() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute some tests\n-    let _result1 = environment.execute_test(\"test_report_1\", || {\n-        Ok(\"test1\")\n-    }).await;\n+    // Test tracing manager\n+    let tracing_manager = TracingManager::new();\n+    environment.set_tracing_manager(tracing_manager).await?;\n     \n-    let _result2 = environment.execute_test(\"test_report_2\", || {\n-        Ok(\"test2\")\n-    }).await;\n+    // Execute test with tracing\n+    let result = environment.execute_test_with_tracing(\"traced_test\", || {\n+        println!(\"Traced test execution\");\n+        Ok(\"traced_result\")\n+    }).await?;\n     \n-    // Generate report\n-    let report = environment.report_generator.generate_report(&environment.get_metrics().await).await.unwrap();\n+    assert_eq!(result, \"traced_result\");\n     \n-    assert_eq!(report.session_id, environment.session_id);\n-    assert_eq!(report.test_summary.total_tests, 2);\n-    assert_eq!(report.test_summary.passed_tests, 2);\n-    assert_eq!(report.test_summary.failed_tests, 0);\n+    // Get trace logs\n+    let trace_logs = environment.get_trace_logs().await?;\n+    assert!(!trace_logs.is_empty());\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom cleanup\n+/// Test comprehensive reporting\n #[tokio::test]\n-async fn test_cleanroom_cleanup() {\n+async fn test_comprehensive_reporting() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute some tests\n-    let _result = environment.execute_test(\"test_cleanup\", || {\n-        Ok(\"test\")\n-    }).await;\n+    // Execute multiple tests\n+    environment.execute_test(\"test1\", || Ok(\"result1\")).await?;\n+    environment.execute_test(\"test2\", || Ok(\"result2\")).await?;\n+    environment.execute_test(\"test3\", || Ok(\"result3\")).await?;\n     \n-    // Cleanup\n-    let cleanup_result = environment.cleanup().await;\n-    assert!(cleanup_result.is_ok());\n+    // Generate comprehensive report\n+    let report = environment.generate_comprehensive_report().await?;\n     \n-    let metrics = environment.get_metrics().await;\n-    assert!(metrics.end_time.is_some());\n+    // Verify report structure\n+    assert!(!report.session_id.is_nil());\n+    assert!(report.test_summary.total_tests >= 3);\n+    assert!(report.test_summary.passed_tests >= 3);\n+    assert_eq!(report.test_summary.failed_tests, 0);\n+    \n+    // Test report serialization\n+    let json_report = report.to_json()?;\n+    assert!(json_report.contains(\"session_id\"));\n+    assert!(json_report.contains(\"test_summary\"));\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom comprehensive workflow\n+/// Test error handling and recovery\n #[tokio::test]\n-async fn test_cleanroom_comprehensive_workflow() {\n-    let mut config = CleanroomConfig::default();\n-    config.enable_deterministic_execution = true;\n-    config.deterministic_seed = Some(42);\n-    config.enable_coverage_tracking = true;\n-    config.enable_snapshot_testing = true;\n-    config.enable_tracing = true;\n-    config.security_policy.enable_data_redaction = true;\n-    config.security_policy.redaction_patterns = vec![\n-        r\"password\\s*=\\s*[^\\s]+\".to_string(),\n-    ];\n+async fn test_error_handling() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test container startup failure\n+    let invalid_container = GenericContainer::new(\"nonexistent:latest\");\n+    let result = environment.start_container(invalid_container).await;\n+    assert!(result.is_err());\n     \n-    // Test 1: Basic functionality\n-    let result1 = environment.execute_test(\"test_basic\", || {\n-        Ok(\"basic_test\")\n+    // Test test execution failure\n+    let test_result = environment.execute_test(\"failing_test\", || {\n+        Err(CleanroomError::validation_error(\"Test failure\"))\n     }).await;\n-    assert!(result1.is_ok());\n+    assert!(test_result.is_err());\n     \n-    // Test 2: Error handling\n-    let result2 = environment.execute_test(\"test_error\", || {\n-        Err(cleanroom::CleanroomError::internal_error(\"Test error\"))\n-    }).await;\n-    assert!(result2.is_err());\n+    // Test timeout handling\n+    let timeout_result = timeout(\n+        Duration::from_millis(100),\n+        environment.execute_test(\"slow_test\", || {\n+            std::thread::sleep(Duration::from_millis(200));\n+            Ok(\"slow_result\")\n+        })\n+    ).await;\n+    assert!(timeout_result.is_err());\n     \n-    // Test 3: Coverage tracking\n-    environment.coverage_tracker.start_test(\"coverage_test\".to_string(), \"test.rs\".to_string()).await.unwrap();\n-    environment.coverage_tracker.record_line_coverage(\"coverage_test\", 10, true).await.unwrap();\n-    environment.coverage_tracker.end_test(\"coverage_test\", cleanroom::TestStatus::Passed, 100).await.unwrap();\n+    Ok(())\n+}\n+\n+/// Test concurrent test execution\n+#[tokio::test]\n+async fn test_concurrent_execution() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Test 4: Snapshot testing\n-    environment.snapshot_manager.capture_snapshot(\n-        \"workflow_snapshot\".to_string(),\n-        \"workflow content\".to_string(),\n-        cleanroom::SnapshotType::Text,\n-        std::collections::HashMap::new(),\n-    ).await.unwrap();\n+    // Execute multiple tests concurrently\n+    let futures: Vec<_> = (0..5).map(|i| {\n+        let env = environment.clone();\n+        async move {\n+            env.execute_test(&format!(\"concurrent_test_{}\", i), || {\n+                Ok(format!(\"result_{}\", i))\n+            }).await\n+        }\n+    }).collect();\n     \n-    // Test 5: Tracing\n-    let span_id = environment.tracing_manager.start_span(\"workflow_span\".to_string(), None).await.unwrap();\n-    environment.tracing_manager.add_span_event(\n-        \"workflow_span\",\n-        \"workflow_event\".to_string(),\n-        std::collections::HashMap::new(),\n-    ).await.unwrap();\n-    environment.tracing_manager.end_span(\"workflow_span\", cleanroom::SpanStatus::Completed).await.unwrap();\n+    let results = futures::future::join_all(futures).await;\n     \n-    // Test 6: Redaction\n-    let redacted = environment.redaction_manager.redact(\"password=secret123\").await.unwrap();\n-    assert!(redacted.contains(\"[REDACTED]\"));\n+    // Verify all tests completed successfully\n+    for (i, result) in results.iter().enumerate() {\n+        assert!(result.is_ok());\n+        assert_eq!(result.as_ref().unwrap(), &format!(\"result_{}\", i));\n+    }\n     \n-    // Test 7: Report generation\n-    let report = environment.report_generator.generate_report(&environment.get_metrics().await).await.unwrap();\n-    assert_eq!(report.test_summary.total_tests, 2);\n-    assert_eq!(report.test_summary.passed_tests, 1);\n-    assert_eq!(report.test_summary.failed_tests, 1);\n-    \n-    // Test 8: Cleanup\n-    let cleanup_result = environment.cleanup().await;\n-    assert!(cleanup_result.is_ok());\n-    \n-    let final_metrics = environment.get_metrics().await;\n-    assert!(final_metrics.end_time.is_some());\n-    assert_eq!(final_metrics.tests_executed, 2);\n-    assert_eq!(final_metrics.tests_passed, 1);\n-    assert_eq!(final_metrics.tests_failed, 1);\n+    Ok(())\n }\n \n-/// Test cleanroom performance under load\n+/// Test cleanroom environment cleanup\n #[tokio::test]\n-async fn test_cleanroom_performance_load() {\n-    let mut config = CleanroomConfig::default();\n-    config.test_execution_timeout = Duration::from_secs(30);\n-    config.performance_monitoring.enable_monitoring = true;\n+async fn test_environment_cleanup() -> Result<(), Box<dyn std::error::Error>> {\n+    let config = CleanroomConfig::default();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Start some containers\n+    let postgres_container = PostgresContainer::new(\"postgres:15\")\n+        .with_env(\"POSTGRES_PASSWORD\", \"test\");\n+    let postgres_id = environment.start_container(postgres_container).await?;\n     \n-    // Execute multiple tests in parallel\n-    let mut handles = Vec::new();\n-    for i in 0..10 {\n-        let env = Arc::new(environment);\n-        let handle = tokio::spawn(async move {\n-            env.execute_test(&format!(\"test_load_{}\", i), || {\n-                Ok(format!(\"test_{}\", i))\n-            }).await\n-        });\n-        handles.push(handle);\n-    }\n+    let redis_container = RedisContainer::new(\"redis:7\");\n+    let redis_id = environment.start_container(redis_container).await?;\n     \n-    // Wait for all tests to complete\n-    for handle in handles {\n-        let result = handle.await.unwrap();\n-        assert!(result.is_ok());\n-    }\n+    // Verify containers are running\n+    assert!(environment.is_container_running(&postgres_id).await?);\n+    assert!(environment.is_container_running(&redis_id).await?);\n     \n-    let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 10);\n-    assert_eq!(metrics.tests_passed, 10);\n-    assert_eq!(metrics.tests_failed, 0);\n+    // Cleanup environment\n+    environment.cleanup().await?;\n+    \n+    // Verify containers are stopped\n+    assert!(!environment.is_container_running(&postgres_id).await?);\n+    assert!(!environment.is_container_running(&redis_id).await?);\n+    \n+    Ok(())\n }\n \n-/// Test cleanroom resource monitoring\n+/// Test configuration validation\n #[tokio::test]\n-async fn test_cleanroom_resource_monitoring() {\n-    let mut config = CleanroomConfig::default();\n-    config.performance_monitoring.enable_monitoring = true;\n-    config.performance_monitoring.thresholds.max_cpu_usage_percent = 90.0;\n-    config.performance_monitoring.thresholds.max_memory_usage_bytes = 1024 * 1024 * 1024;\n+async fn test_configuration_validation() -> Result<(), Box<dyn std::error::Error>> {\n+    // Test valid configuration\n+    let valid_config = CleanroomConfig::default();\n+    assert!(valid_config.validate().is_ok());\n     \n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    // Test invalid configuration\n+    let mut invalid_config = CleanroomConfig::default();\n+    invalid_config.max_concurrent_containers = 0; // Invalid value\n     \n-    // Execute tests that should be within limits\n-    for i in 0..5 {\n-        let _result = environment.execute_test(&format!(\"test_resource_{}\", i), || {\n-            Ok(format!(\"test_{}\", i))\n-        }).await;\n-    }\n+    let validation_result = invalid_config.validate();\n+    assert!(validation_result.is_err());\n     \n-    // Check resource limits\n-    let result = environment.check_resource_limits().await;\n-    assert!(result.is_ok());\n-    \n-    let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 5);\n-    assert_eq!(metrics.tests_passed, 5);\n+    Ok(())\n }\n \n-/// Test cleanroom error recovery\n+/// Test performance metrics collection\n #[tokio::test]\n-async fn test_cleanroom_error_recovery() {\n+async fn test_performance_metrics() -> Result<(), Box<dyn std::error::Error>> {\n     let config = CleanroomConfig::default();\n-    let environment = CleanroomEnvironment::new(config).await.unwrap();\n+    let environment = CleanroomEnvironment::new(config).await?;\n     \n-    // Execute a failing test\n-    let result1 = environment.execute_test(\"test_failure\", || {\n-        Err(cleanroom::CleanroomError::internal_error(\"Test failure\"))\n-    }).await;\n-    assert!(result1.is_err());\n+    // Execute test and measure performance\n+    let start_time = std::time::Instant::now();\n+    let result = environment.execute_test(\"performance_test\", || {\n+        // Simulate some work\n+        std::thread::sleep(Duration::from_millis(10));\n+        Ok(\"performance_result\")\n+    }).await?;\n     \n-    // Execute a successful test after failure\n-    let result2 = environment.execute_test(\"test_recovery\", || {\n-        Ok(\"recovery_test\")\n-    }).await;\n-    assert!(result2.is_ok());\n+    let duration = start_time.elapsed();\n     \n+    assert_eq!(result, \"performance_result\");\n+    assert!(duration >= Duration::from_millis(10));\n+    \n+    // Get performance metrics\n     let metrics = environment.get_metrics().await;\n-    assert_eq!(metrics.tests_executed, 2);\n-    assert_eq!(metrics.tests_passed, 1);\n-    assert_eq!(metrics.tests_failed, 1);\n-    assert_eq!(metrics.error_count, 1);\n+    assert!(metrics.total_tests >= 1);\n+    assert!(metrics.average_execution_time >= Duration::from_millis(10));\n+    \n+    Ok(())\n }\n"
                }
            ],
            "date": 1760266637917,
            "name": "Commit-0",
            "content": "//! Integration tests for cleanroom testing framework\n//!\n//! These tests verify the complete cleanroom functionality following core team best practices:\n//! - End-to-end cleanroom environment testing\n//! - Container lifecycle management\n//! - Resource monitoring and limits\n//! - Performance validation\n//! - Error handling and recovery\n\nuse cleanroom::{\n    CleanroomEnvironment, CleanroomConfig, CleanroomGuard,\n    PostgresContainer, RedisContainer, GenericContainer,\n    SecurityPolicy, PerformanceMonitoringConfig, PerformanceThresholds,\n    ResourceLimits, ContainerCustomizer, VolumeMount, PortMapping,\n    ContainerResourceLimits, HealthCheckConfig,\n};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n/// Test cleanroom environment creation and basic functionality\n#[tokio::test]\nasync fn test_cleanroom_environment_creation() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n    \n    let env = environment.unwrap();\n    assert!(env.session_id != uuid::Uuid::nil());\n}\n\n/// Test cleanroom environment with custom configuration\n#[tokio::test]\nasync fn test_cleanroom_environment_custom_config() {\n    let mut config = CleanroomConfig::default();\n    config.enable_singleton_containers = true;\n    config.container_startup_timeout = Duration::from_secs(60);\n    config.test_execution_timeout = Duration::from_secs(600);\n    config.enable_deterministic_execution = true;\n    config.deterministic_seed = Some(12345);\n    \n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n}\n\n/// Test cleanroom environment with security policy\n#[tokio::test]\nasync fn test_cleanroom_environment_security_policy() {\n    let mut config = CleanroomConfig::default();\n    config.security_policy.enable_network_isolation = true;\n    config.security_policy.enable_filesystem_isolation = true;\n    config.security_policy.enable_process_isolation = true;\n    config.security_policy.allowed_ports = vec![5432, 6379, 8080];\n    config.security_policy.blocked_addresses = vec![\"127.0.0.1\".to_string()];\n    \n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n}\n\n/// Test cleanroom environment with performance monitoring\n#[tokio::test]\nasync fn test_cleanroom_environment_performance_monitoring() {\n    let mut config = CleanroomConfig::default();\n    config.performance_monitoring.enable_monitoring = true;\n    config.performance_monitoring.metrics_interval = Duration::from_secs(5);\n    config.performance_monitoring.thresholds.max_cpu_usage_percent = 70.0;\n    config.performance_monitoring.thresholds.max_memory_usage_bytes = 512 * 1024 * 1024;\n    config.performance_monitoring.thresholds.max_test_execution_time = Duration::from_secs(120);\n    \n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n}\n\n/// Test cleanroom environment with resource limits\n#[tokio::test]\nasync fn test_cleanroom_environment_resource_limits() {\n    let mut config = CleanroomConfig::default();\n    config.resource_limits.max_cpu_usage_percent = 50.0;\n    config.resource_limits.max_memory_usage_bytes = 256 * 1024 * 1024;\n    config.resource_limits.max_disk_usage_bytes = 5 * 1024 * 1024 * 1024;\n    config.resource_limits.max_network_bandwidth_bytes_per_sec = 50 * 1024 * 1024;\n    config.resource_limits.max_container_count = 5;\n    \n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n}\n\n/// Test cleanroom environment with container customizers\n#[tokio::test]\nasync fn test_cleanroom_environment_container_customizers() {\n    let mut config = CleanroomConfig::default();\n    \n    let customizer = ContainerCustomizer {\n        name: \"postgres_customizer\".to_string(),\n        env_vars: std::collections::HashMap::from([\n            (\"POSTGRES_DB\".to_string(), \"testdb\".to_string()),\n            (\"POSTGRES_USER\".to_string(), \"testuser\".to_string()),\n            (\"POSTGRES_PASSWORD\".to_string(), \"testpass\".to_string()),\n        ]),\n        volume_mounts: vec![\n            VolumeMount {\n                host_path: \"/tmp/test\".to_string(),\n                container_path: \"/data\".to_string(),\n                read_only: false,\n            },\n        ],\n        port_mappings: vec![\n            PortMapping {\n                container_port: 5432,\n                host_port: Some(5433),\n                protocol: \"tcp\".to_string(),\n            },\n        ],\n        resource_limits: ContainerResourceLimits {\n            cpu_limit: 0.5,\n            memory_limit_bytes: 512 * 1024 * 1024,\n            disk_limit_bytes: 1024 * 1024 * 1024,\n            network_bandwidth_limit: 100 * 1024 * 1024,\n        },\n        health_check: HealthCheckConfig {\n            command: \"pg_isready -U testuser -d testdb\".to_string(),\n            interval: Duration::from_secs(10),\n            timeout: Duration::from_secs(5),\n            retries: 3,\n            start_period: Duration::from_secs(30),\n        },\n        init_commands: vec![\n            \"psql -U testuser -d testdb -c 'CREATE TABLE IF NOT EXISTS test_table (id SERIAL PRIMARY KEY);'\".to_string(),\n        ],\n    };\n    \n    config.container_customizers.insert(\"postgres\".to_string(), customizer);\n    \n    let environment = CleanroomEnvironment::new(config).await;\n    assert!(environment.is_ok());\n}\n\n/// Test cleanroom guard for automatic cleanup\n#[tokio::test]\nasync fn test_cleanroom_guard() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    let environment_arc = Arc::new(environment);\n    \n    let _guard = CleanroomGuard::new(environment_arc.clone());\n    \n    // Guard should be dropped automatically\n    sleep(Duration::from_millis(100)).await;\n}\n\n/// Test cleanroom metrics collection\n#[tokio::test]\nasync fn test_cleanroom_metrics_collection() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute a test\n    let result = environment.execute_test(\"test_metrics\", || {\n        Ok(\"test_result\")\n    }).await;\n    \n    assert!(result.is_ok());\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 1);\n    assert_eq!(metrics.tests_passed, 1);\n    assert_eq!(metrics.tests_failed, 0);\n}\n\n/// Test cleanroom resource limits checking\n#[tokio::test]\nasync fn test_cleanroom_resource_limits() {\n    let mut config = CleanroomConfig::default();\n    config.performance_monitoring.thresholds.max_cpu_usage_percent = 50.0;\n    config.performance_monitoring.thresholds.max_memory_usage_bytes = 256 * 1024 * 1024;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Check resource limits (should pass initially)\n    let result = environment.check_resource_limits().await;\n    assert!(result.is_ok());\n}\n\n/// Test cleanroom error handling\n#[tokio::test]\nasync fn test_cleanroom_error_handling() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute a failing test\n    let result = environment.execute_test(\"test_error\", || {\n        Err(cleanroom::CleanroomError::internal_error(\"Test error\"))\n    }).await;\n    \n    assert!(result.is_err());\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 1);\n    assert_eq!(metrics.tests_passed, 0);\n    assert_eq!(metrics.tests_failed, 1);\n    assert_eq!(metrics.error_count, 1);\n}\n\n/// Test cleanroom timeout handling\n#[tokio::test]\nasync fn test_cleanroom_timeout_handling() {\n    let mut config = CleanroomConfig::default();\n    config.test_execution_timeout = Duration::from_millis(100);\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute a test that should timeout\n    let result = environment.execute_test(\"test_timeout\", || {\n        sleep(Duration::from_millis(200)).await;\n        Ok(\"should_not_reach_here\")\n    }).await;\n    \n    assert!(result.is_err());\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 1);\n    assert_eq!(metrics.tests_failed, 1);\n    assert_eq!(metrics.error_count, 1);\n}\n\n/// Test cleanroom deterministic execution\n#[tokio::test]\nasync fn test_cleanroom_deterministic_execution() {\n    let mut config = CleanroomConfig::default();\n    config.enable_deterministic_execution = true;\n    config.deterministic_seed = Some(42);\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Test deterministic execution\n    let result1 = environment.execute_test(\"test_deterministic\", || {\n        Ok(environment.deterministic_manager.random().await)\n    }).await;\n    \n    let result2 = environment.execute_test(\"test_deterministic_2\", || {\n        Ok(environment.deterministic_manager.random().await)\n    }).await;\n    \n    assert!(result1.is_ok());\n    assert!(result2.is_ok());\n    \n    // Results should be deterministic (same seed)\n    let value1 = result1.unwrap();\n    let value2 = result2.unwrap();\n    \n    // Note: In a real test, you'd reset the deterministic manager between tests\n    // to ensure true determinism. This is a simplified test.\n    assert!(value1 != value2); // Different calls in sequence\n}\n\n/// Test cleanroom coverage tracking\n#[tokio::test]\nasync fn test_cleanroom_coverage_tracking() {\n    let mut config = CleanroomConfig::default();\n    config.enable_coverage_tracking = true;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute tests with coverage tracking\n    let _result1 = environment.execute_test(\"test_coverage_1\", || {\n        Ok(\"test1\")\n    }).await;\n    \n    let _result2 = environment.execute_test(\"test_coverage_2\", || {\n        Ok(\"test2\")\n    }).await;\n    \n    let coverage_data = environment.coverage_tracker.get_coverage_data().await;\n    assert_eq!(coverage_data.test_coverage.len(), 2);\n}\n\n/// Test cleanroom snapshot testing\n#[tokio::test]\nasync fn test_cleanroom_snapshot_testing() {\n    let mut config = CleanroomConfig::default();\n    config.enable_snapshot_testing = true;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Capture snapshot\n    environment.snapshot_manager.capture_snapshot(\n        \"test_snapshot\".to_string(),\n        \"test content\".to_string(),\n        cleanroom::SnapshotType::Text,\n        std::collections::HashMap::new(),\n    ).await.unwrap();\n    \n    // Validate snapshot\n    let result = environment.snapshot_manager.validate_snapshot(\"test_snapshot\", \"test content\").await;\n    assert!(result.is_ok());\n    assert!(result.unwrap());\n}\n\n/// Test cleanroom tracing\n#[tokio::test]\nasync fn test_cleanroom_tracing() {\n    let mut config = CleanroomConfig::default();\n    config.enable_tracing = true;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Start span\n    let span_id = environment.tracing_manager.start_span(\"test_span\".to_string(), None).await.unwrap();\n    assert!(span_id != uuid::Uuid::nil());\n    \n    // Add event\n    environment.tracing_manager.add_span_event(\n        \"test_span\",\n        \"test_event\".to_string(),\n        std::collections::HashMap::from([(\"key\".to_string(), \"value\".to_string())]),\n    ).await.unwrap();\n    \n    // End span\n    environment.tracing_manager.end_span(\"test_span\", cleanroom::SpanStatus::Completed).await.unwrap();\n    \n    let tracing_data = environment.tracing_manager.get_tracing_data().await;\n    assert_eq!(tracing_data.spans.len(), 1);\n    assert!(tracing_data.spans.contains_key(\"test_span\"));\n}\n\n/// Test cleanroom redaction\n#[tokio::test]\nasync fn test_cleanroom_redaction() {\n    let mut config = CleanroomConfig::default();\n    config.security_policy.enable_data_redaction = true;\n    config.security_policy.redaction_patterns = vec![\n        r\"password\\s*=\\s*[^\\s]+\".to_string(),\n        r\"token\\s*=\\s*[^\\s]+\".to_string(),\n    ];\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Test redaction\n    let content = \"password=secret123 token=abc456\";\n    let redacted = environment.redaction_manager.redact(content).await.unwrap();\n    \n    assert!(redacted.contains(\"[REDACTED]\"));\n    assert!(!redacted.contains(\"secret123\"));\n    assert!(!redacted.contains(\"abc456\"));\n}\n\n/// Test cleanroom report generation\n#[tokio::test]\nasync fn test_cleanroom_report_generation() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute some tests\n    let _result1 = environment.execute_test(\"test_report_1\", || {\n        Ok(\"test1\")\n    }).await;\n    \n    let _result2 = environment.execute_test(\"test_report_2\", || {\n        Ok(\"test2\")\n    }).await;\n    \n    // Generate report\n    let report = environment.report_generator.generate_report(&environment.get_metrics().await).await.unwrap();\n    \n    assert_eq!(report.session_id, environment.session_id);\n    assert_eq!(report.test_summary.total_tests, 2);\n    assert_eq!(report.test_summary.passed_tests, 2);\n    assert_eq!(report.test_summary.failed_tests, 0);\n}\n\n/// Test cleanroom cleanup\n#[tokio::test]\nasync fn test_cleanroom_cleanup() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute some tests\n    let _result = environment.execute_test(\"test_cleanup\", || {\n        Ok(\"test\")\n    }).await;\n    \n    // Cleanup\n    let cleanup_result = environment.cleanup().await;\n    assert!(cleanup_result.is_ok());\n    \n    let metrics = environment.get_metrics().await;\n    assert!(metrics.end_time.is_some());\n}\n\n/// Test cleanroom comprehensive workflow\n#[tokio::test]\nasync fn test_cleanroom_comprehensive_workflow() {\n    let mut config = CleanroomConfig::default();\n    config.enable_deterministic_execution = true;\n    config.deterministic_seed = Some(42);\n    config.enable_coverage_tracking = true;\n    config.enable_snapshot_testing = true;\n    config.enable_tracing = true;\n    config.security_policy.enable_data_redaction = true;\n    config.security_policy.redaction_patterns = vec![\n        r\"password\\s*=\\s*[^\\s]+\".to_string(),\n    ];\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Test 1: Basic functionality\n    let result1 = environment.execute_test(\"test_basic\", || {\n        Ok(\"basic_test\")\n    }).await;\n    assert!(result1.is_ok());\n    \n    // Test 2: Error handling\n    let result2 = environment.execute_test(\"test_error\", || {\n        Err(cleanroom::CleanroomError::internal_error(\"Test error\"))\n    }).await;\n    assert!(result2.is_err());\n    \n    // Test 3: Coverage tracking\n    environment.coverage_tracker.start_test(\"coverage_test\".to_string(), \"test.rs\".to_string()).await.unwrap();\n    environment.coverage_tracker.record_line_coverage(\"coverage_test\", 10, true).await.unwrap();\n    environment.coverage_tracker.end_test(\"coverage_test\", cleanroom::TestStatus::Passed, 100).await.unwrap();\n    \n    // Test 4: Snapshot testing\n    environment.snapshot_manager.capture_snapshot(\n        \"workflow_snapshot\".to_string(),\n        \"workflow content\".to_string(),\n        cleanroom::SnapshotType::Text,\n        std::collections::HashMap::new(),\n    ).await.unwrap();\n    \n    // Test 5: Tracing\n    let span_id = environment.tracing_manager.start_span(\"workflow_span\".to_string(), None).await.unwrap();\n    environment.tracing_manager.add_span_event(\n        \"workflow_span\",\n        \"workflow_event\".to_string(),\n        std::collections::HashMap::new(),\n    ).await.unwrap();\n    environment.tracing_manager.end_span(\"workflow_span\", cleanroom::SpanStatus::Completed).await.unwrap();\n    \n    // Test 6: Redaction\n    let redacted = environment.redaction_manager.redact(\"password=secret123\").await.unwrap();\n    assert!(redacted.contains(\"[REDACTED]\"));\n    \n    // Test 7: Report generation\n    let report = environment.report_generator.generate_report(&environment.get_metrics().await).await.unwrap();\n    assert_eq!(report.test_summary.total_tests, 2);\n    assert_eq!(report.test_summary.passed_tests, 1);\n    assert_eq!(report.test_summary.failed_tests, 1);\n    \n    // Test 8: Cleanup\n    let cleanup_result = environment.cleanup().await;\n    assert!(cleanup_result.is_ok());\n    \n    let final_metrics = environment.get_metrics().await;\n    assert!(final_metrics.end_time.is_some());\n    assert_eq!(final_metrics.tests_executed, 2);\n    assert_eq!(final_metrics.tests_passed, 1);\n    assert_eq!(final_metrics.tests_failed, 1);\n}\n\n/// Test cleanroom performance under load\n#[tokio::test]\nasync fn test_cleanroom_performance_load() {\n    let mut config = CleanroomConfig::default();\n    config.test_execution_timeout = Duration::from_secs(30);\n    config.performance_monitoring.enable_monitoring = true;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute multiple tests in parallel\n    let mut handles = Vec::new();\n    for i in 0..10 {\n        let env = Arc::new(environment);\n        let handle = tokio::spawn(async move {\n            env.execute_test(&format!(\"test_load_{}\", i), || {\n                Ok(format!(\"test_{}\", i))\n            }).await\n        });\n        handles.push(handle);\n    }\n    \n    // Wait for all tests to complete\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 10);\n    assert_eq!(metrics.tests_passed, 10);\n    assert_eq!(metrics.tests_failed, 0);\n}\n\n/// Test cleanroom resource monitoring\n#[tokio::test]\nasync fn test_cleanroom_resource_monitoring() {\n    let mut config = CleanroomConfig::default();\n    config.performance_monitoring.enable_monitoring = true;\n    config.performance_monitoring.thresholds.max_cpu_usage_percent = 90.0;\n    config.performance_monitoring.thresholds.max_memory_usage_bytes = 1024 * 1024 * 1024;\n    \n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute tests that should be within limits\n    for i in 0..5 {\n        let _result = environment.execute_test(&format!(\"test_resource_{}\", i), || {\n            Ok(format!(\"test_{}\", i))\n        }).await;\n    }\n    \n    // Check resource limits\n    let result = environment.check_resource_limits().await;\n    assert!(result.is_ok());\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 5);\n    assert_eq!(metrics.tests_passed, 5);\n}\n\n/// Test cleanroom error recovery\n#[tokio::test]\nasync fn test_cleanroom_error_recovery() {\n    let config = CleanroomConfig::default();\n    let environment = CleanroomEnvironment::new(config).await.unwrap();\n    \n    // Execute a failing test\n    let result1 = environment.execute_test(\"test_failure\", || {\n        Err(cleanroom::CleanroomError::internal_error(\"Test failure\"))\n    }).await;\n    assert!(result1.is_err());\n    \n    // Execute a successful test after failure\n    let result2 = environment.execute_test(\"test_recovery\", || {\n        Ok(\"recovery_test\")\n    }).await;\n    assert!(result2.is_ok());\n    \n    let metrics = environment.get_metrics().await;\n    assert_eq!(metrics.tests_executed, 2);\n    assert_eq!(metrics.tests_passed, 1);\n    assert_eq!(metrics.tests_failed, 1);\n    assert_eq!(metrics.error_count, 1);\n}\n"
        }
    ]
}