{
    "sourceFile": "cleanroom/tests/bdd/world.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760261841888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n use std::collections::HashMap;\n use std::path::PathBuf;\n use std::process::Output;\n use tempfile::TempDir;\n+use serde_json::Value;\n \n /// World state for Cleanroom BDD tests\n ///\n /// Maintains state across scenario steps including:\n@@ -10,8 +11,10 @@\n /// - Command outputs and exit codes\n /// - Captured file contents and artifacts\n /// - Backend configuration and state\n /// - Policy and constraint settings\n+/// - Service management and health checks\n+/// - Coverage and attestation data\n #[derive(Debug, Default, cucumber::World)]\n pub struct CleanroomWorld {\n     /// Temporary directory for test isolation (kept alive for test duration)\n     #[allow(dead_code)]\n@@ -49,20 +52,160 @@\n \n     /// Mock server for external service testing\n     #[allow(dead_code)]\n     pub mock_server: Option<mockito::Server>,\n+\n+    /// Fixture project information\n+    pub fixture_project: Option<String>,\n+\n+    /// Binary path for the fixture project\n+    pub binary_path: Option<String>,\n+\n+    /// Environment variables\n+    pub environment: HashMap<String, String>,\n+\n+    /// Available backends\n+    pub available_backends: Vec<String>,\n+\n+    /// Docker availability\n+    pub docker_available: Option<bool>,\n+\n+    /// Podman availability\n+    pub podman_available: Option<bool>,\n+\n+    /// Scenario definitions\n+    pub scenarios: HashMap<String, ScenarioDefinition>,\n+\n+    /// Current scenario being executed\n+    pub current_scenario: Option<String>,\n+\n+    /// Scenario execution results\n+    pub scenario_results: HashMap<String, ScenarioResult>,\n+\n+    /// Snapshots for comparison\n+    pub snapshots: HashMap<String, String>,\n+\n+    /// Coverage data\n+    pub coverage_data: HashMap<String, Value>,\n+\n+    /// Service definitions\n+    pub services: HashMap<String, ServiceDefinition>,\n+\n+    /// Service health status\n+    pub service_health: HashMap<String, bool>,\n+\n+    /// Redaction patterns\n+    pub redaction_patterns: Vec<String>,\n+\n+    /// RNG seed for deterministic testing\n+    pub rng_seed: Option<u64>,\n+\n+    /// Timeout settings\n+    pub timeout_ms: Option<u64>,\n+\n+    /// Step timeout settings\n+    pub step_timeout_ms: Option<u64>,\n+\n+    /// Output limits\n+    pub max_output_bytes: Option<usize>,\n+\n+    /// Trace data\n+    pub trace_data: Vec<TraceSpan>,\n+\n+    /// Run ID for artifact organization\n+    pub run_id: Option<String>,\n+\n+    /// Artifact directory\n+    pub artifact_dir: Option<PathBuf>,\n+\n+    /// JSON report data\n+    pub json_report: Option<Value>,\n+\n+    /// Skip reasons\n+    pub skip_reasons: HashMap<String, String>,\n+\n+    /// Engine matrix results\n+    pub engine_results: HashMap<String, EngineResult>,\n+\n+    /// Typestate policy level\n+    pub policy_typestate: Option<PolicyTypestate>,\n }\n \n+/// Scenario definition for DSL\n+#[derive(Debug, Clone)]\n+pub struct ScenarioDefinition {\n+    pub name: String,\n+    pub steps: Vec<ScenarioStep>,\n+    pub concurrent: bool,\n+    pub continue_on_fail: bool,\n+}\n+\n+/// Individual step in a scenario\n+#[derive(Debug, Clone)]\n+pub struct ScenarioStep {\n+    pub name: String,\n+    pub args: Vec<String>,\n+    pub expect: String,\n+    pub max_output: Option<usize>,\n+}\n+\n+/// Scenario execution result\n+#[derive(Debug, Clone)]\n+pub struct ScenarioResult {\n+    pub scenario_name: String,\n+    pub steps_succeeded: Vec<String>,\n+    pub steps_failed: Vec<String>,\n+    pub total_duration_ms: u64,\n+    pub aggregated_duration_ms: u64,\n+}\n+\n+/// Service definition\n+#[derive(Debug, Clone)]\n+pub struct ServiceDefinition {\n+    pub name: String,\n+    pub image: String,\n+    pub port: Option<u16>,\n+    pub health_check: Option<String>,\n+}\n+\n+/// Trace span for structured logging\n+#[derive(Debug, Clone)]\n+pub struct TraceSpan {\n+    pub name: String,\n+    pub duration_ms: u64,\n+    pub status: String,\n+}\n+\n+/// Engine result for matrix testing\n+#[derive(Debug, Clone)]\n+pub struct EngineResult {\n+    pub engine: String,\n+    pub success: bool,\n+    pub duration_ms: u64,\n+    pub metadata: HashMap<String, String>,\n+}\n+\n+/// Policy typestate levels\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum PolicyTypestate {\n+    Restricted,\n+    Permissive,\n+}\n+\n impl CleanroomWorld {\n     /// Create a new world with a temporary directory\n     #[allow(dead_code)]\n     pub fn new() -> Self {\n         let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n         let project_dir = temp_dir.path().to_path_buf();\n+        let run_id = uuid::Uuid::new_v4().to_string();\n+        let artifact_dir = project_dir.join(\"artifacts\").join(&run_id);\n \n         Self {\n             temp_dir: Some(temp_dir),\n             project_dir,\n+            run_id: Some(run_id),\n+            artifact_dir: Some(artifact_dir),\n             ..Default::default()\n         }\n     }\n \n@@ -143,17 +286,139 @@\n         self.mock_server = Some(server);\n         server_url\n     }\n \n+    /// Set fixture project\n+    pub fn set_fixture_project(&mut self, project: String, binary: String) {\n+        self.fixture_project = Some(project);\n+        self.binary_path = Some(binary);\n+    }\n+\n+    /// Set environment variable\n+    pub fn set_env(&mut self, key: String, value: String) {\n+        self.environment.insert(key, value);\n+    }\n+\n+    /// Unset environment variable\n+    pub fn unset_env(&mut self, key: String) {\n+        self.environment.remove(&key);\n+    }\n+\n+    /// Check if backend is available\n+    pub fn is_backend_available(&self, backend: &str) -> bool {\n+        match backend {\n+            \"docker\" => self.docker_available.unwrap_or(false),\n+            \"podman\" => self.podman_available.unwrap_or(false),\n+            \"local\" => true,\n+            \"auto\" => self.docker_available.unwrap_or(false) || self.podman_available.unwrap_or(false) || true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Add scenario definition\n+    pub fn add_scenario(&mut self, scenario: ScenarioDefinition) {\n+        self.scenarios.insert(scenario.name.clone(), scenario);\n+    }\n+\n+    /// Set current scenario\n+    pub fn set_current_scenario(&mut self, name: String) {\n+        self.current_scenario = Some(name);\n+    }\n+\n+    /// Add snapshot\n+    pub fn add_snapshot(&mut self, name: String, content: String) {\n+        self.snapshots.insert(name, content);\n+    }\n+\n+    /// Get snapshot\n+    pub fn get_snapshot(&self, name: &str) -> Option<&String> {\n+        self.snapshots.get(name)\n+    }\n+\n+    /// Add service definition\n+    pub fn add_service(&mut self, service: ServiceDefinition) {\n+        self.services.insert(service.name.clone(), service);\n+    }\n+\n+    /// Set service health\n+    pub fn set_service_health(&mut self, name: String, healthy: bool) {\n+        self.service_health.insert(name, healthy);\n+    }\n+\n+    /// Add redaction pattern\n+    pub fn add_redaction_pattern(&mut self, pattern: String) {\n+        self.redaction_patterns.push(pattern);\n+    }\n+\n+    /// Set RNG seed\n+    pub fn set_rng_seed(&mut self, seed: u64) {\n+        self.rng_seed = Some(seed);\n+    }\n+\n+    /// Set timeout\n+    pub fn set_timeout(&mut self, timeout_ms: u64) {\n+        self.timeout_ms = Some(timeout_ms);\n+    }\n+\n+    /// Set step timeout\n+    pub fn set_step_timeout(&mut self, timeout_ms: u64) {\n+        self.step_timeout_ms = Some(timeout_ms);\n+    }\n+\n+    /// Set output limit\n+    pub fn set_max_output(&mut self, max_bytes: usize) {\n+        self.max_output_bytes = Some(max_bytes);\n+    }\n+\n+    /// Add trace span\n+    pub fn add_trace_span(&mut self, span: TraceSpan) {\n+        self.trace_data.push(span);\n+    }\n+\n+    /// Set policy typestate\n+    pub fn set_policy_typestate(&mut self, typestate: PolicyTypestate) {\n+        self.policy_typestate = Some(typestate);\n+    }\n+\n+    /// Add engine result\n+    pub fn add_engine_result(&mut self, result: EngineResult) {\n+        self.engine_results.insert(result.engine.clone(), result);\n+    }\n+\n+    /// Set skip reason\n+    pub fn set_skip_reason(&mut self, scenario: String, reason: String) {\n+        self.skip_reasons.insert(scenario, reason);\n+    }\n+\n+    /// Set JSON report\n+    pub fn set_json_report(&mut self, report: Value) {\n+        self.json_report = Some(report);\n+    }\n+\n     /// Debug dump of world state\n     pub fn debug_dump(&self) {\n         eprintln!(\"=== CLEANROOM WORLD STATE ===\");\n         eprintln!(\"Project dir: {}\", self.project_dir.display());\n+        eprintln!(\"Run ID: {:?}\", self.run_id);\n         eprintln!(\"Backend: {:?}\", self.current_backend);\n         eprintln!(\"Last exit code: {:?}\", self.last_exit_code);\n         eprintln!(\"Policy settings: {:?}\", self.policy_settings);\n         eprintln!(\"Network constraints: {:?}\", self.network_constraints);\n         eprintln!(\"Filesystem constraints: {:?}\", self.filesystem_constraints);\n+        eprintln!(\"Fixture project: {:?}\", self.fixture_project);\n+        eprintln!(\"Binary path: {:?}\", self.binary_path);\n+        eprintln!(\"Available backends: {:?}\", self.available_backends);\n+        eprintln!(\"Docker available: {:?}\", self.docker_available);\n+        eprintln!(\"Podman available: {:?}\", self.podman_available);\n+        eprintln!(\"Current scenario: {:?}\", self.current_scenario);\n+        eprintln!(\"Scenarios: {:?}\", self.scenarios.keys());\n+        eprintln!(\"Snapshots: {:?}\", self.snapshots.keys());\n+        eprintln!(\"Services: {:?}\", self.services.keys());\n+        eprintln!(\"RNG seed: {:?}\", self.rng_seed);\n+        eprintln!(\"Timeout: {:?}\", self.timeout_ms);\n+        eprintln!(\"Step timeout: {:?}\", self.step_timeout_ms);\n+        eprintln!(\"Max output: {:?}\", self.max_output_bytes);\n+        eprintln!(\"Trace spans: {}\", self.trace_data.len());\n         eprintln!(\"Captured files: {:?}\", self.captured_files.keys());\n         eprintln!(\"Captured artifacts: {:?}\", self.captured_artifacts.keys());\n         eprintln!(\"Captured hashes: {}\", self.captured_hashes.len());\n         eprintln!(\"=============================\");\n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::process::Output;\nuse tempfile::TempDir;\n\n/// World state for Cleanroom BDD tests\n///\n/// Maintains state across scenario steps including:\n/// - Temporary directories for isolated test runs\n/// - Command outputs and exit codes\n/// - Captured file contents and artifacts\n/// - Backend configuration and state\n/// - Policy and constraint settings\n#[derive(Debug, Default, cucumber::World)]\npub struct CleanroomWorld {\n    /// Temporary directory for test isolation (kept alive for test duration)\n    #[allow(dead_code)]\n    pub temp_dir: Option<TempDir>,\n\n    /// Project directory path (usually temp_dir.path())\n    pub project_dir: PathBuf,\n\n    /// Last command output\n    pub last_output: Option<Output>,\n\n    /// Last command exit code\n    pub last_exit_code: Option<i32>,\n\n    /// Captured file contents by path\n    pub captured_files: HashMap<String, String>,\n\n    /// Captured artifacts for verification\n    pub captured_artifacts: HashMap<String, Vec<u8>>,\n\n    /// Captured output hashes for determinism testing\n    pub captured_hashes: Vec<String>,\n\n    /// Current backend type being used\n    pub current_backend: Option<String>,\n\n    /// Policy settings for current test\n    pub policy_settings: HashMap<String, String>,\n\n    /// Network constraints\n    pub network_constraints: Vec<String>,\n\n    /// Filesystem constraints\n    pub filesystem_constraints: Vec<String>,\n\n    /// Mock server for external service testing\n    #[allow(dead_code)]\n    pub mock_server: Option<mockito::Server>,\n}\n\nimpl CleanroomWorld {\n    /// Create a new world with a temporary directory\n    #[allow(dead_code)]\n    pub fn new() -> Self {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let project_dir = temp_dir.path().to_path_buf();\n\n        Self {\n            temp_dir: Some(temp_dir),\n            project_dir,\n            ..Default::default()\n        }\n    }\n\n    /// Get the project directory path\n    #[allow(dead_code)]\n    pub fn project_dir(&self) -> &PathBuf {\n        &self.project_dir\n    }\n\n    /// Set current backend type\n    pub fn set_backend(&mut self, backend: String) {\n        self.current_backend = Some(backend);\n    }\n\n    /// Capture file content for later comparison\n    pub fn capture_file(&mut self, path: &str, content: String) {\n        self.captured_files.insert(path.to_string(), content);\n    }\n\n    /// Capture binary artifact for later verification\n    pub fn capture_artifact(&mut self, path: &str, content: Vec<u8>) {\n        self.captured_artifacts.insert(path.to_string(), content);\n    }\n\n    /// Capture output hash for determinism testing\n    pub fn capture_hash(&mut self, hash: String) {\n        self.captured_hashes.push(hash);\n    }\n\n    /// Get last captured hash\n    #[allow(dead_code)]\n    pub fn last_hash(&self) -> Option<&String> {\n        self.captured_hashes.last()\n    }\n\n    /// Check if last command succeeded\n    pub fn last_command_succeeded(&self) -> bool {\n        self.last_exit_code == Some(0)\n    }\n\n    /// Get last command stdout as string\n    pub fn last_stdout(&self) -> String {\n        self.last_output\n            .as_ref()\n            .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n            .unwrap_or_default()\n    }\n\n    /// Get last command stderr as string\n    pub fn last_stderr(&self) -> String {\n        self.last_output\n            .as_ref()\n            .map(|output| String::from_utf8_lossy(&output.stderr).to_string())\n            .unwrap_or_default()\n    }\n\n    /// Set policy constraint\n    pub fn set_policy(&mut self, key: String, value: String) {\n        self.policy_settings.insert(key, value);\n    }\n\n    /// Add network constraint\n    pub fn add_network_constraint(&mut self, constraint: String) {\n        self.network_constraints.push(constraint);\n    }\n\n    /// Add filesystem constraint\n    pub fn add_filesystem_constraint(&mut self, constraint: String) {\n        self.filesystem_constraints.push(constraint);\n    }\n\n    /// Setup mock HTTP server for external service testing\n    pub fn setup_mock_server(&mut self) -> String {\n        let mut server = mockito::Server::new();\n        let server_url = server.url();\n        \n        // Keep server alive for test duration\n        self.mock_server = Some(server);\n        server_url\n    }\n\n    /// Debug dump of world state\n    pub fn debug_dump(&self) {\n        eprintln!(\"=== CLEANROOM WORLD STATE ===\");\n        eprintln!(\"Project dir: {}\", self.project_dir.display());\n        eprintln!(\"Backend: {:?}\", self.current_backend);\n        eprintln!(\"Last exit code: {:?}\", self.last_exit_code);\n        eprintln!(\"Policy settings: {:?}\", self.policy_settings);\n        eprintln!(\"Network constraints: {:?}\", self.network_constraints);\n        eprintln!(\"Filesystem constraints: {:?}\", self.filesystem_constraints);\n        eprintln!(\"Captured files: {:?}\", self.captured_files.keys());\n        eprintln!(\"Captured artifacts: {:?}\", self.captured_artifacts.keys());\n        eprintln!(\"Captured hashes: {}\", self.captured_hashes.len());\n        eprintln!(\"=============================\");\n    }\n}\n\n// World trait is automatically implemented by the derive macro\n"
        }
    ]
}