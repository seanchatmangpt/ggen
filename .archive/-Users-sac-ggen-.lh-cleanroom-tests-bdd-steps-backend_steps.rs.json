{
    "sourceFile": "cleanroom/tests/bdd/steps/backend_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse assert_cmd::Command;\nuse cucumber::{given, then, when};\nuse std::fs;\n\n/// Backend step definitions for Cleanroom BDD tests\n///\n/// These steps handle backend selection, configuration, and validation\n/// for different execution environments (local, Docker, Podman).\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have Docker available$\")]\nfn docker_available(world: &mut CleanroomWorld) {\n    // Check if Docker is available\n    let output = Command::new(\"docker\")\n        .arg(\"version\")\n        .output();\n    \n    match output {\n        Ok(output) if output.status.success() => {\n            world.set_backend(\"docker\".to_string());\n        }\n        _ => {\n            panic!(\"Docker is not available - required for this test\");\n        }\n    }\n}\n\n#[given(regex = r\"^I have Podman available$\")]\nfn podman_available(world: &mut CleanroomWorld) {\n    // Check if Podman is available\n    let output = Command::new(\"podman\")\n        .arg(\"version\")\n        .output();\n    \n    match output {\n        Ok(output) if output.status.success() => {\n            world.set_backend(\"podman\".to_string());\n        }\n        _ => {\n            panic!(\"Podman is not available - required for this test\");\n        }\n    }\n}\n\n#[given(regex = r\"^I have a local execution environment$\")]\nfn local_execution_environment(world: &mut CleanroomWorld) {\n    // Local backend is always available\n    world.set_backend(\"local\".to_string());\n}\n\n#[given(regex = r\"^I have a container image \"([^\"]+)\"$\")]\nfn have_container_image(world: &mut CleanroomWorld, image: String) {\n    // Verify the image exists locally or can be pulled\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set before checking for container image\");\n    \n    let cmd = match backend.as_str() {\n        \"docker\" => \"docker\",\n        \"podman\" => \"podman\",\n        _ => panic!(\"Container backend required for image operations\"),\n    };\n    \n    let output = Command::new(cmd)\n        .arg(\"image\")\n        .arg(\"inspect\")\n        .arg(&image)\n        .output();\n    \n    match output {\n        Ok(output) if output.status.success() => {\n            // Image exists locally\n        }\n        _ => {\n            // Try to pull the image\n            let pull_output = Command::new(cmd)\n                .arg(\"pull\")\n                .arg(&image)\n                .output()\n                .expect(\"Failed to pull container image\");\n            \n            if !pull_output.status.success() {\n                panic!(\"Failed to pull container image '{}'\", image);\n            }\n        }\n    }\n}\n\n#[given(regex = r\"^I have a container registry at \"([^\"]+)\"$\")]\nfn have_container_registry(world: &mut CleanroomWorld, registry_url: String) {\n    // Setup mock registry if needed, or verify real registry\n    if registry_url.contains(\"localhost\") || registry_url.contains(\"127.0.0.1\") {\n        // Use mock registry\n        let mock_url = world.setup_mock_server();\n        world.set_policy(\"registry_url\".to_string(), mock_url);\n    } else {\n        // Verify real registry is accessible\n        world.set_policy(\"registry_url\".to_string(), registry_url);\n    }\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I select the \"([^\"]+)\" backend$\")]\nfn select_backend(world: &mut CleanroomWorld, backend: String) {\n    match backend.as_str() {\n        \"local\" => {\n            world.set_backend(\"local\".to_string());\n        }\n        \"docker\" => {\n            // Verify Docker is available\n            let output = Command::new(\"docker\")\n                .arg(\"version\")\n                .output()\n                .expect(\"Failed to check Docker version\");\n            \n            if !output.status.success() {\n                panic!(\"Docker backend selected but Docker is not available\");\n            }\n            \n            world.set_backend(\"docker\".to_string());\n        }\n        \"podman\" => {\n            // Verify Podman is available\n            let output = Command::new(\"podman\")\n                .arg(\"version\")\n                .output()\n                .expect(\"Failed to check Podman version\");\n            \n            if !output.status.success() {\n                panic!(\"Podman backend selected but Podman is not available\");\n            }\n            \n            world.set_backend(\"podman\".to_string());\n        }\n        \"auto\" => {\n            // Auto-detect backend\n            if Command::new(\"docker\").arg(\"version\").output().map(|o| o.status.success()).unwrap_or(false) {\n                world.set_backend(\"docker\".to_string());\n            } else if Command::new(\"podman\").arg(\"version\").output().map(|o| o.status.success()).unwrap_or(false) {\n                world.set_backend(\"podman\".to_string());\n            } else {\n                world.set_backend(\"local\".to_string());\n            }\n        }\n        _ => {\n            panic!(\"Unknown backend: {}\", backend);\n        }\n    }\n}\n\n#[when(regex = r\"^I configure the backend with:$\")]\nfn configure_backend(world: &mut CleanroomWorld, config: String) {\n    // Parse configuration and apply to world state\n    for line in config.lines() {\n        let line = line.trim();\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n        \n        if let Some((key, value)) = line.split_once('=') {\n            world.set_policy(key.trim().to_string(), value.trim().to_string());\n        }\n    }\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the backend should be \"([^\"]+)\"$\")]\nfn backend_should_be(world: &mut CleanroomWorld, expected_backend: String) {\n    let actual_backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    assert_eq!(\n        actual_backend, &expected_backend,\n        \"Expected backend '{}', but got '{}'\",\n        expected_backend, actual_backend\n    );\n}\n\n#[then(regex = r\"^the backend should be automatically detected$\")]\nfn backend_should_be_auto_detected(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    // Verify it's one of the supported backends\n    assert!(\n        matches!(backend.as_str(), \"local\" | \"docker\" | \"podman\"),\n        \"Backend '{}' is not a supported auto-detected backend\",\n        backend\n    );\n}\n\n#[then(regex = r\"^the container should be running$\")]\nfn container_should_be_running(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    let cmd = match backend.as_str() {\n        \"docker\" => \"docker\",\n        \"podman\" => \"podman\",\n        _ => panic!(\"Container backend required for container operations\"),\n    };\n    \n    // Check if any containers are running\n    let output = Command::new(cmd)\n        .arg(\"ps\")\n        .arg(\"--format\")\n        .arg(\"{{.Status}}\")\n        .output()\n        .expect(\"Failed to check container status\");\n    \n    let stdout = String::from_utf8_lossy(&output.stdout);\n    \n    if !stdout.contains(\"Up\") {\n        panic!(\"No containers are running\");\n    }\n}\n\n#[then(regex = r\"^the container should be stopped$\")]\nfn container_should_be_stopped(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    let cmd = match backend.as_str() {\n        \"docker\" => \"docker\",\n        \"podman\" => \"podman\",\n        _ => panic!(\"Container backend required for container operations\"),\n    };\n    \n    // Check if any containers are running\n    let output = Command::new(cmd)\n        .arg(\"ps\")\n        .arg(\"--format\")\n        .arg(\"{{.Status}}\")\n        .output()\n        .expect(\"Failed to check container status\");\n    \n    let stdout = String::from_utf8_lossy(&output.stdout);\n    \n    if stdout.contains(\"Up\") {\n        panic!(\"Containers are still running\");\n    }\n}\n\n#[then(regex = r\"^the backend should support network isolation$\")]\nfn backend_supports_network_isolation(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    match backend.as_str() {\n        \"docker\" | \"podman\" => {\n            // Container backends support network isolation\n        }\n        \"local\" => {\n            // Local backend has limited network isolation\n            world.add_network_constraint(\"limited\".to_string());\n        }\n        _ => {\n            panic!(\"Unknown backend: {}\", backend);\n        }\n    }\n}\n\n#[then(regex = r\"^the backend should support filesystem isolation$\")]\nfn backend_supports_filesystem_isolation(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    match backend.as_str() {\n        \"docker\" | \"podman\" => {\n            // Container backends support full filesystem isolation\n            world.add_filesystem_constraint(\"isolated\".to_string());\n        }\n        \"local\" => {\n            // Local backend has limited filesystem isolation\n            world.add_filesystem_constraint(\"limited\".to_string());\n        }\n        _ => {\n            panic!(\"Unknown backend: {}\", backend);\n        }\n    }\n}\n\n#[then(regex = r\"^the backend should support resource limits$\")]\nfn backend_supports_resource_limits(world: &mut CleanroomWorld) {\n    let backend = world.current_backend.as_ref()\n        .expect(\"Backend should be set\");\n    \n    match backend.as_str() {\n        \"docker\" | \"podman\" => {\n            // Container backends support resource limits\n        }\n        \"local\" => {\n            // Local backend has limited resource control\n        }\n        _ => {\n            panic!(\"Unknown backend: {}\", backend);\n        }\n    }\n}\n"
        }
    ]
}