{
    "sourceFile": "cleanroom/tests/bdd/steps/assertion_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse cucumber::{given, then, when};\nuse std::fs;\nuse std::path::Path;\n\n/// Assertion step definitions for Cleanroom BDD tests\n///\n/// These steps handle test assertions, validation, and verification\n/// of cleanroom execution results and artifacts.\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have an assertion file \"([^\"]+)\" with:$\")]\nfn assertion_file(world: &mut CleanroomWorld, filename: String, content: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        fs::create_dir_all(parent).expect(\"Failed to create parent directories\");\n    }\n    \n    fs::write(&file_path, content.trim())\n        .unwrap_or_else(|e| panic!(\"Failed to write assertion file {}: {}\", filename, e));\n    \n    world.capture_file(&filename, content.trim().to_string());\n}\n\n#[given(regex = r\"^I have expected output \"([^\"]+)\"$\")]\nfn expected_output(world: &mut CleanroomWorld, expected: String) {\n    world.set_policy(\"expected_output\".to_string(), expected);\n}\n\n#[given(regex = r\"^I have expected exit code (\\d+)$\")]\nfn expected_exit_code(world: &mut CleanroomWorld, code: i32) {\n    world.set_policy(\"expected_exit_code\".to_string(), code.to_string());\n}\n\n#[given(regex = r\"^I have expected files: \"([^\"]+)\"$\")]\nfn expected_files(world: &mut CleanroomWorld, files: String) {\n    world.set_policy(\"expected_files\".to_string(), files);\n}\n\n#[given(regex = r\"^I have expected artifacts: \"([^\"]+)\"$\")]\nfn expected_artifacts(world: &mut CleanroomWorld, artifacts: String) {\n    world.set_policy(\"expected_artifacts\".to_string(), artifacts);\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I validate the results$\")]\nfn validate_results(world: &mut CleanroomWorld) {\n    // Perform validation of execution results\n    // This would typically involve checking outputs, files, artifacts, etc.\n    \n    // For now, just mark that validation was performed\n    world.set_policy(\"validation_performed\".to_string(), \"true\".to_string());\n}\n\n#[when(regex = r\"^I compare with baseline \"([^\"]+)\"$\")]\nfn compare_with_baseline(world: &mut CleanroomWorld, baseline: String) {\n    // Compare current results with a baseline\n    let baseline_file = world.project_dir.join(&baseline);\n    \n    if !baseline_file.exists() {\n        panic!(\"Baseline file '{}' does not exist\", baseline);\n    }\n    \n    let baseline_content = fs::read_to_string(&baseline_file)\n        .unwrap_or_else(|e| panic!(\"Failed to read baseline file '{}': {}\", baseline, e));\n    \n    world.set_policy(\"baseline_content\".to_string(), baseline_content);\n}\n\n#[when(regex = r\"^I run assertions from \"([^\"]+)\"$\")]\nfn run_assertions_from_file(world: &mut CleanroomWorld, assertion_file: String) {\n    let file_path = world.project_dir.join(&assertion_file);\n    \n    if !file_path.exists() {\n        panic!(\"Assertion file '{}' does not exist\", assertion_file);\n    }\n    \n    let content = fs::read_to_string(&file_path)\n        .unwrap_or_else(|e| panic!(\"Failed to read assertion file '{}': {}\", assertion_file, e));\n    \n    // Parse and execute assertions\n    for line in content.lines() {\n        let line = line.trim();\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n        \n        // Simple assertion parsing (would be more sophisticated in real implementation)\n        if line.starts_with(\"assert_output_contains:\") {\n            let expected = line.strip_prefix(\"assert_output_contains:\").unwrap().trim();\n            world.set_policy(\"assert_output_contains\".to_string(), expected.to_string());\n        } else if line.starts_with(\"assert_file_exists:\") {\n            let expected = line.strip_prefix(\"assert_file_exists:\").unwrap().trim();\n            world.set_policy(\"assert_file_exists\".to_string(), expected.to_string());\n        }\n    }\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the output should match the expected result$\")]\nfn output_should_match_expected(world: &mut CleanroomWorld) {\n    let expected = world.policy_settings.get(\"expected_output\")\n        .expect(\"Expected output should be set\");\n    \n    let actual = world.last_stdout();\n    \n    if !actual.contains(expected) {\n        eprintln!(\"=== OUTPUT MISMATCH ===\");\n        eprintln!(\"Expected to contain: '{}'\", expected);\n        eprintln!(\"Actual output:\\n{}\", actual);\n        panic!(\"Output should match expected result\");\n    }\n}\n\n#[then(regex = r\"^the exit code should match the expected code$\")]\nfn exit_code_should_match_expected(world: &mut CleanroomWorld) {\n    let expected_code: i32 = world.policy_settings.get(\"expected_exit_code\")\n        .expect(\"Expected exit code should be set\")\n        .parse()\n        .expect(\"Expected exit code should be a number\");\n    \n    let actual_code = world.last_exit_code.unwrap_or(-1);\n    \n    if actual_code != expected_code {\n        eprintln!(\"=== EXIT CODE MISMATCH ===\");\n        eprintln!(\"Expected: {}\", expected_code);\n        eprintln!(\"Actual: {}\", actual_code);\n        eprintln!(\"Stdout:\\n{}\", world.last_stdout());\n        eprintln!(\"Stderr:\\n{}\", world.last_stderr());\n        panic!(\"Exit code should match expected code\");\n    }\n}\n\n#[then(regex = r\"^all expected files should exist$\")]\nfn all_expected_files_should_exist(world: &mut CleanroomWorld) {\n    let expected_files = world.policy_settings.get(\"expected_files\")\n        .expect(\"Expected files should be set\");\n    \n    let files: Vec<&str> = expected_files.split(',').map(|s| s.trim()).collect();\n    \n    for file in files {\n        let file_path = world.project_dir.join(file);\n        if !file_path.exists() {\n            panic!(\"Expected file '{}' does not exist\", file);\n        }\n    }\n}\n\n#[then(regex = r\"^all expected artifacts should be present$\")]\nfn all_expected_artifacts_should_be_present(world: &mut CleanroomWorld) {\n    let expected_artifacts = world.policy_settings.get(\"expected_artifacts\")\n        .expect(\"Expected artifacts should be set\");\n    \n    let artifacts: Vec<&str> = expected_artifacts.split(',').map(|s| s.trim()).collect();\n    \n    for artifact in artifacts {\n        let artifact_path = world.project_dir.join(artifact);\n        if !artifact_path.exists() {\n            panic!(\"Expected artifact '{}' does not exist\", artifact);\n        }\n        \n        // Verify it's a binary file (not empty)\n        let metadata = fs::metadata(&artifact_path)\n            .unwrap_or_else(|e| panic!(\"Failed to get metadata for artifact '{}': {}\", artifact, e));\n        \n        if metadata.len() == 0 {\n            panic!(\"Expected artifact '{}' should not be empty\", artifact);\n        }\n    }\n}\n\n#[then(regex = r\"^the results should be deterministic$\")]\nfn results_should_be_deterministic(world: &mut CleanroomWorld) {\n    // Check if we have multiple runs to compare\n    if world.captured_hashes.len() < 2 {\n        panic!(\"Need at least 2 runs to verify determinism\");\n    }\n    \n    let first_hash = &world.captured_hashes[0];\n    for (i, hash) in world.captured_hashes.iter().enumerate().skip(1) {\n        if hash != first_hash {\n            panic!(\"Results are not deterministic: run {} differs from run 0\", i);\n        }\n    }\n}\n\n#[then(regex = r\"^the results should be reproducible$\")]\nfn results_should_be_reproducible(world: &mut CleanroomWorld) {\n    // Similar to determinism but focuses on reproducibility across environments\n    // For now, just verify that we have consistent output\n    let output = world.last_stdout();\n    \n    if output.is_empty() {\n        panic!(\"Results should be reproducible but output is empty\");\n    }\n    \n    // In a real implementation, this would involve running the same scenario\n    // multiple times and comparing results\n}\n\n#[then(regex = r\"^the execution should be isolated$\")]\nfn execution_should_be_isolated(world: &mut CleanroomWorld) {\n    // Verify that execution was properly isolated\n    // Check that no external files were modified\n    // Check that no external network connections were made\n    \n    if world.network_constraints.contains(&\"isolated\".to_string()) {\n        let stdout = world.last_stdout();\n        let stderr = world.last_stderr();\n        \n        // Check for network-related output\n        if stdout.contains(\"http\") || stderr.contains(\"http\") ||\n           stdout.contains(\"tcp\") || stderr.contains(\"tcp\") {\n            panic!(\"Execution should be isolated but network activity detected\");\n        }\n    }\n    \n    if world.filesystem_constraints.contains(&\"isolated\".to_string()) {\n        // Check that no files were created outside the project directory\n        // This would require more sophisticated tracking in a real implementation\n    }\n}\n\n#[then(regex = r\"^the security constraints should be enforced$\")]\nfn security_constraints_should_be_enforced(world: &mut CleanroomWorld) {\n    // Verify that security constraints were properly enforced\n    let stdout = world.last_stdout();\n    let stderr = world.last_stderr();\n    \n    // Check for security violations\n    if stdout.contains(\"permission denied\") || stderr.contains(\"permission denied\") {\n        // This might be expected if we're testing security constraints\n        return;\n    }\n    \n    // Check for other security-related indicators\n    if stdout.contains(\"unauthorized\") || stderr.contains(\"unauthorized\") {\n        // This might be expected if we're testing security constraints\n        return;\n    }\n    \n    // If we have security constraints set, verify they were respected\n    if !world.policy_settings.is_empty() {\n        // Security constraints are active\n        // In a real implementation, this would involve more sophisticated checks\n    }\n}\n\n#[then(regex = r\"^the performance should be within limits$\")]\nfn performance_should_be_within_limits(world: &mut CleanroomWorld) {\n    // Check performance constraints\n    if let Some(memory_limit) = world.policy_settings.get(\"memory_limit\") {\n        // In a real implementation, this would check actual memory usage\n        // For now, just verify that the limit was set\n        assert!(!memory_limit.is_empty(), \"Memory limit should be set\");\n    }\n    \n    if let Some(cpu_limit) = world.policy_settings.get(\"cpu_limit\") {\n        // In a real implementation, this would check actual CPU usage\n        // For now, just verify that the limit was set\n        assert!(!cpu_limit.is_empty(), \"CPU limit should be set\");\n    }\n    \n    if let Some(timeout) = world.policy_settings.get(\"timeout\") {\n        // In a real implementation, this would check actual execution time\n        // For now, just verify that the timeout was set\n        assert!(!timeout.is_empty(), \"Timeout should be set\");\n    }\n}\n\n#[then(regex = r\"^the assertions should all pass$\")]\nfn assertions_should_all_pass(world: &mut CleanroomWorld) {\n    // Verify that all assertions passed\n    let validation_performed = world.policy_settings.get(\"validation_performed\")\n        .expect(\"Validation should have been performed\");\n    \n    assert_eq!(validation_performed, \"true\", \"Validation should have been performed\");\n    \n    // Check specific assertions\n    if let Some(expected_output) = world.policy_settings.get(\"assert_output_contains\") {\n        let actual_output = world.last_stdout();\n        assert!(\n            actual_output.contains(expected_output),\n            \"Output should contain '{}'\",\n            expected_output\n        );\n    }\n    \n    if let Some(expected_file) = world.policy_settings.get(\"assert_file_exists\") {\n        let file_path = world.project_dir.join(expected_file);\n        assert!(\n            file_path.exists(),\n            \"File '{}' should exist\",\n            expected_file\n        );\n    }\n}\n\n#[then(regex = r\"^the baseline comparison should match$\")]\nfn baseline_comparison_should_match(world: &mut CleanroomWorld) {\n    let baseline_content = world.policy_settings.get(\"baseline_content\")\n        .expect(\"Baseline content should be set\");\n    \n    let current_output = world.last_stdout();\n    \n    // Simple comparison (in real implementation, this would be more sophisticated)\n    if current_output.trim() != baseline_content.trim() {\n        eprintln!(\"=== BASELINE MISMATCH ===\");\n        eprintln!(\"Baseline:\\n{}\", baseline_content);\n        eprintln!(\"Current:\\n{}\", current_output);\n        panic!(\"Baseline comparison should match\");\n    }\n}\n"
        }
    ]
}