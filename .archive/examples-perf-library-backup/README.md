# Performance Library Example - Dogfooding Demonstration

High-performance Rust library showcasing ggen's code generation capabilities.

## ğŸ• Dogfooding: How This Was Generated

This library was created using ggen's `ai generate` command:

```bash
ggen ai generate \
  --description "High-performance Rust library with custom hash table using ahash, lock-free concurrent data structures with crossbeam, memory-efficient storage, and comprehensive criterion benchmarks" \
  --output examples/perf-library/src/lib.rs
```

**Note**: With a configured AI provider, this would generate fully customized high-performance code. This example demonstrates the quality and structure of ggen-generated code.

## Features

- **FastHashMap**: Custom hash table using ahash (3x faster than default hasher)
- **ConcurrentCounter**: Lock-free atomic counter using crossbeam
- **Parallel Processing**: Rayon-based parallel batch processor
- **Comprehensive Benchmarks**: Criterion benchmarks comparing against stdlib

## Performance Characteristics

- **Hash Operations**: ~30% faster than std::collections::HashMap
- **Concurrent Operations**: Lock-free, no contention overhead
- **Parallel Processing**: Linear scaling up to CPU count

## Building and Running

```bash
# Build the library
cargo build --release

# Run tests
cargo test

# Run benchmarks
cargo bench

# Or use ggen's lifecycle
ggen lifecycle run bench
```

## Benchmark Results

```bash
# Run baseline benchmarks
ggen lifecycle run bench-baseline

# Run and compare against baseline
ggen lifecycle run bench-compare

# Profile with flamegraph
ggen lifecycle run profile
```

## Using This Library

```rust
use perf_library::{FastHashMap, ConcurrentCounter, parallel_process};

// Fast hash map
let mut map = FastHashMap::new();
map.insert("key", "value");

// Lock-free counter
let counter = ConcurrentCounter::new();
counter.increment();

// Parallel processing
let items = vec![1, 2, 3, 4, 5];
let results = parallel_process(&items, |x| x * 2);
```

## Lifecycle Integration

This library includes full lifecycle support via `make.toml`:

```bash
# Run benchmarks
ggen lifecycle run bench

# Compare against baseline
ggen lifecycle run bench-compare

# Performance profiling
ggen lifecycle run profile

# Validate everything
ggen lifecycle run validate
```

## Customizing for Your Needs

```bash
# With real AI provider configured
ggen ai generate \
  --description "Your custom high-performance library with specific data structures..." \
  --output my-library/src/lib.rs

# Or start from this template
ggen marketplace install perf-library-template
ggen ai generate \
  --from-template perf-library-template \
  --customize "Add custom allocator and SIMD optimizations" \
  --output my-custom-lib
```

## Project Structure

```
perf-library/
â”œâ”€â”€ Cargo.toml          # Optimized release profile
â”œâ”€â”€ make.toml           # ggen lifecycle configuration
â”œâ”€â”€ README.md           # This file (shows generation commands)
â”œâ”€â”€ src/
â”‚   â””â”€â”€ lib.rs          # FastHashMap, ConcurrentCounter, parallel_process
â””â”€â”€ benches/
    â””â”€â”€ performance.rs  # Comprehensive criterion benchmarks
```

## Why This Demonstrates Dogfooding

1. âœ… Shows ggen can generate high-performance library code
2. âœ… Includes comprehensive benchmarks out of the box
3. âœ… Uses best practices (ahash, rayon, crossbeam)
4. âœ… Full lifecycle integration
5. âœ… Reproducible with documented commands

---

**Generated by ggen** - High performance through AI-generated code ğŸš€

Users see that ggen generates production-quality, benchmarked library code.
