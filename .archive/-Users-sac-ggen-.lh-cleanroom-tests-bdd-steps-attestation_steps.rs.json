{
    "sourceFile": "cleanroom/tests/bdd/steps/attestation_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse cucumber::{given, then, when};\nuse std::fs;\nuse std::path::Path;\n\n/// Attestation step definitions for Cleanroom BDD tests\n///\n/// These steps handle attestation, signing, and verification\n/// of cleanroom execution results and artifacts.\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have attestation enabled$\")]\nfn attestation_enabled(world: &mut CleanroomWorld) {\n    world.set_policy(\"attestation_enabled\".to_string(), \"true\".to_string());\n}\n\n#[given(regex = r\"^I have a signing key \"([^\"]+)\"$\")]\nfn signing_key(world: &mut CleanroomWorld, keyfile: String) {\n    // Create a mock signing key\n    let key_content = r#\"-----BEGIN PRIVATE KEY-----\nMOCK_PRIVATE_KEY_CONTENT_FOR_TESTING\n-----END PRIVATE KEY-----\"#;\n    \n    let key_path = world.project_dir.join(&keyfile);\n    fs::write(&key_path, key_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write signing key {}: {}\", keyfile, e));\n    \n    world.capture_file(&keyfile, key_content.to_string());\n}\n\n#[given(regex = r\"^I have a public key \"([^\"]+)\"$\")]\nfn public_key(world: &mut CleanroomWorld, keyfile: String) {\n    // Create a mock public key\n    let key_content = r#\"-----BEGIN PUBLIC KEY-----\nMOCK_PUBLIC_KEY_CONTENT_FOR_TESTING\n-----END PUBLIC KEY-----\"#;\n    \n    let key_path = world.project_dir.join(&keyfile);\n    fs::write(&key_path, key_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write public key {}: {}\", keyfile, e));\n    \n    world.capture_file(&keyfile, key_content.to_string());\n}\n\n#[given(regex = r\"^I have an attestation policy \"([^\"]+)\"$\")]\nfn attestation_policy(world: &mut CleanroomWorld, policy_file: String) {\n    let policy_content = r#\"attestation:\n  enabled: true\n  algorithm: \"ed25519\"\n  key_file: \"signing_key.pem\"\n  verify_signatures: true\n  include_metadata: true\n  include_artifacts: true\n\"#;\n    \n    let policy_path = world.project_dir.join(&policy_file);\n    fs::write(&policy_path, policy_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write attestation policy {}: {}\", policy_file, e));\n    \n    world.capture_file(&policy_file, policy_content.to_string());\n}\n\n#[given(regex = r\"^I have a verification key \"([^\"]+)\"$\")]\nfn verification_key(world: &mut CleanroomWorld, keyfile: String) {\n    // Create a mock verification key (same as public key for testing)\n    let key_content = r#\"-----BEGIN PUBLIC KEY-----\nMOCK_PUBLIC_KEY_CONTENT_FOR_TESTING\n-----END PUBLIC KEY-----\"#;\n    \n    let key_path = world.project_dir.join(&keyfile);\n    fs::write(&key_path, key_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write verification key {}: {}\", keyfile, e));\n    \n    world.capture_file(&keyfile, key_content.to_string());\n}\n\n#[given(regex = r\"^I have a signed artifact \"([^\"]+)\"$\")]\nfn signed_artifact(world: &mut CleanroomWorld, artifact: String) {\n    // Create a mock signed artifact\n    let artifact_content = b\"Mock artifact content for testing\";\n    let signature = b\"Mock signature for testing\";\n    \n    let artifact_path = world.project_dir.join(&artifact);\n    fs::write(&artifact_path, artifact_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write signed artifact {}: {}\", artifact, e));\n    \n    // Create corresponding signature file\n    let sig_path = world.project_dir.join(format!(\"{}.sig\", artifact));\n    fs::write(&sig_path, signature)\n        .unwrap_or_else(|e| panic!(\"Failed to write signature file: {}\", e));\n    \n    world.capture_artifact(&artifact, artifact_content.to_vec());\n    world.capture_file(&format!(\"{}.sig\", artifact), String::from_utf8_lossy(signature).to_string());\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I sign the artifact \"([^\"]+)\"$\")]\nfn sign_artifact(world: &mut CleanroomWorld, artifact: String) {\n    // Simulate artifact signing\n    let artifact_path = world.project_dir.join(&artifact);\n    \n    if !artifact_path.exists() {\n        panic!(\"Artifact '{}' does not exist\", artifact);\n    }\n    \n    // Create signature\n    let signature_content = format!(\"SIGNATURE_FOR_{}\", artifact);\n    let sig_path = world.project_dir.join(format!(\"{}.sig\", artifact));\n    \n    fs::write(&sig_path, signature_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write signature: {}\", e));\n    \n    world.capture_file(&format!(\"{}.sig\", artifact), signature_content);\n}\n\n#[when(regex = r\"^I verify the signature of \"([^\"]+)\"$\")]\nfn verify_signature(world: &mut CleanroomWorld, artifact: String) {\n    // Simulate signature verification\n    let artifact_path = world.project_dir.join(&artifact);\n    let sig_path = world.project_dir.join(format!(\"{}.sig\", artifact));\n    \n    if !artifact_path.exists() {\n        panic!(\"Artifact '{}' does not exist\", artifact);\n    }\n    \n    if !sig_path.exists() {\n        panic!(\"Signature file for '{}' does not exist\", artifact);\n    }\n    \n    // Mock verification result\n    world.set_policy(\"signature_verified\".to_string(), \"true\".to_string());\n}\n\n#[when(regex = r\"^I create an attestation for \"([^\"]+)\"$\")]\nfn create_attestation(world: &mut CleanroomWorld, target: String) {\n    // Create an attestation document\n    let attestation_content = format!(\n        r#\"attestation:\n  target: {}\n  algorithm: \"ed25519\"\n  signature: \"MOCK_SIGNATURE_FOR_{}\"\n  timestamp: \"2025-01-09T12:00:00Z\"\n  metadata:\n    version: \"1.0\"\n    environment: \"test\"\n\"#,\n        target, target\n    );\n    \n    let attestation_file = world.project_dir.join(format!(\"{}.attestation\", target));\n    fs::write(&attestation_file, attestation_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write attestation: {}\", e));\n    \n    world.capture_file(&format!(\"{}.attestation\", target), attestation_content);\n}\n\n#[when(regex = r\"^I verify the attestation for \"([^\"]+)\"$\")]\nfn verify_attestation(world: &mut CleanroomWorld, target: String) {\n    // Simulate attestation verification\n    let attestation_file = world.project_dir.join(format!(\"{}.attestation\", target));\n    \n    if !attestation_file.exists() {\n        panic!(\"Attestation file for '{}' does not exist\", target);\n    }\n    \n    let content = fs::read_to_string(&attestation_file)\n        .unwrap_or_else(|e| panic!(\"Failed to read attestation file: {}\", e));\n    \n    // Mock verification logic\n    if content.contains(\"MOCK_SIGNATURE\") {\n        world.set_policy(\"attestation_verified\".to_string(), \"true\".to_string());\n    } else {\n        world.set_policy(\"attestation_verified\".to_string(), \"false\".to_string());\n    }\n}\n\n#[when(regex = r\"^I generate a verification report$\")]\nfn generate_verification_report(world: &mut CleanroomWorld) {\n    // Generate a verification report\n    let report_content = r#\"# Verification Report\n\n## Attestations\n- artifact1.txt: VERIFIED\n- artifact2.bin: VERIFIED\n- artifact3.json: FAILED\n\n## Signatures\n- Total checked: 3\n- Verified: 2\n- Failed: 1\n\n## Summary\n- Overall status: PARTIAL\n- Trust level: MEDIUM\n\"#;\n    \n    let report_file = world.project_dir.join(\"verification_report.md\");\n    fs::write(&report_file, report_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write verification report: {}\", e));\n    \n    world.capture_file(\"verification_report.md\", report_content.to_string());\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the artifact should be signed$\")]\nfn artifact_should_be_signed(world: &mut CleanroomWorld) {\n    // Check that signature files exist for captured artifacts\n    let has_signatures = world.captured_files.keys()\n        .any(|k| k.ends_with(\".sig\"));\n    \n    if !has_signatures {\n        panic!(\"Artifacts should be signed but no signature files found\");\n    }\n}\n\n#[then(regex = r\"^the signature should be valid$\")]\nfn signature_should_be_valid(world: &mut CleanroomWorld) {\n    let signature_verified = world.policy_settings.get(\"signature_verified\")\n        .expect(\"Signature verification should have been performed\");\n    \n    assert_eq!(\n        signature_verified, \"true\",\n        \"Signature should be valid\"\n    );\n}\n\n#[then(regex = r\"^the signature should be invalid$\")]\nfn signature_should_be_invalid(world: &mut CleanroomWorld) {\n    let signature_verified = world.policy_settings.get(\"signature_verified\")\n        .expect(\"Signature verification should have been performed\");\n    \n    assert_eq!(\n        signature_verified, \"false\",\n        \"Signature should be invalid\"\n    );\n}\n\n#[then(regex = r\"^the attestation should be created$\")]\nfn attestation_should_be_created(world: &mut CleanroomWorld) {\n    // Check that attestation files exist\n    let has_attestations = world.captured_files.keys()\n        .any(|k| k.ends_with(\".attestation\"));\n    \n    if !has_attestations {\n        panic!(\"Attestations should be created but no attestation files found\");\n    }\n}\n\n#[then(regex = r\"^the attestation should be verified$\")]\nfn attestation_should_be_verified(world: &mut CleanroomWorld) {\n    let attestation_verified = world.policy_settings.get(\"attestation_verified\")\n        .expect(\"Attestation verification should have been performed\");\n    \n    assert_eq!(\n        attestation_verified, \"true\",\n        \"Attestation should be verified\"\n    );\n}\n\n#[then(regex = r\"^the attestation should be invalid$\")]\nfn attestation_should_be_invalid(world: &mut CleanroomWorld) {\n    let attestation_verified = world.policy_settings.get(\"attestation_verified\")\n        .expect(\"Attestation verification should have been performed\");\n    \n    assert_eq!(\n        attestation_verified, \"false\",\n        \"Attestation should be invalid\"\n    );\n}\n\n#[then(regex = r\"^the verification report should be generated$\")]\nfn verification_report_should_be_generated(world: &mut CleanroomWorld) {\n    let report_content = world.captured_files.get(\"verification_report.md\")\n        .expect(\"Verification report should be generated\");\n    \n    // Verify report contains expected sections\n    assert!(report_content.contains(\"Verification Report\"), \"Report should contain title\");\n    assert!(report_content.contains(\"Attestations\"), \"Report should contain attestations section\");\n    assert!(report_content.contains(\"Signatures\"), \"Report should contain signatures section\");\n    assert!(report_content.contains(\"Summary\"), \"Report should contain summary section\");\n}\n\n#[then(regex = r\"^the verification should pass$\")]\nfn verification_should_pass(world: &mut CleanroomWorld) {\n    let report_content = world.captured_files.get(\"verification_report.md\")\n        .expect(\"Verification report should be generated\");\n    \n    // Check for successful verification indicators\n    assert!(\n        report_content.contains(\"VERIFIED\") || report_content.contains(\"SUCCESS\"),\n        \"Verification should pass\"\n    );\n}\n\n#[then(regex = r\"^the verification should fail$\")]\nfn verification_should_fail(world: &mut CleanroomWorld) {\n    let report_content = world.captured_files.get(\"verification_report.md\")\n        .expect(\"Verification report should be generated\");\n    \n    // Check for failed verification indicators\n    assert!(\n        report_content.contains(\"FAILED\") || report_content.contains(\"INVALID\"),\n        \"Verification should fail\"\n    );\n}\n\n#[then(regex = r\"^the trust level should be \"([^\"]+)\"$\")]\nfn trust_level_should_be(world: &mut CleanroomWorld, expected_level: String) {\n    let report_content = world.captured_files.get(\"verification_report.md\")\n        .expect(\"Verification report should be generated\");\n    \n    assert!(\n        report_content.contains(&expected_level),\n        \"Trust level should be '{}'\",\n        expected_level\n    );\n}\n\n#[then(regex = r\"^the attestation should include metadata$\")]\nfn attestation_should_include_metadata(world: &mut CleanroomWorld) {\n    // Check that attestation files contain metadata\n    let attestation_files: Vec<_> = world.captured_files.keys()\n        .filter(|k| k.ends_with(\".attestation\"))\n        .collect();\n    \n    if attestation_files.is_empty() {\n        panic!(\"No attestation files found\");\n    }\n    \n    for attestation_file in attestation_files {\n        let content = world.captured_files.get(attestation_file)\n            .expect(\"Attestation file content should be captured\");\n        \n        assert!(\n            content.contains(\"metadata\"),\n            \"Attestation should include metadata\"\n        );\n    }\n}\n\n#[then(regex = r\"^the attestation should include artifacts$\")]\nfn attestation_should_include_artifacts(world: &mut CleanroomWorld) {\n    // Check that attestation files reference artifacts\n    let attestation_files: Vec<_> = world.captured_files.keys()\n        .filter(|k| k.ends_with(\".attestation\"))\n        .collect();\n    \n    if attestation_files.is_empty() {\n        panic!(\"No attestation files found\");\n    }\n    \n    for attestation_file in attestation_files {\n        let content = world.captured_files.get(attestation_file)\n            .expect(\"Attestation file content should be captured\");\n        \n        assert!(\n            content.contains(\"target\") || content.contains(\"artifact\"),\n            \"Attestation should include artifacts\"\n        );\n    }\n}\n\n#[then(regex = r\"^the signing key should be protected$\")]\nfn signing_key_should_be_protected(world: &mut CleanroomWorld) {\n    // Check that signing keys have appropriate permissions\n    let key_files: Vec<_> = world.captured_files.keys()\n        .filter(|k| k.ends_with(\".pem\") || k.ends_with(\".key\"))\n        .collect();\n    \n    if key_files.is_empty() {\n        panic!(\"No signing keys found\");\n    }\n    \n    // In a real implementation, this would check file permissions\n    // For now, just verify that keys exist\n    for key_file in key_files {\n        let content = world.captured_files.get(key_file)\n            .expect(\"Key file content should be captured\");\n        \n        assert!(\n            content.contains(\"PRIVATE KEY\") || content.contains(\"PUBLIC KEY\"),\n            \"Signing key should be protected\"\n        );\n    }\n}\n"
        }
    ]
}