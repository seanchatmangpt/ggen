{
    "sourceFile": "tests/bdd/steps/cli_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760245905696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760245905696,
            "name": "Commit-0",
            "content": "use super::super::world::GgenWorld;\nuse assert_cmd::Command;\nuse cucumber::{then, when};\n\n// CLI command step definitions\n\n#[when(regex = r\"^I run ggen (.+)$\")]\nfn run_ggen_command(world: &mut GgenWorld, args: String) {\n    let arg_list: Vec<&str> = args.split_whitespace().collect();\n\n    let mut cmd = Command::cargo_bin(\"ggen\").expect(\"ggen binary not found\");\n    let output = cmd\n        .args(&arg_list)\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen command\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run ggen list$\")]\nfn run_ggen_list(world: &mut GgenWorld) {\n    let output = Command::cargo_bin(\"ggen\")\n        .expect(\"ggen binary not found\")\n        .arg(\"list\")\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen list\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run ggen lint (.+)$\")]\nfn run_ggen_lint(world: &mut GgenWorld, template_path: String) {\n    let output = Command::cargo_bin(\"ggen\")\n        .expect(\"ggen binary not found\")\n        .arg(\"lint\")\n        .arg(&template_path)\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen lint\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run ggen hazard$\")]\nfn run_ggen_hazard(world: &mut GgenWorld) {\n    let output = Command::cargo_bin(\"ggen\")\n        .expect(\"ggen binary not found\")\n        .arg(\"hazard\")\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen hazard\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run ggen completion (.+)$\")]\nfn run_ggen_completion(world: &mut GgenWorld, shell: String) {\n    let output = Command::cargo_bin(\"ggen\")\n        .expect(\"ggen binary not found\")\n        .arg(\"completion\")\n        .arg(&shell)\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen completion\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run ggen init$\")]\nfn run_ggen_init(world: &mut GgenWorld) {\n    let output = Command::cargo_bin(\"ggen\")\n        .expect(\"ggen binary not found\")\n        .arg(\"init\")\n        .current_dir(&world.project_dir)\n        .output()\n        .expect(\"Failed to run ggen init\");\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[then(regex = r\"^I should see the help text$\")]\nfn should_see_help_text(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(\"USAGE:\") || stdout.contains(\"Usage:\"),\n        \"Expected help text, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^I should see the version information$\")]\nfn should_see_version_info(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(\"ggen 1.0.0\"),\n        \"Expected version info, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^the command should succeed$\")]\nfn command_should_succeed(world: &mut GgenWorld) {\n    assert!(\n        world.last_command_succeeded(),\n        \"Command should succeed, but failed with exit code: {}\\nStderr: {}\",\n        world.last_exit_code.unwrap_or(-1),\n        world.last_stderr()\n    );\n}\n\n#[then(regex = r\"^I should see available templates$\")]\nfn should_see_available_templates(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(\"template\") || stdout.contains(\".tmpl\") || stdout.len() > 10,\n        \"Expected to see available templates, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^I should see template metadata$\")]\nfn should_see_template_metadata(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(\"to:\") || stdout.contains(\"vars:\") || stdout.contains(\"description\"),\n        \"Expected to see template metadata, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^the command should validate the template$\")]\nfn command_should_validate_template(world: &mut GgenWorld) {\n    // For BDD tests, we assume validation succeeded if the command succeeded\n    // In real implementation, this would check for specific validation output\n    assert!(\n        world.last_command_succeeded(),\n        \"Template validation should succeed\"\n    );\n}\n\n#[then(regex = r\"^I should see a hazard report$\")]\nfn should_see_hazard_report(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(\"hazard\") || stdout.contains(\"risk\") || stdout.contains(\"security\"),\n        \"Expected to see hazard report, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^I should see (.+) completion script$\")]\nfn should_see_completion_script(world: &mut GgenWorld, shell: String) {\n    let stdout = world.last_stdout();\n    match shell.as_str() {\n        \"bash\" => assert!(\n            stdout.contains(\"complete\") || stdout.contains(\"_ggen\"),\n            \"Expected bash completion script, but got: {}\",\n            stdout\n        ),\n        \"zsh\" => assert!(\n            stdout.contains(\"compdef\") || stdout.contains(\"_ggen\"),\n            \"Expected zsh completion script, but got: {}\",\n            stdout\n        ),\n        \"fish\" => assert!(\n            stdout.contains(\"complete\") || stdout.contains(\"ggen\"),\n            \"Expected fish completion script, but got: {}\",\n            stdout\n        ),\n        _ => assert!(\n            stdout.len() > 10,\n            \"Expected completion script, but got: {}\",\n            stdout\n        ),\n    }\n}\n\n#[then(regex = r\"^I should have a basic project structure$\")]\nfn should_have_basic_project_structure(world: &mut GgenWorld) {\n    let project_dir = &world.project_dir;\n\n    // Check for basic files that should be created by ggen init\n    let expected_files = [\"ggen.toml\", \"templates\"];\n    for file in &expected_files {\n        let path = project_dir.join(file);\n        assert!(\n            path.exists(),\n            \"Expected {} to exist at {}\",\n            file,\n            path.display()\n        );\n    }\n}\n\n#[then(regex = r\"^I should see search results$\")]\nfn should_see_search_results(world: &mut GgenWorld) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.len() > 10,\n        \"Expected search results, but got: {}\",\n        stdout\n    );\n}\n\n#[then(regex = r\"^results should contain (.+)$\")]\nfn results_should_contain(world: &mut GgenWorld, expected_result: String) {\n    let stdout = world.last_stdout();\n    assert!(\n        stdout.contains(&expected_result),\n        \"Expected search results to contain '{}', but got: {}\",\n        expected_result,\n        stdout\n    );\n}\n\n#[then(regex = r\"^the gpack should be installed$\")]\nfn gpack_should_be_installed(world: &mut GgenWorld) {\n    // For BDD tests, we assume the gpack is installed if the command succeeded\n    // In real implementation, this would check the lockfile or cache\n    assert!(\n        world.last_command_succeeded(),\n        \"Gpack should be installed successfully\"\n    );\n}\n"
        }
    ]
}