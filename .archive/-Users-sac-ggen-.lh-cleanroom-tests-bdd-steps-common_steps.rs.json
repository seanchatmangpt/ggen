{
    "sourceFile": "cleanroom/tests/bdd/steps/common_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427410,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse assert_cmd::Command;\nuse cucumber::{given, then, when};\nuse std::fs;\nuse std::path::Path;\n\n/// Common step definitions used across multiple features\n///\n/// These steps provide basic setup and validation functionality\n/// that is shared between different cleanroom test scenarios.\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have a clean test environment$\")]\nfn clean_test_environment(world: &mut CleanroomWorld) {\n    // Ensure we're in a clean temporary directory\n    assert!(world.project_dir.exists(), \"Project directory should exist\");\n    \n    // Clear any existing files\n    if world.project_dir.exists() {\n        for entry in fs::read_dir(&world.project_dir).unwrap() {\n            let entry = entry.unwrap();\n            if entry.file_type().unwrap().is_file() {\n                fs::remove_file(entry.path()).unwrap();\n            }\n        }\n    }\n}\n\n#[given(regex = r\"^I have a file \"([^\"]+)\" with content:$\")]\nfn create_file_with_content(world: &mut CleanroomWorld, filename: String, content: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        fs::create_dir_all(parent).expect(\"Failed to create parent directories\");\n    }\n    \n    fs::write(&file_path, content.trim())\n        .unwrap_or_else(|e| panic!(\"Failed to write file {}: {}\", filename, e));\n    \n    // Capture the file content for later verification\n    world.capture_file(&filename, content.trim().to_string());\n}\n\n#[given(regex = r\"^I have a binary file \"([^\"]+)\" with (\\d+) bytes$\")]\nfn create_binary_file(world: &mut CleanroomWorld, filename: String, size: usize) {\n    let file_path = world.project_dir.join(&filename);\n    \n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        fs::create_dir_all(parent).expect(\"Failed to create parent directories\");\n    }\n    \n    // Generate random binary data\n    let data: Vec<u8> = (0..size).map(|i| (i % 256) as u8).collect();\n    \n    fs::write(&file_path, &data)\n        .unwrap_or_else(|e| panic!(\"Failed to write binary file {}: {}\", filename, e));\n    \n    // Capture the binary artifact\n    world.capture_artifact(&filename, data);\n}\n\n#[given(regex = r\"^I have a directory \"([^\"]+)\"$\")]\nfn create_directory(world: &mut CleanroomWorld, dirname: String) {\n    let dir_path = world.project_dir.join(&dirname);\n    fs::create_dir_all(&dir_path)\n        .unwrap_or_else(|e| panic!(\"Failed to create directory {}: {}\", dirname, e));\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I run \"([^\"]+)\"$\")]\nfn run_command(world: &mut CleanroomWorld, command: String) {\n    let args: Vec<&str> = command.split_whitespace().collect();\n    \n    if args.is_empty() {\n        panic!(\"Empty command provided\");\n    }\n    \n    let mut cmd = Command::new(args[0]);\n    \n    // Add arguments if any\n    if args.len() > 1 {\n        cmd.args(&args[1..]);\n    }\n    \n    // Set working directory\n    cmd.current_dir(&world.project_dir);\n    \n    // Execute command\n    let output = cmd.output()\n        .unwrap_or_else(|e| panic!(\"Failed to run command '{}': {}\", command, e));\n    \n    // Store output for later verification\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[when(regex = r\"^I run cleanroom \"([^\"]+)\"$\")]\nfn run_cleanroom_command(world: &mut CleanroomWorld, args: String) {\n    // Parse arguments using shell-words for proper handling of quoted strings\n    let arg_list = shell_words::split(&args)\n        .unwrap_or_else(|e| panic!(\"Failed to parse arguments: {}\", e));\n    \n    let mut cmd = Command::cargo_bin(\"cleanroom\")\n        .expect(\"cleanroom binary not found - run 'cargo make build' first\");\n    \n    cmd.args(&arg_list)\n        .current_dir(&world.project_dir);\n    \n    let output = cmd.output()\n        .unwrap_or_else(|e| panic!(\"Failed to run cleanroom command: {}\", e));\n    \n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the command should succeed$\")]\nfn command_should_succeed(world: &mut CleanroomWorld) {\n    if !world.last_command_succeeded() {\n        // Debug information on failure\n        eprintln!(\"=== COMMAND FAILED ===\");\n        eprintln!(\"Exit code: {}\", world.last_exit_code.unwrap_or(-1));\n        eprintln!(\"Stdout:\\n{}\", world.last_stdout());\n        eprintln!(\"Stderr:\\n{}\", world.last_stderr());\n        eprintln!(\"Working dir: {}\", world.project_dir.display());\n        eprintln!(\"Files present:\");\n        for entry in fs::read_dir(&world.project_dir).unwrap() {\n            eprintln!(\"  - {}\", entry.unwrap().path().display());\n        }\n        panic!(\"Command should have succeeded but failed\");\n    }\n}\n\n#[then(regex = r\"^the command should fail$\")]\nfn command_should_fail(world: &mut CleanroomWorld) {\n    if world.last_command_succeeded() {\n        eprintln!(\"=== UNEXPECTED SUCCESS ===\");\n        eprintln!(\"Exit code: {}\", world.last_exit_code.unwrap_or(0));\n        eprintln!(\"Stdout:\\n{}\", world.last_stdout());\n        eprintln!(\"Stderr:\\n{}\", world.last_stderr());\n        panic!(\"Command should have failed but succeeded\");\n    }\n}\n\n#[then(regex = r\"^I should see \"([^\"]+)\" in output$\")]\nfn should_see_in_output(world: &mut CleanroomWorld, expected: String) {\n    let stdout = world.last_stdout();\n    let stderr = world.last_stderr();\n    \n    if !stdout.contains(&expected) && !stderr.contains(&expected) {\n        eprintln!(\"=== EXPECTED TEXT NOT FOUND ===\");\n        eprintln!(\"Looking for: '{}'\", expected);\n        eprintln!(\"Stdout:\\n{}\", stdout);\n        eprintln!(\"Stderr:\\n{}\", stderr);\n        panic!(\"Expected to see '{}' in output\", expected);\n    }\n}\n\n#[then(regex = r\"^I should not see \"([^\"]+)\" in output$\")]\nfn should_not_see_in_output(world: &mut CleanroomWorld, unexpected: String) {\n    let stdout = world.last_stdout();\n    let stderr = world.last_stderr();\n    \n    if stdout.contains(&unexpected) || stderr.contains(&unexpected) {\n        eprintln!(\"=== UNEXPECTED TEXT FOUND ===\");\n        eprintln!(\"Found: '{}'\", unexpected);\n        eprintln!(\"Stdout:\\n{}\", stdout);\n        eprintln!(\"Stderr:\\n{}\", stderr);\n        panic!(\"Should not see '{}' in output\", unexpected);\n    }\n}\n\n#[then(regex = r\"^the file \"([^\"]+)\" should exist$\")]\nfn file_should_exist(world: &mut CleanroomWorld, filename: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    if !file_path.exists() {\n        eprintln!(\"=== FILE NOT FOUND ===\");\n        eprintln!(\"Expected file: {}\", file_path.display());\n        eprintln!(\"Files in directory:\");\n        for entry in fs::read_dir(&world.project_dir).unwrap() {\n            eprintln!(\"  - {}\", entry.unwrap().path().display());\n        }\n        panic!(\"File '{}' should exist\", filename);\n    }\n}\n\n#[then(regex = r\"^the file \"([^\"]+)\" should not exist$\")]\nfn file_should_not_exist(world: &mut CleanroomWorld, filename: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    if file_path.exists() {\n        panic!(\"File '{}' should not exist\", filename);\n    }\n}\n\n#[then(regex = r\"^the file \"([^\"]+)\" should contain \"([^\"]+)\"$\")]\nfn file_should_contain(world: &mut CleanroomWorld, filename: String, expected: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    if !file_path.exists() {\n        panic!(\"File '{}' does not exist\", filename);\n    }\n    \n    let content = fs::read_to_string(&file_path)\n        .unwrap_or_else(|e| panic!(\"Failed to read file '{}': {}\", filename, e));\n    \n    if !content.contains(&expected) {\n        eprintln!(\"=== FILE CONTENT MISMATCH ===\");\n        eprintln!(\"File: {}\", file_path.display());\n        eprintln!(\"Expected to contain: '{}'\", expected);\n        eprintln!(\"Actual content:\\n{}\", content);\n        panic!(\"File '{}' should contain '{}'\", filename, expected);\n    }\n}\n\n#[then(regex = r\"^the directory \"([^\"]+)\" should exist$\")]\nfn directory_should_exist(world: &mut CleanroomWorld, dirname: String) {\n    let dir_path = world.project_dir.join(&dirname);\n    \n    if !dir_path.exists() || !dir_path.is_dir() {\n        panic!(\"Directory '{}' should exist\", dirname);\n    }\n}\n\n#[then(regex = r\"^the output should be valid JSON$\")]\nfn output_should_be_valid_json(world: &mut CleanroomWorld) {\n    let stdout = world.last_stdout();\n    \n    // Try to parse as JSON\n    match serde_json::from_str::<serde_json::Value>(&stdout) {\n        Ok(_) => {\n            // Valid JSON\n        }\n        Err(e) => {\n            eprintln!(\"=== INVALID JSON ===\");\n            eprintln!(\"Error: {}\", e);\n            eprintln!(\"Output:\\n{}\", stdout);\n            panic!(\"Output should be valid JSON\");\n        }\n    }\n}\n\n#[then(regex = r\"^the exit code should be (\\d+)$\")]\nfn exit_code_should_be(world: &mut CleanroomWorld, expected_code: i32) {\n    let actual_code = world.last_exit_code.unwrap_or(-1);\n    \n    if actual_code != expected_code {\n        eprintln!(\"=== EXIT CODE MISMATCH ===\");\n        eprintln!(\"Expected: {}\", expected_code);\n        eprintln!(\"Actual: {}\", actual_code);\n        eprintln!(\"Stdout:\\n{}\", world.last_stdout());\n        eprintln!(\"Stderr:\\n{}\", world.last_stderr());\n        panic!(\"Expected exit code {}, got {}\", expected_code, actual_code);\n    }\n}\n"
        }
    ]
}