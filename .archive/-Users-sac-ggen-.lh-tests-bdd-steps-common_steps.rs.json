{
    "sourceFile": "tests/bdd/steps/common_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760245905696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760245905696,
            "name": "Commit-0",
            "content": "use assert_cmd::Command;\nuse cucumber::{given, then, when};\nuse std::fs;\n\nuse super::super::world::GgenWorld;\n\n/// Common step definitions used across multiple features\n///\n/// These steps provide basic functionality for:\n/// - Setting up clean project directories\n/// - Running ggen commands\n/// - Basic file operations\n/// - Command output validation\n\n#[given(regex = r\"^I have a clean project directory$\")]\nfn clean_project_directory(world: &mut GgenWorld) {\n    // World is already initialized with temp directory\n    // Ensure it's clean\n    if world.project_dir.exists() {\n        fs::remove_dir_all(&world.project_dir).expect(\"Failed to clean project dir\");\n    }\n    fs::create_dir_all(&world.project_dir).expect(\"Failed to create project dir\");\n}\n\n#[given(regex = r\"^ggen is installed$\")]\nfn ggen_is_installed(_world: &mut GgenWorld) {\n    // Verify ggen binary exists and is executable\n    let mut cmd = Command::cargo_bin(\"ggen\").expect(\"ggen binary not found\");\n    let output = cmd\n        .arg(\"--version\")\n        .output()\n        .expect(\"Failed to run ggen --version\");\n\n    assert!(\n        output.status.success(),\n        \"ggen --version failed: {}\",\n        String::from_utf8_lossy(&output.stderr)\n    );\n\n    let version_output = String::from_utf8_lossy(&output.stdout);\n    assert!(\n        version_output.contains(\"ggen 1.0.0\"),\n        \"Expected version 'ggen 1.0.0', got: {}\",\n        version_output\n    );\n}\n\n#[when(regex = r\"^I run the command (.+)$\")]\nfn run_generic_command(world: &mut GgenWorld, command: String) {\n    let args: Vec<&str> = command.split_whitespace().collect();\n\n    if args.is_empty() {\n        panic!(\"Empty command provided\");\n    }\n\n    let binary = args[0];\n    let cmd_args = &args[1..];\n\n    let mut cmd = if binary == \"ggen\" {\n        Command::cargo_bin(\"ggen\").expect(\"ggen binary not found\")\n    } else if binary == \"cargo\" {\n        Command::new(\"cargo\")\n    } else {\n        Command::new(binary)\n    };\n\n    let output = cmd\n        .args(cmd_args)\n        .current_dir(&world.project_dir)\n        .output()\n        .unwrap_or_else(|_| panic!(\"Failed to run command: {}\", command));\n\n    world.last_output = Some(output.clone());\n    world.last_exit_code = output.status.code();\n}\n\n#[then(regex = r\"^the command should succeed$\")]\nfn command_should_succeed(world: &mut GgenWorld) {\n    assert!(\n        world.last_command_succeeded(),\n        \"Command failed with exit code: {}\\nStderr: {}\",\n        world.last_exit_code.unwrap_or(-1),\n        world.last_stderr()\n    );\n}\n\n#[then(regex = r\"^I should see (.+)$\")]\nfn should_see_text(world: &mut GgenWorld, expected: String) {\n    let stdout = world.last_stdout();\n    let stderr = world.last_stderr();\n\n    assert!(\n        stdout.contains(&expected) || stderr.contains(&expected),\n        \"Expected to see '{}' in output, but got:\\nStdout: {}\\nStderr: {}\",\n        expected,\n        stdout,\n        stderr\n    );\n}\n\n#[then(regex = r\"^the file (.+) should exist$\")]\nfn file_should_exist(world: &mut GgenWorld, path: String) {\n    let file_path = world.project_dir.join(&path);\n    assert!(\n        file_path.exists(),\n        \"File {} should exist at {}\",\n        path,\n        file_path.display()\n    );\n}\n"
        }
    ]
}