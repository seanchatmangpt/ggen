{
    "sourceFile": "crates/ggen-marketplace/tests/backend_p2p.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762979113876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762979398251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n         .license(\"MIT\")\n         .content_id(ContentId::new(\"abcd1234567890\", HashAlgorithm::Sha256))\n         .build()\n         .expect(\"Failed to build test package\");\n-    \n+\n     // Validate package before use (Poka-yoke: ensures package meets requirements)\n     let validated = unvalidated.validate().expect(\"Failed to validate package\");\n     let package = validated.package().clone();\n \n@@ -113,9 +113,11 @@\n         .license(\"MIT\")\n         .content_id(ContentId::new(\"hash1\", HashAlgorithm::Sha256))\n         .build()\n         .expect(\"Failed to build package1\");\n-    let validated1 = unvalidated1.validate().expect(\"Failed to validate package1\");\n+    let validated1 = unvalidated1\n+        .validate()\n+        .expect(\"Failed to validate package1\");\n     let package1 = validated1.package().clone();\n \n     let unvalidated2 = Package::builder(package2_id.clone(), Version::new(1, 0, 0))\n         .title(\"Web Client\")\n@@ -123,9 +125,11 @@\n         .license(\"MIT\")\n         .content_id(ContentId::new(\"hash2\", HashAlgorithm::Sha256))\n         .build()\n         .expect(\"Failed to build package2\");\n-    let validated2 = unvalidated2.validate().expect(\"Failed to validate package2\");\n+    let validated2 = unvalidated2\n+        .validate()\n+        .expect(\"Failed to validate package2\");\n     let package2 = validated2.package().clone();\n \n     // Set up mock search results from remote peers\n     registry.set_search_results(\"web\".to_string(), vec![package1.clone(), package2.clone()]);\n"
                }
            ],
            "date": 1762979113876,
            "name": "Commit-0",
            "content": "//! Tests for P2P Registry implementation using libp2p\n//! Following London TDD approach with mocks\n\nuse ggen_marketplace::prelude::*;\nuse std::collections::HashMap;\nuse tokio;\n\n/// Mock implementation for testing P2P registry behavior\n#[derive(Debug)]\nstruct MockP2PRegistry {\n    local_packages: HashMap<String, Package>,\n    discovered_peers: Vec<String>,\n    published_packages: Vec<String>,\n    search_results: HashMap<String, Vec<Package>>,\n}\n\nimpl MockP2PRegistry {\n    fn new() -> Self {\n        Self {\n            local_packages: HashMap::new(),\n            discovered_peers: Vec::new(),\n            published_packages: Vec::new(),\n            search_results: HashMap::new(),\n        }\n    }\n\n    fn add_peer(&mut self, peer_id: String) {\n        self.discovered_peers.push(peer_id);\n    }\n\n    fn set_search_results(&mut self, query: String, packages: Vec<Package>) {\n        self.search_results.insert(query, packages);\n    }\n}\n\n#[tokio::test]\nasync fn test_p2p_network_initialization() {\n    // Test that we can initialize a P2P network with proper configuration\n    let registry = MockP2PRegistry::new();\n\n    // Verify initial state\n    assert_eq!(registry.discovered_peers.len(), 0);\n    assert_eq!(registry.local_packages.len(), 0);\n    assert_eq!(registry.published_packages.len(), 0);\n}\n\n#[tokio::test]\nasync fn test_discover_peers_via_dht() {\n    // Test DHT-based peer discovery\n    let mut registry = MockP2PRegistry::new();\n\n    // Simulate peer discovery\n    registry.add_peer(\"peer1\".to_string());\n    registry.add_peer(\"peer2\".to_string());\n    registry.add_peer(\"peer3\".to_string());\n\n    // Verify peers were discovered\n    assert_eq!(registry.discovered_peers.len(), 3);\n    assert!(registry.discovered_peers.contains(&\"peer1\".to_string()));\n    assert!(registry.discovered_peers.contains(&\"peer2\".to_string()));\n    assert!(registry.discovered_peers.contains(&\"peer3\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_announce_package_via_gossipsub() {\n    // Test package announcement through gossipsub\n    let mut registry = MockP2PRegistry::new();\n\n    // Create a test package\n    let package_id = PackageId::new(\"test\", \"package\");\n    let version = Version::new(1, 0, 0);\n\n    let unvalidated = Package::builder(package_id.clone(), version)\n        .title(\"Test Package\")\n        .description(\"A test package for P2P testing\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"abcd1234567890\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build test package\");\n    \n    // Validate package before use (Poka-yoke: ensures package meets requirements)\n    let validated = unvalidated.validate().expect(\"Failed to validate package\");\n    let package = validated.package().clone();\n\n    // Simulate publishing (announcing) the package\n    registry.published_packages.push(package.id.to_string());\n    registry\n        .local_packages\n        .insert(package.id.to_string(), package.clone());\n\n    // Verify package was announced\n    assert_eq!(registry.published_packages.len(), 1);\n    assert!(registry\n        .published_packages\n        .contains(&package.id.to_string()));\n    assert!(registry\n        .local_packages\n        .contains_key(&package.id.to_string()));\n}\n\n#[tokio::test]\nasync fn test_search_discovers_remote_packages() {\n    // Test that search can discover packages from remote peers\n    let mut registry = MockP2PRegistry::new();\n\n    // Create test packages\n    let package1_id = PackageId::new(\"test\", \"web-server\");\n    let package2_id = PackageId::new(\"test\", \"web-client\");\n\n    let unvalidated1 = Package::builder(package1_id.clone(), Version::new(1, 0, 0))\n        .title(\"Web Server\")\n        .description(\"A web server package\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"hash1\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build package1\");\n    let validated1 = unvalidated1.validate().expect(\"Failed to validate package1\");\n    let package1 = validated1.package().clone();\n\n    let unvalidated2 = Package::builder(package2_id.clone(), Version::new(1, 0, 0))\n        .title(\"Web Client\")\n        .description(\"A web client package\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"hash2\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build package2\");\n    let validated2 = unvalidated2.validate().expect(\"Failed to validate package2\");\n    let package2 = validated2.package().clone();\n\n    // Set up mock search results from remote peers\n    registry.set_search_results(\"web\".to_string(), vec![package1.clone(), package2.clone()]);\n\n    // Simulate search\n    let results = registry.search_results.get(\"web\");\n\n    // Verify search found remote packages\n    assert!(results.is_some());\n    let results = results.unwrap();\n    assert_eq!(results.len(), 2);\n    assert!(results.iter().any(|p| p.id == package1_id));\n    assert!(results.iter().any(|p| p.id == package2_id));\n}\n\n#[tokio::test]\nasync fn test_retrieve_package_from_peer() {\n    // Test retrieving package content from a remote peer\n    let mut registry = MockP2PRegistry::new();\n\n    // Add a remote peer\n    registry.add_peer(\"peer1\".to_string());\n\n    // Create and store a package in local cache (simulating retrieval)\n    let package_id = PackageId::new(\"test\", \"remote-package\");\n    let unvalidated = Package::builder(package_id.clone(), Version::new(1, 0, 0))\n        .title(\"Remote Package\")\n        .description(\"A package from a remote peer\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"remote-hash\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build package\");\n    let validated = unvalidated.validate().expect(\"Failed to validate package\");\n    let package = validated.package().clone();\n\n    registry\n        .local_packages\n        .insert(package_id.to_string(), package.clone());\n\n    // Verify package can be retrieved\n    let retrieved = registry.local_packages.get(&package_id.to_string());\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().id, package_id);\n}\n\n#[tokio::test]\nasync fn test_multiple_peers_package_discovery() {\n    // Test package discovery across multiple peers\n    let mut registry = MockP2PRegistry::new();\n\n    // Add multiple peers\n    registry.add_peer(\"peer1\".to_string());\n    registry.add_peer(\"peer2\".to_string());\n    registry.add_peer(\"peer3\".to_string());\n\n    // Create packages from different peers\n    let packages: Vec<Package> = (0..5)\n        .map(|i| {\n            let package_id = PackageId::new(\"test\", format!(\"package{}\", i));\n            let unvalidated = Package::builder(package_id, Version::new(1, 0, 0))\n                .title(format!(\"Package {}\", i))\n                .description(format!(\"Test package number {}\", i))\n                .license(\"MIT\")\n                .content_id(ContentId::new(format!(\"hash{}\", i), HashAlgorithm::Sha256))\n                .build()\n                .expect(\"Failed to build package\");\n            let validated = unvalidated.validate().expect(\"Failed to validate package\");\n            validated.package().clone()\n        })\n        .collect();\n\n    // Store packages\n    for package in &packages {\n        registry\n            .local_packages\n            .insert(package.id.to_string(), package.clone());\n    }\n\n    // Verify all packages are discoverable\n    assert_eq!(registry.local_packages.len(), 5);\n    assert_eq!(registry.discovered_peers.len(), 3);\n}\n\n#[tokio::test]\nasync fn test_package_republishing_prevents_duplicates() {\n    // Test that republishing the same package doesn't create duplicates\n    let mut registry = MockP2PRegistry::new();\n\n    let package_id = PackageId::new(\"test\", \"duplicate-test\");\n    let unvalidated = Package::builder(package_id.clone(), Version::new(1, 0, 0))\n        .title(\"Duplicate Test\")\n        .description(\"Test duplicate prevention\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"hash\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build package\");\n    let validated = unvalidated.validate().expect(\"Failed to validate package\");\n    let package = validated.package().clone();\n\n    // Publish the package twice\n    registry\n        .local_packages\n        .insert(package_id.to_string(), package.clone());\n    registry.published_packages.push(package_id.to_string());\n\n    // Try to publish again (should replace, not duplicate)\n    registry\n        .local_packages\n        .insert(package_id.to_string(), package.clone());\n    registry.published_packages.push(package_id.to_string());\n\n    // Verify: local packages should have only one entry (replaced)\n    assert_eq!(registry.local_packages.len(), 1);\n    // But published_packages (announcements) may have multiple entries\n    assert_eq!(registry.published_packages.len(), 2);\n}\n\n#[tokio::test]\nasync fn test_peer_reputation_tracking() {\n    // Test basic peer reputation tracking\n    let mut registry = MockP2PRegistry::new();\n\n    // Add peers with different reliability\n    registry.add_peer(\"reliable-peer\".to_string());\n    registry.add_peer(\"unreliable-peer\".to_string());\n\n    // In a real implementation, we would track:\n    // - Successful package retrievals\n    // - Failed retrievals\n    // - Response times\n    // - Package verification failures\n\n    assert_eq!(registry.discovered_peers.len(), 2);\n}\n\n#[tokio::test]\nasync fn test_dht_put_get_operations() {\n    // Test DHT storage and retrieval operations\n    let mut registry = MockP2PRegistry::new();\n\n    let package_id = PackageId::new(\"test\", \"dht-package\");\n    let unvalidated = Package::builder(package_id.clone(), Version::new(1, 0, 0))\n        .title(\"DHT Package\")\n        .description(\"Package stored in DHT\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"dht-hash\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build package\");\n    let validated = unvalidated.validate().expect(\"Failed to validate package\");\n    let package = validated.package().clone();\n\n    // Simulate DHT put operation\n    registry\n        .local_packages\n        .insert(package_id.to_string(), package.clone());\n\n    // Simulate DHT get operation\n    let retrieved = registry.local_packages.get(&package_id.to_string());\n\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().id, package_id);\n}\n\n#[tokio::test]\nasync fn test_gossipsub_topic_subscription() {\n    // Test gossipsub topic subscription for package announcements\n    let registry = MockP2PRegistry::new();\n\n    // In a real implementation, we would verify:\n    // - Subscription to \"/packages/v1\" topic\n    // - Receiving messages on the topic\n    // - Publishing messages to the topic\n\n    // For now, verify initial state\n    assert_eq!(registry.published_packages.len(), 0);\n}\n\n#[tokio::test]\nasync fn test_package_version_updates() {\n    // Test handling package version updates\n    let mut registry = MockP2PRegistry::new();\n\n    let package_id = PackageId::new(\"test\", \"versioned-package\");\n\n    // Publish version 1.0.0\n    let unvalidated_v1 = Package::builder(package_id.clone(), Version::new(1, 0, 0))\n        .title(\"Versioned Package\")\n        .description(\"Test version updates\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"hash-v1\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build v1\");\n    let validated_v1 = unvalidated_v1.validate().expect(\"Failed to validate v1\");\n    let v1 = validated_v1.package().clone();\n\n    registry\n        .local_packages\n        .insert(format!(\"{}@1.0.0\", package_id), v1);\n\n    // Publish version 2.0.0\n    let unvalidated_v2 = Package::builder(package_id.clone(), Version::new(2, 0, 0))\n        .title(\"Versioned Package\")\n        .description(\"Test version updates - v2\")\n        .license(\"MIT\")\n        .content_id(ContentId::new(\"hash-v2\", HashAlgorithm::Sha256))\n        .build()\n        .expect(\"Failed to build v2\");\n    let validated_v2 = unvalidated_v2.validate().expect(\"Failed to validate v2\");\n    let v2 = validated_v2.package().clone();\n\n    registry\n        .local_packages\n        .insert(format!(\"{}@2.0.0\", package_id), v2);\n\n    // Verify both versions exist\n    assert!(registry\n        .local_packages\n        .contains_key(&format!(\"{}@1.0.0\", package_id)));\n    assert!(registry\n        .local_packages\n        .contains_key(&format!(\"{}@2.0.0\", package_id)));\n}\n"
        }
    ]
}