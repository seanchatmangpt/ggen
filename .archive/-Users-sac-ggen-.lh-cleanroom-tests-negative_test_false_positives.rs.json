{
    "sourceFile": "cleanroom/tests/negative_test_false_positives.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760415381277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760415381277,
            "name": "Commit-0",
            "content": "//! Negative Testing: False Positive Detection\n//!\n//! This test suite is designed to detect false positives - methods that\n//! return success when they should fail without Docker.\n//!\n//! **CRITICAL**: These tests should FAIL if mock implementations are present.\n//!\n//! Run these tests WITHOUT Docker running to verify proper error handling.\n\nuse crate::cleanroom::containers::{GenericContainer, PostgresContainer, RedisContainer};\nuse crate::cleanroom::error::Result;\n\n/// Test that postgres methods fail properly without Docker\n///\n/// **Expected Behavior WITHOUT Docker**:\n/// - Container creation should fail at `.start()`\n/// - If creation somehow succeeds (bug), connection tests should fail\n#[tokio::test]\n#[ignore] // Run manually with `cargo test --test negative_test_false_positives -- --ignored`\nasync fn negative_test_postgres_false_positives() {\n    println!(\"\\nüîç NEGATIVE TEST: Testing PostgreSQL false positives...\");\n    println!(\"‚ö†Ô∏è  This test should be run WITHOUT Docker running!\");\n\n    // Step 1: Try to create container (should fail without Docker)\n    let postgres_result = PostgresContainer::new(\"testdb\", \"testuser\", \"testpass\");\n\n    match postgres_result {\n        Err(e) => {\n            println!(\"‚úÖ GOOD: Container creation failed as expected: {}\", e);\n            // This is the correct behavior - test passes\n            return;\n        }\n        Ok(postgres) => {\n            println!(\"‚ö†Ô∏è  WARNING: Container creation succeeded (Docker might be running)\");\n            println!(\"   Now testing for false positives in method implementations...\");\n\n            // Step 2: Test connection (should fail without real database)\n            let connection_result = postgres.test_connection().await;\n            match connection_result {\n                Ok(()) => {\n                    panic!(\n                        \"‚ùå FALSE POSITIVE DETECTED: test_connection() returned Ok(()) \\\n                        without real database connection! This is a mock implementation.\"\n                    );\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: test_connection() properly failed: {}\", e);\n                }\n            }\n\n            // Step 3: Test SQL execution (should fail without real database)\n            let sql_result = postgres.execute_sql(\"SELECT 1\").await;\n            match sql_result {\n                Ok(result) => {\n                    if result.contains(\"Mock\") {\n                        panic!(\n                            \"‚ùå FALSE POSITIVE DETECTED: execute_sql() returned mock data: '{}' \\\n                            without real database connection!\",\n                            result\n                        );\n                    } else {\n                        println!(\"‚úÖ SQL execution returned: {}\", result);\n                    }\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: execute_sql() properly failed: {}\", e);\n                }\n            }\n        }\n    }\n}\n\n/// Test that redis methods fail properly without Docker\n///\n/// **Expected Behavior WITHOUT Docker**:\n/// - Container creation should fail at `.start()`\n/// - If creation somehow succeeds (bug), command execution should fail\n#[tokio::test]\n#[ignore] // Run manually\nasync fn negative_test_redis_false_positives() {\n    println!(\"\\nüîç NEGATIVE TEST: Testing Redis false positives...\");\n    println!(\"‚ö†Ô∏è  This test should be run WITHOUT Docker running!\");\n\n    // Step 1: Try to create container (should fail without Docker)\n    let redis_result = RedisContainer::new(None);\n\n    match redis_result {\n        Err(e) => {\n            println!(\"‚úÖ GOOD: Container creation failed as expected: {}\", e);\n            return;\n        }\n        Ok(redis) => {\n            println!(\"‚ö†Ô∏è  WARNING: Container creation succeeded (Docker might be running)\");\n            println!(\"   Now testing for false positives in method implementations...\");\n\n            // Step 2: Test connection (should fail without real Redis)\n            let connection_result = redis.test_connection().await;\n            match connection_result {\n                Ok(()) => {\n                    panic!(\n                        \"‚ùå FALSE POSITIVE DETECTED: test_connection() returned Ok(()) \\\n                        without real Redis connection! This is a mock implementation.\"\n                    );\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: test_connection() properly failed: {}\", e);\n                }\n            }\n\n            // Step 3: Test command execution (should fail without real Redis)\n            let cmd_result = redis.execute_command(\"PING\").await;\n            match cmd_result {\n                Ok(result) => {\n                    if result.contains(\"Mock\") {\n                        panic!(\n                            \"‚ùå FALSE POSITIVE DETECTED: execute_command() returned mock data: '{}' \\\n                            without real Redis connection!\",\n                            result\n                        );\n                    } else {\n                        println!(\"‚úÖ Command execution returned: {}\", result);\n                    }\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: execute_command() properly failed: {}\", e);\n                }\n            }\n\n            // Step 4: Test SET operation (should fail without real Redis)\n            let set_result = redis.set(\"key\", \"value\").await;\n            match set_result {\n                Ok(result) => {\n                    if result.contains(\"Mock\") {\n                        panic!(\n                            \"‚ùå FALSE POSITIVE DETECTED: set() returned mock data: '{}' \\\n                            without real Redis connection!\",\n                            result\n                        );\n                    }\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: set() properly failed: {}\", e);\n                }\n            }\n        }\n    }\n}\n\n/// Test that generic container methods fail properly without Docker\n#[tokio::test]\n#[ignore] // Run manually\nasync fn negative_test_generic_container_false_positives() {\n    println!(\"\\nüîç NEGATIVE TEST: Testing GenericContainer false positives...\");\n    println!(\"‚ö†Ô∏è  This test should be run WITHOUT Docker running!\");\n\n    // Step 1: Try to create container (should fail without Docker)\n    let container_result = GenericContainer::new(\"test\", \"alpine\", \"latest\");\n\n    match container_result {\n        Err(e) => {\n            println!(\"‚úÖ GOOD: Container creation failed as expected: {}\", e);\n            return;\n        }\n        Ok(container) => {\n            println!(\"‚ö†Ô∏è  WARNING: Container creation succeeded (Docker might be running)\");\n            println!(\"   Now testing for false positives in method implementations...\");\n\n            // Step 2: Test command execution (should fail without real container)\n            let cmd_result = container\n                .execute_command(vec![\"echo\".into(), \"test\".into()])\n                .await;\n            match cmd_result {\n                Ok(result) => {\n                    if result.contains(\"Mock\") {\n                        panic!(\n                            \"‚ùå FALSE POSITIVE DETECTED: execute_command() returned mock data: '{}' \\\n                            without real container!\",\n                            result\n                        );\n                    } else {\n                        println!(\"‚úÖ Command execution returned: {}\", result);\n                    }\n                }\n                Err(e) => {\n                    println!(\"‚úÖ GOOD: execute_command() properly failed: {}\", e);\n                }\n            }\n        }\n    }\n}\n\n/// Test that container status is accurate\n///\n/// **Expected Behavior**:\n/// - Status should NOT always return \"Running\"\n/// - Status should reflect actual Docker state\n#[tokio::test]\n#[ignore] // Run manually\nasync fn negative_test_container_status_accuracy() {\n    println!(\"\\nüîç NEGATIVE TEST: Testing container status accuracy...\");\n\n    // This test verifies that status() doesn't always return Running\n    // Run this WITHOUT Docker and status should return Error or Stopped\n\n    use crate::cleanroom::clnrm::{ContainerStatus, ContainerWrapper};\n\n    let postgres_result = PostgresContainer::new(\"testdb\", \"testuser\", \"testpass\");\n\n    if let Ok(postgres) = postgres_result {\n        let status = postgres.status();\n\n        if status == ContainerStatus::Running {\n            println!(\"‚ö†Ô∏è  WARNING: Container status is 'Running'\");\n            println!(\"   This might be accurate if Docker is running,\");\n            println!(\"   or it might be a false positive (hardcoded status).\");\n            println!(\"   Verify by stopping Docker and running this test again.\");\n        } else {\n            println!(\"‚úÖ GOOD: Container status is: {:?}\", status);\n        }\n    } else {\n        println!(\"‚úÖ Container creation failed without Docker (expected)\");\n    }\n}\n\n/// Test that metrics are not hardcoded\n///\n/// **Expected Behavior**:\n/// - Metrics should reflect actual container state\n/// - Metrics should fail or return zeros without Docker\n#[tokio::test]\n#[ignore] // Run manually\nasync fn negative_test_metrics_accuracy() {\n    println!(\"\\nüîç NEGATIVE TEST: Testing metrics accuracy...\");\n\n    use crate::cleanroom::clnrm::ContainerWrapper;\n\n    let postgres_result = PostgresContainer::new(\"testdb\", \"testuser\", \"testpass\");\n\n    if let Ok(postgres) = postgres_result {\n        let metrics = postgres.metrics();\n\n        // Check for suspiciously static values\n        if metrics.cpu_usage_percent == 5.0\n            && metrics.memory_usage_bytes == 128 * 1024 * 1024\n            && metrics.network_bytes_sent == 0\n            && metrics.network_bytes_received == 0\n        {\n            println!(\n                \"‚ö†Ô∏è  WARNING: Metrics appear to be hardcoded values:\\n\\\n                CPU: {}%, Memory: {} bytes, Network: {}/{} bytes\",\n                metrics.cpu_usage_percent,\n                metrics.memory_usage_bytes,\n                metrics.network_bytes_sent,\n                metrics.network_bytes_received\n            );\n            println!(\"   These should vary based on actual container usage.\");\n        } else {\n            println!(\"‚úÖ GOOD: Metrics appear to be dynamic: {:?}\", metrics);\n        }\n    } else {\n        println!(\"‚úÖ Container creation failed without Docker (expected)\");\n    }\n}\n\n/// Integration test: Full workflow should fail without Docker\n///\n/// This test simulates a typical workflow and ensures all steps\n/// fail appropriately when Docker is not available.\n#[tokio::test]\n#[ignore] // Run manually with Docker stopped\nasync fn negative_test_full_workflow_without_docker() {\n    println!(\"\\nüîç NEGATIVE TEST: Full workflow without Docker...\");\n    println!(\"‚ö†Ô∏è  Docker should be STOPPED for this test!\");\n\n    let mut failures = Vec::new();\n\n    // Test 1: PostgreSQL creation should fail\n    match PostgresContainer::new(\"testdb\", \"testuser\", \"testpass\") {\n        Ok(_) => failures.push(\"PostgreSQL container creation succeeded (should fail)\"),\n        Err(_) => println!(\"‚úÖ PostgreSQL creation failed (expected)\"),\n    }\n\n    // Test 2: Redis creation should fail\n    match RedisContainer::new(None) {\n        Ok(_) => failures.push(\"Redis container creation succeeded (should fail)\"),\n        Err(_) => println!(\"‚úÖ Redis creation failed (expected)\"),\n    }\n\n    // Test 3: Generic container creation should fail\n    match GenericContainer::new(\"test\", \"alpine\", \"latest\") {\n        Ok(_) => failures.push(\"Generic container creation succeeded (should fail)\"),\n        Err(_) => println!(\"‚úÖ Generic container creation failed (expected)\"),\n    }\n\n    if !failures.is_empty() {\n        panic!(\n            \"‚ùå FALSE POSITIVES DETECTED:\\n{}\",\n            failures\n                .iter()\n                .map(|f| format!(\"  - {}\", f))\n                .collect::<Vec<_>>()\n                .join(\"\\n\")\n        );\n    }\n\n    println!(\"‚úÖ All operations properly failed without Docker!\");\n}\n\n#[cfg(test)]\nmod documentation {\n    //! HOW TO USE THESE TESTS\n    //!\n    //! These are negative tests designed to detect false positives.\n    //!\n    //! ## Running the tests:\n    //!\n    //! 1. Stop Docker Desktop completely\n    //! 2. Run: `cargo test --test negative_test_false_positives -- --ignored --nocapture`\n    //! 3. Verify all tests PASS (meaning they detected the expected failures)\n    //!\n    //! ## Expected Results:\n    //!\n    //! WITH Docker running:\n    //! - Tests may fail (because operations succeed)\n    //! - This is OK - tests are meant for \"Docker stopped\" scenario\n    //!\n    //! WITHOUT Docker running:\n    //! - Tests should PASS (operations fail as expected)\n    //! - If tests FAIL, false positives are detected!\n    //!\n    //! ## What False Positives Look Like:\n    //!\n    //! ```\n    //! ‚ùå FALSE POSITIVE DETECTED: test_connection() returned Ok(())\n    //!    without real database connection! This is a mock implementation.\n    //! ```\n    //!\n    //! ## Fixing False Positives:\n    //!\n    //! Replace mock implementations with proper error handling:\n    //!\n    //! ```rust\n    //! // Before (FALSE POSITIVE):\n    //! pub async fn test_connection(&self) -> Result<()> {\n    //!     Ok(())  // Always succeeds\n    //! }\n    //!\n    //! // After (PROPER):\n    //! pub async fn test_connection(&self) -> Result<()> {\n    //!     // Attempt real connection\n    //!     self.client.ping().await\n    //!         .map_err(|e| CleanroomError::connection_error(e))\n    //! }\n    //! ```\n}\n"
        }
    ]
}