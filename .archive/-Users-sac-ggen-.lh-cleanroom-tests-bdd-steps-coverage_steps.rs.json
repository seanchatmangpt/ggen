{
    "sourceFile": "cleanroom/tests/bdd/steps/coverage_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse cucumber::{given, then, when};\nuse std::fs;\nuse std::path::Path;\n\n/// Coverage step definitions for Cleanroom BDD tests\n///\n/// These steps handle coverage analysis, reporting, and validation\n/// for cleanroom test execution and code coverage.\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have coverage analysis enabled$\")]\nfn coverage_analysis_enabled(world: &mut CleanroomWorld) {\n    world.set_policy(\"coverage_enabled\".to_string(), \"true\".to_string());\n}\n\n#[given(regex = r\"^I have a coverage report \"([^\"]+)\"$\")]\nfn coverage_report(world: &mut CleanroomWorld, filename: String) {\n    // Create a mock coverage report\n    let coverage_content = r#\"{\n  \"coverage\": {\n    \"lines\": {\n      \"total\": 100,\n      \"covered\": 85,\n      \"percentage\": 85.0\n    },\n    \"functions\": {\n      \"total\": 20,\n      \"covered\": 18,\n      \"percentage\": 90.0\n    },\n    \"branches\": {\n      \"total\": 30,\n      \"covered\": 25,\n      \"percentage\": 83.33\n    }\n  }\n}\"#;\n    \n    let file_path = world.project_dir.join(&filename);\n    fs::write(&file_path, coverage_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write coverage report {}: {}\", filename, e));\n    \n    world.capture_file(&filename, coverage_content.to_string());\n}\n\n#[given(regex = r\"^I have a coverage threshold of (\\d+)%$\")]\nfn coverage_threshold(world: &mut CleanroomWorld, threshold: i32) {\n    world.set_policy(\"coverage_threshold\".to_string(), threshold.to_string());\n}\n\n#[given(regex = r\"^I have coverage data for \"([^\"]+)\"$\")]\nfn coverage_data_for_file(world: &mut CleanroomWorld, filename: String) {\n    // Create coverage data for a specific file\n    let coverage_data = format!(\n        r#\"file: {}\nlines_covered: 45\nlines_total: 50\ncoverage_percentage: 90.0\n\"#,\n        filename\n    );\n    \n    let data_file = world.project_dir.join(format!(\"{}.coverage\", filename));\n    fs::write(&data_file, coverage_data)\n        .unwrap_or_else(|e| panic!(\"Failed to write coverage data: {}\", e));\n    \n    world.capture_file(&format!(\"{}.coverage\", filename), coverage_data);\n}\n\n#[given(regex = r\"^I have branch coverage data$\")]\nfn branch_coverage_data(world: &mut CleanroomWorld) {\n    let branch_data = r#\"branches: [\n  {\n    \"line\": 10,\n    \"type\": \"if\",\n    \"covered\": true\n  },\n  {\n    \"line\": 15,\n    \"type\": \"else\",\n    \"covered\": false\n  },\n  {\n    \"line\": 20,\n    \"type\": \"match\",\n    \"covered\": true\n  }\n]\"#;\n    \n    let data_file = world.project_dir.join(\"branch_coverage.json\");\n    fs::write(&data_file, branch_data)\n        .unwrap_or_else(|e| panic!(\"Failed to write branch coverage data: {}\", e));\n    \n    world.capture_file(\"branch_coverage.json\", branch_data.to_string());\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I generate a coverage report$\")]\nfn generate_coverage_report(world: &mut CleanroomWorld) {\n    // Simulate coverage report generation\n    let report_content = r#\"# Coverage Report\n\n## Summary\n- Lines: 85/100 (85%)\n- Functions: 18/20 (90%)\n- Branches: 25/30 (83.33%)\n\n## Files\n- src/main.rs: 90%\n- src/lib.rs: 80%\n- src/utils.rs: 85%\n\"#;\n    \n    let report_file = world.project_dir.join(\"coverage_report.md\");\n    fs::write(&report_file, report_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write coverage report: {}\", e));\n    \n    world.capture_file(\"coverage_report.md\", report_content.to_string());\n}\n\n#[when(regex = r\"^I analyze coverage for \"([^\"]+)\"$\")]\nfn analyze_coverage_for_file(world: &mut CleanroomWorld, filename: String) {\n    // Simulate coverage analysis for a specific file\n    let analysis_content = format!(\n        r#\"Coverage analysis for {}\n\nLines covered: 45/50 (90%)\nFunctions covered: 8/10 (80%)\nBranches covered: 12/15 (80%)\n\nUncovered lines: 15, 23, 31, 42, 48\n\"#,\n        filename\n    );\n    \n    let analysis_file = world.project_dir.join(format!(\"{}_analysis.txt\", filename));\n    fs::write(&analysis_file, analysis_content)\n        .unwrap_or_else(|e| panic!(\"Failed to write coverage analysis: {}\", e));\n    \n    world.capture_file(&format!(\"{}_analysis.txt\", filename), analysis_content);\n}\n\n#[when(regex = r\"^I check coverage against threshold$\")]\nfn check_coverage_against_threshold(world: &mut CleanroomWorld) {\n    // Check coverage against the configured threshold\n    let threshold: i32 = world.policy_settings.get(\"coverage_threshold\")\n        .unwrap_or(&\"80\".to_string())\n        .parse()\n        .expect(\"Coverage threshold should be a number\");\n    \n    // Simulate coverage check\n    let current_coverage = 85; // Mock coverage percentage\n    \n    if current_coverage >= threshold {\n        world.set_policy(\"coverage_check_passed\".to_string(), \"true\".to_string());\n    } else {\n        world.set_policy(\"coverage_check_passed\".to_string(), \"false\".to_string());\n    }\n}\n\n#[when(regex = r\"^I export coverage data to \"([^\"]+)\"$\")]\nfn export_coverage_data(world: &mut CleanroomWorld, format: String) {\n    let export_content = match format.as_str() {\n        \"json\" => r#\"{\n  \"coverage\": {\n    \"lines\": 85,\n    \"functions\": 18,\n    \"branches\": 25\n  }\n}\"#,\n        \"xml\" => r#\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<coverage>\n  <lines>85</lines>\n  <functions>18</functions>\n  <branches>25</branches>\n</coverage>\"#,\n        \"html\" => r#\"<html>\n<head><title>Coverage Report</title></head>\n<body>\n  <h1>Coverage Report</h1>\n  <p>Lines: 85%</p>\n  <p>Functions: 90%</p>\n  <p>Branches: 83.33%</p>\n</body>\n</html>\"#,\n        _ => panic!(\"Unsupported coverage export format: {}\", format),\n    };\n    \n    let export_file = world.project_dir.join(format!(\"coverage.{}\", format));\n    fs::write(&export_file, export_content)\n        .unwrap_or_else(|e| panic!(\"Failed to export coverage data: {}\", e));\n    \n    world.capture_file(&format!(\"coverage.{}\", format), export_content.to_string());\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the coverage report should be generated$\")]\nfn coverage_report_should_be_generated(world: &mut CleanroomWorld) {\n    let report_file = world.project_dir.join(\"coverage_report.md\");\n    \n    if !report_file.exists() {\n        panic!(\"Coverage report should be generated\");\n    }\n    \n    let content = fs::read_to_string(&report_file)\n        .unwrap_or_else(|e| panic!(\"Failed to read coverage report: {}\", e));\n    \n    // Verify report contains expected sections\n    assert!(content.contains(\"Coverage Report\"), \"Report should contain title\");\n    assert!(content.contains(\"Summary\"), \"Report should contain summary\");\n    assert!(content.contains(\"Files\"), \"Report should contain files section\");\n}\n\n#[then(regex = r\"^the coverage should be at least (\\d+)%$\")]\nfn coverage_should_be_at_least(world: &mut CleanroomWorld, min_coverage: i32) {\n    // Check if coverage meets the minimum threshold\n    let coverage_check_passed = world.policy_settings.get(\"coverage_check_passed\")\n        .unwrap_or(&\"false\".to_string());\n    \n    if coverage_check_passed != \"true\" {\n        panic!(\"Coverage should be at least {}%\", min_coverage);\n    }\n}\n\n#[then(regex = r\"^the coverage should meet the threshold$\")]\nfn coverage_should_meet_threshold(world: &mut CleanroomWorld) {\n    let coverage_check_passed = world.policy_settings.get(\"coverage_check_passed\")\n        .expect(\"Coverage check should have been performed\");\n    \n    assert_eq!(\n        coverage_check_passed, \"true\",\n        \"Coverage should meet the configured threshold\"\n    );\n}\n\n#[then(regex = r\"^the coverage analysis should identify uncovered lines$\")]\nfn coverage_analysis_should_identify_uncovered_lines(world: &mut CleanroomWorld) {\n    // Check if coverage analysis identified uncovered lines\n    let analysis_files: Vec<_> = world.captured_files.keys()\n        .filter(|k| k.ends_with(\"_analysis.txt\"))\n        .collect();\n    \n    if analysis_files.is_empty() {\n        panic!(\"Coverage analysis should identify uncovered lines\");\n    }\n    \n    // Check that analysis files contain uncovered line information\n    for analysis_file in analysis_files {\n        let content = world.captured_files.get(analysis_file)\n            .expect(\"Analysis file content should be captured\");\n        \n        if !content.contains(\"Uncovered lines\") {\n            panic!(\"Coverage analysis should identify uncovered lines\");\n        }\n    }\n}\n\n#[then(regex = r\"^the branch coverage should be reported$\")]\nfn branch_coverage_should_be_reported(world: &mut CleanroomWorld) {\n    let branch_data = world.captured_files.get(\"branch_coverage.json\")\n        .expect(\"Branch coverage data should be captured\");\n    \n    // Verify branch coverage data structure\n    assert!(branch_data.contains(\"branches\"), \"Should contain branches data\");\n    assert!(branch_data.contains(\"covered\"), \"Should contain coverage information\");\n}\n\n#[then(regex = r\"^the coverage data should be exported in \"([^\"]+)\" format$\")]\nfn coverage_data_should_be_exported_in_format(world: &mut CleanroomWorld, format: String) {\n    let export_file = format!(\"coverage.{}\", format);\n    let exported_data = world.captured_files.get(&export_file)\n        .expect(\"Coverage data should be exported\");\n    \n    // Verify format-specific content\n    match format.as_str() {\n        \"json\" => {\n            assert!(exported_data.contains(\"{\"), \"JSON should contain braces\");\n            assert!(exported_data.contains(\"coverage\"), \"JSON should contain coverage key\");\n        }\n        \"xml\" => {\n            assert!(exported_data.contains(\"<?xml\"), \"XML should contain declaration\");\n            assert!(exported_data.contains(\"<coverage>\"), \"XML should contain coverage tag\");\n        }\n        \"html\" => {\n            assert!(exported_data.contains(\"<html>\"), \"HTML should contain html tag\");\n            assert!(exported_data.contains(\"Coverage Report\"), \"HTML should contain title\");\n        }\n        _ => {\n            panic!(\"Unsupported format: {}\", format);\n        }\n    }\n}\n\n#[then(regex = r\"^the coverage report should show \"([^\"]+)\"$\")]\nfn coverage_report_should_show(world: &mut CleanroomWorld, expected_content: String) {\n    let report_content = world.captured_files.get(\"coverage_report.md\")\n        .expect(\"Coverage report should be captured\");\n    \n    assert!(\n        report_content.contains(&expected_content),\n        \"Coverage report should show '{}'\",\n        expected_content\n    );\n}\n\n#[then(regex = r\"^the coverage should be tracked for \"([^\"]+)\"$\")]\nfn coverage_should_be_tracked_for_file(world: &mut CleanroomWorld, filename: String) {\n    let coverage_file = format!(\"{}.coverage\", filename);\n    let coverage_data = world.captured_files.get(&coverage_file)\n        .expect(\"Coverage data should be tracked for file\");\n    \n    assert!(\n        coverage_data.contains(&filename),\n        \"Coverage data should be tracked for '{}'\",\n        filename\n    );\n}\n\n#[then(regex = r\"^the coverage metrics should be accurate$\")]\nfn coverage_metrics_should_be_accurate(world: &mut CleanroomWorld) {\n    // Verify that coverage metrics are reasonable\n    let report_content = world.captured_files.get(\"coverage_report.md\")\n        .expect(\"Coverage report should be captured\");\n    \n    // Check for percentage values\n    assert!(report_content.contains(\"%\"), \"Report should contain percentage values\");\n    \n    // Check for numeric values\n    assert!(report_content.contains(\"85\"), \"Report should contain coverage numbers\");\n    assert!(report_content.contains(\"90\"), \"Report should contain coverage numbers\");\n}\n\n#[then(regex = r\"^the coverage report should be comprehensive$\")]\nfn coverage_report_should_be_comprehensive(world: &mut CleanroomWorld) {\n    let report_content = world.captured_files.get(\"coverage_report.md\")\n        .expect(\"Coverage report should be captured\");\n    \n    // Check for comprehensive coverage information\n    assert!(report_content.contains(\"Lines\"), \"Report should include line coverage\");\n    assert!(report_content.contains(\"Functions\"), \"Report should include function coverage\");\n    assert!(report_content.contains(\"Branches\"), \"Report should include branch coverage\");\n    assert!(report_content.contains(\"Files\"), \"Report should include file coverage\");\n}\n"
        }
    ]
}