{
    "sourceFile": "cleanroom/tests/lib.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760268144240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760268144240,
            "name": "Commit-0",
            "content": "//! Test suite for cleanroom testing framework\n//!\n//! This module contains all test types for the cleanroom framework:\n//! - Integration tests\n//! - Unit tests\n//! - Property tests\n//! - BDD tests\n\npub mod integration_tests;\npub mod unit_tests;\npub mod property_tests;\npub mod bdd_tests;\n\n/// Test utilities and helpers\npub mod test_utils {\n    use std::time::Duration;\n    use tokio::time::timeout;\n    use cleanroom::{\n        CleanroomEnvironment, CleanroomConfig, CleanroomError,\n        PostgresContainer, RedisContainer, GenericContainer,\n        Policy, SecurityLevel, ResourceLimits,\n    };\n    use std::sync::Arc;\n\n    /// Create a test cleanroom environment with default configuration\n    pub async fn create_test_environment() -> Result<Arc<CleanroomEnvironment>, CleanroomError> {\n        let config = CleanroomConfig::default();\n        let environment = CleanroomEnvironment::new(config).await?;\n        Ok(Arc::new(environment))\n    }\n\n    /// Create a test cleanroom environment with custom configuration\n    pub async fn create_test_environment_with_config(\n        config: CleanroomConfig,\n    ) -> Result<Arc<CleanroomEnvironment>, CleanroomError> {\n        let environment = CleanroomEnvironment::new(config).await?;\n        Ok(Arc::new(environment))\n    }\n\n    /// Create a test Postgres container\n    pub fn create_test_postgres_container() -> PostgresContainer {\n        PostgresContainer::new(\"postgres:15\")\n            .with_env(\"POSTGRES_PASSWORD\", \"test\")\n            .with_env(\"POSTGRES_DB\", \"testdb\")\n            .with_port(5432)\n    }\n\n    /// Create a test Redis container\n    pub fn create_test_redis_container() -> RedisContainer {\n        RedisContainer::new(\"redis:7\")\n            .with_port(6379)\n    }\n\n    /// Create a test generic container\n    pub fn create_test_generic_container() -> GenericContainer {\n        GenericContainer::new(\"nginx:latest\")\n            .with_port(8080)\n            .with_env(\"NGINX_PORT\", \"8080\")\n    }\n\n    /// Create a test policy\n    pub fn create_test_policy() -> Policy {\n        Policy::with_security_level(SecurityLevel::Standard)\n            .with_network_isolation(false)\n    }\n\n    /// Create test resource limits\n    pub fn create_test_resource_limits() -> ResourceLimits {\n        ResourceLimits::new()\n            .with_max_memory_mb(512)\n            .with_max_cpu_percent(50.0)\n            .with_max_disk_mb(1024)\n    }\n\n    /// Wait for a condition to be true with timeout\n    pub async fn wait_for_condition<F, Fut>(\n        condition: F,\n        timeout_duration: Duration,\n    ) -> Result<bool, CleanroomError>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = bool>,\n    {\n        let start_time = std::time::Instant::now();\n        while start_time.elapsed() < timeout_duration {\n            if condition().await {\n                return Ok(true);\n            }\n            tokio::time::sleep(Duration::from_millis(10)).await;\n        }\n        Ok(false)\n    }\n\n    /// Execute a test with timeout\n    pub async fn execute_test_with_timeout<F, Fut, T>(\n        test: F,\n        timeout_duration: Duration,\n    ) -> Result<T, CleanroomError>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = Result<T, CleanroomError>>,\n    {\n        timeout(timeout_duration, test())\n            .await\n            .map_err(|_| CleanroomError::validation_error(\"Test timeout\"))?\n    }\n\n    /// Generate test data\n    pub fn generate_test_data(size: usize) -> serde_json::Value {\n        let mut data = serde_json::Map::new();\n        for i in 0..size {\n            data.insert(\n                format!(\"key_{}\", i),\n                serde_json::Value::String(format!(\"value_{}\", i)),\n            );\n        }\n        serde_json::Value::Object(data)\n    }\n\n    /// Create test snapshot data\n    pub fn create_test_snapshot_data() -> serde_json::Value {\n        serde_json::json!({\n            \"test_data\": \"snapshot_value\",\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"metadata\": {\n                \"version\": \"1.0\",\n                \"environment\": \"test\"\n            }\n        })\n    }\n\n    /// Assert that two values are approximately equal (for floating point comparisons)\n    pub fn assert_approx_eq(a: f64, b: f64, epsilon: f64) {\n        assert!((a - b).abs() < epsilon, \"{} is not approximately equal to {} (epsilon: {})\", a, b, epsilon);\n    }\n\n    /// Assert that a duration is within expected range\n    pub fn assert_duration_in_range(duration: Duration, min: Duration, max: Duration) {\n        assert!(\n            duration >= min && duration <= max,\n            \"Duration {:?} is not in range [{:?}, {:?}]\",\n            duration,\n            min,\n            max\n        );\n    }\n\n    /// Assert that a string contains expected content\n    pub fn assert_string_contains(haystack: &str, needle: &str) {\n        assert!(\n            haystack.contains(needle),\n            \"String '{}' does not contain '{}'\",\n            haystack,\n            needle\n        );\n    }\n\n    /// Assert that a vector contains expected elements\n    pub fn assert_vec_contains<T: PartialEq + std::fmt::Debug>(vec: &[T], expected: &T) {\n        assert!(\n            vec.contains(expected),\n            \"Vector {:?} does not contain {:?}\",\n            vec,\n            expected\n        );\n    }\n\n    /// Assert that a result is ok and contains expected value\n    pub fn assert_result_ok<T: PartialEq + std::fmt::Debug>(result: &Result<T, CleanroomError>, expected: &T) {\n        match result {\n            Ok(value) => assert_eq!(value, expected),\n            Err(error) => panic!(\"Expected Ok({:?}), got Err({:?})\", expected, error),\n        }\n    }\n\n    /// Assert that a result is an error\n    pub fn assert_result_err<T: std::fmt::Debug>(result: &Result<T, CleanroomError>) {\n        match result {\n            Ok(value) => panic!(\"Expected Err, got Ok({:?})\", value),\n            Err(_) => {} // Expected\n        }\n    }\n\n    /// Assert that a result is an error with specific kind\n    pub fn assert_result_err_kind<T: std::fmt::Debug>(\n        result: &Result<T, CleanroomError>,\n        expected_kind: cleanroom::ErrorKind,\n    ) {\n        match result {\n            Ok(value) => panic!(\"Expected Err({:?}), got Ok({:?})\", expected_kind, value),\n            Err(error) => assert_eq!(error.kind(), expected_kind),\n        }\n    }\n\n    /// Assert that a result is an error with specific message\n    pub fn assert_result_err_message<T: std::fmt::Debug>(\n        result: &Result<T, CleanroomError>,\n        expected_message: &str,\n    ) {\n        match result {\n            Ok(value) => panic!(\"Expected Err with message '{}', got Ok({:?})\", expected_message, value),\n            Err(error) => assert!(error.message().contains(expected_message)),\n        }\n    }\n\n    /// Test configuration builder\n    pub struct TestConfigBuilder {\n        config: CleanroomConfig,\n    }\n\n    impl TestConfigBuilder {\n        pub fn new() -> Self {\n            Self {\n                config: CleanroomConfig::default(),\n            }\n        }\n\n        pub fn with_singleton_containers(mut self, enable: bool) -> Self {\n            self.config.enable_singleton_containers = enable;\n            self\n        }\n\n        pub fn with_startup_timeout(mut self, timeout: Duration) -> Self {\n            self.config.container_startup_timeout = timeout;\n            self\n        }\n\n        pub fn with_execution_timeout(mut self, timeout: Duration) -> Self {\n            self.config.test_execution_timeout = timeout;\n            self\n        }\n\n        pub fn with_max_containers(mut self, max: usize) -> Self {\n            self.config.max_concurrent_containers = max;\n            self\n        }\n\n        pub fn with_deterministic_execution(mut self, enable: bool) -> Self {\n            self.config.enable_deterministic_execution = enable;\n            self\n        }\n\n        pub fn with_coverage_tracking(mut self, enable: bool) -> Self {\n            self.config.enable_coverage_tracking = enable;\n            self\n        }\n\n        pub fn with_snapshot_testing(mut self, enable: bool) -> Self {\n            self.config.enable_snapshot_testing = enable;\n            self\n        }\n\n        pub fn with_tracing(mut self, enable: bool) -> Self {\n            self.config.enable_tracing = enable;\n            self\n        }\n\n        pub fn with_security_policy(mut self, enable: bool) -> Self {\n            self.config.enable_security_policy = enable;\n            self\n        }\n\n        pub fn build(self) -> CleanroomConfig {\n            self.config\n        }\n    }\n\n    impl Default for TestConfigBuilder {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n\n    /// Test policy builder\n    pub struct TestPolicyBuilder {\n        policy: Policy,\n    }\n\n    impl TestPolicyBuilder {\n        pub fn new() -> Self {\n            Self {\n                policy: Policy::default(),\n            }\n        }\n\n        pub fn with_security_level(mut self, level: SecurityLevel) -> Self {\n            self.policy.security_level = level;\n            self\n        }\n\n        pub fn with_network_isolation(mut self, enable: bool) -> Self {\n            self.policy.network.enable_network_isolation = enable;\n            self\n        }\n\n        pub fn with_port_scanning(mut self, enable: bool) -> Self {\n            self.policy.network.enable_port_scanning = enable;\n            self\n        }\n\n        pub fn with_file_system_isolation(mut self, enable: bool) -> Self {\n            self.policy.network.enable_file_system_isolation = enable;\n            self\n        }\n\n        pub fn build(self) -> Policy {\n            self.policy\n        }\n    }\n\n    impl Default for TestPolicyBuilder {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n\n    /// Test resource limits builder\n    pub struct TestResourceLimitsBuilder {\n        limits: ResourceLimits,\n    }\n\n    impl TestResourceLimitsBuilder {\n        pub fn new() -> Self {\n            Self {\n                limits: ResourceLimits::new(),\n            }\n        }\n\n        pub fn with_max_memory_mb(mut self, memory: usize) -> Self {\n            self.limits.max_memory_mb = memory;\n            self\n        }\n\n        pub fn with_max_cpu_percent(mut self, cpu: f64) -> Self {\n            self.limits.max_cpu_percent = cpu;\n            self\n        }\n\n        pub fn with_max_disk_mb(mut self, disk: usize) -> Self {\n            self.limits.max_disk_mb = disk;\n            self\n        }\n\n        pub fn with_max_network_mb(mut self, network: usize) -> Self {\n            self.limits.max_network_mb = network;\n            self\n        }\n\n        pub fn build(self) -> ResourceLimits {\n            self.limits\n        }\n    }\n\n    impl Default for TestResourceLimitsBuilder {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n"
        }
    ]
}