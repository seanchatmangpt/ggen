{
    "sourceFile": "cli/tests/integration/testcontainers_readiness.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760253622187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760253622187,
            "name": "Commit-0",
            "content": "//! Production Readiness Validation with Testcontainers\n//!\n//! This module provides comprehensive production readiness validation using testcontainers\n//! to test against real services and validate production deployment scenarios.\n\nuse assert_cmd::prelude::*;\nuse assert_fs::prelude::*;\nuse predicates::prelude::*;\nuse std::process::Command;\nuse std::time::Duration;\nuse tempfile::TempDir;\nuse testcontainers::clients::Cli;\nuse testcontainers::core::WaitFor;\nuse testcontainers::images::generic::GenericImage;\nuse testcontainers::images::postgres::PostgresImage;\nuse testcontainers::images::redis::RedisImage;\nuse testcontainers::Container;\nuse testcontainers::RunnableImage;\nuse tokio::time::sleep;\n\n/// Testcontainers client for managing containers\npub struct TestEnvironment {\n    pub client: Cli,\n    pub temp_dir: TempDir,\n}\n\nimpl TestEnvironment {\n    pub fn new() -> Self {\n        Self {\n            client: Cli::default(),\n            temp_dir: TempDir::new().unwrap(),\n        }\n    }\n\n    pub fn temp_path(&self) -> &std::path::Path {\n        self.temp_dir.path()\n    }\n}\n\n/// PostgreSQL test container for database integration testing\npub struct PostgresTestContainer {\n    pub container: Container<'static, PostgresImage>,\n    pub connection_string: String,\n}\n\nimpl PostgresTestContainer {\n    pub fn new(client: &Cli) -> Self {\n        let image = PostgresImage::default()\n            .with_env_var(\"POSTGRES_DB\", \"ggen_test\")\n            .with_env_var(\"POSTGRES_USER\", \"ggen\")\n            .with_env_var(\"POSTGRES_PASSWORD\", \"ggen_password\");\n\n        let container = client.run(image);\n        let port = container.get_host_port_ipv4(5432);\n        let connection_string = format!(\"postgresql://ggen:ggen_password@localhost:{}\", port);\n\n        Self {\n            container,\n            connection_string,\n        }\n    }\n\n    pub async fn wait_for_ready(&self) {\n        // Wait for PostgreSQL to be ready\n        sleep(Duration::from_secs(5)).await;\n    }\n}\n\n/// Redis test container for caching and session storage testing\npub struct RedisTestContainer {\n    pub container: Container<'static, RedisImage>,\n    pub connection_string: String,\n}\n\nimpl RedisTestContainer {\n    pub fn new(client: &Cli) -> Self {\n        let image = RedisImage::default();\n        let container = client.run(image);\n        let port = container.get_host_port_ipv4(6379);\n        let connection_string = format!(\"redis://localhost:{}\", port);\n\n        Self {\n            container,\n            connection_string,\n        }\n    }\n\n    pub async fn wait_for_ready(&self) {\n        // Wait for Redis to be ready\n        sleep(Duration::from_secs(2)).await;\n    }\n}\n\n/// Mock API server container for testing external integrations\npub struct MockApiContainer {\n    pub container: Container<'static, GenericImage>,\n    pub base_url: String,\n}\n\nimpl MockApiContainer {\n    pub fn new(client: &Cli) -> Self {\n        // Use a simple HTTP server image for mocking API responses\n        let image = GenericImage::new(\"nginx\", \"alpine\")\n            .with_exposed_port(80)\n            .with_wait_for(WaitFor::message_on_stdout(\"start worker process\"));\n\n        let container = client.run(image);\n        let port = container.get_host_port_ipv4(80);\n        let base_url = format!(\"http://localhost:{}\", port);\n\n        Self {\n            container,\n            base_url,\n        }\n    }\n\n    pub async fn wait_for_ready(&self) {\n        // Wait for nginx to be ready\n        sleep(Duration::from_secs(3)).await;\n    }\n}\n\n/// Production readiness test suite using testcontainers\n#[tokio::test]\nasync fn test_production_readiness_database_integration() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    // Test database connectivity and schema validation\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Database connection validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_cache_integration() {\n    let env = TestEnvironment::new();\n    let redis = RedisTestContainer::new(&env.client);\n    redis.wait_for_ready().await;\n\n    // Test Redis connectivity and caching\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--config\",\n        &format!(\"cache_url={}\", redis.connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Cache connection validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_api_integration() {\n    let env = TestEnvironment::new();\n    let mock_api = MockApiContainer::new(&env.client);\n    mock_api.wait_for_ready().await;\n\n    // Test external API integration\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"ci\",\n        \"github\",\n        \"pages\",\n        \"status\",\n        \"--repo\",\n        \"test/repo\",\n        \"--api-base\",\n        &mock_api.base_url,\n    ]);\n\n    let assert = cmd.assert();\n    // Should handle API errors gracefully\n    assert.failure().stderr(predicate::str::contains(\"API integration validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_concurrent_operations() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    let redis = RedisTestContainer::new(&env.client);\n    \n    postgres.wait_for_ready().await;\n    redis.wait_for_ready().await;\n\n    // Test concurrent operations across multiple services\n    let mut handles = Vec::new();\n\n    // Spawn multiple concurrent operations\n    for i in 0..5 {\n        let postgres_url = postgres.connection_string.clone();\n        let redis_url = redis.connection_string.clone();\n        \n        let handle = tokio::spawn(async move {\n            let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n            cmd.args([\n                \"lifecycle\",\n                \"run\",\n                \"build\",\n                \"--config\",\n                &format!(\"database_url={}&cache_url={}\", postgres_url, redis_url),\n            ]);\n\n            let assert = cmd.assert();\n            assert.success()\n        });\n        \n        handles.push(handle);\n    }\n\n    // Wait for all operations to complete\n    for handle in handles {\n        handle.await.unwrap();\n    }\n}\n\n#[tokio::test]\nasync fn test_production_readiness_error_handling() {\n    let env = TestEnvironment::new();\n    \n    // Test with invalid database connection\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"init\",\n        \"--config\",\n        \"database_url=postgresql://invalid:invalid@localhost:9999/invalid\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.failure().stderr(predicate::str::contains(\"Connection failed\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_performance_validation() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    let start = std::time::Instant::now();\n\n    // Test performance under load\n    let mut handles = Vec::new();\n    for _ in 0..10 {\n        let postgres_url = postgres.connection_string.clone();\n        \n        let handle = tokio::spawn(async move {\n            let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n            cmd.args([\n                \"lifecycle\",\n                \"run\",\n                \"test\",\n                \"--config\",\n                &format!(\"database_url={}\", postgres_url),\n            ]);\n\n            let assert = cmd.assert();\n            assert.success()\n        });\n        \n        handles.push(handle);\n    }\n\n    // Wait for all operations to complete\n    for handle in handles {\n        handle.await.unwrap();\n    }\n\n    let duration = start.elapsed();\n    \n    // Performance assertion: all operations should complete within 30 seconds\n    assert!(duration.as_secs() < 30, \"Performance test failed: took {} seconds\", duration.as_secs());\n}\n\n#[tokio::test]\nasync fn test_production_readiness_security_validation() {\n    let env = TestEnvironment::new();\n    \n    // Test SQL injection protection\n    let malicious_input = \"'; DROP TABLE users; --\";\n    \n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"template\",\n        \"render\",\n        \"test.tmpl\",\n        \"--var\",\n        &format!(\"user_input={}\", malicious_input),\n    ]);\n\n    let assert = cmd.assert();\n    // Should sanitize input and not execute malicious SQL\n    assert.success().stdout(predicate::str::contains(\"Input sanitized\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_resource_cleanup() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    // Test resource cleanup after operations\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"cleanup\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Resources cleaned up\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_monitoring_integration() {\n    let env = TestEnvironment::new();\n    \n    // Test monitoring and observability features\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"monitor\",\n        \"--metrics\",\n        \"--tracing\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Monitoring enabled\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_health_checks() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    let redis = RedisTestContainer::new(&env.client);\n    \n    postgres.wait_for_ready().await;\n    redis.wait_for_ready().await;\n\n    // Test health check endpoints\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"health\",\n        \"--config\",\n        &format!(\"database_url={}&cache_url={}\", postgres.connection_string, redis.connection_string),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"All services healthy\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_backup_and_restore() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    // Test backup functionality\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"backup\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n        \"--output\",\n        env.temp_path().join(\"backup.sql\").to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Backup completed\"));\n\n    // Test restore functionality\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"restore\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n        \"--input\",\n        env.temp_path().join(\"backup.sql\").to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Restore completed\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_disaster_recovery() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    // Simulate disaster recovery scenario\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"disaster-recovery\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n        \"--scenario\",\n        \"database-failure\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Recovery completed\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_load_balancing() {\n    let env = TestEnvironment::new();\n    \n    // Test load balancing across multiple instances\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"load-test\",\n        \"--instances\",\n        \"3\",\n        \"--requests\",\n        \"100\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Load balancing validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_graceful_shutdown() {\n    let env = TestEnvironment::new();\n    \n    // Test graceful shutdown handling\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"graceful-shutdown\",\n        \"--timeout\",\n        \"10\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Graceful shutdown completed\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_configuration_validation() {\n    let env = TestEnvironment::new();\n    \n    // Test configuration validation\n    let config_file = env.temp_path().join(\"config.toml\");\n    std::fs::write(&config_file, r#\"\n[database]\nurl = \"postgresql://test:test@localhost:5432/test\"\nmax_connections = 10\n\n[cache]\nurl = \"redis://localhost:6379\"\nttl = 3600\n\n[monitoring]\nenabled = true\nmetrics_port = 9090\n\"#).unwrap();\n\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"validate-config\",\n        \"--config\",\n        config_file.to_str().unwrap(),\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Configuration valid\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_secrets_management() {\n    let env = TestEnvironment::new();\n    \n    // Test secrets management\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"secrets-test\",\n        \"--secret\",\n        \"api_key\",\n        \"--secret\",\n        \"database_password\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Secrets management validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_circuit_breaker() {\n    let env = TestEnvironment::new();\n    \n    // Test circuit breaker pattern\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"circuit-breaker-test\",\n        \"--failure-threshold\",\n        \"3\",\n        \"--timeout\",\n        \"5\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Circuit breaker validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_rate_limiting() {\n    let env = TestEnvironment::new();\n    \n    // Test rate limiting\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"rate-limit-test\",\n        \"--requests-per-second\",\n        \"10\",\n        \"--duration\",\n        \"5\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Rate limiting validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_data_consistency() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    postgres.wait_for_ready().await;\n\n    // Test data consistency across operations\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"consistency-test\",\n        \"--config\",\n        &format!(\"database_url={}\", postgres.connection_string),\n        \"--transactions\",\n        \"100\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Data consistency validated\"));\n}\n\n#[tokio::test]\nasync fn test_production_readiness_comprehensive_validation() {\n    let env = TestEnvironment::new();\n    let postgres = PostgresTestContainer::new(&env.client);\n    let redis = RedisTestContainer::new(&env.client);\n    let mock_api = MockApiContainer::new(&env.client);\n    \n    postgres.wait_for_ready().await;\n    redis.wait_for_ready().await;\n    mock_api.wait_for_ready().await;\n\n    // Comprehensive production readiness validation\n    let mut cmd = Command::cargo_bin(\"ggen\").unwrap();\n    cmd.args([\n        \"lifecycle\",\n        \"run\",\n        \"production-readiness\",\n        \"--config\",\n        &format!(\n            \"database_url={}&cache_url={}&api_base_url={}\",\n            postgres.connection_string,\n            redis.connection_string,\n            mock_api.base_url\n        ),\n        \"--validate-all\",\n    ]);\n\n    let assert = cmd.assert();\n    assert.success().stdout(predicate::str::contains(\"Production readiness validated\"));\n}"
        }
    ]
}