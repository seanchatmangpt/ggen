{
    "sourceFile": "cleanroom/tests/container_tests.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760266637918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760266637918,
            "name": "Commit-0",
            "content": "//! Container tests for cleanroom testing framework\n//!\n//! These tests verify container functionality following core team best practices:\n//! - Container lifecycle management\n//! - Container metrics and monitoring\n//! - Container error handling\n//! - Container resource management\n\nuse cleanroom::{\n    PostgresContainer, RedisContainer, GenericContainer,\n    ContainerWrapper, ContainerStatus, ContainerMetrics,\n};\nuse testcontainers::clients::Cli;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n/// Test PostgreSQL container creation\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_creation() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\");\n    assert!(postgres.is_ok());\n    \n    let postgres = postgres.unwrap();\n    assert_eq!(postgres.database_name, \"testdb\");\n    assert_eq!(postgres.username, \"testuser\");\n    assert_eq!(postgres.password, \"testpass\");\n}\n\n/// Test PostgreSQL container with custom configuration\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_custom_config() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"customdb\", \"customuser\", \"custompass\");\n    assert!(postgres.is_ok());\n    \n    let postgres = postgres.unwrap();\n    assert_eq!(postgres.database_name, \"customdb\");\n    assert_eq!(postgres.username, \"customuser\");\n    assert_eq!(postgres.password, \"custompass\");\n}\n\n/// Test PostgreSQL container readiness\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_readiness() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    let result = postgres.wait_for_ready().await;\n    assert!(result.is_ok());\n}\n\n/// Test PostgreSQL container connection test\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_connection_test() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    let result = postgres.test_connection().await;\n    assert!(result.is_ok());\n}\n\n/// Test PostgreSQL container SQL execution\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_sql_execution() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Test SQL execution\n    let result = postgres.execute_sql(\"SELECT 1;\").await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert!(output.contains(\"1\"));\n}\n\n/// Test PostgreSQL container database operations\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_database_operations() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Create test table\n    let result = postgres.create_test_table().await;\n    assert!(result.is_ok());\n    \n    // Insert test data\n    let result = postgres.insert_test_data(\"test_name\").await;\n    assert!(result.is_ok());\n    \n    let id = result.unwrap();\n    assert!(id > 0);\n    \n    // Get database size\n    let result = postgres.get_database_size().await;\n    assert!(result.is_ok());\n    \n    let size = result.unwrap();\n    assert!(!size.is_empty());\n    \n    // Get active connections\n    let result = postgres.get_active_connections().await;\n    assert!(result.is_ok());\n    \n    let connections = result.unwrap();\n    assert!(connections >= 0);\n}\n\n/// Test PostgreSQL container metrics\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_metrics() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Update metrics\n    let result = postgres.update_metrics().await;\n    assert!(result.is_ok());\n    \n    // Get metrics\n    let metrics = postgres.metrics();\n    assert!(metrics.uptime_seconds > 0);\n    assert!(metrics.memory_usage_bytes > 0);\n    assert!(metrics.cpu_usage_percent >= 0.0);\n}\n\n/// Test PostgreSQL container wrapper interface\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_postgres_container_wrapper() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    // Test wrapper interface\n    assert_eq!(postgres.name(), \"postgres\");\n    assert!(matches!(postgres.status(), ContainerStatus::Running));\n    \n    let metrics = postgres.metrics();\n    assert!(metrics.uptime_seconds >= 0);\n    \n    let cleanup_result = postgres.cleanup();\n    assert!(cleanup_result.is_ok());\n}\n\n/// Test Redis container creation\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_creation() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None);\n    assert!(redis.is_ok());\n    \n    let redis = redis.unwrap();\n    assert_eq!(redis.password(), None);\n}\n\n/// Test Redis container with password\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_with_password() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, Some(\"testpass\".to_string()));\n    assert!(redis.is_ok());\n    \n    let redis = redis.unwrap();\n    assert_eq!(redis.password(), Some(\"testpass\"));\n}\n\n/// Test Redis container readiness\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_readiness() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None).unwrap();\n    \n    let result = redis.wait_for_ready().await;\n    assert!(result.is_ok());\n}\n\n/// Test Redis container connection test\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_connection_test() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None).unwrap();\n    \n    redis.wait_for_ready().await.unwrap();\n    \n    let result = redis.test_connection().await;\n    assert!(result.is_ok());\n}\n\n/// Test Redis container operations\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_operations() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None).unwrap();\n    \n    redis.wait_for_ready().await.unwrap();\n    \n    // Test SET operation\n    let result = redis.set(\"test_key\", \"test_value\").await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert_eq!(output.trim(), \"OK\");\n    \n    // Test GET operation\n    let result = redis.get(\"test_key\").await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert_eq!(output.trim(), \"test_value\");\n    \n    // Test DEL operation\n    let result = redis.del(\"test_key\").await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert_eq!(output.trim(), \"1\");\n    \n    // Test INFO operation\n    let result = redis.info().await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert!(output.contains(\"redis_version\"));\n    \n    // Test DBSIZE operation\n    let result = redis.dbsize().await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert!(output.trim().parse::<i32>().unwrap() >= 0);\n}\n\n/// Test Redis container metrics\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_metrics() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None).unwrap();\n    \n    redis.wait_for_ready().await.unwrap();\n    \n    // Update metrics\n    let result = redis.update_metrics().await;\n    assert!(result.is_ok());\n    \n    // Get metrics\n    let metrics = redis.metrics();\n    assert!(metrics.uptime_seconds > 0);\n    assert!(metrics.memory_usage_bytes > 0);\n    assert!(metrics.cpu_usage_percent >= 0.0);\n}\n\n/// Test Redis container wrapper interface\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_redis_container_wrapper() {\n    let docker_client = Cli::default();\n    let redis = RedisContainer::new(&docker_client, None).unwrap();\n    \n    // Test wrapper interface\n    assert_eq!(redis.name(), \"redis\");\n    assert!(matches!(redis.status(), ContainerStatus::Running));\n    \n    let metrics = redis.metrics();\n    assert!(metrics.uptime_seconds >= 0);\n    \n    let cleanup_result = redis.cleanup();\n    assert!(cleanup_result.is_ok());\n}\n\n/// Test Generic container creation\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_generic_container_creation() {\n    let docker_client = Cli::default();\n    let container = GenericContainer::new(&docker_client, \"test\", \"alpine\", \"latest\");\n    assert!(container.is_ok());\n    \n    let container = container.unwrap();\n    assert_eq!(container.name, \"test\");\n}\n\n/// Test Generic container readiness\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_generic_container_readiness() {\n    let docker_client = Cli::default();\n    let container = GenericContainer::new(&docker_client, \"test\", \"alpine\", \"latest\").unwrap();\n    \n    let result = container.wait_for_ready().await;\n    assert!(result.is_ok());\n}\n\n/// Test Generic container command execution\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_generic_container_command_execution() {\n    let docker_client = Cli::default();\n    let container = GenericContainer::new(&docker_client, \"test\", \"alpine\", \"latest\").unwrap();\n    \n    container.wait_for_ready().await.unwrap();\n    \n    // Test command execution\n    let result = container.execute_command(vec![\"echo\".to_string(), \"hello\".to_string()]).await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert!(output.contains(\"hello\"));\n}\n\n/// Test Generic container metrics\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_generic_container_metrics() {\n    let docker_client = Cli::default();\n    let container = GenericContainer::new(&docker_client, \"test\", \"alpine\", \"latest\").unwrap();\n    \n    container.wait_for_ready().await.unwrap();\n    \n    // Update metrics\n    let result = container.update_metrics().await;\n    assert!(result.is_ok());\n    \n    // Get metrics\n    let metrics = container.metrics();\n    assert!(metrics.uptime_seconds > 0);\n    assert!(metrics.memory_usage_bytes > 0);\n    assert!(metrics.cpu_usage_percent >= 0.0);\n}\n\n/// Test Generic container wrapper interface\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_generic_container_wrapper() {\n    let docker_client = Cli::default();\n    let container = GenericContainer::new(&docker_client, \"test\", \"alpine\", \"latest\").unwrap();\n    \n    // Test wrapper interface\n    assert_eq!(container.name(), \"test\");\n    assert!(matches!(container.status(), ContainerStatus::Running));\n    \n    let metrics = container.metrics();\n    assert!(metrics.uptime_seconds >= 0);\n    \n    let cleanup_result = container.cleanup();\n    assert!(cleanup_result.is_ok());\n}\n\n/// Test container error handling\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_error_handling() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    // Test SQL execution with invalid SQL\n    let result = postgres.execute_sql(\"INVALID SQL;\").await;\n    assert!(result.is_err());\n}\n\n/// Test container resource management\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_resource_management() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Test resource usage\n    let metrics = postgres.metrics();\n    assert!(metrics.memory_usage_bytes > 0);\n    assert!(metrics.cpu_usage_percent >= 0.0);\n    assert!(metrics.disk_usage_bytes >= 0);\n}\n\n/// Test container lifecycle management\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_lifecycle_management() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    // Test container startup\n    let result = postgres.wait_for_ready().await;\n    assert!(result.is_ok());\n    \n    // Test container operations\n    let result = postgres.test_connection().await;\n    assert!(result.is_ok());\n    \n    // Test container cleanup\n    let result = postgres.cleanup();\n    assert!(result.is_ok());\n}\n\n/// Test container performance monitoring\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_performance_monitoring() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Perform some operations\n    for i in 0..10 {\n        let _result = postgres.execute_sql(&format!(\"SELECT {};\", i)).await;\n    }\n    \n    // Update metrics\n    let result = postgres.update_metrics().await;\n    assert!(result.is_ok());\n    \n    // Check metrics\n    let metrics = postgres.metrics();\n    assert!(metrics.uptime_seconds > 0);\n    assert!(metrics.memory_usage_bytes > 0);\n}\n\n/// Test container concurrent access\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_concurrent_access() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Test concurrent operations\n    let mut handles = Vec::new();\n    for i in 0..5 {\n        let postgres_clone = &postgres;\n        let handle = tokio::spawn(async move {\n            postgres_clone.execute_sql(&format!(\"SELECT {};\", i)).await\n        });\n        handles.push(handle);\n    }\n    \n    // Wait for all operations to complete\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n}\n\n/// Test container state persistence\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_state_persistence() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Create a table\n    let result = postgres.create_test_table().await;\n    assert!(result.is_ok());\n    \n    // Insert some data\n    let result = postgres.insert_test_data(\"persistence_test\").await;\n    assert!(result.is_ok());\n    \n    // Verify data persistence\n    let result = postgres.execute_sql(\"SELECT COUNT(*) FROM test_table;\").await;\n    assert!(result.is_ok());\n    \n    let output = result.unwrap();\n    assert!(output.contains(\"1\"));\n}\n\n/// Test container health monitoring\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_health_monitoring() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Test health check\n    let result = postgres.test_connection().await;\n    assert!(result.is_ok());\n    \n    // Test metrics collection\n    let result = postgres.update_metrics().await;\n    assert!(result.is_ok());\n    \n    let metrics = postgres.metrics();\n    assert!(metrics.uptime_seconds > 0);\n    assert!(metrics.memory_usage_bytes > 0);\n}\n\n/// Test container configuration validation\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_configuration_validation() {\n    let docker_client = Cli::default();\n    \n    // Test valid configuration\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\");\n    assert!(postgres.is_ok());\n    \n    // Test invalid configuration (empty database name)\n    let postgres = PostgresContainer::new(&docker_client, \"\", \"testuser\", \"testpass\");\n    assert!(postgres.is_ok()); // Should still work, just with empty name\n    \n    // Test invalid configuration (empty username)\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"\", \"testpass\");\n    assert!(postgres.is_ok()); // Should still work, just with empty username\n}\n\n/// Test container error recovery\n#[tokio::test]\n#[ignore] // Requires Docker\nasync fn test_container_error_recovery() {\n    let docker_client = Cli::default();\n    let postgres = PostgresContainer::new(&docker_client, \"testdb\", \"testuser\", \"testpass\").unwrap();\n    \n    postgres.wait_for_ready().await.unwrap();\n    \n    // Test error recovery\n    let result1 = postgres.execute_sql(\"INVALID SQL;\").await;\n    assert!(result1.is_err());\n    \n    // Test recovery after error\n    let result2 = postgres.execute_sql(\"SELECT 1;\").await;\n    assert!(result2.is_ok());\n    \n    let output = result2.unwrap();\n    assert!(output.contains(\"1\"));\n}\n"
        }
    ]
}