{
    "sourceFile": "cleanroom/tests/bdd/steps/policy_steps.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760261427411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760261427411,
            "name": "Commit-0",
            "content": "use super::super::world::CleanroomWorld;\nuse cucumber::{given, then, when};\nuse std::fs;\n\n/// Policy step definitions for Cleanroom BDD tests\n///\n/// These steps handle policy configuration, constraints, and validation\n/// for security, isolation, and resource management.\n\n// ============================================================================\n// GIVEN steps - Setup preconditions\n// ============================================================================\n\n#[given(regex = r\"^I have a security policy with:$\")]\nfn security_policy(world: &mut CleanroomWorld, policy_config: String) {\n    // Parse policy configuration\n    for line in policy_config.lines() {\n        let line = line.trim();\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n        \n        if let Some((key, value)) = line.split_once(':') {\n            let key = key.trim().to_string();\n            let value = value.trim().to_string();\n            \n            match key.as_str() {\n                \"network\" => {\n                    world.add_network_constraint(value);\n                }\n                \"filesystem\" => {\n                    world.add_filesystem_constraint(value);\n                }\n                \"memory_limit\" | \"cpu_limit\" | \"timeout\" => {\n                    world.set_policy(key, value);\n                }\n                _ => {\n                    world.set_policy(key, value);\n                }\n            }\n        }\n    }\n}\n\n#[given(regex = r\"^I have network isolation enabled$\")]\nfn network_isolation_enabled(world: &mut CleanroomWorld) {\n    world.add_network_constraint(\"isolated\".to_string());\n}\n\n#[given(regex = r\"^I have filesystem isolation enabled$\")]\nfn filesystem_isolation_enabled(world: &mut CleanroomWorld) {\n    world.add_filesystem_constraint(\"isolated\".to_string());\n}\n\n#[given(regex = r\"^I have resource limits configured$\")]\nfn resource_limits_configured(world: &mut CleanroomWorld) {\n    world.set_policy(\"memory_limit\".to_string(), \"512MB\".to_string());\n    world.set_policy(\"cpu_limit\".to_string(), \"1.0\".to_string());\n    world.set_policy(\"timeout\".to_string(), \"30s\".to_string());\n}\n\n#[given(regex = r\"^I have a policy file \"([^\"]+)\" with:$\")]\nfn policy_file(world: &mut CleanroomWorld, filename: String, content: String) {\n    let file_path = world.project_dir.join(&filename);\n    \n    // Create parent directories if needed\n    if let Some(parent) = file_path.parent() {\n        fs::create_dir_all(parent).expect(\"Failed to create parent directories\");\n    }\n    \n    fs::write(&file_path, content.trim())\n        .unwrap_or_else(|e| panic!(\"Failed to write policy file {}: {}\", filename, e));\n    \n    // Capture the policy file\n    world.capture_file(&filename, content.trim().to_string());\n}\n\n#[given(regex = r\"^I have allowed network ports: \"([^\"]+)\"$\")]\nfn allowed_network_ports(world: &mut CleanroomWorld, ports: String) {\n    world.set_policy(\"allowed_ports\".to_string(), ports);\n}\n\n#[given(regex = r\"^I have blocked network access$\")]\nfn blocked_network_access(world: &mut CleanroomWorld) {\n    world.add_network_constraint(\"blocked\".to_string());\n}\n\n#[given(regex = r\"^I have read-only filesystem access$\")]\nfn readonly_filesystem_access(world: &mut CleanroomWorld) {\n    world.add_filesystem_constraint(\"readonly\".to_string());\n}\n\n#[given(regex = r\"^I have writable filesystem access$\")]\nfn writable_filesystem_access(world: &mut CleanroomWorld) {\n    world.add_filesystem_constraint(\"writable\".to_string());\n}\n\n// ============================================================================\n// WHEN steps - Execute actions\n// ============================================================================\n\n#[when(regex = r\"^I apply the policy \"([^\"]+)\"$\")]\nfn apply_policy(world: &mut CleanroomWorld, policy_name: String) {\n    // Load and apply policy from file\n    let policy_file = world.project_dir.join(&policy_name);\n    \n    if !policy_file.exists() {\n        panic!(\"Policy file '{}' does not exist\", policy_name);\n    }\n    \n    let content = fs::read_to_string(&policy_file)\n        .unwrap_or_else(|e| panic!(\"Failed to read policy file '{}': {}\", policy_name, e));\n    \n    // Parse and apply policy\n    for line in content.lines() {\n        let line = line.trim();\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n        \n        if let Some((key, value)) = line.split_once('=') {\n            world.set_policy(key.trim().to_string(), value.trim().to_string());\n        }\n    }\n}\n\n#[when(regex = r\"^I set the memory limit to \"([^\"]+)\"$\")]\nfn set_memory_limit(world: &mut CleanroomWorld, limit: String) {\n    world.set_policy(\"memory_limit\".to_string(), limit);\n}\n\n#[when(regex = r\"^I set the CPU limit to \"([^\"]+)\"$\")]\nfn set_cpu_limit(world: &mut CleanroomWorld, limit: String) {\n    world.set_policy(\"cpu_limit\".to_string(), limit);\n}\n\n#[when(regex = r\"^I set the timeout to \"([^\"]+)\"$\")]\nfn set_timeout(world: &mut CleanroomWorld, timeout: String) {\n    world.set_policy(\"timeout\".to_string(), timeout);\n}\n\n#[when(regex = r\"^I enable network isolation$\")]\nfn enable_network_isolation(world: &mut CleanroomWorld) {\n    world.add_network_constraint(\"isolated\".to_string());\n}\n\n#[when(regex = r\"^I disable network isolation$\")]\nfn disable_network_isolation(world: &mut CleanroomWorld) {\n    // Remove network isolation constraint\n    world.network_constraints.retain(|c| c != \"isolated\");\n}\n\n#[when(regex = r\"^I enable filesystem isolation$\")]\nfn enable_filesystem_isolation(world: &mut CleanroomWorld) {\n    world.add_filesystem_constraint(\"isolated\".to_string());\n}\n\n#[when(regex = r\"^I disable filesystem isolation$\")]\nfn disable_filesystem_isolation(world: &mut CleanroomWorld) {\n    // Remove filesystem isolation constraint\n    world.filesystem_constraints.retain(|c| c != \"isolated\");\n}\n\n// ============================================================================\n// THEN steps - Verify outcomes\n// ============================================================================\n\n#[then(regex = r\"^the policy should be active$\")]\nfn policy_should_be_active(world: &mut CleanroomWorld) {\n    // Verify that policy settings are applied\n    assert!(\n        !world.policy_settings.is_empty() || \n        !world.network_constraints.is_empty() || \n        !world.filesystem_constraints.is_empty(),\n        \"No policy settings are active\"\n    );\n}\n\n#[then(regex = r\"^the network should be isolated$\")]\nfn network_should_be_isolated(world: &mut CleanroomWorld) {\n    assert!(\n        world.network_constraints.contains(&\"isolated\".to_string()),\n        \"Network isolation should be enabled\"\n    );\n}\n\n#[then(regex = r\"^the filesystem should be isolated$\")]\nfn filesystem_should_be_isolated(world: &mut CleanroomWorld) {\n    assert!(\n        world.filesystem_constraints.contains(&\"isolated\".to_string()),\n        \"Filesystem isolation should be enabled\"\n    );\n}\n\n#[then(regex = r\"^the memory limit should be \"([^\"]+)\"$\")]\nfn memory_limit_should_be(world: &mut CleanroomWorld, expected_limit: String) {\n    let actual_limit = world.policy_settings.get(\"memory_limit\")\n        .expect(\"Memory limit should be set\");\n    \n    assert_eq!(\n        actual_limit, &expected_limit,\n        \"Expected memory limit '{}', but got '{}'\",\n        expected_limit, actual_limit\n    );\n}\n\n#[then(regex = r\"^the CPU limit should be \"([^\"]+)\"$\")]\nfn cpu_limit_should_be(world: &mut CleanroomWorld, expected_limit: String) {\n    let actual_limit = world.policy_settings.get(\"cpu_limit\")\n        .expect(\"CPU limit should be set\");\n    \n    assert_eq!(\n        actual_limit, &expected_limit,\n        \"Expected CPU limit '{}', but got '{}'\",\n        expected_limit, actual_limit\n    );\n}\n\n#[then(regex = r\"^the timeout should be \"([^\"]+)\"$\")]\nfn timeout_should_be(world: &mut CleanroomWorld, expected_timeout: String) {\n    let actual_timeout = world.policy_settings.get(\"timeout\")\n        .expect(\"Timeout should be set\");\n    \n    assert_eq!(\n        actual_timeout, &expected_timeout,\n        \"Expected timeout '{}', but got '{}'\",\n        expected_timeout, actual_timeout\n    );\n}\n\n#[then(regex = r\"^the network access should be blocked$\")]\nfn network_access_should_be_blocked(world: &mut CleanroomWorld) {\n    assert!(\n        world.network_constraints.contains(&\"blocked\".to_string()),\n        \"Network access should be blocked\"\n    );\n}\n\n#[then(regex = r\"^the filesystem should be read-only$\")]\nfn filesystem_should_be_readonly(world: &mut CleanroomWorld) {\n    assert!(\n        world.filesystem_constraints.contains(&\"readonly\".to_string()),\n        \"Filesystem should be read-only\"\n    );\n}\n\n#[then(regex = r\"^the filesystem should be writable$\")]\nfn filesystem_should_be_writable(world: &mut CleanroomWorld) {\n    assert!(\n        world.filesystem_constraints.contains(&\"writable\".to_string()),\n        \"Filesystem should be writable\"\n    );\n}\n\n#[then(regex = r\"^the allowed ports should be \"([^\"]+)\"$\")]\nfn allowed_ports_should_be(world: &mut CleanroomWorld, expected_ports: String) {\n    let actual_ports = world.policy_settings.get(\"allowed_ports\")\n        .expect(\"Allowed ports should be set\");\n    \n    assert_eq!(\n        actual_ports, &expected_ports,\n        \"Expected allowed ports '{}', but got '{}'\",\n        expected_ports, actual_ports\n    );\n}\n\n#[then(regex = r\"^the policy should be validated$\")]\nfn policy_should_be_validated(world: &mut CleanroomWorld) {\n    // Check that policy settings are consistent\n    let has_network_constraints = !world.network_constraints.is_empty();\n    let has_filesystem_constraints = !world.filesystem_constraints.is_empty();\n    let has_resource_limits = world.policy_settings.contains_key(\"memory_limit\") ||\n                             world.policy_settings.contains_key(\"cpu_limit\") ||\n                             world.policy_settings.contains_key(\"timeout\");\n    \n    // At least one type of constraint should be active\n    assert!(\n        has_network_constraints || has_filesystem_constraints || has_resource_limits,\n        \"Policy should have at least one constraint active\"\n    );\n}\n\n#[then(regex = r\"^the policy should be enforced$\")]\nfn policy_should_be_enforced(world: &mut CleanroomWorld) {\n    // Verify that policy enforcement is active\n    // This would typically involve checking that the policy is actually\n    // being applied to the execution environment\n    \n    // For now, just verify that policy settings exist\n    assert!(\n        !world.policy_settings.is_empty() || \n        !world.network_constraints.is_empty() || \n        !world.filesystem_constraints.is_empty(),\n        \"Policy should be enforced but no constraints are active\"\n    );\n}\n"
        }
    ]
}