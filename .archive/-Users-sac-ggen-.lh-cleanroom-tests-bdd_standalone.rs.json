{
    "sourceFile": "cleanroom/tests/bdd_standalone.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760262264967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760262264967,
            "name": "Commit-0",
            "content": "use cucumber::{given, then, when, World};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::process::Output;\nuse tempfile::TempDir;\n\n/// Standalone world state for BDD tests\n#[derive(Debug, Default, cucumber::World)]\npub struct StandaloneWorld {\n    pub temp_dir: Option<TempDir>,\n    pub project_dir: PathBuf,\n    pub last_output: Option<Output>,\n    pub last_exit_code: Option<i32>,\n    pub captured_files: HashMap<String, String>,\n    pub environment: HashMap<String, String>,\n    pub backend: Option<String>,\n    pub config: HashMap<String, String>,\n}\n\nimpl StandaloneWorld {\n    pub fn new() -> Self {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let project_dir = temp_dir.path().to_path_buf();\n\n        Self {\n            temp_dir: Some(temp_dir),\n            project_dir,\n            ..Default::default()\n        }\n    }\n}\n\n// Step definitions for basic functionality\n#[given(\"a cleanroom project\")]\nfn given_cleanroom_project(world: &mut StandaloneWorld) {\n    // Create a basic project structure\n    std::fs::create_dir_all(&world.project_dir).expect(\"Failed to create project dir\");\n    world.environment.insert(\"CLEANROOM_PROJECT\".to_string(), world.project_dir.to_string_lossy().to_string());\n}\n\n#[given(\"backend {string} is available\")]\nfn given_backend_available(world: &mut StandaloneWorld, backend: String) {\n    world.backend = Some(backend);\n}\n\n#[given(\"cleanroom is configured with defaults\")]\nfn given_default_config(world: &mut StandaloneWorld) {\n    world.config.insert(\"timeout\".to_string(), \"30\".to_string());\n    world.config.insert(\"backend\".to_string(), \"local\".to_string());\n}\n\n#[when(\"I run the binary with args {string}\")]\nfn when_run_binary(world: &mut StandaloneWorld, args: String) {\n    // Simulate running a binary\n    let args_vec: Vec<&str> = args.split_whitespace().collect();\n    \n    // For testing purposes, simulate a successful run\n    world.last_exit_code = Some(0);\n    \n    // Create mock output\n    let output = Output {\n        status: std::process::ExitStatus::from_raw(0),\n        stdout: b\"Mock output: binary executed successfully\\n\".to_vec(),\n        stderr: Vec::new(),\n    };\n    \n    world.last_output = Some(output);\n}\n\n#[then(\"the exit code is {int}\")]\nfn then_exit_code(world: &mut StandaloneWorld, expected_code: i32) {\n    assert_eq!(world.last_exit_code, Some(expected_code));\n}\n\n#[then(\"stdout contains {string}\")]\nfn then_stdout_contains(world: &mut StandaloneWorld, expected_text: String) {\n    if let Some(output) = &world.last_output {\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        assert!(stdout.contains(&expected_text), \"Expected stdout to contain '{}', but got: {}\", expected_text, stdout);\n    } else {\n        panic!(\"No output available to check\");\n    }\n}\n\n#[then(\"stderr is empty\")]\nfn then_stderr_empty(world: &mut StandaloneWorld) {\n    if let Some(output) = &world.last_output {\n        assert!(output.stderr.is_empty(), \"Expected stderr to be empty, but got: {}\", String::from_utf8_lossy(&output.stderr));\n    }\n}\n\n#[then(\"execution is hermetic\")]\nfn then_execution_hermetic(world: &mut StandaloneWorld) {\n    // Verify that execution was isolated\n    assert!(world.project_dir.exists(), \"Project directory should exist\");\n    // In a real implementation, this would check for isolation\n}\n\n#[then(\"mounts are deterministic\")]\nfn then_mounts_deterministic(world: &mut StandaloneWorld) {\n    // Verify that mounts are deterministic\n    // In a real implementation, this would check mount consistency\n}\n\n#[then(\"clock is normalized\")]\nfn then_clock_normalized(world: &mut StandaloneWorld) {\n    // Verify that clock is normalized\n    // In a real implementation, this would check time consistency\n}\n\n// Test runner\n#[tokio::test]\nasync fn test_standalone_bdd() {\n    StandaloneWorld::cucumber()\n        .features(&[\"tests/bdd/features/00_basic.feature\"])\n        .run_and_exit()\n        .await;\n}\n\n#[tokio::test]\nasync fn test_all_standalone_features() {\n    StandaloneWorld::cucumber()\n        .features(&[\n            \"tests/bdd/features/00_basic.feature\",\n        ])\n        .run_and_exit()\n        .await;\n}\n"
        }
    ]
}