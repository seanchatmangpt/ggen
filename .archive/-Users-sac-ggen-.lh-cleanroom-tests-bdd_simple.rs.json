{
    "sourceFile": "cleanroom/tests/bdd_simple.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760262033858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760262033858,
            "name": "Commit-0",
            "content": "use cucumber::{given, then, when, World};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::process::Output;\nuse tempfile::TempDir;\n\n/// Simple world state for BDD tests\n#[derive(Debug, Default, cucumber::World)]\npub struct SimpleWorld {\n    pub temp_dir: Option<TempDir>,\n    pub project_dir: PathBuf,\n    pub last_output: Option<Output>,\n    pub last_exit_code: Option<i32>,\n    pub captured_files: HashMap<String, String>,\n    pub environment: HashMap<String, String>,\n}\n\nimpl SimpleWorld {\n    pub fn new() -> Self {\n        let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n        let project_dir = temp_dir.path().to_path_buf();\n\n        Self {\n            temp_dir: Some(temp_dir),\n            project_dir,\n            ..Default::default()\n        }\n    }\n}\n\n// Step definitions\n#[given(\"a cleanroom project\")]\nfn given_cleanroom_project(world: &mut SimpleWorld) {\n    // Create a basic project structure\n    std::fs::create_dir_all(&world.project_dir).expect(\"Failed to create project dir\");\n    \n    // Create a simple config file\n    let config_content = r#\"\n[cleanroom]\nbackend = \"local\"\ntimeout_ms = 5000\n\"#;\n    std::fs::write(world.project_dir.join(\"cleanroom.toml\"), config_content)\n        .expect(\"Failed to write config\");\n}\n\n#[when(\"I run cleanroom with args {string}\")]\nfn when_run_cleanroom(world: &mut SimpleWorld, args: String) {\n    use assert_cmd::Command;\n    \n    // Parse arguments\n    let arg_list: Vec<&str> = args.split_whitespace().collect();\n    \n    // Create command\n    let mut cmd = Command::new(\"cargo\");\n    cmd.args(&[\"run\", \"--bin\", \"cleanroom\", \"--\"]);\n    cmd.args(&arg_list);\n    cmd.current_dir(&world.project_dir);\n    \n    // Execute and capture output\n    let output = cmd.output().expect(\"Failed to execute command\");\n    world.last_output = Some(output);\n    world.last_exit_code = Some(world.last_output.as_ref().unwrap().status.code().unwrap_or(-1));\n}\n\n#[then(\"the exit code is {int}\")]\nfn then_exit_code(world: &mut SimpleWorld, expected_code: i32) {\n    let actual_code = world.last_exit_code.unwrap_or(-1);\n    assert_eq!(actual_code, expected_code, \"Expected exit code {}, got {}\", expected_code, actual_code);\n}\n\n#[then(\"stdout contains {string}\")]\nfn then_stdout_contains(world: &mut SimpleWorld, expected_text: String) {\n    let output = world.last_output.as_ref().expect(\"No output captured\");\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    assert!(stdout.contains(&expected_text), \"Expected stdout to contain '{}', got: {}\", expected_text, stdout);\n}\n\n#[then(\"stderr is empty\")]\nfn then_stderr_empty(world: &mut SimpleWorld) {\n    let output = world.last_output.as_ref().expect(\"No output captured\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(stderr.is_empty(), \"Expected stderr to be empty, got: {}\", stderr);\n}\n\n#[tokio::test]\nasync fn test_basic_cleanroom_features() {\n    SimpleWorld::cucumber()\n        .features(&[\"tests/bdd/features/01_unified_execution.feature\"])\n        .run_and_exit()\n        .await;\n}\n\n#[tokio::test]\nasync fn test_all_bdd_features() {\n    SimpleWorld::cucumber()\n        .features(&[\n            \"tests/bdd/features/01_unified_execution.feature\",\n            \"tests/bdd/features/02_backend_autodetect.feature\",\n            \"tests/bdd/features/03_config_precedence.feature\",\n        ])\n        .run_and_exit()\n        .await;\n}\n"
        }
    ]
}