{
    "sourceFile": "cleanroom/tests/unit_tests.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760268144240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760268144240,
            "name": "Commit-0",
            "content": "//! Unit tests for cleanroom testing framework modules\n//!\n//! These tests verify individual module functionality in isolation.\n\nuse cleanroom::{\n    CleanroomConfig, Policy, SecurityLevel, NetworkPolicy,\n    ResourceLimits, DeterministicManager, CoverageTracker,\n    SnapshotManager, TracingManager, TestReport,\n    PostgresContainer, RedisContainer, GenericContainer,\n    ContainerWrapper, ServiceContainer,\n    CleanroomError, ErrorKind,\n};\nuse std::time::Duration;\nuse uuid::Uuid;\n\n/// Test CleanroomConfig functionality\n#[test]\nfn test_cleanroom_config() {\n    // Test default configuration\n    let config = CleanroomConfig::default();\n    assert!(config.enable_singleton_containers);\n    assert_eq!(config.container_startup_timeout, Duration::from_secs(30));\n    assert_eq!(config.test_execution_timeout, Duration::from_secs(300));\n    assert!(config.enable_deterministic_execution);\n    assert!(config.enable_coverage_tracking);\n    assert!(config.enable_snapshot_testing);\n    assert!(config.enable_tracing);\n    \n    // Test configuration validation\n    assert!(config.validate().is_ok());\n    \n    // Test invalid configuration\n    let mut invalid_config = CleanroomConfig::default();\n    invalid_config.max_concurrent_containers = 0;\n    assert!(invalid_config.validate().is_err());\n}\n\n/// Test Policy functionality\n#[test]\nfn test_policy() {\n    // Test default policy\n    let policy = Policy::default();\n    assert_eq!(policy.security_level, SecurityLevel::Standard);\n    assert!(policy.allows_network());\n    \n    // Test locked policy\n    let locked_policy = Policy::locked();\n    assert_eq!(locked_policy.security_level, SecurityLevel::Locked);\n    assert!(!locked_policy.allows_network());\n    \n    // Test custom policy\n    let custom_policy = Policy::with_security_level(SecurityLevel::Strict)\n        .with_network_isolation(false);\n    assert_eq!(custom_policy.security_level, SecurityLevel::Strict);\n    assert!(custom_policy.allows_network());\n    \n    // Test policy summary\n    let summary = custom_policy.summary();\n    assert!(summary.contains(\"Policy Summary\"));\n    assert!(summary.contains(\"Security Level\"));\n}\n\n/// Test ResourceLimits functionality\n#[test]\nfn test_resource_limits() {\n    // Test default limits\n    let limits = ResourceLimits::new();\n    assert_eq!(limits.max_memory_mb, 1024);\n    assert_eq!(limits.max_cpu_percent, 100.0);\n    assert_eq!(limits.max_disk_mb, 2048);\n    \n    // Test custom limits\n    let custom_limits = ResourceLimits::new()\n        .with_max_memory_mb(512)\n        .with_max_cpu_percent(50.0)\n        .with_max_disk_mb(1024);\n    \n    assert_eq!(custom_limits.max_memory_mb, 512);\n    assert_eq!(custom_limits.max_cpu_percent, 50.0);\n    assert_eq!(custom_limits.max_disk_mb, 1024);\n    \n    // Test limit validation\n    assert!(custom_limits.validate().is_ok());\n    \n    // Test invalid limits\n    let invalid_limits = ResourceLimits::new()\n        .with_max_memory_mb(0)\n        .with_max_cpu_percent(-10.0);\n    \n    assert!(invalid_limits.validate().is_err());\n}\n\n/// Test DeterministicManager functionality\n#[test]\nfn test_deterministic_manager() {\n    let manager = DeterministicManager::new();\n    \n    // Test seed setting\n    let seed = 12345u64;\n    manager.set_seed(seed);\n    assert_eq!(manager.get_current_seed(), seed);\n    \n    // Test deterministic generation\n    let value1 = manager.generate_deterministic_value(\"test_key\");\n    let value2 = manager.generate_deterministic_value(\"test_key\");\n    assert_eq!(value1, value2);\n    \n    // Test different keys produce different values\n    let value3 = manager.generate_deterministic_value(\"different_key\");\n    assert_ne!(value1, value3);\n}\n\n/// Test CoverageTracker functionality\n#[test]\nfn test_coverage_tracker() {\n    let tracker = CoverageTracker::new();\n    \n    // Test initial state\n    let report = tracker.get_report();\n    assert_eq!(report.total_tests, 0);\n    assert_eq!(report.covered_lines, 0);\n    assert_eq!(report.coverage_percentage, 0.0);\n    \n    // Test test execution tracking\n    tracker.start_test(\"test1\");\n    tracker.record_line_execution(\"test1\", 10);\n    tracker.record_line_execution(\"test1\", 20);\n    tracker.end_test(\"test1\", true);\n    \n    let report = tracker.get_report();\n    assert_eq!(report.total_tests, 1);\n    assert_eq!(report.passed_tests, 1);\n    assert_eq!(report.failed_tests, 0);\n    assert_eq!(report.covered_lines, 2);\n}\n\n/// Test SnapshotManager functionality\n#[test]\nfn test_snapshot_manager() {\n    let manager = SnapshotManager::new();\n    \n    // Test snapshot creation\n    let test_data = serde_json::json!({\n        \"key\": \"value\",\n        \"number\": 42\n    });\n    \n    let snapshot_id = manager.create_snapshot(\"test_snapshot\", &test_data);\n    assert!(!snapshot_id.is_nil());\n    \n    // Test snapshot verification\n    let is_valid = manager.verify_snapshot(\"test_snapshot\", &test_data);\n    assert!(is_valid);\n    \n    // Test snapshot retrieval\n    let retrieved_snapshot = manager.get_snapshot(\"test_snapshot\");\n    assert!(retrieved_snapshot.is_some());\n    \n    // Test invalid snapshot\n    let invalid_data = serde_json::json!({\n        \"key\": \"different_value\"\n    });\n    \n    let is_invalid = manager.verify_snapshot(\"test_snapshot\", &invalid_data);\n    assert!(!is_invalid);\n}\n\n/// Test TracingManager functionality\n#[test]\nfn test_tracing_manager() {\n    let manager = TracingManager::new();\n    \n    // Test trace creation\n    let trace_id = manager.start_trace(\"test_trace\");\n    assert!(!trace_id.is_nil());\n    \n    // Test trace logging\n    manager.log_trace_event(&trace_id, \"test_event\", \"test_data\");\n    \n    // Test trace completion\n    manager.end_trace(&trace_id);\n    \n    // Test trace retrieval\n    let traces = manager.get_traces();\n    assert!(!traces.is_empty());\n    \n    // Test trace filtering\n    let filtered_traces = manager.get_traces_by_name(\"test_trace\");\n    assert!(!filtered_traces.is_empty());\n}\n\n/// Test TestReport functionality\n#[test]\nfn test_test_report() {\n    let report = TestReport::new();\n    \n    // Test initial state\n    assert!(!report.session_id.is_nil());\n    assert_eq!(report.test_summary.total_tests, 0);\n    assert_eq!(report.test_summary.passed_tests, 0);\n    assert_eq!(report.test_summary.failed_tests, 0);\n    \n    // Test test execution tracking\n    report.record_test_execution(\"test1\", true, Duration::from_millis(100));\n    report.record_test_execution(\"test2\", false, Duration::from_millis(200));\n    \n    assert_eq!(report.test_summary.total_tests, 2);\n    assert_eq!(report.test_summary.passed_tests, 1);\n    assert_eq!(report.test_summary.failed_tests, 1);\n    \n    // Test report serialization\n    let json_report = report.to_json().unwrap();\n    assert!(json_report.contains(\"session_id\"));\n    assert!(json_report.contains(\"test_summary\"));\n}\n\n/// Test PostgresContainer functionality\n#[test]\nfn test_postgres_container() {\n    let container = PostgresContainer::new(\"postgres:15\");\n    \n    // Test basic properties\n    assert_eq!(container.image(), \"postgres:15\");\n    assert_eq!(container.container_type(), \"postgres\");\n    \n    // Test environment variables\n    let container_with_env = container\n        .with_env(\"POSTGRES_PASSWORD\", \"test\")\n        .with_env(\"POSTGRES_DB\", \"testdb\");\n    \n    // Test port configuration\n    let container_with_port = container_with_env.with_port(5432);\n    assert_eq!(container_with_port.port(), Some(5432));\n    \n    // Test connection string generation\n    let connection_string = container_with_port.connection_string();\n    assert!(connection_string.contains(\"postgresql://\"));\n    assert!(connection_string.contains(\"testdb\"));\n}\n\n/// Test RedisContainer functionality\n#[test]\nfn test_redis_container() {\n    let container = RedisContainer::new(\"redis:7\");\n    \n    // Test basic properties\n    assert_eq!(container.image(), \"redis:7\");\n    assert_eq!(container.container_type(), \"redis\");\n    \n    // Test port configuration\n    let container_with_port = container.with_port(6379);\n    assert_eq!(container_with_port.port(), Some(6379));\n    \n    // Test Redis URL generation\n    let redis_url = container_with_port.redis_url();\n    assert!(redis_url.starts_with(\"redis://\"));\n}\n\n/// Test GenericContainer functionality\n#[test]\nfn test_generic_container() {\n    let container = GenericContainer::new(\"nginx:latest\");\n    \n    // Test basic properties\n    assert_eq!(container.image(), \"nginx:latest\");\n    assert_eq!(container.container_type(), \"generic\");\n    \n    // Test environment variables\n    let container_with_env = container\n        .with_env(\"NGINX_PORT\", \"8080\")\n        .with_env(\"NGINX_HOST\", \"localhost\");\n    \n    // Test port configuration\n    let container_with_port = container_with_env.with_port(8080);\n    assert_eq!(container_with_port.port(), Some(8080));\n    \n    // Test command configuration\n    let container_with_cmd = container_with_port.with_command(\"nginx\", &[\"-g\", \"daemon off;\"]);\n    assert_eq!(container_with_cmd.command(), Some((\"nginx\", vec![\"-g\", \"daemon off;\"])));\n}\n\n/// Test CleanroomError functionality\n#[test]\nfn test_cleanroom_error() {\n    // Test error creation\n    let error = CleanroomError::new(ErrorKind::ValidationError, \"Test error message\");\n    assert_eq!(error.kind(), ErrorKind::ValidationError);\n    assert_eq!(error.message(), \"Test error message\");\n    \n    // Test error conversion\n    let io_error = std::io::Error::new(std::io::ErrorKind::NotFound, \"File not found\");\n    let cleanroom_error = CleanroomError::from(io_error);\n    assert_eq!(cleanroom_error.kind(), ErrorKind::IoError);\n    \n    // Test error chaining\n    let chained_error = CleanroomError::chain_error(error, \"Additional context\");\n    assert!(chained_error.message().contains(\"Additional context\"));\n    assert!(chained_error.message().contains(\"Test error message\"));\n}\n\n/// Test error kind functionality\n#[test]\nfn test_error_kind() {\n    // Test error kind display\n    assert_eq!(format!(\"{}\", ErrorKind::ValidationError), \"ValidationError\");\n    assert_eq!(format!(\"{}\", ErrorKind::IoError), \"IoError\");\n    assert_eq!(format!(\"{}\", ErrorKind::ContainerError), \"ContainerError\");\n    \n    // Test error kind from string\n    assert_eq!(ErrorKind::from_str(\"ValidationError\"), Ok(ErrorKind::ValidationError));\n    assert_eq!(ErrorKind::from_str(\"IoError\"), Ok(ErrorKind::IoError));\n    assert_eq!(ErrorKind::from_str(\"InvalidError\"), Err(\"Invalid error kind\"));\n}\n\n/// Test configuration serialization\n#[test]\nfn test_config_serialization() {\n    let config = CleanroomConfig::default();\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&config).unwrap();\n    assert!(json.contains(\"enable_singleton_containers\"));\n    assert!(json.contains(\"container_startup_timeout\"));\n    \n    // Test JSON deserialization\n    let deserialized_config: CleanroomConfig = serde_json::from_str(&json).unwrap();\n    assert_eq!(deserialized_config.enable_singleton_containers, config.enable_singleton_containers);\n    assert_eq!(deserialized_config.container_startup_timeout, config.container_startup_timeout);\n    \n    // Test TOML serialization\n    let toml = toml::to_string(&config).unwrap();\n    assert!(toml.contains(\"enable_singleton_containers\"));\n    assert!(toml.contains(\"container_startup_timeout\"));\n    \n    // Test TOML deserialization\n    let deserialized_config: CleanroomConfig = toml::from_str(&toml).unwrap();\n    assert_eq!(deserialized_config.enable_singleton_containers, config.enable_singleton_containers);\n}\n\n/// Test policy serialization\n#[test]\nfn test_policy_serialization() {\n    let policy = Policy::with_security_level(SecurityLevel::Strict)\n        .with_network_isolation(false);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&policy).unwrap();\n    assert!(json.contains(\"security_level\"));\n    assert!(json.contains(\"network\"));\n    \n    // Test JSON deserialization\n    let deserialized_policy: Policy = serde_json::from_str(&json).unwrap();\n    assert_eq!(deserialized_policy.security_level, policy.security_level);\n    assert_eq!(deserialized_policy.network.enable_network_isolation, policy.network.enable_network_isolation);\n}\n\n/// Test resource limits serialization\n#[test]\nfn test_resource_limits_serialization() {\n    let limits = ResourceLimits::new()\n        .with_max_memory_mb(512)\n        .with_max_cpu_percent(50.0)\n        .with_max_disk_mb(1024);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&limits).unwrap();\n    assert!(json.contains(\"max_memory_mb\"));\n    assert!(json.contains(\"max_cpu_percent\"));\n    assert!(json.contains(\"max_disk_mb\"));\n    \n    // Test JSON deserialization\n    let deserialized_limits: ResourceLimits = serde_json::from_str(&json).unwrap();\n    assert_eq!(deserialized_limits.max_memory_mb, limits.max_memory_mb);\n    assert_eq!(deserialized_limits.max_cpu_percent, limits.max_cpu_percent);\n    assert_eq!(deserialized_limits.max_disk_mb, limits.max_disk_mb);\n}\n\n/// Test deterministic manager serialization\n#[test]\nfn test_deterministic_manager_serialization() {\n    let manager = DeterministicManager::new();\n    manager.set_seed(12345);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&manager).unwrap();\n    assert!(json.contains(\"seed\"));\n    assert!(json.contains(\"12345\"));\n    \n    // Test JSON deserialization\n    let deserialized_manager: DeterministicManager = serde_json::from_str(&json).unwrap();\n    assert_eq!(deserialized_manager.get_current_seed(), 12345);\n}\n\n/// Test coverage tracker serialization\n#[test]\nfn test_coverage_tracker_serialization() {\n    let tracker = CoverageTracker::new();\n    tracker.start_test(\"test1\");\n    tracker.record_line_execution(\"test1\", 10);\n    tracker.end_test(\"test1\", true);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&tracker).unwrap();\n    assert!(json.contains(\"total_tests\"));\n    assert!(json.contains(\"covered_lines\"));\n    \n    // Test JSON deserialization\n    let deserialized_tracker: CoverageTracker = serde_json::from_str(&json).unwrap();\n    assert_eq!(deserialized_tracker.get_report().total_tests, 1);\n    assert_eq!(deserialized_tracker.get_report().covered_lines, 1);\n}\n\n/// Test snapshot manager serialization\n#[test]\nfn test_snapshot_manager_serialization() {\n    let manager = SnapshotManager::new();\n    let test_data = serde_json::json!({\"key\": \"value\"});\n    let snapshot_id = manager.create_snapshot(\"test_snapshot\", &test_data);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&manager).unwrap();\n    assert!(json.contains(\"snapshots\"));\n    \n    // Test JSON deserialization\n    let deserialized_manager: SnapshotManager = serde_json::from_str(&json).unwrap();\n    assert!(deserialized_manager.get_snapshot(\"test_snapshot\").is_some());\n}\n\n/// Test tracing manager serialization\n#[test]\nfn test_tracing_manager_serialization() {\n    let manager = TracingManager::new();\n    let trace_id = manager.start_trace(\"test_trace\");\n    manager.log_trace_event(&trace_id, \"test_event\", \"test_data\");\n    manager.end_trace(&trace_id);\n    \n    // Test JSON serialization\n    let json = serde_json::to_string(&manager).unwrap();\n    assert!(json.contains(\"traces\"));\n    \n    // Test JSON deserialization\n    let deserialized_manager: TracingManager = serde_json::from_str(&json).unwrap();\n    assert!(!deserialized_manager.get_traces().is_empty());\n}\n\n/// Test test report serialization\n#[test]\nfn test_test_report_serialization() {\n    let report = TestReport::new();\n    report.record_test_execution(\"test1\", true, Duration::from_millis(100));\n    \n    // Test JSON serialization\n    let json = report.to_json().unwrap();\n    assert!(json.contains(\"session_id\"));\n    assert!(json.contains(\"test_summary\"));\n    \n    // Test TOML serialization\n    let toml = report.to_toml().unwrap();\n    assert!(toml.contains(\"session_id\"));\n    assert!(toml.contains(\"test_summary\"));\n}\n"
        }
    ]
}