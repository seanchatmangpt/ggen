{
    "sourceFile": "cleanroom/tests/common.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760268144241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760268144241,
            "name": "Commit-0",
            "content": "//! Common test utilities and shared test code for cleanroom framework\n\nuse std::time::Duration;\nuse std::sync::Arc;\nuse tokio::time::timeout;\nuse cleanroom::{\n    CleanroomEnvironment, CleanroomConfig, CleanroomError,\n    PostgresContainer, RedisContainer, GenericContainer,\n    Policy, SecurityLevel, ResourceLimits,\n};\n\n/// Common test timeout duration\npub const TEST_TIMEOUT: Duration = Duration::from_secs(30);\n\n/// Common test configuration\npub fn default_test_config() -> CleanroomConfig {\n    CleanroomConfig {\n        enable_singleton_containers: true,\n        container_startup_timeout: Duration::from_secs(10),\n        test_execution_timeout: Duration::from_secs(30),\n        max_concurrent_containers: 5,\n        enable_deterministic_execution: true,\n        enable_coverage_tracking: true,\n        enable_snapshot_testing: true,\n        enable_tracing: true,\n        enable_security_policy: true,\n        ..CleanroomConfig::default()\n    }\n}\n\n/// Fast test configuration for quick tests\npub fn fast_test_config() -> CleanroomConfig {\n    CleanroomConfig {\n        enable_singleton_containers: true,\n        container_startup_timeout: Duration::from_secs(5),\n        test_execution_timeout: Duration::from_secs(10),\n        max_concurrent_containers: 3,\n        enable_deterministic_execution: false,\n        enable_coverage_tracking: false,\n        enable_snapshot_testing: false,\n        enable_tracing: false,\n        enable_security_policy: false,\n        ..CleanroomConfig::default()\n    }\n}\n\n/// Comprehensive test configuration\npub fn comprehensive_test_config() -> CleanroomConfig {\n    CleanroomConfig {\n        enable_singleton_containers: true,\n        container_startup_timeout: Duration::from_secs(60),\n        test_execution_timeout: Duration::from_secs(300),\n        max_concurrent_containers: 10,\n        enable_deterministic_execution: true,\n        enable_coverage_tracking: true,\n        enable_snapshot_testing: true,\n        enable_tracing: true,\n        enable_security_policy: true,\n        ..CleanroomConfig::default()\n    }\n}\n\n/// Create a test environment with default configuration\npub async fn create_test_environment() -> Result<Arc<CleanroomEnvironment>, CleanroomError> {\n    let config = default_test_config();\n    let environment = CleanroomEnvironment::new(config).await?;\n    Ok(Arc::new(environment))\n}\n\n/// Create a test environment with custom configuration\npub async fn create_test_environment_with_config(\n    config: CleanroomConfig,\n) -> Result<Arc<CleanroomEnvironment>, CleanroomError> {\n    let environment = CleanroomEnvironment::new(config).await?;\n    Ok(Arc::new(environment))\n}\n\n/// Create a test Postgres container\npub fn create_test_postgres_container() -> PostgresContainer {\n    PostgresContainer::new(\"postgres:15\")\n        .with_env(\"POSTGRES_PASSWORD\", \"test\")\n        .with_env(\"POSTGRES_DB\", \"testdb\")\n        .with_port(5432)\n}\n\n/// Create a test Redis container\npub fn create_test_redis_container() -> RedisContainer {\n    RedisContainer::new(\"redis:7\")\n        .with_port(6379)\n}\n\n/// Create a test generic container\npub fn create_test_generic_container() -> GenericContainer {\n    GenericContainer::new(\"nginx:latest\")\n        .with_port(8080)\n        .with_env(\"NGINX_PORT\", \"8080\")\n}\n\n/// Create a test policy\npub fn create_test_policy() -> Policy {\n    Policy::with_security_level(SecurityLevel::Standard)\n        .with_network_isolation(false)\n}\n\n/// Create test resource limits\npub fn create_test_resource_limits() -> ResourceLimits {\n    ResourceLimits::new()\n        .with_max_memory_mb(512)\n        .with_max_cpu_percent(50.0)\n        .with_max_disk_mb(1024)\n}\n\n/// Wait for a condition to be true with timeout\npub async fn wait_for_condition<F, Fut>(\n    condition: F,\n    timeout_duration: Duration,\n) -> Result<bool, CleanroomError>\nwhere\n    F: Fn() -> Fut,\n    Fut: std::future::Future<Output = bool>,\n{\n    let start_time = std::time::Instant::now();\n    while start_time.elapsed() < timeout_duration {\n        if condition().await {\n            return Ok(true);\n        }\n        tokio::time::sleep(Duration::from_millis(10)).await;\n    }\n    Ok(false)\n}\n\n/// Execute a test with timeout\npub async fn execute_test_with_timeout<F, Fut, T>(\n    test: F,\n    timeout_duration: Duration,\n) -> Result<T, CleanroomError>\nwhere\n    F: Fn() -> Fut,\n    Fut: std::future::Future<Output = Result<T, CleanroomError>>,\n{\n    timeout(timeout_duration, test())\n        .await\n        .map_err(|_| CleanroomError::validation_error(\"Test timeout\"))?\n}\n\n/// Generate test data\npub fn generate_test_data(size: usize) -> serde_json::Value {\n    let mut data = serde_json::Map::new();\n    for i in 0..size {\n        data.insert(\n            format!(\"key_{}\", i),\n            serde_json::Value::String(format!(\"value_{}\", i)),\n        );\n    }\n    serde_json::Value::Object(data)\n}\n\n/// Create test snapshot data\npub fn create_test_snapshot_data() -> serde_json::Value {\n    serde_json::json!({\n        \"test_data\": \"snapshot_value\",\n        \"timestamp\": \"2024-01-01T00:00:00Z\",\n        \"metadata\": {\n            \"version\": \"1.0\",\n            \"environment\": \"test\"\n        }\n    })\n}\n\n/// Test assertion helpers\npub mod assertions {\n    use super::*;\n\n    /// Assert that two values are approximately equal (for floating point comparisons)\n    pub fn assert_approx_eq(a: f64, b: f64, epsilon: f64) {\n        assert!(\n            (a - b).abs() < epsilon,\n            \"{} is not approximately equal to {} (epsilon: {})\",\n            a,\n            b,\n            epsilon\n        );\n    }\n\n    /// Assert that a duration is within expected range\n    pub fn assert_duration_in_range(duration: Duration, min: Duration, max: Duration) {\n        assert!(\n            duration >= min && duration <= max,\n            \"Duration {:?} is not in range [{:?}, {:?}]\",\n            duration,\n            min,\n            max\n        );\n    }\n\n    /// Assert that a string contains expected content\n    pub fn assert_string_contains(haystack: &str, needle: &str) {\n        assert!(\n            haystack.contains(needle),\n            \"String '{}' does not contain '{}'\",\n            haystack,\n            needle\n        );\n    }\n\n    /// Assert that a vector contains expected elements\n    pub fn assert_vec_contains<T: PartialEq + std::fmt::Debug>(vec: &[T], expected: &T) {\n        assert!(\n            vec.contains(expected),\n            \"Vector {:?} does not contain {:?}\",\n            vec,\n            expected\n        );\n    }\n\n    /// Assert that a result is ok and contains expected value\n    pub fn assert_result_ok<T: PartialEq + std::fmt::Debug>(\n        result: &Result<T, CleanroomError>,\n        expected: &T,\n    ) {\n        match result {\n            Ok(value) => assert_eq!(value, expected),\n            Err(error) => panic!(\"Expected Ok({:?}), got Err({:?})\", expected, error),\n        }\n    }\n\n    /// Assert that a result is an error\n    pub fn assert_result_err<T: std::fmt::Debug>(result: &Result<T, CleanroomError>) {\n        match result {\n            Ok(value) => panic!(\"Expected Err, got Ok({:?})\", value),\n            Err(_) => {} // Expected\n        }\n    }\n\n    /// Assert that a result is an error with specific kind\n    pub fn assert_result_err_kind<T: std::fmt::Debug>(\n        result: &Result<T, CleanroomError>,\n        expected_kind: cleanroom::ErrorKind,\n    ) {\n        match result {\n            Ok(value) => panic!(\"Expected Err({:?}), got Ok({:?})\", expected_kind, value),\n            Err(error) => assert_eq!(error.kind(), expected_kind),\n        }\n    }\n\n    /// Assert that a result is an error with specific message\n    pub fn assert_result_err_message<T: std::fmt::Debug>(\n        result: &Result<T, CleanroomError>,\n        expected_message: &str,\n    ) {\n        match result {\n            Ok(value) => {\n                panic!(\n                    \"Expected Err with message '{}', got Ok({:?})\",\n                    expected_message, value\n                )\n            }\n            Err(error) => assert!(error.message().contains(expected_message)),\n        }\n    }\n}\n\n/// Test configuration builder\npub struct TestConfigBuilder {\n    config: CleanroomConfig,\n}\n\nimpl TestConfigBuilder {\n    pub fn new() -> Self {\n        Self {\n            config: CleanroomConfig::default(),\n        }\n    }\n\n    pub fn with_singleton_containers(mut self, enable: bool) -> Self {\n        self.config.enable_singleton_containers = enable;\n        self\n    }\n\n    pub fn with_startup_timeout(mut self, timeout: Duration) -> Self {\n        self.config.container_startup_timeout = timeout;\n        self\n    }\n\n    pub fn with_execution_timeout(mut self, timeout: Duration) -> Self {\n        self.config.test_execution_timeout = timeout;\n        self\n    }\n\n    pub fn with_max_containers(mut self, max: usize) -> Self {\n        self.config.max_concurrent_containers = max;\n        self\n    }\n\n    pub fn with_deterministic_execution(mut self, enable: bool) -> Self {\n        self.config.enable_deterministic_execution = enable;\n        self\n    }\n\n    pub fn with_coverage_tracking(mut self, enable: bool) -> Self {\n        self.config.enable_coverage_tracking = enable;\n        self\n    }\n\n    pub fn with_snapshot_testing(mut self, enable: bool) -> Self {\n        self.config.enable_snapshot_testing = enable;\n        self\n    }\n\n    pub fn with_tracing(mut self, enable: bool) -> Self {\n        self.config.enable_tracing = enable;\n        self\n    }\n\n    pub fn with_security_policy(mut self, enable: bool) -> Self {\n        self.config.enable_security_policy = enable;\n        self\n    }\n\n    pub fn build(self) -> CleanroomConfig {\n        self.config\n    }\n}\n\nimpl Default for TestConfigBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Test policy builder\npub struct TestPolicyBuilder {\n    policy: Policy,\n}\n\nimpl TestPolicyBuilder {\n    pub fn new() -> Self {\n        Self {\n            policy: Policy::default(),\n        }\n    }\n\n    pub fn with_security_level(mut self, level: SecurityLevel) -> Self {\n        self.policy.security_level = level;\n        self\n    }\n\n    pub fn with_network_isolation(mut self, enable: bool) -> Self {\n        self.policy.network.enable_network_isolation = enable;\n        self\n    }\n\n    pub fn with_port_scanning(mut self, enable: bool) -> Self {\n        self.policy.network.enable_port_scanning = enable;\n        self\n    }\n\n    pub fn with_file_system_isolation(mut self, enable: bool) -> Self {\n        self.policy.network.enable_file_system_isolation = enable;\n        self\n    }\n\n    pub fn build(self) -> Policy {\n        self.policy\n    }\n}\n\nimpl Default for TestPolicyBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Test resource limits builder\npub struct TestResourceLimitsBuilder {\n    limits: ResourceLimits,\n}\n\nimpl TestResourceLimitsBuilder {\n    pub fn new() -> Self {\n        Self {\n            limits: ResourceLimits::new(),\n        }\n    }\n\n    pub fn with_max_memory_mb(mut self, memory: usize) -> Self {\n        self.limits.max_memory_mb = memory;\n        self\n    }\n\n    pub fn with_max_cpu_percent(mut self, cpu: f64) -> Self {\n        self.limits.max_cpu_percent = cpu;\n        self\n    }\n\n    pub fn with_max_disk_mb(mut self, disk: usize) -> Self {\n        self.limits.max_disk_mb = disk;\n        self\n    }\n\n    pub fn with_max_network_mb(mut self, network: usize) -> Self {\n        self.limits.max_network_mb = network;\n        self\n    }\n\n    pub fn build(self) -> ResourceLimits {\n        self.limits\n    }\n}\n\nimpl Default for TestResourceLimitsBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Test data generators\npub mod generators {\n    use super::*;\n    use proptest::prelude::*;\n\n    /// Generate random cleanroom configurations\n    pub fn cleanroom_config() -> impl Strategy<Value = CleanroomConfig> {\n        (\n            any::<bool>(),\n            1..300u64,\n            1..600u64,\n            1..100usize,\n            any::<bool>(),\n            any::<bool>(),\n            any::<bool>(),\n            any::<bool>(),\n            any::<bool>(),\n        )\n            .prop_map(\n                |(\n                    enable_singleton,\n                    startup_timeout_secs,\n                    execution_timeout_secs,\n                    max_containers,\n                    enable_deterministic,\n                    enable_coverage,\n                    enable_snapshots,\n                    enable_tracing,\n                    enable_security,\n                )| CleanroomConfig {\n                    enable_singleton_containers: enable_singleton,\n                    container_startup_timeout: Duration::from_secs(startup_timeout_secs),\n                    test_execution_timeout: Duration::from_secs(execution_timeout_secs),\n                    max_concurrent_containers: max_containers,\n                    enable_deterministic_execution: enable_deterministic,\n                    enable_coverage_tracking: enable_coverage,\n                    enable_snapshot_testing: enable_snapshots,\n                    enable_tracing: enable_tracing,\n                    enable_security_policy: enable_security,\n                    ..CleanroomConfig::default()\n                },\n            )\n    }\n\n    /// Generate random policies\n    pub fn policy() -> impl Strategy<Value = Policy> {\n        (\n            prop::sample::select(&[\n                SecurityLevel::Permissive,\n                SecurityLevel::Standard,\n                SecurityLevel::Strict,\n                SecurityLevel::Locked,\n            ]),\n            any::<bool>(),\n            any::<bool>(),\n            any::<bool>(),\n        )\n            .prop_map(|(security_level, network_isolation, port_scanning, fs_isolation)| {\n                Policy {\n                    security_level,\n                    network: cleanroom::NetworkPolicy {\n                        enable_network_isolation: network_isolation,\n                        enable_port_scanning: port_scanning,\n                        enable_file_system_isolation: fs_isolation,\n                    },\n                    ..Policy::default()\n                }\n            })\n    }\n\n    /// Generate random resource limits\n    pub fn resource_limits() -> impl Strategy<Value = ResourceLimits> {\n        (1..4096u32, 1.0..100.0f64, 1..8192u32, 1..1024u32)\n            .prop_map(|(memory_mb, cpu_percent, disk_mb, network_mb)| {\n                ResourceLimits {\n                    max_memory_mb: memory_mb as usize,\n                    max_cpu_percent: cpu_percent,\n                    max_disk_mb: disk_mb as usize,\n                    max_network_mb: network_mb as usize,\n                    ..ResourceLimits::default()\n                }\n            })\n    }\n\n    /// Generate random container images\n    pub fn container_image() -> impl Strategy<Value = String> {\n        \"[a-zA-Z0-9_/:.-]{1,50}\"\n    }\n\n    /// Generate random ports\n    pub fn port() -> impl Strategy<Value = u16> {\n        1..65535u16\n    }\n\n    /// Generate random environment variable keys\n    pub fn env_key() -> impl Strategy<Value = String> {\n        \"[a-zA-Z0-9_]{1,20}\"\n    }\n\n    /// Generate random environment variable values\n    pub fn env_value() -> impl Strategy<Value = String> {\n        \"[a-zA-Z0-9_]{1,50}\"\n    }\n\n    /// Generate random test names\n    pub fn test_name() -> impl Strategy<Value = String> {\n        \"[a-zA-Z0-9_]{1,20}\"\n    }\n\n    /// Generate random error messages\n    pub fn error_message() -> impl Strategy<Value = String> {\n        \"[a-zA-Z0-9_ ]{1,100}\"\n    }\n}\n"
        }
    ]
}