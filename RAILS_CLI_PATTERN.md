# Rails-Style CLI Pattern for clap-noun-verb

## Overview

The Rails-style CLI pattern in clap-noun-verb enables building code generation frameworks similar to Rails' `rails generate` and `rails destroy` commands. This pattern is specifically designed for **RDF-driven code generation** where CLI specifications in `.specify/*.ttl` files are transformed into working CLI applications.

## The Core Equation

```
RDF Spec (Turtle) â†’ Rails Generator Framework â†’ Working CLI
```

This implements the ggen principle: **A = Î¼(O)** â€” Code precipitates from RDF ontology via transformation pipeline.

## Architecture

### 1. RDF Specifications (Source of Truth)

Located in `.specify/cli-commands.ttl`, these define CLI command structure:

```turtle
cli:GenerateCommand
  a cli:Command ;
  cli:label "Generate code artifacts" ;
  cli:positionalArgs cli:ArtifactTypeArg ;
  cli:options cli:OutputOption, cli:DryRunOption .

cli:ArtifactTypeArg
  a cli:PositionalArgument ;
  cli:choices "model", "migration", "controller", "scaffold" .
```

### 2. Rails Generator Framework

The `clap_noun_verb::rails` module provides:

- **GeneratorContext**: File operations, template substitution, argument parsing
- **Generator trait**: Extensible interface for code generation
- **Destroyer trait**: Inverse operations for cleanup
- **RailsCliBuilder**: Fluent API for command composition

### 3. CLI Applications

Built using the framework to implement the RDF-defined commands:

```rust
let cli = RailsCliBuilder::new("ggen")
    .with_generator("model", |ctx| {
        // Generate model files
    })
    .with_destroyer("model", |ctx| {
        // Destroy model files
    });
```

## Usage Patterns

### 1. Generate Pattern

```bash
# Generate a new model
ggen generate model User

# Output:
# ğŸ“ Generating model: User
# âœ… Created src/models/user.rs
# âœ… Created tests/user_test.rs
# âœ… Created db/migrations/..._create_user.sql
```

### 2. Destroy Pattern

```bash
# Destroy a generated model
ggen destroy model User

# Output:
# ğŸ—‘ï¸ Destroying model: User
# âŒ Removed src/models/user.rs
# âŒ Removed tests/user_test.rs
```

### 3. Scaffold Pattern

```bash
# Generate complete CRUD scaffold
ggen generate scaffold Post

# Output:
# ğŸ—ï¸ Generating scaffold: Post
# [generates model, migration, and controller]
```

## Key Features

### 1. File Operations

```rust
let ctx = GeneratorContext::new(project_root, "model", vec!["User".to_string()]);

// Create files
ctx.create_file("src/models/user.rs", &content)?;

// Create with templates
ctx.create_file_from_template(
    "src/models/user.rs",
    template,
    &variables
)?;

// Remove files
ctx.remove_file("src/models/user.rs")?;

// Remove directories
ctx.remove_dir("src/models")?;
```

### 2. Template Substitution

```rust
let variables = HashMap::from([
    ("name".to_string(), "User".to_string()),
    ("fields".to_string(), "id: String".to_string()),
]);

ctx.create_file_from_template(
    "src/models/user.rs",
    "pub struct {{name}} { {{fields}} }",
    &variables
)?;
```

### 3. Fluent Builder API

```rust
let cli = RailsCliBuilder::new("myapp")
    .with_project_root(PathBuf::from("."))
    .with_generator("model", handler_fn)
    .with_generator("migration", handler_fn)
    .with_destroyer("model", cleanup_fn);

// Execute
cli.generate("model", vec!["User".to_string()])?;
cli.destroy("model", vec!["User".to_string()])?;
```

## Integration with ggen

### Step 1: Define CLI in RDF

```turtle
@prefix cli: <http://ggen.org/cli#> .

cli:GenerateCommand a cli:Command ;
    cli:label "Generate artifacts" ;
    cli:positionalArgs cli:ArtifactTypeArg ;
    cli:options cli:OutputOption .
```

### Step 2: Extract to SPARQL

```sparql
PREFIX cli: <http://ggen.org/cli#>
SELECT ?command ?artifact ?option WHERE {
    ?command a cli:Command ;
        cli:positionalArgs ?artifact ;
        cli:options ?option .
}
```

### Step 3: Generate CLI

```rust
// SPARQL results â†’ GeneratorContext â†’ File operations
let outputs = results.into_iter().map(|row| {
    let artifact_type = row.get("artifact")?;
    generator.generate_artifact(&artifact_type)
}).collect();
```

### Step 4: Execute

```bash
cargo run -- generate model User
```

## File Structure

```
project/
â”œâ”€â”€ .specify/
â”‚   â”œâ”€â”€ cli-commands.ttl         # CLI specification
â”‚   â””â”€â”€ [other ontologies].ttl
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ models/                  # Generated by: generate model
â”‚   â”œâ”€â”€ controllers/             # Generated by: generate controller
â”‚   â””â”€â”€ migrations.rs            # Generated by: generate migration
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ [generated tests]/
â””â”€â”€ Cargo.toml
```

## Error Handling

All operations return `Result<T>`:

```rust
pub type Result<T> = std::result::Result<T, NounVerbError>;

// Usage
cli.generate("model", vec!["User".to_string()])
    .map(|output| println!("{:?}", output.messages))
    .map_err(|e| eprintln!("Error: {}", e))
```

## Examples

### 1. `rails_style_cli.rs`

Demonstrates the framework with model, migration, and controller generators:

```bash
cargo run --example rails_style_cli
# Output:
# ğŸ“¦ Available Generators:
#   - migration
#   - model
#   - controller
```

### 2. `ggen_cli_with_rails.rs`

Complete CLI application implementing noun-verb pattern:

```bash
cargo run --example ggen_cli_with_rails -- generate scaffold Post
# ğŸ—ï¸ Generating scaffold: Post
# âœ… Created model files
# âœ… Created migration files
# âœ… Created controller files
```

## Extending the Framework

### Custom Generator

```rust
.with_generator("custom", |ctx| {
    let name = ctx.arg(0)?;

    // Your generation logic
    ctx.create_file(&format!("custom/{}.txt", name), "content")?;

    Ok(GeneratorOutput::new()
        .with_file(PathBuf::from(&file))
        .with_message(format!("Created {}", file)))
})
```

### Custom Destroyer

```rust
.with_destroyer("custom", |ctx| {
    let name = ctx.arg(0)?;

    // Your cleanup logic
    ctx.remove_file(&format!("custom/{}.txt", name))?;

    Ok(())
})
```

## Performance Characteristics

- **Generator Creation**: O(n) where n = number of files to generate
- **File Operations**: O(1) per file (constant time)
- **Template Substitution**: O(m) where m = template size
- **Directory Removal**: O(d) where d = total files in directory

## Best Practices

1. **Always Return GeneratorOutput**
   ```rust
   Ok(GeneratorOutput::new()
       .with_file(path)
       .with_message(msg))
   ```

2. **Use Templates for Complex Code**
   ```rust
   ctx.create_file_from_template(path, template, &variables)?
   ```

3. **Implement Destroyers for Cleanup**
   ```rust
   .with_destroyer("model", |ctx| {
       // Mirror of generator logic
   })
   ```

4. **Provide Helpful Messages**
   ```rust
   .with_message(format!("âœ… Created {}", path))
   ```

## Integration with Noun-Verb Pattern

The Rails generators integrate seamlessly with clap-noun-verb's `#[noun]` and `#[verb]` macros:

```rust
#[noun]
pub struct Generate;

#[verb(on_generate)]
pub async fn generate_command(
    artifact_type: String,
    name: String,
) -> Result<()> {
    let cli = RailsCliBuilder::new("myapp");
    cli.generate(&artifact_type, vec![name])?;
    Ok(())
}
```

## Real-World Examples

### 1. Database Model Generator

```rust
.with_generator("model", |ctx| {
    let name = ctx.arg(0)?;

    // Generate model struct
    ctx.create_file(&format!("src/models/{}.rs", name), &model_code)?;

    // Generate migration
    ctx.create_file(&format!("db/migrations/..._{}.sql", name), &migration_code)?;

    // Generate tests
    ctx.create_file(&format!("tests/{}_test.rs", name), &test_code)?;

    Ok(GeneratorOutput::new())
})
```

### 2. API Endpoint Generator

```rust
.with_generator("api", |ctx| {
    let resource = ctx.arg(0)?;

    // Generate handler
    ctx.create_file(&format!("src/api/{}.rs", resource), &handler_code)?;

    // Generate routes
    ctx.create_file(&format!("src/routes/{}.rs", resource), &routes_code)?;

    Ok(GeneratorOutput::new())
})
```

## Limitations & Future Work

- âš ï¸ Templates use simple `{{var}}` substitution (consider regex engine for v5.2)
- âš ï¸ No conditional generation (depends on context variables)
- âš ï¸ No hook system for pre/post generation
- ğŸ”„ Planned: SPARQL-driven template selection
- ğŸ”„ Planned: Async file operations
- ğŸ”„ Planned: Watch mode for regeneration

## Conclusion

The Rails-style CLI pattern brings the elegance of Rails' scaffold generation to Rust CLIs powered by clap-noun-verb. By combining RDF specifications, fluent APIs, and semantic commands, developers can build powerful code generation tools that are both maintainable and user-friendly.

**The whole point**: Turn RDF ontologies into working CLIs that generate production-ready code.
