# Cleanroom - Production-Ready Test Isolation Framework

[![Crates.io](https://img.shields.io/crates/v/cleanroom.svg)](https://crates.io/crates/cleanroom)
[![Documentation](https://docs.rs/cleanroom/badge.svg)](https://docs.rs/cleanroom)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A lightweight, production-ready testing framework for Rust that provides true test isolation using temporary filesystem environments. Perfect for integration tests, CI/CD pipelines, and scenarios requiring deterministic, reproducible test results.

## ğŸ¯ Generated by ggen (Dogfooding)

This crate was created using ggen's own AI project generation capabilities, demonstrating dogfooding - using ggen to build ggen. It showcases the power of automated code generation combined with production-ready testing practices.

```bash
# Generated with:
ggen ai project \
  --description "Advanced Rust test harness crate 'cleanroom'..." \
  --name "ggen-cleanroom" \
  --output "ggen-cleanroom" \
  --tests --docs
```

## âœ¨ Features

- **ğŸï¸ True Isolation**: Each test runs in its own temporary directory with automatic cleanup
- **ğŸ“Š Performance Metrics**: Built-in benchmarking and performance tracking
- **âœ… Validation Suite**: Extensible validation framework with custom validators
- **âš™ï¸ Builder Pattern**: Flexible configuration with sensible defaults
- **ğŸ”§ Zero Dependencies**: No containers or databases required - pure filesystem isolation
- **ğŸ¯ Deterministic**: Same inputs always produce identical results
- **ğŸš€ Production Ready**: Comprehensive error handling with thiserror
- **ğŸ“ Well Documented**: Extensive examples and API documentation

## ğŸ“¦ Installation

Add cleanroom to your `Cargo.toml`:

```toml
[dev-dependencies]
cleanroom = "0.1"
```

## ğŸš€ Quick Start

```rust
use cleanroom::{CleanroomEnv, CleanroomConfig, TestStatus};

#[test]
fn test_with_cleanroom() {
    let config = CleanroomConfig::default();
    let mut env = CleanroomEnv::new(config)
        .expect("Failed to create cleanroom");

    let result = env.run_test(|env| {
        // Write test data
        env.write_file("test.txt", "Hello, Cleanroom!")?;

        // Read and validate
        let content = env.read_file("test.txt")?;
        assert_eq!(content, "Hello, Cleanroom!");

        Ok(())
    });

    assert_eq!(result.status, TestStatus::Passed);
}
```

## ğŸ“– Core Concepts

### CleanroomEnv

The main testing environment that provides:
- Isolated temporary directory per test
- File operations (read, write, create_dir)
- Test execution with automatic metrics collection
- Automatic cleanup on drop

### CleanroomConfig

Flexible configuration with builder pattern:

```rust
use cleanroom::CleanroomConfigBuilder;
use std::time::Duration;

let config = CleanroomConfigBuilder::new()
    .timeout(Duration::from_secs(30))
    .benchmarking(true)
    .logging(true)
    .concurrency(8)
    .scalability(true, 100)
    .build();
```

### TestResult

Comprehensive test results including:
- Test status (Passed, Failed, Skipped, Timeout)
- Duration in milliseconds
- Optional performance metrics
- Error messages

### ValidationSuite

Extensible validation framework:

```rust
use cleanroom::{ValidationSuite, Validator, ValidationResult};

struct CustomValidator;

impl Validator for CustomValidator {
    fn validate(&self, env: &CleanroomEnv) -> cleanroom::Result<ValidationResult> {
        let mut result = ValidationResult::new(true);
        result.add_message("Validation passed!");
        Ok(result)
    }

    fn name(&self) -> &str {
        "CustomValidator"
    }
}

let mut suite = ValidationSuite::new("My Tests");
suite.add_validator(Box::new(CustomValidator));
let results = suite.run(&env)?;
```

## ğŸ“š Examples

### Basic Usage

```rust
use cleanroom::{CleanroomEnv, CleanroomConfig};

let config = CleanroomConfig::default();
let mut env = CleanroomEnv::new(config)?;

let result = env.run_test(|env| {
    env.write_file("data.txt", "test data")?;
    env.create_dir("subdir")?;
    env.write_file("subdir/nested.txt", "nested")?;
    Ok(())
});

assert!(result.status == TestStatus::Passed);
```

### Performance Benchmarking

```rust
use cleanroom::CleanroomConfigBuilder;

let config = CleanroomConfigBuilder::new()
    .benchmarking(true)
    .build();

let mut env = CleanroomEnv::new(config)?;

let result = env.run_test(|env| {
    for i in 0..1000 {
        env.write_file(&format!("file_{}.txt", i), "data")?;
    }
    Ok(())
});

println!("Benchmark completed in {}ms", result.duration_ms);
```

### Custom Validation

```rust
use cleanroom::{ValidationSuite, Validator, ValidationResult};

struct FileExistsValidator {
    filename: String,
}

impl Validator for FileExistsValidator {
    fn validate(&self, env: &CleanroomEnv) -> cleanroom::Result<ValidationResult> {
        let path = env.path().join(&self.filename);
        let passed = path.exists();

        let mut result = ValidationResult::new(passed);
        result.add_message(format!(
            "File '{}' {}",
            self.filename,
            if passed { "exists" } else { "not found" }
        ));

        Ok(result)
    }

    fn name(&self) -> &str {
        "FileExistsValidator"
    }
}

// Usage
let mut suite = ValidationSuite::new("File Validation");
suite.add_validator(Box::new(FileExistsValidator {
    filename: "test.txt".to_string(),
}));
```

## ğŸ¯ Use Cases

### Integration Testing

Perfect for testing components that interact with the filesystem:

```rust
#[test]
fn test_config_file_loading() {
    let mut env = CleanroomEnv::new(CleanroomConfig::default())?;

    let result = env.run_test(|env| {
        // Write test config
        env.write_file("config.toml", "[server]\nport = 8080")?;

        // Test your config loading logic
        let config = load_config(env.path())?;
        assert_eq!(config.server.port, 8080);

        Ok(())
    });

    assert!(result.status == TestStatus::Passed);
}
```

### CI/CD Pipeline Testing

Deterministic tests for continuous integration:

```rust
#[test]
fn test_deployment_artifacts() {
    let config = CleanroomConfigBuilder::new()
        .timeout(Duration::from_secs(60))
        .logging(true)
        .build();

    let mut env = CleanroomEnv::new(config)?;

    let result = env.run_test(|env| {
        // Simulate build artifacts
        env.create_dir("dist")?;
        env.write_file("dist/app.js", "// compiled code")?;
        env.write_file("dist/manifest.json", "{}")?;

        // Validate artifacts
        validate_deployment_structure(env.path())?;

        Ok(())
    });

    assert_eq!(result.status, TestStatus::Passed);
}
```

### Scalability Testing

Test performance under load:

```rust
#[test]
fn test_bulk_operations() {
    let config = CleanroomConfigBuilder::new()
        .benchmarking(true)
        .scalability(true, 1000)
        .build();

    let mut env = CleanroomEnv::new(config)?;

    let result = env.run_test(|env| {
        for i in 0..1000 {
            env.write_file(&format!("data_{}.json", i), "{}")?;
        }
        Ok(())
    });

    println!("Created 1000 files in {}ms", result.duration_ms);
    assert!(result.duration_ms < 1000); // < 1 second
}
```

## ğŸ”§ Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | `Duration` | 300s | Maximum test execution time |
| `enable_benchmarking` | `bool` | `true` | Enable performance metrics |
| `enable_logging` | `bool` | `true` | Enable detailed logging |
| `concurrency` | `usize` | `4` | Concurrent test execution level |
| `enable_scalability` | `bool` | `false` | Enable scalability testing |
| `scalability_iterations` | `usize` | `100` | Iterations for scalability tests |
| `enable_error_validation` | `bool` | `true` | Validate error handling |
| `auto_cleanup` | `bool` | `true` | Auto-cleanup temp directories |

## ğŸ“Š Test Results

Every test execution returns a `TestResult` with:

```rust
pub struct TestResult {
    pub test_id: Uuid,              // Unique test identifier
    pub status: TestStatus,         // Passed, Failed, Skipped, Timeout
    pub duration_ms: u64,           // Execution duration
    pub metrics: Option<PerformanceMetrics>,  // Performance data
    pub errors: Vec<String>,        // Error messages
}
```

## ğŸ¨ API Overview

### Core Types

- `CleanroomEnv` - Main testing environment
- `CleanroomConfig` - Configuration options
- `CleanroomConfigBuilder` - Builder for configuration
- `TestResult` - Test execution results
- `TestStatus` - Test status enum
- `PerformanceMetrics` - Performance data collection
- `Benchmark` - Benchmarking utilities
- `ValidationSuite` - Validation framework
- `Validator` - Trait for custom validators
- `ValidationResult` - Validation results

### Methods

```rust
// CleanroomEnv
pub fn new(config: CleanroomConfig) -> Result<Self>
pub fn path(&self) -> &Path
pub fn create_dir(&self, name: &str) -> Result<PathBuf>
pub fn write_file(&self, path: &str, content: &str) -> Result<PathBuf>
pub fn read_file(&self, path: &str) -> Result<String>
pub fn run_test<F>(&mut self, test_fn: F) -> TestResult
pub fn elapsed_ms(&self) -> u64
pub fn record_metric(&mut self, name: impl Into<String>, value: f64)

// ValidationSuite
pub fn new(name: impl Into<String>) -> Self
pub fn add_validator(&mut self, validator: Box<dyn Validator>)
pub fn run(&self, env: &CleanroomEnv) -> Result<Vec<ValidationResult>>
```

## ğŸ§ª Running Examples

The crate includes comprehensive examples:

```bash
# Basic usage example
cargo run --example basic_usage

# Output:
# ğŸ§ª Cleanroom Testing Framework - Basic Usage Example
#
# ğŸ“ Example 1: Basic Cleanroom Test
#    âœ“ Test completed in 1ms - Status: Passed
#
# ğŸ“ Example 2: Custom Configuration
#    âœ“ Test completed in 4ms
#
# ğŸ“ Example 3: Performance Benchmarking
#    âœ“ Wrote 100 files in 10.59ms
#    âœ“ Benchmark completed in 10ms
#
# ğŸ“ Example 4: Custom Validation
#    âœ“ Validation suite completed - 1/1 passed
#    âœ“ [PASS] Found 5 files, expected 5
#    âœ“ Score: 1.00
#
# âœ… All examples completed successfully!
```

## ğŸ§¬ Testing

Run the test suite:

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_cleanroom_basics
```

All tests (12 total) include:
- 11 unit tests across all modules
- 1 documentation test
- Examples that double as integration tests

## ğŸ—ï¸ Architecture

The cleanroom crate is organized into 5 core modules:

```
cleanroom/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # Public API and re-exports
â”‚   â”œâ”€â”€ environment.rs   # CleanroomEnv implementation
â”‚   â”œâ”€â”€ config.rs        # Configuration and builder
â”‚   â”œâ”€â”€ validation.rs    # Validation framework
â”‚   â”œâ”€â”€ performance.rs   # Performance metrics
â”‚   â””â”€â”€ error.rs         # Error types
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ basic_usage.rs   # Comprehensive examples
â”œâ”€â”€ Cargo.toml
â””â”€â”€ README.md
```

## ğŸ¤ Contributing

Contributions are welcome! Please feel free to submit pull requests or open issues.

## ğŸ“„ License

This project is licensed under the MIT License - see the LICENSE file for details.

## ğŸ™ Acknowledgments

- Created with [ggen](https://github.com/seanchatmangpt/ggen) - Language-agnostic code generation CLI
- Inspired by cleanroom testing principles and isolation best practices
- Part of the ggen ecosystem demonstrating dogfooding and AI-powered development

## ğŸ“š Resources

- [Documentation](https://docs.rs/cleanroom)
- [Examples](examples/)
- [ggen Project](https://github.com/seanchatmangpt/ggen)
- [Issue Tracker](https://github.com/seanchatmangpt/ggen/issues)

---

**Built with â¤ï¸ using ggen** - Demonstrating the power of AI-assisted code generation and dogfooding
