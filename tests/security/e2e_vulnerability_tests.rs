// e2e_vulnerability_tests.rs - End-to-end tests with intentional vulnerabilities
//
// Week 8: Dependency security and supply chain protection
// Chicago TDD: State-based E2E testing with simulated vulnerabilities

use ggen_utils::supply_chain::{
    check_license_compliance, detect_typosquatting, Dependency, SupplyChainConfig,
};
use std::collections::HashMap;

#[test]
fn test_e2e_detect_multiple_typosquatting_attempts() {
    // Arrange: Simulate a realistic dependency list with multiple typosquatting attempts
    let dependencies = vec![
        // Legitimate dependencies
        Dependency {
            name: "serde".to_string(),
            version: "1.0.193".to_string(),
            license: Some("MIT OR Apache-2.0".to_string()),
            checksum: Some("legitimate_checksum_1".to_string()),
        },
        Dependency {
            name: "tokio".to_string(),
            version: "1.35.1".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("legitimate_checksum_2".to_string()),
        },
        // Typosquatting attempts
        Dependency {
            name: "serda".to_string(), // Similar to "serde"
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("suspicious_checksum_1".to_string()),
        },
        Dependency {
            name: "toklo".to_string(), // Similar to "tokio"
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("suspicious_checksum_2".to_string()),
        },
        Dependency {
            name: "clap_rs".to_string(), // Suffix pattern
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("suspicious_checksum_3".to_string()),
        },
        Dependency {
            name: "rust_reqwest".to_string(), // Prefix pattern
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("suspicious_checksum_4".to_string()),
        },
    ];

    let config = SupplyChainConfig::default();

    // Act
    let result = detect_typosquatting(&dependencies, &config)
        .expect("Typosquatting detection should succeed");

    // Assert
    assert_eq!(
        result.suspicious_dependencies.len(),
        4,
        "Should detect all 4 typosquatting attempts"
    );

    // Verify specific detections
    let names: Vec<_> = result
        .suspicious_dependencies
        .iter()
        .map(|d| d.name.as_str())
        .collect();

    assert!(
        names.contains(&"serda"),
        "Should detect 'serda' as typosquat"
    );
    assert!(
        names.contains(&"toklo"),
        "Should detect 'toklo' as typosquat"
    );
    assert!(
        names.contains(&"clap_rs"),
        "Should detect 'clap_rs' suffix pattern"
    );
    assert!(
        names.contains(&"rust_reqwest"),
        "Should detect 'rust_reqwest' prefix pattern"
    );
}

#[test]
fn test_e2e_license_compliance_mixed_violations() {
    // Arrange: Simulate realistic license distribution with some violations
    let dependencies = vec![
        // Compliant licenses
        Dependency {
            name: "crate-mit".to_string(),
            version: "1.0.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: None,
        },
        Dependency {
            name: "crate-apache".to_string(),
            version: "1.0.0".to_string(),
            license: Some("Apache-2.0".to_string()),
            checksum: None,
        },
        Dependency {
            name: "crate-bsd".to_string(),
            version: "1.0.0".to_string(),
            license: Some("BSD-3-Clause".to_string()),
            checksum: None,
        },
        // Violations
        Dependency {
            name: "bad-crate-gpl".to_string(),
            version: "0.1.0".to_string(),
            license: Some("GPL-3.0".to_string()),
            checksum: None,
        },
        Dependency {
            name: "bad-crate-agpl".to_string(),
            version: "0.1.0".to_string(),
            license: Some("AGPL-3.0".to_string()),
            checksum: None,
        },
    ];

    let config = SupplyChainConfig::default();

    // Act
    let result = check_license_compliance(&dependencies, &config)
        .expect("License compliance check should succeed");

    // Assert
    assert!(
        !result.compliant,
        "Should not be compliant with GPL/AGPL licenses"
    );
    assert_eq!(result.violations.len(), 2, "Should have 2 violations");

    // Verify license distribution
    assert_eq!(result.license_distribution.get("MIT"), Some(&1));
    assert_eq!(result.license_distribution.get("Apache-2.0"), Some(&1));
    assert_eq!(result.license_distribution.get("BSD-3-Clause"), Some(&1));
    assert_eq!(result.license_distribution.get("GPL-3.0"), Some(&1));
    assert_eq!(result.license_distribution.get("AGPL-3.0"), Some(&1));
}

#[test]
fn test_e2e_combined_security_threats() {
    // Arrange: Simulate a worst-case scenario with multiple security issues
    let dependencies = vec![
        // Typosquatting + denied license
        Dependency {
            name: "serda".to_string(),
            version: "0.1.0".to_string(),
            license: Some("GPL-3.0".to_string()),
            checksum: Some("malicious_checksum".to_string()),
        },
        // Suspicious suffix + unknown license
        Dependency {
            name: "crypto_rs".to_string(),
            version: "0.1.0".to_string(),
            license: None,
            checksum: Some("suspicious_checksum".to_string()),
        },
        // Legitimate crate
        Dependency {
            name: "serde".to_string(),
            version: "1.0.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("legitimate_checksum".to_string()),
        },
    ];

    let config = SupplyChainConfig::default();

    // Act: Run both typosquatting and license checks
    let typo_result = detect_typosquatting(&dependencies, &config)
        .expect("Typosquatting detection should succeed");
    let license_result = check_license_compliance(&dependencies, &config)
        .expect("License compliance check should succeed");

    // Assert: Typosquatting detection
    assert_eq!(
        typo_result.suspicious_dependencies.len(),
        2,
        "Should detect 2 suspicious dependencies"
    );

    // Assert: License compliance
    assert!(!license_result.compliant, "Should not be compliant");
    assert_eq!(
        license_result.violations.len(),
        1,
        "Should have 1 GPL violation"
    );
}

#[test]
fn test_e2e_supply_chain_with_large_dependency_tree() {
    // Arrange: Simulate a large dependency tree (100 crates)
    let mut dependencies = Vec::new();

    // Add 95 legitimate crates
    for i in 0..95 {
        dependencies.push(Dependency {
            name: format!("legit-crate-{}", i),
            version: "1.0.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some(format!("checksum_{}", i)),
        });
    }

    // Add 5 malicious crates scattered throughout
    dependencies.insert(
        10,
        Dependency {
            name: "serda".to_string(), // Typo of serde
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("malicious_1".to_string()),
        },
    );

    dependencies.insert(
        30,
        Dependency {
            name: "toklo".to_string(), // Typo of tokio
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("malicious_2".to_string()),
        },
    );

    dependencies.insert(
        50,
        Dependency {
            name: "clap_rs".to_string(), // Suffix pattern
            version: "0.1.0".to_string(),
            license: Some("GPL-3.0".to_string()),
            checksum: Some("malicious_3".to_string()),
        },
    );

    dependencies.insert(
        70,
        Dependency {
            name: "rust_anyhow".to_string(), // Prefix pattern
            version: "0.1.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: Some("malicious_4".to_string()),
        },
    );

    dependencies.insert(
        90,
        Dependency {
            name: "reqwest_rs".to_string(), // Suffix pattern
            version: "0.1.0".to_string(),
            license: Some("AGPL-3.0".to_string()),
            checksum: Some("malicious_5".to_string()),
        },
    );

    let config = SupplyChainConfig::default();

    // Act
    let typo_result = detect_typosquatting(&dependencies, &config)
        .expect("Typosquatting detection should succeed");
    let license_result = check_license_compliance(&dependencies, &config)
        .expect("License compliance check should succeed");

    // Assert: Should find all malicious crates
    assert_eq!(
        typo_result.suspicious_dependencies.len(),
        5,
        "Should detect all 5 malicious crates in large tree"
    );

    assert_eq!(
        license_result.violations.len(),
        2,
        "Should detect 2 license violations (GPL-3.0 and AGPL-3.0)"
    );
}

#[test]
fn test_e2e_custom_security_policy() {
    // Arrange: Use custom security policy with stricter rules
    let dependencies = vec![
        Dependency {
            name: "crate-mit".to_string(),
            version: "1.0.0".to_string(),
            license: Some("MIT".to_string()),
            checksum: None,
        },
        Dependency {
            name: "crate-apache".to_string(),
            version: "1.0.0".to_string(),
            license: Some("Apache-2.0".to_string()),
            checksum: None,
        },
        Dependency {
            name: "crate-bsd".to_string(),
            version: "1.0.0".to_string(),
            license: Some("BSD-3-Clause".to_string()),
            checksum: None,
        },
    ];

    // Custom policy: only MIT and Apache-2.0 allowed
    let config = SupplyChainConfig {
        typosquat_threshold: 1, // Stricter threshold
        denied_licenses: vec!["GPL-3.0".to_string(), "AGPL-3.0".to_string()],
        allowed_licenses: vec!["MIT".to_string(), "Apache-2.0".to_string()],
        popular_crates: vec!["serde".to_string(), "tokio".to_string()],
    };

    // Act
    let result = check_license_compliance(&dependencies, &config)
        .expect("License compliance check should succeed");

    // Assert: BSD-3-Clause should be flagged (not in allowed list)
    assert!(
        !result.compliant,
        "Should not be compliant with strict policy"
    );
    assert_eq!(
        result.violations.len(),
        1,
        "Should have 1 violation (BSD-3-Clause)"
    );
    assert_eq!(result.violations[0].license, "BSD-3-Clause");
}
