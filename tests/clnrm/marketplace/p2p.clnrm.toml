# Marketplace P2P Network Tests with OTEL Validation
# Converts marketplace_p2p_tests.rs to CLNRM format
# Proves execution via 7-layer fake-green detection

[meta]
name = "marketplace_p2p_with_otel_proof"
version = "1.0.0"
description = "Comprehensive P2P network tests with OTEL span validation"

[otel]
exporter = "otlp"
endpoint = "http://localhost:4318"
service_name = "ggen-marketplace-p2p-tests"

[otel.resource]
"service.namespace" = "ggen-marketplace"
"test.suite" = "p2p"

[service.ggen]
plugin = "generic_container"
image = "rust:1.75"
workdir = "/app"
volumes = ["./:/app"]
env.RUST_LOG = "info,ggen=debug"
env.OTEL_EXPORTER_OTLP_ENDPOINT = "http://localhost:4318"

# ============================================================================
# PEER DISCOVERY TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_peer_discovery"
description = "Test P2P peer discovery and connection"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_peer_discovery \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peer.id" = "peer-1" }

[[scenario.expect.span]]
name = "p2p.peer.connect"
attrs.all = {
  "peer.local" = "peer-1",
  "peer.remote" = "bootstrap-peer",
  "connection.status" = "connected"
}

[[scenario.expect.span]]
name = "p2p.peer.verify_connection"
attrs.all = {
  "peer.id" = "peer-1",
  "connected.peers.count" = 1
}

[scenario.expect.status]
all = "OK"

[scenario.expect.graph]
must_have_parent = [
  { child = "p2p.peer.connect", parent = "p2p.network.init" }
]

[scenario.expect.temporal]
must_follow = [
  { later = "p2p.peer.verify_connection", earlier = "p2p.peer.connect" }
]

[[scenario]]
name = "test_p2p_multi_peer_connectivity"
description = "Test mesh network with 5 peers"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_multi_peer_connectivity \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "topology" = "mesh", "peers.count" = 5 }

[scenario.expect.counts]
# Should have 10 connections (5 peers * 4 connections / 2)
"p2p.peer.connect" = { min = 10 }

[scenario.expect.status]
all = "OK"

# Verify each peer has 4 connections
[[scenario.expect.span]]
name = "p2p.network.verify_topology"
attrs.all = { "topology" = "mesh", "verified" = "true" }

# ============================================================================
# PACKAGE PUBLISHING TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_publish_package"
description = "Test publishing package to P2P network"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_publish_package \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peer.id" = "publisher-peer" }

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.all = {
  "package.id" = "p2p-test-package",
  "package.version" = "1.0.0",
  "peer.id" = "publisher-peer"
}

[[scenario.expect.span]]
name = "p2p.dht.put"
attrs.all = {
  "key" = "p2p-test-package",
  "value.type" = "PackageMetadata"
}

[[scenario.expect.span]]
name = "p2p.package.resolve"
attrs.all = {
  "package.id" = "p2p-test-package",
  "found" = "true"
}

[scenario.expect.status]
all = "OK"

[scenario.expect.graph]
must_have_parent = [
  { child = "p2p.package.publish", parent = "p2p.network.init" },
  { child = "p2p.dht.put", parent = "p2p.package.publish" }
]

[scenario.expect.temporal]
must_follow = [
  { later = "p2p.package.resolve", earlier = "p2p.dht.put" }
]

[[scenario]]
name = "test_p2p_package_propagation"
description = "Test package propagation across 3 peers"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_package_propagation \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peers.count" = 3, "topology" = "ring" }

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.all = {
  "package.id" = "propagated-package",
  "peer.id" = "peer-a"
}

[scenario.expect.counts]
# Package should propagate to all 3 peers
"p2p.package.propagate" = { min = 2 }  # 2 propagations (a->b, b->c)
"p2p.package.resolve" = { exact = 3 }  # Verify on all 3 peers

[scenario.expect.status]
all = "OK"

# ============================================================================
# DISTRIBUTED SEARCH TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_distributed_search"
description = "Test distributed search across multiple peers"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_distributed_search \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peers.count" = 3 }

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.any = {
  "package.id" = ["rust-web-server", "python-api", "nodejs-service"]
}

[[scenario.expect.span]]
name = "p2p.search.distributed"
attrs.all = {
  "query" = "rust",
  "peers.queried.gte" = 1,
  "results.count" = 1
}

[scenario.expect.counts]
"p2p.package.publish" = { exact = 3 }  # 3 packages published

[scenario.expect.status]
all = "OK"

[[scenario]]
name = "test_p2p_search_with_timeout"
description = "Test search timeout handling"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_search_with_timeout \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.search"
attrs.all = {
  "query" = "test",
  "timeout.ms" = 1000,
  "error" = "Timeout"
}
status = "ERROR"

[[scenario.expect.span]]
name = "p2p.search"
attrs.all = {
  "query" = "test",
  "timeout.ms" = 3000,
  "status" = "success"
}

[scenario.expect.status]
test = "OK"  # Test passes even with timeout error

# ============================================================================
# DHT OPERATIONS TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_dht_put_get"
description = "Test DHT put and get operations"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_dht_put_get \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.dht.put"
attrs.all = {
  "key" = "dht-test",
  "value.type" = "PackageMetadata"
}

[[scenario.expect.span]]
name = "p2p.dht.get"
attrs.all = {
  "key" = "dht-test",
  "found" = "true"
}

[scenario.expect.status]
all = "OK"

[scenario.expect.temporal]
must_follow = [
  { later = "p2p.dht.get", earlier = "p2p.dht.put" }
]

[[scenario]]
name = "test_p2p_dht_key_distribution"
description = "Test DHT key distribution across 10 peers"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_dht_key_distribution \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peers.count" = 10, "dht.enabled" = "true" }

[scenario.expect.counts]
# 20 packages published
"p2p.dht.put" = { exact = 20 }

[[scenario.expect.span]]
name = "p2p.dht.verify_distribution"
attrs.all = {
  "peers.count" = 10,
  "packages.total" = 20,
  "distribution.balanced" = "true"
}

[scenario.expect.status]
all = "OK"

# ============================================================================
# NETWORK RESILIENCE TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_network_partition_handling"
description = "Test network partition and recovery"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_network_partition_handling \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peer.id" = "resilient-peer" }

[[scenario.expect.span]]
name = "p2p.peer.connect"
attrs.all = { "connected.peers.count" = 3 }

[[scenario.expect.span]]
name = "p2p.network.partition"
attrs.all = {
  "partition.type" = "simulated",
  "disconnected.peers.count" = 3
}

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.all = {
  "package.id" = "partition-test",
  "mode" = "local",  # Published during partition
  "peers.reachable" = 0
}

[[scenario.expect.span]]
name = "p2p.network.heal"
attrs.all = {
  "reconnected.peers.count" = 3
}

[scenario.expect.status]
all = "OK"

[scenario.expect.temporal]
must_follow = [
  { later = "p2p.network.partition", earlier = "p2p.peer.connect" },
  { later = "p2p.package.publish", earlier = "p2p.network.partition" },
  { later = "p2p.network.heal", earlier = "p2p.package.publish" }
]

[[scenario]]
name = "test_p2p_peer_failure_recovery"
description = "Test peer failure and recovery"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_peer_failure_recovery \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peers.count" = 5, "topology" = "ring" }

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.all = { "package.id" = "failure-test" }

[scenario.expect.counts]
# Package propagated to all 5 peers
"p2p.package.propagate" = { min = 4 }

[[scenario.expect.span]]
name = "p2p.peer.failure"
attrs.all = { "peer.id" = "peer-2", "failure.type" = "simulated" }

[[scenario.expect.span]]
name = "p2p.package.resolve"
attrs.all = {
  "package.id" = "failure-test",
  "found" = "true",
  "recovered.from.failure" = "true"
}

[scenario.expect.status]
all = "OK"

# ============================================================================
# PEER REPUTATION TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_peer_reputation_tracking"
description = "Test peer reputation system"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_peer_reputation_tracking \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.reputation.record"
attrs.all = {
  "peer.id" = "good-peer",
  "success.rate.gte" = 0.90
}

[[scenario.expect.span]]
name = "p2p.reputation.record"
attrs.all = {
  "peer.id" = "bad-peer",
  "success.rate.lt" = 0.50
}

[scenario.expect.status]
all = "OK"

# ============================================================================
# PERFORMANCE AND STRESS TESTS
# ============================================================================

[[scenario]]
name = "test_p2p_concurrent_publishes"
description = "Test 100 concurrent package publishes"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_concurrent_publishes \
  -- --nocapture
"""

[scenario.expect.counts]
# Should have 100 concurrent publish operations
"p2p.package.publish" = { exact = 100 }

[scenario.expect.status]
all = "OK"

[scenario.expect.graph]
# All publishes should be siblings (concurrent)
siblings = [
  { spans = ["p2p.package.publish"], min_count = 100 }
]

[[scenario]]
name = "test_p2p_large_network_scalability"
description = "Test network with 50 peers"
service = "ggen"
run = """
cargo test --test marketplace_tests_main \
  integration::marketplace_p2p_tests::test_p2p_large_network_scalability \
  -- --nocapture
"""

[[scenario.expect.span]]
name = "p2p.network.init"
attrs.all = { "peers.count" = 50 }

[[scenario.expect.span]]
name = "p2p.package.publish"
attrs.all = {
  "package.id" = "scalability-test",
  "network.size" = 50
}

[scenario.expect.status]
all = "OK"

# ============================================================================
# REPORT GENERATION
# ============================================================================

[report]
output = "tests/clnrm/reports/marketplace_p2p_report.json"
format = "json"
include_spans = true
include_metrics = true

[report.sha256]
enabled = true
algorithm = "SHA-256"
digest_file = "tests/clnrm/reports/marketplace_p2p_digest.txt"

[report.metrics]
total_peer_connections = { path = "$.scenarios[*].spans[?(@.name=='p2p.peer.connect')].length()" }
total_publishes = { path = "$.scenarios[*].spans[?(@.name=='p2p.package.publish')].length()" }
total_propagations = { path = "$.scenarios[*].spans[?(@.name=='p2p.package.propagate')].length()" }
avg_publish_duration_ms = { path = "$.scenarios[*].spans[?(@.name=='p2p.package.publish')].duration_ms.avg()" }
network_resilience_tests = { path = "$.scenarios[*].spans[?(@.name=='p2p.network.partition')].length()" }
success_rate = { path = "$.scenarios[*].status[?(@=='OK')].length() / $.scenarios.length()" }

# ============================================================================
# 7-LAYER FAKE-GREEN DETECTION SUMMARY
# ============================================================================

[validation]
layers = [
  "lifecycle_events",    # 1. Container start/exec events
  "span_graphs",         # 2. Parent-child relationships
  "span_counts",         # 3. Operation count verification
  "temporal_ordering",   # 4. must_precede/must_follow
  "window_containment",  # 5. Child spans within parent duration
  "status_validation",   # 6. All spans = "OK"
  "hermeticity"          # 7. No external services (except localhost OTLP)
]

[validation.lifecycle_events]
required = ["container.start", "container.exec", "test.run", "p2p.network.init"]

[validation.span_graphs]
verify_parent_child = true
verify_siblings = true

[validation.span_counts]
verify_exact_counts = true
verify_min_counts = true

[validation.temporal_ordering]
verify_must_follow = true

[validation.window_containment]
verify_child_within_parent = true

[validation.status_validation]
all_must_be_ok = true
allow_expected_errors = true

[validation.hermeticity]
no_external_services = true
allowed_localhost = ["4318"]
allowed_p2p_local_network = true
