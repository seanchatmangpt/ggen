use super::super::world::GgenWorld;
use cucumber::{given, then, when};

// Multi-language step definitions

#[given(regex = r"^I have a (.+) template$")]
fn have_language_template(world: &mut GgenWorld, language: String) {
    use std::fs;

    let template_content = match language.as_str() {
        "Rust" => {
            r#"---
to: "src/{{name}}.rs"
vars: ["name"]
---

pub struct {{name}} {
    // Generated by ggen
}

impl {{name}} {
    pub fn new() -> Self {
        Self {}
    }
}
"#
        }
        "Python" => {
            r#"---
to: "{{name}}.py"
vars: ["name"]
---

class {{name}}:
    """Generated by ggen"""
    
    def __init__(self):
        pass
"#
        }
        "TypeScript" => {
            r#"---
to: "{{name}}.ts"
vars: ["name"]
---

export class {{name}} {
    // Generated by ggen
    
    constructor() {
        // Implementation
    }
}
"#
        }
        _ => {
            r#"---
to: "{{name}}.txt"
vars: ["name"]
---

{{name}} - Generated by ggen
"#
        }
    };

    let template_path = world
        .project_dir
        .join(format!("{}.tmpl", language.to_lowercase()));
    #[allow(clippy::expect_used)]
    fs::write(&template_path, template_content).expect("Failed to write template");
}

#[when(regex = r"^I generate (.+) code$")]
fn generate_language_code(world: &mut GgenWorld, language: String) {
    use assert_cmd::Command;
    let template_path = format!("{}.tmpl", language.to_lowercase());

    let output = Command::cargo_bin("ggen")
        #[allow(clippy::expect_used)]
        .expect("ggen binary not found")
        .arg("gen")
        .arg(&template_path)
        .arg("--name")
        .arg("TestClass")
        .current_dir(&world.project_dir)
        .output()
        #[allow(clippy::expect_used)]
        .expect("Failed to run ggen gen");

    world.last_output = Some(output.clone());
    world.last_exit_code = output.status.code();
}

#[then(regex = r"^I should have valid (.+) code$")]
fn should_have_valid_language_code(world: &mut GgenWorld, language: String) {
    use std::fs;

    let expected_file = match language.as_str() {
        "Rust" => "src/TestClass.rs",
        "Python" => "TestClass.py",
        "TypeScript" => "TestClass.ts",
        _ => "TestClass.txt",
    };

    let file_path = world.project_dir.join(expected_file);
    assert!(
        file_path.exists(),
        "Generated {} file should exist",
        language
    );

    #[allow(clippy::expect_used)]
    let content = fs::read_to_string(&file_path).expect("Failed to read generated file");
    assert!(
        content.contains("TestClass"),
        "Generated file should contain class name"
    );
    assert!(
        content.contains("Generated by ggen"),
        "Generated file should contain marker"
    );
}

// ============================================================================
// Missing step definitions for multi_language.feature
// ============================================================================

// REMOVED: Generic step definition causing ambiguity
// Specific noun-verb steps should be used instead
