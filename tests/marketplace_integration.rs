use anyhow::Result;
use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

use rgen::mock_registry::MockGitHubRegistry;

/// Integration test for the complete marketplace workflow
#[test]
fn test_marketplace_workflow() -> Result<()> {
    // Setup: Create a temporary project directory
    let project_dir = TempDir::new()?;
    let project_path = project_dir.path();
    
    // Setup: Create mock GitHub registry
    let mock_registry = MockGitHubRegistry::new()?;
    
    // Step 1: Simulate searching for rpacks
    let search_results = simulate_search(&mock_registry, "rust")?;
    assert!(!search_results.is_empty());
    assert!(search_results.iter().any(|p| p.contains("rust")));
    
    // Step 2: Simulate adding an rpack
    let rpack_id = "io.rgen.rust.cli-subcommand";
    let rpack_version = "0.2.0";
    
    // Create mock rpack repository
    let rpack_dir = mock_registry.create_mock_rpack(rpack_id, rpack_version)?;
    
    // Simulate downloading and caching the rpack
    let cache_dir = project_path.join(".rgen").join("rpacks");
    fs::create_dir_all(&cache_dir)?;
    
    // Copy the mock rpack to cache (simulating git clone)
    let cached_rpack_dir = cache_dir.join(rpack_id).join(rpack_version);
    fs::create_dir_all(&cached_rpack_dir)?;
    copy_dir_all(&rpack_dir, &cached_rpack_dir)?;
    
    // Step 3: Simulate creating/updating lockfile
    let lockfile_path = project_path.join("rgen.lock");
    let lockfile_content = format!(
        r#"[[pack]]
id = "{}"
version = "{}"
sha256 = "mock_sha256_hash"
source = "https://github.com/mock/rpack-rust-cli.git#def456ghi789"
"#,
        rpack_id, rpack_version
    );
    fs::write(&lockfile_path, lockfile_content)?;
    
    // Step 4: Simulate using the rpack template
    let template_path = cached_rpack_dir.join("templates").join("main.tmpl");
    assert!(template_path.exists());
    
    // Simulate template generation
    let template_content = fs::read_to_string(&template_path)?;
    assert!(template_content.contains("Generated by rpack:"));
    
    // Step 5: Simulate listing installed rpacks
    let installed_packs = simulate_list_packs(&lockfile_path)?;
    assert_eq!(installed_packs.len(), 1);
    assert_eq!(installed_packs[0].id, rpack_id);
    assert_eq!(installed_packs[0].version, rpack_version);
    
    // Step 6: Simulate removing an rpack
    simulate_remove_pack(&lockfile_path, rpack_id)?;
    let remaining_packs = simulate_list_packs(&lockfile_path)?;
    assert!(remaining_packs.is_empty());
    
    Ok(())
}

/// Simulate searching for rpacks in the registry
fn simulate_search(registry: &MockGitHubRegistry, query: &str) -> Result<Vec<String>> {
    let index_content = registry.index_content()?;
    let data: serde_json::Value = serde_json::from_str(&index_content)?;
    
    let mut results = Vec::new();
    if let Some(rpacks) = data["rpacks"].as_array() {
        for pack in rpacks {
            let id = pack["id"].as_str().unwrap_or("");
            let name = pack["name"].as_str().unwrap_or("");
            let description = pack["description"].as_str().unwrap_or("");
            let tags = pack["tags"].as_array()
                .map(|tags| tags.iter()
                    .filter_map(|tag| tag.as_str())
                    .collect::<Vec<_>>()
                    .join(", "))
                .unwrap_or_default();
            
            // Simple search logic
            if id.to_lowercase().contains(&query.to_lowercase()) ||
               name.to_lowercase().contains(&query.to_lowercase()) ||
               description.to_lowercase().contains(&query.to_lowercase()) ||
               tags.to_lowercase().contains(&query.to_lowercase()) {
                results.push(id.to_string());
            }
        }
    }
    
    Ok(results)
}

/// Simulate listing installed rpacks from lockfile
fn simulate_list_packs(lockfile_path: &PathBuf) -> Result<Vec<InstalledPack>> {
    if !lockfile_path.exists() {
        return Ok(Vec::new());
    }
    
    let content = fs::read_to_string(lockfile_path)?;
    let mut packs = Vec::new();
    
    // Simple TOML parsing for test
    let mut current_id = String::new();
    let mut current_version = String::new();
    
    for line in content.lines() {
        if line.starts_with("id = ") {
            current_id = line.trim_start_matches("id = \"").trim_end_matches("\"").to_string();
        } else if line.starts_with("version = ") {
            current_version = line.trim_start_matches("version = \"").trim_end_matches("\"").to_string();
            if !current_id.is_empty() {
                packs.push(InstalledPack {
                    id: current_id.clone(),
                    version: current_version.clone(),
                });
                current_id.clear();
                current_version.clear();
            }
        }
    }
    
    Ok(packs)
}

/// Simulate removing a pack from lockfile
fn simulate_remove_pack(lockfile_path: &PathBuf, pack_id: &str) -> Result<()> {
    if !lockfile_path.exists() {
        return Ok(());
    }
    
    let content = fs::read_to_string(lockfile_path)?;
    let mut lines: Vec<&str> = content.lines().collect();
    let mut new_lines = Vec::new();
    let mut skip_pack = false;
    
    for line in lines {
        if line.starts_with("[[pack]]") {
            skip_pack = false;
        } else if line.starts_with(&format!("id = \"{}\"", pack_id)) {
            skip_pack = true;
            continue;
        }
        
        if !skip_pack {
            new_lines.push(line);
        }
    }
    
    let new_content = new_lines.join("\n");
    fs::write(lockfile_path, new_content)?;
    
    Ok(())
}

/// Helper struct for installed pack info
#[derive(Debug, PartialEq)]
struct InstalledPack {
    id: String,
    version: String,
}

/// Helper function to copy directory recursively
fn copy_dir_all(src: &PathBuf, dst: &PathBuf) -> Result<()> {
    fs::create_dir_all(dst)?;
    
    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let ty = entry.file_type()?;
        
        if ty.is_dir() {
            copy_dir_all(&entry.path(), &dst.join(entry.file_name()))?;
        } else {
            fs::copy(entry.path(), dst.join(entry.file_name()))?;
        }
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search_simulation() {
        let registry = MockGitHubRegistry::new().unwrap();
        
        // Test searching for "rust"
        let rust_results = simulate_search(&registry, "rust").unwrap();
        assert!(!rust_results.is_empty());
        assert!(rust_results.contains(&"io.rgen.rust.cli-subcommand".to_string()));
        
        // Test searching for "python"
        let python_results = simulate_search(&registry, "python").unwrap();
        assert!(!python_results.is_empty());
        assert!(python_results.contains(&"io.rgen.python.fastapi".to_string()));
        
        // Test searching for non-existent term
        let empty_results = simulate_search(&registry, "nonexistent").unwrap();
        assert!(empty_results.is_empty());
    }

    #[test]
    fn test_lockfile_operations() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("rgen.lock");
        
        // Test empty lockfile
        let packs = simulate_list_packs(&lockfile_path).unwrap();
        assert!(packs.is_empty());
        
        // Create a lockfile with some packs
        let lockfile_content = r#"[[pack]]
id = "io.rgen.test1"
version = "0.1.0"
sha256 = "hash1"
source = "https://github.com/test1.git#abc123"

[[pack]]
id = "io.rgen.test2"
version = "0.2.0"
sha256 = "hash2"
source = "https://github.com/test2.git#def456"
"#;
        fs::write(&lockfile_path, lockfile_content).unwrap();
        
        // Test listing packs
        let packs = simulate_list_packs(&lockfile_path).unwrap();
        assert_eq!(packs.len(), 2);
        assert_eq!(packs[0].id, "io.rgen.test1");
        assert_eq!(packs[1].id, "io.rgen.test2");
        
        // Test removing a pack
        simulate_remove_pack(&lockfile_path, "io.rgen.test1").unwrap();
        let remaining_packs = simulate_list_packs(&lockfile_path).unwrap();
        assert_eq!(remaining_packs.len(), 1);
        assert_eq!(remaining_packs[0].id, "io.rgen.test2");
    }
}
