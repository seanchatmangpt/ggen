//! # ggen-cleanroom
//!
//! Production-ready cleanroom testing utilities for isolated, deterministic validation.
//!
//! ## Generated by ggen (Dogfooding)
//!
//! This crate was generated using ggen's own AI project generation to demonstrate
//! dogfooding - using ggen to build ggen.
//!
//! ## Features
//!
//! - **Isolated Testing**: Temporary filesystem isolation with TempDir
//! - **Performance Metrics**: Comprehensive benchmarking and performance tracking
//! - **Validation Suite**: Trait-based validation system for extensible testing
//! - **Configuration**: Builder pattern for flexible test configuration
//! - **Error Handling**: Production-ready error handling with thiserror
//! - **Deterministic**: Same inputs produce identical results
//! - **Zero Dependencies**: No container or database dependencies
//!
//! ## Example
//!
//! ```rust,no_run
//! use cleanroom::{CleanroomEnv, CleanroomConfig, TestStatus};
//!
//! #[test]
//! fn test_with_cleanroom() {
//!     let config = CleanroomConfig::default();
//!     let mut env = CleanroomEnv::new(config)
//!         .expect("Failed to create cleanroom");
//!
//!     let result = env.run_test(|env| {
//!         env.write_file("test.txt", "Hello, cleanroom!")?;
//!         let content = env.read_file("test.txt")?;
//!         assert_eq!(content, "Hello, cleanroom!");
//!         Ok(())
//!     });
//!
//!     assert!(result.status == TestStatus::Passed);
//! }
//! ```

pub mod environment;
pub mod config;
pub mod validation;
pub mod performance;
pub mod error;

// Re-export core types
pub use environment::{CleanroomEnv, TestResult, TestStatus};
pub use config::{CleanroomConfig, CleanroomConfigBuilder};
pub use validation::{ValidationResult, ValidationSuite, Validator};
pub use performance::{PerformanceMetrics, Benchmark};
pub use error::{CleanroomError, Result};

/// Version of the ggen-cleanroom crate
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Framework name
pub const FRAMEWORK_NAME: &str = "ggen-cleanroom";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cleanroom_basics() {
        let config = CleanroomConfig::default();
        let env = CleanroomEnv::new(config).expect("Failed to create cleanroom");

        assert!(env.path().exists());
        assert!(env.test_id().to_string().len() > 0);
    }

    #[test]
    fn test_cleanroom_file_operations() {
        let config = CleanroomConfig::default();
        let env = CleanroomEnv::new(config).expect("Failed to create cleanroom");

        let path = env.write_file("test.txt", "content").expect("Failed to write");
        assert!(path.exists());

        let content = env.read_file("test.txt").expect("Failed to read");
        assert_eq!(content, "content");
    }

    #[test]
    fn test_cleanroom_test_execution() {
        let config = CleanroomConfig::default();
        let mut env = CleanroomEnv::new(config).expect("Failed to create cleanroom");

        let result = env.run_test(|env| {
            env.write_file("test.txt", "test")?;
            let content = env.read_file("test.txt")?;
            assert_eq!(content, "test");
            Ok(())
        });

        assert_eq!(result.status, TestStatus::Passed);
    }

    #[test]
    fn test_performance_metrics() {
        let mut metrics = PerformanceMetrics::new();
        metrics.record("test_metric", 42.0);
        assert_eq!(metrics.get("test_metric"), Some(42.0));
    }

    #[test]
    fn test_benchmark() {
        let mut bench = Benchmark::new("test");
        bench.record_iteration(10);
        bench.record_iteration(20);
        assert_eq!(bench.iterations, 2);
        assert_eq!(bench.avg_ms, 15.0);
    }
}
