@startuml data-transformation
!theme blueprint

title Data Transformation Pipeline - Operations & Flow

' Define source data
rectangle "Source Data" as SourceData {
    class CSVRecord {
        + id: String
        + firstName: String
        + lastName: String
        + email: String
        + age: Integer
        + status: String
        + country: String
        + amount: Decimal
    }
}

' Define transformation stages
rectangle "Transformation Pipeline" as TransformPipeline {

    package "1. Mapping Transform" as MapStage {
        class Mapper {
            + sourceField: String
            + targetField: String
            + typeConverter: Function
            --
            + map(record): MappedRecord
        }

        note right of Mapper
            **Field Mappings:**
            firstName -> foaf:givenName
            lastName -> foaf:familyName
            email -> foaf:mbox
            age -> foaf:age (Integer)
            country -> schema:addressCountry
        end note
    }

    package "2. Filter Transform" as FilterStage {
        class Filter {
            + condition: Expression
            + filterMode: FilterMode
            --
            + evaluate(record): Boolean
        }

        note right of Filter
            **Filter Conditions:**
            - status == 'active'
            - age >= 18
            - country in ['US', 'UK', 'CA']
            - email is not null
        end note
    }

    package "3. Aggregate Transform" as AggStage {
        class Aggregator {
            + groupByFields: List<String>
            + aggFunctions: List<AggFunc>
            --
            + aggregate(records): AggregatedRecord
        }

        note right of Aggregator
            **Aggregations:**
            GROUP BY: country
            - COUNT(*) as user_count
            - SUM(amount) as total_amount
            - AVG(age) as avg_age
            - MAX(amount) as max_amount
        end note
    }

    package "4. Join Transform" as JoinStage {
        class Joiner {
            + leftSource: DataSource
            + rightSource: DataSource
            + joinType: JoinType
            + joinCondition: Expression
            --
            + join(left, right): JoinedRecord
        }

        note right of Joiner
            **Join Operation:**
            LEFT: users
            RIGHT: orders
            TYPE: INNER JOIN
            ON: users.id = orders.user_id
        end note
    }

    package "5. Validation Transform" as ValidateStage {
        class Validator {
            + validationRules: List<Rule>
            + failureMode: FailureMode
            --
            + validate(record): ValidationResult
        }

        note right of Validator
            **Validation Rules:**
            - email matches regex
            - age between 0 and 120
            - amount >= 0
            - country in country_codes
            - required fields present
        end note
    }
}

' Define output data
rectangle "Transformed Data" as OutputData {
    class RDFTriple {
        + subject: URI
        + predicate: URI
        + object: Literal | URI
        --
        + serialize(): String
    }

    class AggregatedResult {
        + groupKey: Map<String, Value>
        + aggregates: Map<String, Value>
    }
}

' Define supporting classes
package "Supporting Components" {
    enum FilterMode {
        INCLUDE
        EXCLUDE
    }

    enum JoinType {
        INNER
        LEFT
        RIGHT
        FULL
    }

    enum FailureMode {
        SKIP
        FAIL
        LOG_AND_CONTINUE
    }

    class AggFunc {
        + function: String
        + field: String
        + alias: String
    }

    class ValidationResult {
        + valid: Boolean
        + errors: List<String>
        + warnings: List<String>
    }
}

' Data flow
CSVRecord --> Mapper: Raw record
Mapper --> Filter: Mapped record
Filter --> Aggregator: Filtered record
Aggregator --> Joiner: Aggregated record
Joiner --> Validator: Joined record
Validator --> RDFTriple: Validated record
Validator --> AggregatedResult: Validated aggregates

' Component relationships
Mapper ..> Filter: outputs to
Filter ..> Aggregator: outputs to
Aggregator ..> Joiner: outputs to
Joiner ..> Validator: outputs to

Filter --> FilterMode: uses
Joiner --> JoinType: uses
Aggregator --> AggFunc: uses
Validator --> FailureMode: uses
Validator --> ValidationResult: produces

note bottom of TransformPipeline
    **Transformation Pipeline Benefits:**
    - Composable: Chain transforms together
    - Reusable: Define once, use in multiple pipelines
    - Testable: Each transform can be tested independently
    - Performant: Parallel execution & batch processing
    - Fault-tolerant: Error handling at each stage
end note

@enduml
