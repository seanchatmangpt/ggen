---
to: "src/api/{{ name | lower }}.rs"
inject: false
---
//! {{ name }} API endpoint
//!
//! Generated by ggen AI-powered code generation
//! Specification: data/api-spec.ttl

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    db::DbPool,
    error::AppError,
    models::{{ name | lower }}::{{ name }},
};

// ============================================================================
// Request/Response Types (80/20: Focus on core data structures)
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct Create{{ name }}Request {
    // TODO: Add fields from SPARQL specification
    pub name: String,
}

#[derive(Debug, Serialize)]
pub struct {{ name }}Response {
    pub id: Uuid,
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

// ============================================================================
// Handlers (80/20: Core CRUD operations)
// ============================================================================

/// Create new {{ name | lower }}
#[tracing::instrument(skip(pool))]
pub async fn create(
    State(pool): State<DbPool>,
    Json(payload): Json<Create{{ name }}Request>,
) -> Result<impl IntoResponse, AppError> {
    // Input validation (CRITICAL for production)
    if payload.name.is_empty() {
        return Err(AppError::BadRequest("Name cannot be empty".into()));
    }

    // Database operation with proper error handling
    let {{ name | lower }} = {{ name }}::create(&pool, payload.name).await?;

    tracing::info!({{ name | lower }}_id = %{{ name | lower }}.id, "Created {{ name | lower }}");

    Ok((StatusCode::CREATED, Json({{name}}Response {
        id: {{ name | lower }}.id,
        name: {{ name | lower }}.name,
        created_at: {{ name | lower }}.created_at,
    })))
}

/// Get {{ name | lower }} by ID
#[tracing::instrument(skip(pool))]
pub async fn get(
    State(pool): State<DbPool>,
    Path(id): Path<Uuid>,
) -> Result<impl IntoResponse, AppError> {
    let {{ name | lower }} = {{ name }}::find_by_id(&pool, id).await?
        .ok_or(AppError::NotFound(format!("{{ name }} not found: {}", id)))?;

    Ok(Json({{ name }}Response {
        id: {{ name | lower }}.id,
        name: {{ name | lower }}.name,
        created_at: {{ name | lower }}.created_at,
    }))
}

/// List all {{ name | lower }}s with pagination
#[tracing::instrument(skip(pool))]
pub async fn list(
    State(pool): State<DbPool>,
) -> Result<impl IntoResponse, AppError> {
    let {{ name | lower }}s = {{ name }}::list(&pool).await?;

    let response: Vec<{{ name }}Response> = {{ name | lower }}s.into_iter()
        .map(|{{ name | lower }}| {{ name }}Response {
            id: {{ name | lower }}.id,
            name: {{ name | lower }}.name,
            created_at: {{ name | lower }}.created_at,
        })
        .collect();

    Ok(Json(response))
}

/// Update {{ name | lower }}
#[tracing::instrument(skip(pool))]
pub async fn update(
    State(pool): State<DbPool>,
    Path(id): Path<Uuid>,
    Json(payload): Json<Create{{ name }}Request>,
) -> Result<impl IntoResponse, AppError> {
    // Input validation
    if payload.name.is_empty() {
        return Err(AppError::BadRequest("Name cannot be empty".into()));
    }

    let {{ name | lower }} = {{ name }}::update(&pool, id, payload.name).await?
        .ok_or(AppError::NotFound(format!("{{ name }} not found: {}", id)))?;

    tracing::info!({{ name | lower }}_id = %id, "Updated {{ name | lower }}");

    Ok(Json({{ name }}Response {
        id: {{ name | lower }}.id,
        name: {{ name | lower }}.name,
        created_at: {{ name | lower }}.created_at,
    }))
}

/// Delete {{ name | lower }}
#[tracing::instrument(skip(pool))]
pub async fn delete(
    State(pool): State<DbPool>,
    Path(id): Path<Uuid>,
) -> Result<impl IntoResponse, AppError> {
    {{ name }}::delete(&pool, id).await?;

    tracing::info!({{ name | lower }}_id = %id, "Deleted {{ name | lower }}");

    Ok(StatusCode::NO_CONTENT)
}

// ============================================================================
// Router Configuration
// ============================================================================

pub fn router() -> axum::Router<DbPool> {
    axum::Router::new()
        .route("/", axum::routing::post(create))
        .route("/", axum::routing::get(list))
        .route("/:id", axum::routing::get(get))
        .route("/:id", axum::routing::put(update))
        .route("/:id", axum::routing::delete(delete))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_{{ name | lower }}_request_validation() {
        let request = Create{{ name }}Request {
            name: "Test".to_string(),
        };
        assert!(!request.name.is_empty());
    }
}
