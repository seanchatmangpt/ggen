---
to: "lib/definitions/tasks.mjs"
description: ESM task definitions generated from YAWL ontology
vars:
  specId: string
  taskId: string
  taskName: string
metadata:
  category: definitions
  framework: esm
  features: [zod-validation]
---
{# =============================================================================
   TASK DEFINITIONS TEMPLATE
   Generates ESM task definitions from RDF task specifications
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Task Definitions
 * Generated from RDF ontology specifications
 * DO NOT EDIT - auto-generated by ggen sync
 * @module tasks
 */

import { z } from 'zod';

// =============================================================================
// Task Kind Enumeration
// =============================================================================

export const TaskKind = {
  ATOMIC: 'atomic',
  COMPOSITE: 'composite',
  MULTIPLE_INSTANCE: 'multiple-instance',
  AUTOMATED: 'automated',
  MANUAL: 'manual',
};

export const TaskKindSchema = z.enum(['atomic', 'composite', 'multiple-instance', 'automated', 'manual']);

// =============================================================================
// Split/Join Behavior Enumerations
// =============================================================================

export const SplitBehavior = {
  XOR: 'XOR',
  AND: 'AND',
  OR: 'OR',
};

export const SplitBehaviorSchema = z.enum(['XOR', 'AND', 'OR']);

export const JoinBehavior = {
  XOR: 'XOR',
  AND: 'AND',
  OR: 'OR',
};

export const JoinBehaviorSchema = z.enum(['XOR', 'AND', 'OR']);

// =============================================================================
// Multiple Instance Configuration
// =============================================================================

export const MultipleInstanceConfigSchema = z.object({
  minimum: z.number().int().min(1),
  maximum: z.number().int().min(1),
  threshold: z.number().int().min(1),
  creationMode: z.enum(['static', 'dynamic']),
});

// =============================================================================
// Task Definition Schema
// =============================================================================

export const TaskDefinitionSchema = z.object({
  taskId: z.string().min(1),
  taskName: z.string().min(1),
  taskKind: TaskKindSchema,
  description: z.string().optional(),
  splitBehavior: SplitBehaviorSchema.optional().default('XOR'),
  joinBehavior: JoinBehaviorSchema.optional().default('XOR'),
  miConfig: MultipleInstanceConfigSchema.optional(),
  decomposesTo: z.string().optional(),
  cancellationSet: z.array(z.string()).optional(),
  inputParameters: z.record(z.unknown()).optional(),
  outputParameters: z.record(z.unknown()).optional(),
});

// =============================================================================
// Generated Task Definitions by Workflow
// =============================================================================

{%- set current_spec = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- set taskId = row["?taskId"] | default(value="") %}
{%- set taskName = row["?taskName"] | default(value="") %}
{%- set taskKind = row["?taskKind"] | default(value="atomic") %}
{%- set splitBehavior = row["?splitBehavior"] | default(value="XOR") %}
{%- set joinBehavior = row["?joinBehavior"] | default(value="XOR") %}
{%- set taskComment = row["?taskComment"] | default(value="") %}
{%- set miMinimum = row["?miMinimum"] | default(value="") %}
{%- set miMaximum = row["?miMaximum"] | default(value="") %}
{%- set miThreshold = row["?miThreshold"] | default(value="") %}
{%- set miCreationMode = row["?miCreationMode"] | default(value="") %}

{%- if specId != current_spec and specId != "" %}
{%- if current_spec != "" %}
];

{%- endif %}
{%- set_global current_spec = specId %}
// -----------------------------------------------------------------------------
// {{ specId | replace(from="-", to=" ") | title }} Tasks
// -----------------------------------------------------------------------------

export const {{ specId | replace(from="-", to="_") | upper }}_TASKS = [
{%- endif %}

{%- if taskId != "" %}
  {
    taskId: '{{ taskId }}',
    taskName: '{{ taskName }}',
    taskKind: '{{ taskKind }}',
{%- if taskComment != "" %}
    description: '{{ taskComment | replace(from="'", to="\\'") }}',
{%- endif %}
    splitBehavior: '{{ splitBehavior | default(value="XOR") }}',
    joinBehavior: '{{ joinBehavior | default(value="XOR") }}',
{%- if miMinimum != "" %}
    miConfig: {
      minimum: {{ miMinimum }},
      maximum: {{ miMaximum | default(value="10") }},
      threshold: {{ miThreshold | default(value="1") }},
      creationMode: '{{ miCreationMode | default(value="static") }}',
    },
{%- endif %}
  },
{%- endif %}
{%- endfor %}
];

// =============================================================================
// Task Registry
// =============================================================================

export class TaskRegistry {
  /** @type {Map<string, Map<string, object>>} */
  #tasks = new Map();

  constructor() {
    this.#registerWorkflowTasks();
  }

  #registerWorkflowTasks() {
{%- set seen_specs = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- if specId != "" and specId not in seen_specs %}
{%- set_global seen_specs = seen_specs ~ "," ~ specId %}
    this.#registerTasks('{{ specId }}', {{ specId | replace(from="-", to="_") | upper }}_TASKS);
{%- endif %}
{%- endfor %}
  }

  /**
   * @param {string} specId
   * @param {Array} tasks
   */
  #registerTasks(specId, tasks) {
    const taskMap = new Map();
    for (const task of tasks) {
      taskMap.set(task.taskId, task);
    }
    this.#tasks.set(specId, taskMap);
  }

  /**
   * Get task definition by workflow and task ID
   * @param {string} specId
   * @param {string} taskId
   * @returns {object|undefined}
   */
  getTask(specId, taskId) {
    return this.#tasks.get(specId)?.get(taskId);
  }

  /**
   * Get all tasks for a workflow
   * @param {string} specId
   * @returns {Array}
   */
  getWorkflowTasks(specId) {
    const taskMap = this.#tasks.get(specId);
    return taskMap ? Array.from(taskMap.values()) : [];
  }

  /**
   * Get all registered workflow IDs
   * @returns {string[]}
   */
  getWorkflowIds() {
    return Array.from(this.#tasks.keys());
  }

  /**
   * Validate task definition
   * @param {unknown} task
   * @returns {object}
   */
  validateTask(task) {
    return TaskDefinitionSchema.parse(task);
  }
}

// =============================================================================
// Singleton Instance
// =============================================================================

export const taskRegistry = new TaskRegistry();

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Check if a task is a multiple instance task
 * @param {object} task
 * @returns {boolean}
 */
export function isMultipleInstanceTask(task) {
  return task.taskKind === 'multiple-instance' && !!task.miConfig;
}

/**
 * Check if a task requires human interaction
 * @param {object} task
 * @returns {boolean}
 */
export function isManualTask(task) {
  return task.taskKind === 'manual';
}

/**
 * Check if a task is automated
 * @param {object} task
 * @returns {boolean}
 */
export function isAutomatedTask(task) {
  return task.taskKind === 'automated';
}

/**
 * Get the split pattern name (Van der Aalst pattern)
 * @param {string} behavior
 * @returns {string}
 */
export function getSplitPatternName(behavior) {
  switch (behavior) {
    case 'XOR': return 'WP4: Exclusive Choice';
    case 'AND': return 'WP2: Parallel Split';
    case 'OR': return 'WP6: Multi-Choice';
    default: return 'Unknown';
  }
}

/**
 * Get the join pattern name (Van der Aalst pattern)
 * @param {string} behavior
 * @returns {string}
 */
export function getJoinPatternName(behavior) {
  switch (behavior) {
    case 'XOR': return 'WP5: Simple Merge';
    case 'AND': return 'WP3: Synchronization';
    case 'OR': return 'WP7: Structured Synchronizing Merge';
    default: return 'Unknown';
  }
}
