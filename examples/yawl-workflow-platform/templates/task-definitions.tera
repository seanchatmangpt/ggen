---
to: "lib/definitions/tasks.ts"
description: TypeScript task definitions generated from YAWL ontology
vars:
  specId: string
  taskId: string
  taskName: string
metadata:
  category: definitions
  framework: typescript
  features: [zod-validation, type-safety]
---
{# =============================================================================
   TASK DEFINITIONS TEMPLATE
   Generates TypeScript task definitions from RDF task specifications
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Task Definitions
 * Generated from RDF ontology specifications
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { z } from 'zod';

// =============================================================================
// Task Kind Enumeration
// =============================================================================

export const TaskKind = {
  ATOMIC: 'atomic',
  COMPOSITE: 'composite',
  MULTIPLE_INSTANCE: 'multiple-instance',
  AUTOMATED: 'automated',
  MANUAL: 'manual',
} as const;

export type TaskKind = typeof TaskKind[keyof typeof TaskKind];

// =============================================================================
// Split/Join Behavior Enumerations
// =============================================================================

export const SplitBehavior = {
  XOR: 'XOR',
  AND: 'AND',
  OR: 'OR',
} as const;

export type SplitBehavior = typeof SplitBehavior[keyof typeof SplitBehavior];

export const JoinBehavior = {
  XOR: 'XOR',
  AND: 'AND',
  OR: 'OR',
} as const;

export type JoinBehavior = typeof JoinBehavior[keyof typeof JoinBehavior];

// =============================================================================
// Multiple Instance Configuration
// =============================================================================

export const MultipleInstanceConfigSchema = z.object({
  minimum: z.number().int().min(1),
  maximum: z.number().int().min(1),
  threshold: z.number().int().min(1),
  creationMode: z.enum(['static', 'dynamic']),
});

export type MultipleInstanceConfig = z.infer<typeof MultipleInstanceConfigSchema>;

// =============================================================================
// Task Definition Schema
// =============================================================================

export const TaskDefinitionSchema = z.object({
  taskId: z.string().min(1),
  taskName: z.string().min(1),
  taskKind: z.enum(['atomic', 'composite', 'multiple-instance', 'automated', 'manual']),
  description: z.string().optional(),
  splitBehavior: z.enum(['XOR', 'AND', 'OR']).optional().default('XOR'),
  joinBehavior: z.enum(['XOR', 'AND', 'OR']).optional().default('XOR'),
  miConfig: MultipleInstanceConfigSchema.optional(),
  decomposesTo: z.string().optional(),
  cancellationSet: z.array(z.string()).optional(),
  inputParameters: z.record(z.unknown()).optional(),
  outputParameters: z.record(z.unknown()).optional(),
});

export type TaskDefinition = z.infer<typeof TaskDefinitionSchema>;

// =============================================================================
// Generated Task Definitions by Workflow
// =============================================================================

{%- set current_spec = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- set taskId = row["?taskId"] | default(value="") %}
{%- set taskName = row["?taskName"] | default(value="") %}
{%- set taskKind = row["?taskKind"] | default(value="atomic") %}
{%- set splitBehavior = row["?splitBehavior"] | default(value="XOR") %}
{%- set joinBehavior = row["?joinBehavior"] | default(value="XOR") %}
{%- set taskComment = row["?taskComment"] | default(value="") %}
{%- set miMinimum = row["?miMinimum"] | default(value="") %}
{%- set miMaximum = row["?miMaximum"] | default(value="") %}
{%- set miThreshold = row["?miThreshold"] | default(value="") %}
{%- set miCreationMode = row["?miCreationMode"] | default(value="") %}

{%- if specId != current_spec and specId != "" %}
{%- if current_spec != "" %}
];

{%- endif %}
{%- set_global current_spec = specId %}
// -----------------------------------------------------------------------------
// {{ specId | replace(from="-", to=" ") | title }} Tasks
// -----------------------------------------------------------------------------

export const {{ specId | replace(from="-", to="_") | upper }}_TASKS: TaskDefinition[] = [
{%- endif %}

{%- if taskId != "" %}
  {
    taskId: '{{ taskId }}',
    taskName: '{{ taskName }}',
    taskKind: '{{ taskKind }}',
{%- if taskComment != "" %}
    description: '{{ taskComment | replace(from="'", to="\\'") }}',
{%- endif %}
    splitBehavior: '{{ splitBehavior | default(value="XOR") }}',
    joinBehavior: '{{ joinBehavior | default(value="XOR") }}',
{%- if miMinimum != "" %}
    miConfig: {
      minimum: {{ miMinimum }},
      maximum: {{ miMaximum | default(value="10") }},
      threshold: {{ miThreshold | default(value="1") }},
      creationMode: '{{ miCreationMode | default(value="static") }}',
    },
{%- endif %}
  },
{%- endif %}
{%- endfor %}
];

// =============================================================================
// Task Registry
// =============================================================================

export class TaskRegistry {
  private tasks: Map<string, Map<string, TaskDefinition>> = new Map();

  constructor() {
    this.registerWorkflowTasks();
  }

  private registerWorkflowTasks(): void {
{%- set seen_specs = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- if specId != "" and specId not in seen_specs %}
{%- set_global seen_specs = seen_specs ~ "," ~ specId %}
    this.registerTasks('{{ specId }}', {{ specId | replace(from="-", to="_") | upper }}_TASKS);
{%- endif %}
{%- endfor %}
  }

  private registerTasks(specId: string, tasks: TaskDefinition[]): void {
    const taskMap = new Map<string, TaskDefinition>();
    for (const task of tasks) {
      taskMap.set(task.taskId, task);
    }
    this.tasks.set(specId, taskMap);
  }

  /**
   * Get task definition by workflow and task ID
   */
  getTask(specId: string, taskId: string): TaskDefinition | undefined {
    return this.tasks.get(specId)?.get(taskId);
  }

  /**
   * Get all tasks for a workflow
   */
  getWorkflowTasks(specId: string): TaskDefinition[] {
    const taskMap = this.tasks.get(specId);
    return taskMap ? Array.from(taskMap.values()) : [];
  }

  /**
   * Get all registered workflow IDs
   */
  getWorkflowIds(): string[] {
    return Array.from(this.tasks.keys());
  }

  /**
   * Validate task definition
   */
  validateTask(task: unknown): TaskDefinition {
    return TaskDefinitionSchema.parse(task);
  }
}

// =============================================================================
// Singleton Instance
// =============================================================================

export const taskRegistry = new TaskRegistry();

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Check if a task is a multiple instance task
 */
export function isMultipleInstanceTask(task: TaskDefinition): boolean {
  return task.taskKind === 'multiple-instance' && !!task.miConfig;
}

/**
 * Check if a task requires human interaction
 */
export function isManualTask(task: TaskDefinition): boolean {
  return task.taskKind === 'manual';
}

/**
 * Check if a task is automated
 */
export function isAutomatedTask(task: TaskDefinition): boolean {
  return task.taskKind === 'automated';
}

/**
 * Get the split pattern name (Van der Aalst pattern)
 */
export function getSplitPatternName(behavior: SplitBehavior): string {
  switch (behavior) {
    case 'XOR': return 'WP4: Exclusive Choice';
    case 'AND': return 'WP2: Parallel Split';
    case 'OR': return 'WP6: Multi-Choice';
  }
}

/**
 * Get the join pattern name (Van der Aalst pattern)
 */
export function getJoinPatternName(behavior: JoinBehavior): string {
  switch (behavior) {
    case 'XOR': return 'WP5: Simple Merge';
    case 'AND': return 'WP3: Synchronization';
    case 'OR': return 'WP7: Structured Synchronizing Merge';
  }
}
