---
to: "{{ outputPath | replace(from='.ts', to='.mjs') }}"
description: ESM worklet exception handler with RDF-based rules
vars:
  workletId: string
  workletName: string
  exceptionType: string
metadata:
  category: worklet
  features: [exception-handling, sparql-rules, compensation]
---
{# =============================================================================
   WORKLET EXCEPTION HANDLER TEMPLATE
   Generates ESM exception handlers from RDF worklet definitions
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview {{ workletName }} - YAWL Worklet Exception Handler
 * Exception Type: {{ exceptionType }}
 * DO NOT EDIT - auto-generated by ggen sync
 * @module {{ workletName }}
 */

import { z } from 'zod';
import {
  generateReceipt,
  YAWL_EVENT_TYPES,
  executeSparqlAsk,
} from '@unrdf/yawl';

// =============================================================================
// Zod Schemas
// =============================================================================

export const CompensationActionSchema = z.enum(['rollback', 'retry', 'escalate', 'skip', 'fail']);

export const RuleSchema = z.object({
  condition: z.string(),
  action: z.string(),
  priority: z.number(),
});

// =============================================================================
// Rule Definitions (from RDF)
// =============================================================================

{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- set exceptionType = row["?exceptionType"] | default(value="Unknown") %}
{%- set compensationAction = row["?compensationAction"] | default(value="skip") %}
{%- set rules = row["?rules"] | default(value="") %}

const RULES_{{ workletId | upper | replace(from="-", to="_") }} = [
{%- if rules != "" %}
{%- for rule in rules | split(pat=";;") %}
{%- set ruleParts = rule | split(pat="||") %}
{%- if ruleParts | length >= 3 %}
  {
    condition: `{{ ruleParts[0] }}`,
    action: '{{ ruleParts[1] }}',
    priority: {{ ruleParts[2] }},
  },
{%- endif %}
{%- endfor %}
{%- endif %}
];
{%- endfor %}

// =============================================================================
// Worklet Handler Class
// =============================================================================

{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- set exceptionType = row["?exceptionType"] | default(value="Unknown") %}
{%- set compensationAction = row["?compensationAction"] | default(value="skip") %}

export class {{ workletName }} {
  /** @type {string} */
  #workletId = '{{ workletId }}';
  /** @type {string} */
  #exceptionType = '{{ exceptionType }}';
  /** @type {string} */
  #defaultAction = '{{ compensationAction | lower }}';
  /** @type {Array} */
  #rules = RULES_{{ workletId | upper | replace(from="-", to="_") }};

  /**
   * Evaluate worklet rules and determine compensation action
   * @param {object} context
   * @returns {Promise<object>}
   */
  async evaluate(context) {
    const sortedRules = [...this.#rules].sort((a, b) => a.priority - b.priority);

    for (const rule of sortedRules) {
      try {
        const conditionMet = await this.#evaluateCondition(rule.condition, context);

        if (conditionMet) {
          const action = this.#parseAction(rule.action);
          return await this.#executeAction(action, context);
        }
      } catch (error) {
        console.warn(`Rule evaluation failed: ${error}`);
        continue;
      }
    }

    return await this.#executeAction(this.#defaultAction, context);
  }

  /**
   * Evaluate SPARQL ASK condition against the RDF store
   * @param {string} sparqlAsk
   * @param {object} context
   * @returns {Promise<boolean>}
   */
  async #evaluateCondition(sparqlAsk, context) {
    const boundQuery = sparqlAsk
      .replace(/\?workItem/g, `<${context.workItem.workItemId}>`)
      .replace(/\?task/g, `<${context.task.taskId}>`)
      .replace(/\?case/g, `<${context.case.caseId}>`);

    try {
      return await executeSparqlAsk(context.store, boundQuery);
    } catch {
      return false;
    }
  }

  /**
   * Parse action string into compensation action
   * @param {string} actionStr
   * @returns {string}
   */
  #parseAction(actionStr) {
    const normalizedAction = actionStr.toLowerCase();

    if (normalizedAction.includes('retry')) return 'retry';
    if (normalizedAction.includes('rollback')) return 'rollback';
    if (normalizedAction.includes('escalate') || normalizedAction.includes('reassign')) return 'escalate';
    if (normalizedAction.includes('skip') || normalizedAction.includes('continue')) return 'skip';
    if (normalizedAction.includes('fail') || normalizedAction.includes('cancel')) return 'fail';

    return this.#defaultAction;
  }

  /**
   * Execute compensation action
   * @param {string} action
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #executeAction(action, context) {
    let resultData = {};

    switch (action) {
      case 'retry':
        resultData = await this.#performRetry(context);
        break;
      case 'rollback':
        resultData = await this.#performRollback(context);
        break;
      case 'escalate':
        resultData = await this.#performEscalation(context);
        break;
      case 'skip':
        resultData = await this.#performSkip(context);
        break;
      case 'fail':
        resultData = await this.#performFail(context);
        break;
    }

    const receipt = await generateReceipt({
      eventType: YAWL_EVENT_TYPES.EXCEPTION_HANDLED,
      entityId: context.workItem.workItemId,
      data: {
        workletId: this.#workletId,
        exceptionType: this.#exceptionType,
        action,
        ...resultData,
      },
    });

    return {
      action,
      data: resultData,
      receipt: {
        id: receipt.id,
        hash: receipt.hash,
        timestamp: receipt.timestamp,
      },
    };
  }

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #performRetry(context) {
    const newRetryCount = context.retryCount + 1;
    const backoffMs = Math.min(1000 * Math.pow(2, newRetryCount), 30000);

    return {
      retryCount: newRetryCount,
      backoffMs,
      scheduledAt: new Date(Date.now() + backoffMs).toISOString(),
    };
  }

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #performRollback(context) {
    return {
      rolledBackTo: context.case.lastSuccessfulTaskId || 'start',
      affectedWorkItems: [context.workItem.workItemId],
    };
  }

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #performEscalation(context) {
    return {
      escalatedTo: 'supervisor',
      originalAssignee: context.workItem.owner,
      severity: 'high',
    };
  }

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #performSkip(context) {
    return {
      skipped: true,
      reason: `${this.#exceptionType} exception - continuing to next task`,
    };
  }

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #performFail(context) {
    return {
      failed: true,
      reason: context.error.message,
      exceptionType: this.#exceptionType,
    };
  }

  /**
   * Check if this worklet handles the given exception type
   * @param {string} exceptionType
   * @returns {boolean}
   */
  handles(exceptionType) {
    return this.#exceptionType.toLowerCase() === exceptionType.toLowerCase();
  }
}
{%- endfor %}

// =============================================================================
// Worklet Registry
// =============================================================================

export class WorkletRegistry {
  /** @type {Map<string, object>} */
  #worklets = new Map();

  constructor() {
{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
    this.#worklets.set('{{ workletId }}', new {{ workletName }}());
{%- endfor %}
  }

  /**
   * Get worklet by ID
   * @param {string} workletId
   * @returns {object|undefined}
   */
  get(workletId) {
    return this.#worklets.get(workletId);
  }

  /**
   * Find worklet that handles the given exception type
   * @param {string} exceptionType
   * @returns {object|undefined}
   */
  findByExceptionType(exceptionType) {
    for (const worklet of this.#worklets.values()) {
      if (worklet.handles(exceptionType)) {
        return worklet;
      }
    }
    return undefined;
  }

  /**
   * Evaluate appropriate worklet for context
   * @param {object} context
   * @param {string} exceptionType
   * @returns {Promise<object|null>}
   */
  async evaluate(context, exceptionType) {
    const worklet = this.findByExceptionType(exceptionType);
    if (!worklet) {
      return null;
    }
    return worklet.evaluate(context);
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * @returns {WorkletRegistry}
 */
export function createWorkletRegistry() {
  return new WorkletRegistry();
}
