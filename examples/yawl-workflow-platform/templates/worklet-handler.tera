---
to: "{{ outputPath }}"
description: TypeScript worklet exception handler with RDF-based rules
vars:
  workletId: string
  workletName: string
  exceptionType: string
metadata:
  category: worklet
  features: [exception-handling, sparql-rules, compensation]
---
{# =============================================================================
   WORKLET EXCEPTION HANDLER TEMPLATE
   Generates TypeScript exception handlers from RDF worklet definitions
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview {{ workletName }} - YAWL Worklet Exception Handler
 * Exception Type: {{ exceptionType }}
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { z } from 'zod';
import {
  WorkflowEngine,
  YawlCase,
  YawlTask,
  WorkItem,
  generateReceipt,
  YAWL_EVENT_TYPES,
} from '@unrdf/yawl';
import { createStore, executeSparqlAsk } from '@unrdf/oxigraph';

// =============================================================================
// Worklet Types
// =============================================================================

export type CompensationAction = 'rollback' | 'retry' | 'escalate' | 'skip' | 'fail';

export interface WorkletContext {
  case: YawlCase;
  task: YawlTask;
  workItem: WorkItem;
  error: Error;
  retryCount: number;
  store: ReturnType<typeof createStore>;
}

export interface WorkletResult {
  action: CompensationAction;
  data?: Record<string, unknown>;
  receipt: {
    id: string;
    hash: string;
    timestamp: string;
  };
}

export interface Rule {
  condition: string;
  action: string;
  priority: number;
}

// =============================================================================
// Rule Definitions (from RDF)
// =============================================================================

{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- set exceptionType = row["?exceptionType"] | default(value="Unknown") %}
{%- set compensationAction = row["?compensationAction"] | default(value="skip") %}
{%- set rules = row["?rules"] | default(value="") %}

const RULES_{{ workletId | upper | replace(from="-", to="_") }}: Rule[] = [
{%- if rules != "" %}
{%- for rule in rules | split(pat=";;") %}
{%- set ruleParts = rule | split(pat="||") %}
{%- if ruleParts | length >= 3 %}
  {
    condition: `{{ ruleParts[0] }}`,
    action: '{{ ruleParts[1] }}',
    priority: {{ ruleParts[2] }},
  },
{%- endif %}
{%- endfor %}
{%- endif %}
];
{%- endfor %}

// =============================================================================
// Worklet Handler Class
// =============================================================================

{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- set exceptionType = row["?exceptionType"] | default(value="Unknown") %}
{%- set compensationAction = row["?compensationAction"] | default(value="skip") %}

export class {{ workletName }} {
  private readonly workletId = '{{ workletId }}';
  private readonly exceptionType = '{{ exceptionType }}';
  private readonly defaultAction: CompensationAction = '{{ compensationAction | lower }}';
  private readonly rules = RULES_{{ workletId | upper | replace(from="-", to="_") }};

  /**
   * Evaluate worklet rules and determine compensation action
   */
  async evaluate(context: WorkletContext): Promise<WorkletResult> {
    const startTime = Date.now();

    // Sort rules by priority (lower = higher priority)
    const sortedRules = [...this.rules].sort((a, b) => a.priority - b.priority);

    // Evaluate each rule's SPARQL ASK condition
    for (const rule of sortedRules) {
      try {
        const conditionMet = await this.evaluateCondition(rule.condition, context);

        if (conditionMet) {
          const action = this.parseAction(rule.action);
          return await this.executeAction(action, context);
        }
      } catch (error) {
        console.warn(`Rule evaluation failed: ${error}`);
        continue;
      }
    }

    // No rules matched, use default action
    return await this.executeAction(this.defaultAction, context);
  }

  /**
   * Evaluate SPARQL ASK condition against the RDF store
   */
  private async evaluateCondition(
    sparqlAsk: string,
    context: WorkletContext
  ): Promise<boolean> {
    // Bind context variables to SPARQL query
    const boundQuery = sparqlAsk
      .replace(/\?workItem/g, `<${context.workItem.workItemId}>`)
      .replace(/\?task/g, `<${context.task.taskId}>`)
      .replace(/\?case/g, `<${context.case.caseId}>`);

    try {
      return await executeSparqlAsk(context.store, boundQuery);
    } catch {
      return false;
    }
  }

  /**
   * Parse action string into CompensationAction
   */
  private parseAction(actionStr: string): CompensationAction {
    const normalizedAction = actionStr.toLowerCase();

    if (normalizedAction.includes('retry')) return 'retry';
    if (normalizedAction.includes('rollback')) return 'rollback';
    if (normalizedAction.includes('escalate') || normalizedAction.includes('reassign')) return 'escalate';
    if (normalizedAction.includes('skip') || normalizedAction.includes('continue')) return 'skip';
    if (normalizedAction.includes('fail') || normalizedAction.includes('cancel')) return 'fail';

    return this.defaultAction;
  }

  /**
   * Execute compensation action
   */
  private async executeAction(
    action: CompensationAction,
    context: WorkletContext
  ): Promise<WorkletResult> {
    let resultData: Record<string, unknown> = {};

    switch (action) {
      case 'retry':
        resultData = await this.performRetry(context);
        break;
      case 'rollback':
        resultData = await this.performRollback(context);
        break;
      case 'escalate':
        resultData = await this.performEscalation(context);
        break;
      case 'skip':
        resultData = await this.performSkip(context);
        break;
      case 'fail':
        resultData = await this.performFail(context);
        break;
    }

    // Generate receipt for audit trail
    const receipt = await generateReceipt({
      eventType: YAWL_EVENT_TYPES.EXCEPTION_HANDLED,
      entityId: context.workItem.workItemId,
      data: {
        workletId: this.workletId,
        exceptionType: this.exceptionType,
        action,
        ...resultData,
      },
    });

    return {
      action,
      data: resultData,
      receipt: {
        id: receipt.id,
        hash: receipt.hash,
        timestamp: receipt.timestamp,
      },
    };
  }

  private async performRetry(context: WorkletContext): Promise<Record<string, unknown>> {
    const newRetryCount = context.retryCount + 1;
    const backoffMs = Math.min(1000 * Math.pow(2, newRetryCount), 30000);

    return {
      retryCount: newRetryCount,
      backoffMs,
      scheduledAt: new Date(Date.now() + backoffMs).toISOString(),
    };
  }

  private async performRollback(context: WorkletContext): Promise<Record<string, unknown>> {
    // Find previous successful state in case history
    return {
      rolledBackTo: context.case.lastSuccessfulTaskId || 'start',
      affectedWorkItems: [context.workItem.workItemId],
    };
  }

  private async performEscalation(context: WorkletContext): Promise<Record<string, unknown>> {
    return {
      escalatedTo: 'supervisor',
      originalAssignee: context.workItem.owner,
      severity: 'high',
    };
  }

  private async performSkip(context: WorkletContext): Promise<Record<string, unknown>> {
    return {
      skipped: true,
      reason: `${this.exceptionType} exception - continuing to next task`,
    };
  }

  private async performFail(context: WorkletContext): Promise<Record<string, unknown>> {
    return {
      failed: true,
      reason: context.error.message,
      exceptionType: this.exceptionType,
    };
  }

  /**
   * Check if this worklet handles the given exception type
   */
  handles(exceptionType: string): boolean {
    return this.exceptionType.toLowerCase() === exceptionType.toLowerCase();
  }
}
{%- endfor %}

// =============================================================================
// Worklet Registry
// =============================================================================

export class WorkletRegistry {
  private worklets: Map<string, {{ workletName }}> = new Map();

  constructor() {
{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
    this.worklets.set('{{ workletId }}', new {{ workletName }}());
{%- endfor %}
  }

  /**
   * Get worklet by ID
   */
  get(workletId: string): {{ workletName }} | undefined {
    return this.worklets.get(workletId);
  }

  /**
   * Find worklet that handles the given exception type
   */
  findByExceptionType(exceptionType: string): {{ workletName }} | undefined {
    for (const worklet of this.worklets.values()) {
      if (worklet.handles(exceptionType)) {
        return worklet;
      }
    }
    return undefined;
  }

  /**
   * Evaluate appropriate worklet for context
   */
  async evaluate(context: WorkletContext, exceptionType: string): Promise<WorkletResult | null> {
    const worklet = this.findByExceptionType(exceptionType);
    if (!worklet) {
      return null;
    }
    return worklet.evaluate(context);
  }
}

// =============================================================================
// Factory Function
// =============================================================================

export function createWorkletRegistry(): WorkletRegistry {
  return new WorkletRegistry();
}
