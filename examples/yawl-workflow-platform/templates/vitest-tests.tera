---
to: "lib/tests/workflow.test.ts"
description: Vitest integration tests with MSW mocking for YAWL workflows
vars:
  specId: string
  servletId: string
metadata:
  category: testing
  framework: vitest
  features: [msw-mocking, snapshots, receipts]
---
{# =============================================================================
   VITEST INTEGRATION TESTS TEMPLATE
   Generates Vitest tests with MSW mocking from RDF specifications
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Workflow Platform Integration Tests
 * Uses MSW for network mocking and Vitest for testing
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { http, HttpResponse } from 'msw';
import { setupServer } from 'msw/node';
import {
  createWorkflowEngine,
  WorkflowEngine,
  ENGINE_EVENTS,
} from '../engine/WorkflowEngine';
import { createWorkletRegistry } from '../worklets';
import { verifyReceipt, ProofChain } from '@unrdf/yawl';

// =============================================================================
// Test Fixtures
// =============================================================================

const mockWorkflows = {
{%- set seen_specs = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- set specName = row["?specName"] | default(value="") %}
{%- if specId != "" and specId not in seen_specs %}
{%- set_global seen_specs = seen_specs ~ "," ~ specId %}
  '{{ specId }}': {
    specId: '{{ specId }}',
    specName: '{{ specName | default(value=specId) }}',
    version: '1.0.0',
    tasks: [],
    flows: [],
  },
{%- endif %}
{%- endfor %}
};

const mockCases = {
  'case-001': {
    caseId: 'case-001',
    specId: 'document-approval',
    status: 'active',
    createdAt: '2024-01-01T00:00:00.000Z',
    caseData: {},
  },
};

const mockWorkItems = {
  'workitem-001': {
    workItemId: 'workitem-001',
    caseId: 'case-001',
    taskId: 'submit-document',
    status: 'enabled',
    createdAt: '2024-01-01T00:00:00.000Z',
  },
};

// =============================================================================
// MSW Server Setup
// =============================================================================

const handlers = [
{%- set seen_handlers = "" %}
{%- for row in sparql_results %}
{%- set servletId = row["?servletId"] | default(value="") %}
{%- set urlPattern = row["?urlPattern"] | default(value="") %}
{%- set httpMethod = row["?httpMethod"] | default(value="GET") | lower %}
{%- set handlerKey = httpMethod ~ urlPattern %}
{%- if handlerKey != "" and handlerKey not in seen_handlers and servletId != "" %}
{%- set_global seen_handlers = seen_handlers ~ "," ~ handlerKey %}

  // {{ servletId }}: {{ httpMethod | upper }} {{ urlPattern }}
  http.{{ httpMethod }}('http://localhost:3000{{ urlPattern | replace(from=":id", to=":id") | replace(from=":taskId", to=":taskId") }}', ({ params }) => {
{%- if "list" in servletId and "workflow" in servletId %}
    return HttpResponse.json(Object.values(mockWorkflows));
{%- elif "get" in servletId and "workflow" in servletId %}
    const { id } = params;
    const workflow = mockWorkflows[id as string];
    if (!workflow) {
      return HttpResponse.json({ error: 'Not found' }, { status: 404 });
    }
    return HttpResponse.json(workflow);
{%- elif "create" in servletId and "workflow" in servletId %}
    return HttpResponse.json(
      { specId: 'new-workflow', status: 'created' },
      { status: 201 }
    );
{%- elif "list" in servletId and "case" in servletId %}
    return HttpResponse.json(Object.values(mockCases));
{%- elif "get" in servletId and "case" in servletId %}
    const { id } = params;
    const caseInstance = mockCases[id as string];
    if (!caseInstance) {
      return HttpResponse.json({ error: 'Not found' }, { status: 404 });
    }
    return HttpResponse.json(caseInstance);
{%- elif "create" in servletId and "case" in servletId %}
    return HttpResponse.json(
      { caseId: 'new-case', status: 'active' },
      { status: 201 }
    );
{%- elif "cancel" in servletId %}
    const { id } = params;
    return HttpResponse.json({ cancelled: true, caseId: id });
{%- elif "workitem" in servletId or ("list" in servletId and "task" in servletId) %}
    return HttpResponse.json(Object.values(mockWorkItems));
{%- elif "enable" in servletId %}
    return HttpResponse.json({
      workItemId: 'new-workitem',
      status: 'enabled',
      receipt: { id: 'receipt-001', hash: 'abc123', timestamp: new Date().toISOString() },
    });
{%- elif "start" in servletId %}
    return HttpResponse.json({
      workItemId: 'workitem-001',
      status: 'started',
      receipt: { id: 'receipt-002', hash: 'def456', timestamp: new Date().toISOString() },
    });
{%- elif "complete" in servletId %}
    return HttpResponse.json({
      workItemId: 'workitem-001',
      status: 'completed',
      receipt: { id: 'receipt-003', hash: 'ghi789', timestamp: new Date().toISOString() },
    });
{%- elif "metrics" in servletId %}
    return HttpResponse.json({
      activeCases: 5,
      completedCases: 100,
      failedCases: 2,
      averageCompletionTime: 3600000,
    });
{%- elif "replay" in servletId %}
    const { id } = params;
    return HttpResponse.json({
      caseId: id,
      status: 'replayed',
      replayedTo: new Date().toISOString(),
    });
{%- else %}
    return HttpResponse.json({ success: true });
{%- endif %}
  }),
{%- endif %}
{%- endfor %}
];

const server = setupServer(...handlers);

// =============================================================================
// Test Lifecycle
// =============================================================================

beforeAll(() => {
  server.listen({ onUnhandledRequest: 'error' });
});

afterEach(() => {
  server.resetHandlers();
});

afterAll(() => {
  server.close();
});

// =============================================================================
// API Client Helper
// =============================================================================

async function apiClient<T>(
  path: string,
  options: RequestInit = {}
): Promise<{ data: T | null; status: number; error?: string }> {
  const response = await fetch(`http://localhost:3000${path}`, {
    headers: {
      'Content-Type': 'application/json',
      Authorization: 'Bearer test-token',
      ...options.headers,
    },
    ...options,
  });

  const data = await response.json();

  if (!response.ok) {
    return { data: null, status: response.status, error: data.error };
  }

  return { data, status: response.status };
}

// =============================================================================
// Workflow Engine Unit Tests
// =============================================================================

describe('WorkflowEngine', () => {
  let engine: WorkflowEngine;

  beforeAll(() => {
    engine = createWorkflowEngine({
      enableReceipts: true,
      enableTimeTravel: true,
    });
  });

  describe('Workflow Management', () => {
    it('should create a workflow', async () => {
      const workflow = await engine.createWorkflow({
        specId: 'test-workflow',
        specName: 'Test Workflow',
        tasks: [
          { taskId: 'task-1', taskName: 'Task 1', taskKind: 'manual' },
          { taskId: 'task-2', taskName: 'Task 2', taskKind: 'automated' },
        ],
        flows: [
          { sourceTaskId: 'task-1', targetTaskId: 'task-2' },
        ],
      });

      expect(workflow.specId).toBe('test-workflow');
    });

    it('should list workflows', async () => {
      const workflows = await engine.listWorkflows();
      expect(Array.isArray(workflows)).toBe(true);
    });

    it('should get workflow by ID', async () => {
      const workflow = await engine.getWorkflow('test-workflow');
      expect(workflow?.specId).toBe('test-workflow');
    });
  });

  describe('Case Management', () => {
    it('should create a case for a workflow', async () => {
      const caseInstance = await engine.createCase('test-workflow', { key: 'value' });

      expect(caseInstance.specId).toBe('test-workflow');
      expect(caseInstance.status).toBe('active');
      expect(caseInstance.caseData).toEqual({ key: 'value' });
    });

    it('should emit CASE_CREATED event', async () => {
      const eventHandler = vi.fn();
      engine.on(ENGINE_EVENTS.CASE_CREATED, eventHandler);

      await engine.createCase('test-workflow');

      expect(eventHandler).toHaveBeenCalled();
    });

    it('should cancel a case', async () => {
      const caseInstance = await engine.createCase('test-workflow');
      await engine.cancelCase(caseInstance.caseId);

      const cancelled = await engine.getCase(caseInstance.caseId);
      expect(cancelled?.status).toBe('cancelled');
    });
  });

  describe('Task Lifecycle', () => {
    it('should enable first task when case is created', async () => {
      const eventHandler = vi.fn();
      engine.on(ENGINE_EVENTS.TASK_ENABLED, eventHandler);

      await engine.createCase('test-workflow');

      expect(eventHandler).toHaveBeenCalled();
    });

    it('should transition task through lifecycle', async () => {
      const caseInstance = await engine.createCase('test-workflow');
      const { caseId } = caseInstance;

      // Enable -> Start -> Complete
      const workItem = await engine.enableTask(caseId, 'task-1');
      expect(workItem.status).toBe('enabled');

      const started = await engine.startTask(caseId, 'task-1', 'user-1');
      expect(started.status).toBe('started');

      const completed = await engine.completeTask(caseId, 'task-1', { result: 'done' });
      expect(completed.status).toBe('completed');
    });
  });

  describe('Control Flow Patterns', () => {
    it('should handle XOR-split (exclusive choice)', async () => {
      await engine.createWorkflow({
        specId: 'xor-test',
        specName: 'XOR Test',
        tasks: [
          { taskId: 'start', taskName: 'Start', taskKind: 'automated', splitBehavior: 'XOR' },
          { taskId: 'branch-a', taskName: 'Branch A', taskKind: 'automated' },
          { taskId: 'branch-b', taskName: 'Branch B', taskKind: 'automated' },
        ],
        flows: [
          { sourceTaskId: 'start', targetTaskId: 'branch-a', condition: "choice == 'a'", priority: 1 },
          { sourceTaskId: 'start', targetTaskId: 'branch-b', isDefault: true, priority: 2 },
        ],
      });

      const caseInstance = await engine.createCase('xor-test', { choice: 'a' });

      // Complete start task
      await engine.startTask(caseInstance.caseId, 'start');
      await engine.completeTask(caseInstance.caseId, 'start', { choice: 'a' });

      // Branch A should be enabled, not Branch B
      const workItems = await engine.listWorkItems({ caseId: caseInstance.caseId });
      const enabledTasks = workItems.filter(w => w.status === 'enabled').map(w => w.taskId);

      expect(enabledTasks).toContain('branch-a');
      expect(enabledTasks).not.toContain('branch-b');
    });

    it('should handle AND-split (parallel split)', async () => {
      await engine.createWorkflow({
        specId: 'and-test',
        specName: 'AND Test',
        tasks: [
          { taskId: 'start', taskName: 'Start', taskKind: 'automated', splitBehavior: 'AND' },
          { taskId: 'parallel-a', taskName: 'Parallel A', taskKind: 'automated' },
          { taskId: 'parallel-b', taskName: 'Parallel B', taskKind: 'automated' },
        ],
        flows: [
          { sourceTaskId: 'start', targetTaskId: 'parallel-a' },
          { sourceTaskId: 'start', targetTaskId: 'parallel-b' },
        ],
      });

      const caseInstance = await engine.createCase('and-test');

      await engine.startTask(caseInstance.caseId, 'start');
      await engine.completeTask(caseInstance.caseId, 'start');

      // Both branches should be enabled
      const workItems = await engine.listWorkItems({ caseId: caseInstance.caseId });
      const enabledTasks = workItems.filter(w => w.status === 'enabled').map(w => w.taskId);

      expect(enabledTasks).toContain('parallel-a');
      expect(enabledTasks).toContain('parallel-b');
    });
  });

  describe('Receipt Generation', () => {
    it('should generate receipts for task completion', async () => {
      const receiptHandler = vi.fn();
      engine.on(ENGINE_EVENTS.RECEIPT_GENERATED, receiptHandler);

      const caseInstance = await engine.createCase('test-workflow');
      await engine.startTask(caseInstance.caseId, 'task-1');
      await engine.completeTask(caseInstance.caseId, 'task-1');

      expect(receiptHandler).toHaveBeenCalled();
      const receipt = receiptHandler.mock.calls[0][0];
      expect(receipt).toHaveProperty('id');
      expect(receipt).toHaveProperty('hash');
      expect(receipt).toHaveProperty('timestamp');
    });

    it('should verify receipt chain integrity', async () => {
      const caseInstance = await engine.createCase('test-workflow');
      await engine.startTask(caseInstance.caseId, 'task-1');
      await engine.completeTask(caseInstance.caseId, 'task-1');

      const isValid = await engine.verifyReceiptChain();
      expect(isValid).toBe(true);
    });
  });
});

// =============================================================================
// API Integration Tests (with MSW)
// =============================================================================

describe('REST API Integration', () => {
{%- set tested_specs = "" %}
{%- for row in sparql_results %}
{%- set specId = row["?specId"] | default(value="") %}
{%- if specId != "" and specId not in tested_specs %}
{%- set_global tested_specs = tested_specs ~ "," ~ specId %}

  describe('{{ specId }} Workflow API', () => {
    it('should list workflows', async () => {
      const { data, status } = await apiClient('/api/workflows');

      expect(status).toBe(200);
      expect(Array.isArray(data)).toBe(true);
    });

    it('should handle workflow not found', async () => {
      server.use(
        http.get('http://localhost:3000/api/workflows/:id', () => {
          return HttpResponse.json({ error: 'Not found' }, { status: 404 });
        })
      );

      const { status, error } = await apiClient('/api/workflows/nonexistent');

      expect(status).toBe(404);
      expect(error).toBe('Not found');
    });
  });
{%- endif %}
{%- endfor %}

  describe('Case Management API', () => {
    it('should create a new case', async () => {
      const { data, status } = await apiClient('/api/cases', {
        method: 'POST',
        body: JSON.stringify({
          workflowId: 'document-approval',
          initialData: { documentId: 'doc-123' },
        }),
      });

      expect(status).toBe(201);
      expect(data).toHaveProperty('caseId');
    });

    it('should list cases', async () => {
      const { data, status } = await apiClient('/api/cases');

      expect(status).toBe(200);
      expect(Array.isArray(data)).toBe(true);
    });

    it('should cancel a case', async () => {
      const { data, status } = await apiClient('/api/cases/case-001/cancel', {
        method: 'POST',
      });

      expect(status).toBe(200);
      expect(data).toHaveProperty('cancelled', true);
    });
  });

  describe('Task Management API', () => {
    it('should list work items', async () => {
      const { data, status } = await apiClient('/api/workitems');

      expect(status).toBe(200);
      expect(Array.isArray(data)).toBe(true);
    });

    it('should enable a task', async () => {
      const { data, status } = await apiClient('/api/tasks/task-1/enable', {
        method: 'POST',
        body: JSON.stringify({ caseId: 'case-001' }),
      });

      expect(status).toBe(200);
      expect(data).toHaveProperty('status', 'enabled');
      expect(data).toHaveProperty('receipt');
    });

    it('should complete a task', async () => {
      const { data, status } = await apiClient('/api/tasks/task-1/complete', {
        method: 'POST',
        body: JSON.stringify({
          caseId: 'case-001',
          outputData: { approved: true },
        }),
      });

      expect(status).toBe(200);
      expect(data).toHaveProperty('status', 'completed');
      expect(data).toHaveProperty('receipt');
    });
  });

  describe('Admin API', () => {
    it('should return metrics', async () => {
      const { data, status } = await apiClient('/api/admin/metrics');

      expect(status).toBe(200);
      expect(data).toHaveProperty('activeCases');
      expect(data).toHaveProperty('completedCases');
    });

    it('should replay a case', async () => {
      const { data, status } = await apiClient('/api/admin/cases/case-001/replay', {
        method: 'POST',
        body: JSON.stringify({
          toTimestamp: '2024-01-01T12:00:00.000Z',
        }),
      });

      expect(status).toBe(200);
      expect(data).toHaveProperty('replayedTo');
    });
  });
});

// =============================================================================
// Snapshot Tests
// =============================================================================

describe('Snapshot Tests', () => {
  it('should match workflow list response snapshot', async () => {
    const { data } = await apiClient('/api/workflows');
    expect(data).toMatchSnapshot();
  });

  it('should match case list response snapshot', async () => {
    const { data } = await apiClient('/api/cases');
    expect(data).toMatchSnapshot();
  });

  it('should match work item list response snapshot', async () => {
    const { data } = await apiClient('/api/workitems');
    expect(data).toMatchSnapshot();
  });

  it('should match metrics response snapshot', async () => {
    const { data } = await apiClient('/api/admin/metrics');
    expect(data).toMatchSnapshot();
  });
});

// =============================================================================
// Worklet Exception Handler Tests
// =============================================================================

describe('Worklet Exception Handlers', () => {
  it('should create worklet registry', () => {
    const registry = createWorkletRegistry();
    expect(registry).toBeDefined();
  });

  it('should find worklet by exception type', () => {
    const registry = createWorkletRegistry();
    const worklet = registry.findByExceptionType('Timeout');
    expect(worklet).toBeDefined();
  });

  it('should evaluate worklet rules', async () => {
    const registry = createWorkletRegistry();
    const engine = createWorkflowEngine();
    const store = engine.getStore();

    const context = {
      case: { caseId: 'test', specId: 'test', status: 'active' },
      task: { taskId: 'test-task', taskKind: 'manual' },
      workItem: { workItemId: 'wi-001', status: 'failed' },
      error: new Error('Timeout'),
      retryCount: 1,
      store,
    };

    const result = await registry.evaluate(context as any, 'Timeout');

    expect(result).toBeDefined();
    expect(result?.action).toBeDefined();
    expect(result?.receipt).toBeDefined();
  });
});
