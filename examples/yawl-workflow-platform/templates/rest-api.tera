---
to: "lib/api/routes.ts"
description: Express-style REST API routes for YAWL workflow operations
vars:
  servletId: string
  urlPattern: string
  httpMethod: string
metadata:
  category: api
  framework: express
  features: [routing, middleware, validation]
---
{# =============================================================================
   REST API ROUTES TEMPLATE
   Generates Express-style routes from RDF servlet definitions
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Workflow Platform REST API Routes
 * Generated from RDF servlet definitions
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { WorkflowEngine } from '../engine/WorkflowEngine';
import { createWorkletRegistry } from '../worklets';
import { generateReceipt, YAWL_EVENT_TYPES } from '@unrdf/yawl';

// =============================================================================
// Middleware
// =============================================================================

/**
 * Authentication middleware placeholder
 * Replace with your actual auth implementation
 */
export function authMiddleware(req: Request, res: Response, next: NextFunction): void {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  // TODO: Validate token
  next();
}

/**
 * Request validation middleware factory
 */
export function validateRequest(schema: z.ZodSchema) {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          error: 'Validation failed',
          details: error.errors,
        });
        return;
      }
      next(error);
    }
  };
}

/**
 * Receipt generation middleware
 */
export function receiptMiddleware(eventType: string) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const originalJson = res.json.bind(res);

    res.json = async (body: unknown) => {
      if (res.statusCode < 400) {
        const receipt = await generateReceipt({
          eventType,
          entityId: req.params.id || 'unknown',
          data: body,
        });

        return originalJson({
          ...body as object,
          receipt: {
            id: receipt.id,
            hash: receipt.hash,
            timestamp: receipt.timestamp,
          },
        });
      }
      return originalJson(body);
    };

    next();
  };
}

// =============================================================================
// Route Handlers
// =============================================================================

export function createWorkflowRoutes(engine: WorkflowEngine): Router {
  const router = Router();

{%- set seen_routes = "" %}
{%- for row in sparql_results %}
{%- set servletId = row["?servletId"] | default(value="") %}
{%- set servletName = row["?servletName"] | default(value="") %}
{%- set urlPattern = row["?urlPattern"] | default(value="") %}
{%- set httpMethod = row["?httpMethod"] | default(value="GET") %}
{%- set requiresAuth = row["?requiresAuth"] | default(value="true") %}
{%- set servletType = row["?servletType"] | default(value="") %}

{%- set routeKey = httpMethod ~ urlPattern %}
{%- if routeKey != "" and routeKey not in seen_routes and servletId != "" %}
{%- set_global seen_routes = seen_routes ~ "," ~ routeKey %}

  // {{ servletName }}: {{ httpMethod }} {{ urlPattern }}
  router.{{ httpMethod | lower }}(
    '{{ urlPattern | replace(from=":id", to=":id") }}',
{%- if requiresAuth == "true" %}
    authMiddleware,
{%- endif %}
    receiptMiddleware(YAWL_EVENT_TYPES.{% if "create" in servletId %}CASE_STARTED{% elif "complete" in servletId %}TASK_COMPLETED{% elif "start" in servletId %}TASK_STARTED{% elif "cancel" in servletId %}CASE_CANCELLED{% else %}TASK_ENABLED{% endif %}),
    async (req: Request, res: Response, next: NextFunction) => {
      try {
{%- if "workflow" in servletType | lower %}
{%- if "create" in servletId %}
        const workflow = await engine.createWorkflow(req.body);
        res.status(201).json(workflow);
{%- elif "list" in servletId %}
        const workflows = await engine.listWorkflows();
        res.json(workflows);
{%- elif "get" in servletId %}
        const workflow = await engine.getWorkflow(req.params.id);
        if (!workflow) {
          res.status(404).json({ error: 'Workflow not found' });
          return;
        }
        res.json(workflow);
{%- else %}
        res.json({ message: 'Operation completed' });
{%- endif %}
{%- elif "case" in servletType | lower %}
{%- if "create" in servletId %}
        const caseInstance = await engine.createCase(
          req.body.workflowId,
          req.body.initialData
        );
        res.status(201).json(caseInstance);
{%- elif "list" in servletId %}
        const cases = await engine.listCases(req.query as any);
        res.json(cases);
{%- elif "get" in servletId %}
        const caseInstance = await engine.getCase(req.params.id);
        if (!caseInstance) {
          res.status(404).json({ error: 'Case not found' });
          return;
        }
        res.json(caseInstance);
{%- elif "cancel" in servletId %}
        await engine.cancelCase(req.params.id);
        res.json({ cancelled: true, caseId: req.params.id });
{%- else %}
        res.json({ message: 'Operation completed' });
{%- endif %}
{%- elif "task" in servletType | lower %}
{%- if "enable" in servletId %}
        const workItem = await engine.enableTask(req.body.caseId, req.params.taskId);
        res.json(workItem);
{%- elif "start" in servletId %}
        const workItem = await engine.startTask(
          req.body.caseId,
          req.params.taskId,
          req.body.userId
        );
        res.json(workItem);
{%- elif "complete" in servletId %}
        const workItem = await engine.completeTask(
          req.body.caseId,
          req.params.taskId,
          req.body.outputData
        );
        res.json(workItem);
{%- elif "list" in servletId or "workitem" in servletId %}
        const workItems = await engine.listWorkItems(req.query as any);
        res.json(workItems);
{%- else %}
        res.json({ message: 'Operation completed' });
{%- endif %}
{%- elif "admin" in servletType | lower %}
{%- if "metrics" in servletId %}
        const metrics = await engine.getMetrics();
        res.json(metrics);
{%- elif "replay" in servletId %}
        const replayedCase = await engine.replayCase(
          req.params.id,
          new Date(req.body.toTimestamp)
        );
        res.json(replayedCase);
{%- else %}
        res.json({ message: 'Admin operation completed' });
{%- endif %}
{%- else %}
        res.json({ message: 'Operation completed' });
{%- endif %}
      } catch (error) {
        next(error);
      }
    }
  );
{%- endif %}
{%- endfor %}

  return router;
}

// =============================================================================
// Error Handler
// =============================================================================

export function errorHandler(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  console.error('API Error:', error);

  if (error instanceof z.ZodError) {
    res.status(400).json({
      error: 'Validation error',
      details: error.errors,
    });
    return;
  }

  if (error.message.includes('not found')) {
    res.status(404).json({ error: error.message });
    return;
  }

  res.status(500).json({
    error: 'Internal server error',
    message: error.message,
  });
}

// =============================================================================
// Application Factory
// =============================================================================

import express from 'express';

export function createApp(engine: WorkflowEngine): express.Application {
  const app = express();

  // Middleware
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));

  // CORS
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    if (req.method === 'OPTIONS') {
      res.sendStatus(204);
      return;
    }
    next();
  });

  // Health check
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  // API routes
  app.use('/api', createWorkflowRoutes(engine));

  // Error handler
  app.use(errorHandler);

  return app;
}

// =============================================================================
// Server Startup
// =============================================================================

export async function startServer(port: number = 3000): Promise<void> {
  const { createWorkflowEngine } = await import('../engine/WorkflowEngine');

  const engine = createWorkflowEngine({
    enableReceipts: true,
    enableTimeTravel: true,
  });

  const app = createApp(engine);

  app.listen(port, () => {
    console.log(`YAWL Workflow Platform running on http://localhost:${port}`);
    console.log('Available endpoints:');
{%- set logged_routes = "" %}
{%- for row in sparql_results %}
{%- set urlPattern = row["?urlPattern"] | default(value="") %}
{%- set httpMethod = row["?httpMethod"] | default(value="GET") %}
{%- set routeKey = httpMethod ~ urlPattern %}
{%- if routeKey != "" and routeKey not in logged_routes %}
{%- set_global logged_routes = logged_routes ~ "," ~ routeKey %}
    console.log('  {{ httpMethod }} {{ urlPattern }}');
{%- endif %}
{%- endfor %}
  });
}
