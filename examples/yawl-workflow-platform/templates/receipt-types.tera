---
to: "lib/types/receipts.mjs"
description: Receipt and audit trail types
metadata:
  category: types
---
{# =============================================================================
   RECEIPT TYPES TEMPLATE
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Receipt and Audit Trail Types
 * DO NOT EDIT - auto-generated by ggen sync
 * @module receipts
 */

import { z } from 'zod';

export const ReceiptSchema = z.object({
  id: z.string().uuid(),
  hash: z.string(),
  previousHash: z.string().optional(),
  timestamp: z.string().datetime(),
  eventType: z.string(),
  entityId: z.string(),
  data: z.record(z.unknown()),
  signature: z.string().optional(),
});

export const EventType = {
{%- for row in sparql_results %}
{%- set statusLabel = row["?statusLabel"] | default(value="") %}
{%- if statusLabel != "" %}
  {{ statusLabel | upper | replace(from=" ", to="_") }}: '{{ statusLabel | lower }}',
{%- endif %}
{%- endfor %}
  WORKFLOW_CREATED: 'workflow:created',
  CASE_STARTED: 'case:started',
  CASE_COMPLETED: 'case:completed',
  CASE_CANCELLED: 'case:cancelled',
  TASK_ENABLED: 'task:enabled',
  TASK_STARTED: 'task:started',
  TASK_COMPLETED: 'task:completed',
  TASK_FAILED: 'task:failed',
  EXCEPTION_HANDLED: 'exception:handled',
};

export class AuditTrail {
  /** @type {Array<{receipt: object, timestamp: Date, actor?: string}>} */
  #entries = [];

  /**
   * @param {object} receipt
   * @param {string} [actor]
   */
  append(receipt, actor) {
    this.#entries.push({
      receipt,
      timestamp: new Date(receipt.timestamp),
      actor,
    });
  }

  /**
   * @param {{entityId?: string, eventType?: string}} [filter]
   * @returns {Array}
   */
  getEntries(filter) {
    let result = [...this.#entries];
    if (filter?.entityId) {
      result = result.filter(e => e.receipt.entityId === filter.entityId);
    }
    if (filter?.eventType) {
      result = result.filter(e => e.receipt.eventType === filter.eventType);
    }
    return result;
  }

  /**
   * @returns {boolean}
   */
  verifyChain() {
    for (let i = 1; i < this.#entries.length; i++) {
      if (this.#entries[i].receipt.previousHash !== this.#entries[i - 1].receipt.hash) {
        return false;
      }
    }
    return true;
  }
}
