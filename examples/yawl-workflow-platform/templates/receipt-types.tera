---
to: "lib/types/receipts.ts"
description: Receipt and audit trail types
metadata:
  category: types
---
{# =============================================================================
   RECEIPT TYPES TEMPLATE
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Receipt and Audit Trail Types
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { z } from 'zod';

export const ReceiptSchema = z.object({
  id: z.string().uuid(),
  hash: z.string(),
  previousHash: z.string().optional(),
  timestamp: z.string().datetime(),
  eventType: z.string(),
  entityId: z.string(),
  data: z.record(z.unknown()),
  signature: z.string().optional(),
});

export type Receipt = z.infer<typeof ReceiptSchema>;

export const EventType = {
{%- for row in sparql_results %}
{%- set statusLabel = row["?statusLabel"] | default(value="") %}
{%- if statusLabel != "" %}
  {{ statusLabel | upper | replace(from=" ", to="_") }}: '{{ statusLabel | lower }}',
{%- endif %}
{%- endfor %}
  WORKFLOW_CREATED: 'workflow:created',
  CASE_STARTED: 'case:started',
  CASE_COMPLETED: 'case:completed',
  CASE_CANCELLED: 'case:cancelled',
  TASK_ENABLED: 'task:enabled',
  TASK_STARTED: 'task:started',
  TASK_COMPLETED: 'task:completed',
  TASK_FAILED: 'task:failed',
  EXCEPTION_HANDLED: 'exception:handled',
} as const;

export type EventType = typeof EventType[keyof typeof EventType];

export interface AuditTrailEntry {
  receipt: Receipt;
  timestamp: Date;
  actor?: string;
}

export class AuditTrail {
  private entries: AuditTrailEntry[] = [];

  append(receipt: Receipt, actor?: string): void {
    this.entries.push({
      receipt,
      timestamp: new Date(receipt.timestamp),
      actor,
    });
  }

  getEntries(filter?: { entityId?: string; eventType?: string }): AuditTrailEntry[] {
    let result = [...this.entries];
    if (filter?.entityId) {
      result = result.filter(e => e.receipt.entityId === filter.entityId);
    }
    if (filter?.eventType) {
      result = result.filter(e => e.receipt.eventType === filter.eventType);
    }
    return result;
  }

  verifyChain(): boolean {
    for (let i = 1; i < this.entries.length; i++) {
      if (this.entries[i].receipt.previousHash !== this.entries[i - 1].receipt.hash) {
        return false;
      }
    }
    return true;
  }
}
