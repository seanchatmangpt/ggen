---
to: "{{ outputPath | replace(from='.ts', to='.mjs') }}"
description: ESM servlet handler for YAWL workflow operations
vars:
  servletId: string
  servletName: string
  urlPattern: string
  httpMethod: string
metadata:
  category: servlet
  framework: express
  features: [yawl-integration, receipts, validation]
---
{# =============================================================================
   SERVLET HANDLER TEMPLATE
   Generates ESM handlers from RDF servlet definitions
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview {{ servletName }} - YAWL Servlet Handler
 * URL Pattern: {{ urlPattern }}
 * HTTP Method: {{ httpMethod }}
 * DO NOT EDIT - auto-generated by ggen sync
 * @module {{ servletName }}
 */

import { z } from 'zod';
import {
  createWorkflowEngine,
  generateReceipt,
  verifyReceipt,
  YAWL_EVENT_TYPES,
  createYawlStore,
} from '@unrdf/yawl';

// =============================================================================
// Request/Response Schemas (from RDF definitions)
// =============================================================================

{%- for row in sparql_results %}
{%- set servletId = row["?servletId"] | default(value="") %}
{%- set servletName = row["?servletName"] | default(value="") %}
{%- set urlPattern = row["?urlPattern"] | default(value="") %}
{%- set httpMethod = row["?httpMethod"] | default(value="GET") %}
{%- set requiresAuth = row["?requiresAuth"] | default(value="true") %}
{%- set requestSchema = row["?requestSchema"] | default(value="") %}
{%- set responseSchema = row["?responseSchema"] | default(value="") %}
{%- set servletType = row["?servletType"] | default(value="") %}

{%- if requestSchema != "" %}
const {{ servletId | replace(from="-", to="_") }}RequestSchema = z.object({
  // Schema derived from RDF: {{ requestSchema | truncate(length=50) }}
  workflowId: z.string().optional(),
  caseId: z.string().optional(),
  taskId: z.string().optional(),
  data: z.record(z.unknown()).optional(),
});
{%- endif %}

{%- if responseSchema != "" %}
const {{ servletId | replace(from="-", to="_") }}ResponseSchema = z.object({
  // Schema derived from RDF: {{ responseSchema | truncate(length=50) }}
  success: z.boolean(),
  data: z.unknown().optional(),
  receipt: z.object({
    id: z.string(),
    hash: z.string(),
    timestamp: z.string(),
  }).optional(),
  error: z.string().optional(),
});
{%- endif %}
{%- endfor %}

// =============================================================================
// Servlet Handler Class
// =============================================================================

export class {{ servletName }} {
  /** @type {import('@unrdf/yawl').WorkflowEngine} */
  #engine;
  /** @type {object} */
  #store;

  /**
   * @param {import('@unrdf/yawl').WorkflowEngine} engine
   * @param {object} store
   */
  constructor(engine, store) {
    this.#engine = engine;
    this.#store = store;
  }

  /**
   * Handle {{ httpMethod }} request to {{ urlPattern }}
   * @param {import('express').Request} req
   * @param {import('express').Response} res
   * @param {import('express').NextFunction} next
   * @returns {Promise<void>}
   */
  async handle(req, res, next) {
    const startTime = Date.now();

    try {
      // Validate request if schema defined
{%- if requestSchema != "" %}
      const validatedBody = {{ servletId | replace(from="-", to="_") }}RequestSchema.parse(req.body);
{%- endif %}

      // Execute servlet logic based on type
{%- if "workflow" in servletType | lower %}
      const result = await this.handleWorkflowOperation(req);
{%- elif "case" in servletType | lower %}
      const result = await this.handleCaseOperation(req);
{%- elif "task" in servletType | lower %}
      const result = await this.handleTaskOperation(req);
{%- elif "admin" in servletType | lower %}
      const result = await this.handleAdminOperation(req);
{%- else %}
      const result = await this.handleGenericOperation(req);
{%- endif %}

      // Generate cryptographic receipt for audit trail
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_COMPLETED,
        entityId: result.entityId || req.params.id || 'unknown',
        data: result.data,
        previousHash: result.previousHash,
      });

      // Send response with receipt
      res.status(result.status || 200).json({
        success: true,
        data: result.data,
        receipt: {
          id: receipt.id,
          hash: receipt.hash,
          timestamp: receipt.timestamp,
        },
        meta: {
          duration: Date.now() - startTime,
          servlet: '{{ servletId }}',
        },
      });

    } catch (error) {
      // Error handling with receipt for failed operations
      const errorReceipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_FAILED,
        entityId: req.params.id || 'unknown',
        data: { error: error instanceof Error ? error.message : 'Unknown error' },
      });

      res.status(error instanceof z.ZodError ? 400 : 500).json({
        success: false,
        error: error instanceof Error ? error.message : 'Internal server error',
        receipt: {
          id: errorReceipt.id,
          hash: errorReceipt.hash,
          timestamp: errorReceipt.timestamp,
        },
      });
    }
  }

{%- if "workflow" in servletType | lower %}
  /**
   * @param {import('express').Request} req
   * @returns {Promise<object>}
   */
  async handleWorkflowOperation(req) {
    const { id } = req.params;
    const method = req.method.toUpperCase();

    switch (method) {
      case 'GET':
        if (id) {
          const workflow = await this.#engine.getWorkflow(id);
          return { data: workflow, status: 200, entityId: id };
        }
        const workflows = await this.#engine.listWorkflows();
        return { data: workflows, status: 200 };

      case 'POST':
        const newWorkflow = await this.#engine.createWorkflow(req.body);
        return { data: newWorkflow, status: 201, entityId: newWorkflow.id };

      case 'DELETE':
        await this.#engine.deleteWorkflow(id);
        return { data: { deleted: id }, status: 200, entityId: id };

      default:
        throw new Error(`Unsupported method: ${method}`);
    }
  }
{%- endif %}

{%- if "case" in servletType | lower %}
  /**
   * @param {import('express').Request} req
   * @returns {Promise<object>}
   */
  async handleCaseOperation(req) {
    const { id } = req.params;
    const method = req.method.toUpperCase();

    switch (method) {
      case 'GET':
        if (id) {
          const caseInstance = await this.#engine.getCase(id);
          return { data: caseInstance, status: 200, entityId: id };
        }
        const cases = await this.#engine.listCases();
        return { data: cases, status: 200 };

      case 'POST':
        if (req.path.includes('/cancel')) {
          await this.#engine.cancelCase(id);
          return { data: { cancelled: id }, status: 200, entityId: id };
        }
        const newCase = await this.#engine.createCase(req.body.workflowId, req.body.initialData);
        return { data: newCase, status: 201, entityId: newCase.caseId };

      default:
        throw new Error(`Unsupported method: ${method}`);
    }
  }
{%- endif %}

{%- if "task" in servletType | lower %}
  /**
   * @param {import('express').Request} req
   * @returns {Promise<object>}
   */
  async handleTaskOperation(req) {
    const { taskId } = req.params;
    const { caseId, userId, outputData } = req.body;

    if (req.path.includes('/enable')) {
      const workItem = await this.#engine.enableTask(caseId, taskId);
      return { data: workItem, status: 200, entityId: workItem.workItemId };
    }

    if (req.path.includes('/start')) {
      const workItem = await this.#engine.startTask(caseId, taskId, userId);
      return { data: workItem, status: 200, entityId: workItem.workItemId };
    }

    if (req.path.includes('/complete')) {
      const workItem = await this.#engine.completeTask(caseId, taskId, outputData);
      return { data: workItem, status: 200, entityId: workItem.workItemId };
    }

    // List work items
    const workItems = await this.#engine.listWorkItems({ taskId });
    return { data: workItems, status: 200 };
  }
{%- endif %}

{%- if "admin" in servletType | lower %}
  /**
   * @param {import('express').Request} req
   * @returns {Promise<object>}
   */
  async handleAdminOperation(req) {
    if (req.path.includes('/metrics')) {
      const metrics = await this.#engine.getMetrics();
      return { data: metrics, status: 200 };
    }

    if (req.path.includes('/replay')) {
      const { id } = req.params;
      const { toTimestamp } = req.body;
      const replayedCase = await this.#engine.replayCase(id, new Date(toTimestamp));
      return { data: replayedCase, status: 200, entityId: id };
    }

    throw new Error('Unknown admin operation');
  }
{%- endif %}

  /**
   * @param {import('express').Request} req
   * @returns {Promise<object>}
   */
  async handleGenericOperation(req) {
    return { data: { message: 'Operation completed' }, status: 200 };
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * @param {import('@unrdf/yawl').WorkflowEngine} engine
 * @param {object} store
 * @returns {{ servletName }}
 */
export function create{{ servletName }}(engine, store) {
  return new {{ servletName }}(engine, store);
}

// =============================================================================
// Route Registration Helper
// =============================================================================

/**
 * @param {object} app
 * @param {import('@unrdf/yawl').WorkflowEngine} engine
 * @param {object} store
 * @param {Function} [authMiddleware]
 */
export function register{{ servletName }}Route(app, engine, store, authMiddleware) {
  const servlet = create{{ servletName }}(engine, store);
  const handlers = [
{%- if requiresAuth == "true" %}
    authMiddleware || ((req, res, next) => next()),
{%- endif %}
    (req, res, next) => servlet.handle(req, res, next),
  ];

  app.{{ httpMethod | lower }}('{{ urlPattern }}', ...handlers);
}
