---
to: "lib/worklets/index.mjs"
description: Worklet registry index module
metadata:
  category: worklet
  features: [exception-handling, registry]
---
{# =============================================================================
   WORKLET INDEX TEMPLATE
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Worklet Registry Index
 * Auto-generated registry of all exception handlers
 * DO NOT EDIT - auto-generated by ggen sync
 * @module worklets
 */

import { z } from 'zod';
import { generateReceipt, YAWL_EVENT_TYPES, executeSparqlAsk } from '@unrdf/yawl';

// =============================================================================
// Compensation Action Types
// =============================================================================

export const CompensationActionSchema = z.enum(['rollback', 'retry', 'escalate', 'skip', 'fail']);

// =============================================================================
// Worklet Classes
// =============================================================================

{%- set seen_worklets = "" %}
{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- set exceptionType = row["?exceptionType"] | default(value="Unknown") %}
{%- if workletId != "" and workletId not in seen_worklets %}
{%- set_global seen_worklets = seen_worklets ~ "," ~ workletId %}

export class {{ workletName }} {
  /** @type {string} */
  #workletId = '{{ workletId }}';
  /** @type {string} */
  #exceptionType = '{{ exceptionType }}';
  /** @type {string} */
  #defaultAction = 'skip';
  /** @type {Array} */
  #rules = [];

  /**
   * @param {object} context
   * @returns {Promise<object>}
   */
  async evaluate(context) {
    const sortedRules = [...this.#rules].sort((a, b) => a.priority - b.priority);

    for (const rule of sortedRules) {
      try {
        const conditionMet = await this.#evaluateCondition(rule.condition, context);
        if (conditionMet) {
          return await this.#executeAction(this.#parseAction(rule.action), context);
        }
      } catch (error) {
        console.warn(`Rule evaluation failed: ${error}`);
        continue;
      }
    }

    return await this.#executeAction(this.#defaultAction, context);
  }

  /**
   * @param {string} sparqlAsk
   * @param {object} context
   * @returns {Promise<boolean>}
   */
  async #evaluateCondition(sparqlAsk, context) {
    const boundQuery = sparqlAsk
      .replace(/\?workItem/g, `<${context.workItem?.workItemId || 'unknown'}>`)
      .replace(/\?task/g, `<${context.task?.taskId || 'unknown'}>`)
      .replace(/\?case/g, `<${context.case?.caseId || 'unknown'}>`);

    try {
      return await executeSparqlAsk(context.store, boundQuery);
    } catch {
      return false;
    }
  }

  /**
   * @param {string} actionStr
   * @returns {string}
   */
  #parseAction(actionStr) {
    const normalizedAction = actionStr.toLowerCase();

    if (normalizedAction.includes('retry')) return 'retry';
    if (normalizedAction.includes('rollback')) return 'rollback';
    if (normalizedAction.includes('escalate')) return 'escalate';
    if (normalizedAction.includes('skip')) return 'skip';
    if (normalizedAction.includes('fail')) return 'fail';

    return this.#defaultAction;
  }

  /**
   * @param {string} action
   * @param {object} context
   * @returns {Promise<object>}
   */
  async #executeAction(action, context) {
    let resultData = {};

    switch (action) {
      case 'retry':
        const newRetryCount = (context.retryCount || 0) + 1;
        const backoffMs = Math.min(1000 * Math.pow(2, newRetryCount), 30000);
        resultData = {
          retryCount: newRetryCount,
          backoffMs,
          scheduledAt: new Date(Date.now() + backoffMs).toISOString(),
        };
        break;
      case 'rollback':
        resultData = {
          rolledBackTo: context.case?.lastSuccessfulTaskId || 'start',
          affectedWorkItems: [context.workItem?.workItemId],
        };
        break;
      case 'escalate':
        resultData = {
          escalatedTo: 'supervisor',
          originalAssignee: context.workItem?.owner,
          severity: 'high',
        };
        break;
      case 'skip':
        resultData = {
          skipped: true,
          reason: `${this.#exceptionType} exception - continuing to next task`,
        };
        break;
      case 'fail':
        resultData = {
          failed: true,
          reason: context.error?.message || 'Unknown error',
          exceptionType: this.#exceptionType,
        };
        break;
    }

    const receipt = await generateReceipt({
      eventType: YAWL_EVENT_TYPES.EXCEPTION_HANDLED,
      entityId: context.workItem?.workItemId || 'unknown',
      data: {
        workletId: this.#workletId,
        exceptionType: this.#exceptionType,
        action,
        ...resultData,
      },
    });

    return {
      action,
      data: resultData,
      receipt: {
        id: receipt.id,
        hash: receipt.hash,
        timestamp: receipt.timestamp,
      },
    };
  }

  /**
   * @param {string} exceptionType
   * @returns {boolean}
   */
  handles(exceptionType) {
    return this.#exceptionType.toLowerCase() === exceptionType.toLowerCase();
  }
}
{%- endif %}
{%- endfor %}

// =============================================================================
// Worklet Registry
// =============================================================================

export class WorkletRegistry {
  /** @type {Map<string, object>} */
  #worklets = new Map();

  constructor() {
{%- set seen_worklets2 = "" %}
{%- for row in sparql_results %}
{%- set workletId = row["?workletId"] | default(value="") %}
{%- set workletName = row["?workletName"] | default(value="") %}
{%- if workletId != "" and workletId not in seen_worklets2 %}
{%- set_global seen_worklets2 = seen_worklets2 ~ "," ~ workletId %}
    this.#worklets.set('{{ workletId }}', new {{ workletName }}());
{%- endif %}
{%- endfor %}
  }

  /**
   * Get worklet by ID
   * @param {string} workletId
   * @returns {object|undefined}
   */
  get(workletId) {
    return this.#worklets.get(workletId);
  }

  /**
   * Find worklet that handles the given exception type
   * @param {string} exceptionType
   * @returns {object|undefined}
   */
  findByExceptionType(exceptionType) {
    for (const worklet of this.#worklets.values()) {
      if (worklet.handles(exceptionType)) {
        return worklet;
      }
    }
    return undefined;
  }

  /**
   * Evaluate appropriate worklet for context
   * @param {object} context
   * @param {string} exceptionType
   * @returns {Promise<object|null>}
   */
  async evaluate(context, exceptionType) {
    const worklet = this.findByExceptionType(exceptionType);
    if (!worklet) {
      return null;
    }
    return worklet.evaluate(context);
  }

  /**
   * List all registered worklet IDs
   * @returns {string[]}
   */
  listWorkletIds() {
    return Array.from(this.#worklets.keys());
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * @returns {WorkletRegistry}
 */
export function createWorkletRegistry() {
  return new WorkletRegistry();
}
