---
to: "lib/engine/WorkflowEngine.ts"
description: Main workflow engine with Van der Aalst patterns and RDF integration
vars:
  splitTypes: array
  joinTypes: array
metadata:
  category: engine
  framework: typescript
  features: [van-der-aalst-patterns, rdf-integration, receipts]
---
{# =============================================================================
   WORKFLOW ENGINE TEMPLATE
   Generates the main workflow engine with Van der Aalst pattern implementations
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Workflow Engine
 * Implements Van der Aalst workflow patterns with RDF/SPARQL integration
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { EventEmitter } from 'events';
import { z } from 'zod';
import {
  createWorkflow,
  createCase,
  enableTask,
  startTask,
  completeTask,
  cancelWorkItem,
  replayCase,
  YAWL_NS,
  YAWL_EVENT_TYPES,
  WorkflowSpec,
  YawlCase,
  TaskDefinition,
  WorkItem,
  generateReceipt,
  verifyReceipt,
  ProofChain,
} from '@unrdf/yawl';
import { createStore, executeSparqlSelect, executeSparqlAsk } from '@unrdf/oxigraph';

// =============================================================================
// Type Definitions
// =============================================================================

export type SplitBehavior = 'XOR' | 'AND' | 'OR';
export type JoinBehavior = 'XOR' | 'AND' | 'OR';

export interface WorkflowEngineConfig {
  storeType?: 'memory' | 'persistent';
  storagePath?: string;
  enableReceipts?: boolean;
  enableTimeTravel?: boolean;
}

export interface WorkflowMetrics {
  activeCases: number;
  completedCases: number;
  failedCases: number;
  averageCompletionTime: number;
  taskMetrics: Map<string, TaskMetrics>;
}

export interface TaskMetrics {
  executionCount: number;
  averageDuration: number;
  failureRate: number;
}

export interface FlowEvaluation {
  flowId: string;
  sourceTaskId: string;
  targetTaskId: string;
  condition?: string;
  priority: number;
  isDefault: boolean;
  evaluated: boolean;
  result: boolean;
}

// =============================================================================
// Workflow Engine Events
// =============================================================================

export const ENGINE_EVENTS = {
  CASE_CREATED: 'case:created',
  CASE_COMPLETED: 'case:completed',
  CASE_CANCELLED: 'case:cancelled',
  CASE_FAILED: 'case:failed',
  TASK_ENABLED: 'task:enabled',
  TASK_STARTED: 'task:started',
  TASK_COMPLETED: 'task:completed',
  TASK_FAILED: 'task:failed',
  FLOW_EVALUATED: 'flow:evaluated',
  RECEIPT_GENERATED: 'receipt:generated',
} as const;

// =============================================================================
// Van der Aalst Pattern Implementations
// =============================================================================

/**
 * WP1: Sequence Pattern
 * A task is enabled after the preceding task is completed
 */
function evaluateSequence(
  completedTaskId: string,
  flows: FlowEvaluation[]
): string[] {
  return flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .map(f => f.targetTaskId);
}

/**
 * WP2: Parallel Split (AND-Split)
 * Enables all outgoing branches simultaneously
 */
function evaluateAndSplit(
  completedTaskId: string,
  flows: FlowEvaluation[]
): string[] {
  const outgoingFlows = flows.filter(f => f.sourceTaskId === completedTaskId);
  // AND-split: enable ALL targets
  return outgoingFlows.map(f => f.targetTaskId);
}

/**
 * WP3: Synchronization (AND-Join)
 * Waits for all incoming branches to complete before enabling
 */
async function evaluateAndJoin(
  taskId: string,
  store: ReturnType<typeof createStore>,
  caseId: string
): Promise<boolean> {
  // Query for all incoming flows and their completion status
  const query = `
    PREFIX yawl: <${YAWL_NS}>
    ASK {
      ?flow yawl:targetTask ?task .
      ?flow yawl:sourceTask ?source .
      ?workItem yawl:taskRef ?source ;
                yawl:caseRef <${caseId}> ;
                yawl:status yawl:WorkItem_Completed .
      FILTER NOT EXISTS {
        ?otherFlow yawl:targetTask ?task .
        ?otherFlow yawl:sourceTask ?otherSource .
        FILTER NOT EXISTS {
          ?otherWorkItem yawl:taskRef ?otherSource ;
                         yawl:caseRef <${caseId}> ;
                         yawl:status yawl:WorkItem_Completed .
        }
      }
    }
  `.replace('?task', `<${taskId}>`);

  return executeSparqlAsk(store, query);
}

/**
 * WP4: Exclusive Choice (XOR-Split)
 * Enables exactly one outgoing branch based on condition evaluation
 */
function evaluateXorSplit(
  completedTaskId: string,
  flows: FlowEvaluation[],
  caseData: Record<string, unknown>
): string[] {
  const outgoingFlows = flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .sort((a, b) => a.priority - b.priority);

  // Evaluate conditions in priority order
  for (const flow of outgoingFlows) {
    if (flow.condition) {
      const result = evaluateCondition(flow.condition, caseData);
      if (result) {
        return [flow.targetTaskId];
      }
    } else if (flow.isDefault) {
      return [flow.targetTaskId];
    }
  }

  // Fallback to first default flow
  const defaultFlow = outgoingFlows.find(f => f.isDefault);
  return defaultFlow ? [defaultFlow.targetTaskId] : [];
}

/**
 * WP5: Simple Merge (XOR-Join)
 * Enables task when any incoming branch completes
 */
function evaluateXorJoin(
  completedTaskId: string,
  flows: FlowEvaluation[]
): boolean {
  // XOR-join: any incoming completion enables the task
  return flows.some(f => f.sourceTaskId === completedTaskId);
}

/**
 * WP6: Multi-Choice (OR-Split)
 * Enables one or more outgoing branches based on conditions
 */
function evaluateOrSplit(
  completedTaskId: string,
  flows: FlowEvaluation[],
  caseData: Record<string, unknown>
): string[] {
  const outgoingFlows = flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .sort((a, b) => a.priority - b.priority);

  const enabledTargets: string[] = [];

  for (const flow of outgoingFlows) {
    if (flow.condition) {
      const result = evaluateCondition(flow.condition, caseData);
      if (result) {
        enabledTargets.push(flow.targetTaskId);
      }
    } else if (flow.isDefault && enabledTargets.length === 0) {
      enabledTargets.push(flow.targetTaskId);
    }
  }

  // Ensure at least one path is taken
  if (enabledTargets.length === 0) {
    const defaultFlow = outgoingFlows.find(f => f.isDefault);
    if (defaultFlow) {
      enabledTargets.push(defaultFlow.targetTaskId);
    }
  }

  return enabledTargets;
}

/**
 * WP7: Structured Synchronizing Merge (OR-Join)
 * Waits for all active incoming branches (that were actually taken)
 */
async function evaluateOrJoin(
  taskId: string,
  store: ReturnType<typeof createStore>,
  caseId: string
): Promise<boolean> {
  // Query for expected incoming tokens based on which paths were taken
  const query = `
    PREFIX yawl: <${YAWL_NS}>
    ASK {
      # All active incoming paths have completed
      FILTER NOT EXISTS {
        ?flow yawl:targetTask <${taskId}> .
        ?flow yawl:sourceTask ?source .
        ?enabledWorkItem yawl:taskRef ?source ;
                         yawl:caseRef <${caseId}> ;
                         yawl:status ?status .
        FILTER(?status IN (yawl:WorkItem_Enabled, yawl:WorkItem_Started))
      }
    }
  `;

  return executeSparqlAsk(store, query);
}

/**
 * Evaluate a condition expression against case data
 */
function evaluateCondition(
  condition: string,
  caseData: Record<string, unknown>
): boolean {
  try {
    // Simple expression evaluator
    // Format: "field == 'value'" or "field.subfield == value"
    const match = condition.match(/(\w+(?:\.\w+)*)\s*(==|!=|>|<|>=|<=)\s*['"]?([^'"]+)['"]?/);

    if (!match) return false;

    const [, path, operator, expected] = match;
    const actual = getNestedValue(caseData, path);

    switch (operator) {
      case '==': return String(actual) === expected;
      case '!=': return String(actual) !== expected;
      case '>': return Number(actual) > Number(expected);
      case '<': return Number(actual) < Number(expected);
      case '>=': return Number(actual) >= Number(expected);
      case '<=': return Number(actual) <= Number(expected);
      default: return false;
    }
  } catch {
    return false;
  }
}

function getNestedValue(obj: Record<string, unknown>, path: string): unknown {
  return path.split('.').reduce((current: unknown, key) => {
    return current && typeof current === 'object' ? (current as Record<string, unknown>)[key] : undefined;
  }, obj);
}

// =============================================================================
// Workflow Engine Class
// =============================================================================

export class WorkflowEngine extends EventEmitter {
  private store: ReturnType<typeof createStore>;
  private workflows: Map<string, WorkflowSpec> = new Map();
  private cases: Map<string, YawlCase> = new Map();
  private proofChain: ProofChain;
  private config: WorkflowEngineConfig;

  constructor(config: WorkflowEngineConfig = {}) {
    super();
    this.config = {
      storeType: 'memory',
      enableReceipts: true,
      enableTimeTravel: true,
      ...config,
    };
    this.store = createStore();
    this.proofChain = new ProofChain();
  }

  // ---------------------------------------------------------------------------
  // Workflow Management
  // ---------------------------------------------------------------------------

  async createWorkflow(spec: WorkflowSpec): Promise<WorkflowSpec> {
    const workflow = createWorkflow(spec);
    this.workflows.set(workflow.specId, workflow);

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.WORKFLOW_CREATED,
        entityId: workflow.specId,
        data: workflow,
      });
      this.proofChain.append(receipt);
      this.emit(ENGINE_EVENTS.RECEIPT_GENERATED, receipt);
    }

    return workflow;
  }

  async getWorkflow(specId: string): Promise<WorkflowSpec | undefined> {
    return this.workflows.get(specId);
  }

  async listWorkflows(): Promise<WorkflowSpec[]> {
    return Array.from(this.workflows.values());
  }

  async deleteWorkflow(specId: string): Promise<void> {
    this.workflows.delete(specId);
  }

  // ---------------------------------------------------------------------------
  // Case Management
  // ---------------------------------------------------------------------------

  async createCase(
    specId: string,
    initialData?: Record<string, unknown>
  ): Promise<YawlCase> {
    const workflow = this.workflows.get(specId);
    if (!workflow) {
      throw new Error(`Workflow not found: ${specId}`);
    }

    const caseInstance = await createCase(this.store, workflow, initialData);
    this.cases.set(caseInstance.caseId, caseInstance);

    this.emit(ENGINE_EVENTS.CASE_CREATED, caseInstance);

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.CASE_STARTED,
        entityId: caseInstance.caseId,
        data: caseInstance,
        previousHash: this.proofChain.getLatestHash(),
      });
      this.proofChain.append(receipt);
    }

    // Enable first task(s)
    await this.evaluateAndEnableTasks(caseInstance);

    return caseInstance;
  }

  async getCase(caseId: string): Promise<YawlCase | undefined> {
    return this.cases.get(caseId);
  }

  async listCases(filter?: { status?: string; specId?: string }): Promise<YawlCase[]> {
    let cases = Array.from(this.cases.values());

    if (filter?.status) {
      cases = cases.filter(c => c.status === filter.status);
    }
    if (filter?.specId) {
      cases = cases.filter(c => c.specId === filter.specId);
    }

    return cases;
  }

  async cancelCase(caseId: string): Promise<void> {
    const caseInstance = this.cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    caseInstance.status = 'cancelled';
    caseInstance.updatedAt = new Date().toISOString();

    this.emit(ENGINE_EVENTS.CASE_CANCELLED, caseInstance);

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.CASE_CANCELLED,
        entityId: caseId,
        data: { reason: 'User requested cancellation' },
        previousHash: this.proofChain.getLatestHash(),
      });
      this.proofChain.append(receipt);
    }
  }

  async replayCase(caseId: string, toTimestamp: Date): Promise<YawlCase> {
    if (!this.config.enableTimeTravel) {
      throw new Error('Time travel not enabled');
    }

    const replayedCase = await replayCase(this.store, caseId, toTimestamp);
    return replayedCase;
  }

  // ---------------------------------------------------------------------------
  // Task Management
  // ---------------------------------------------------------------------------

  async enableTask(caseId: string, taskId: string): Promise<WorkItem> {
    const caseInstance = this.cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    const workItem = await enableTask(this.store, caseInstance, taskId);

    this.emit(ENGINE_EVENTS.TASK_ENABLED, { caseId, taskId, workItem });

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_ENABLED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.proofChain.getLatestHash(),
      });
      this.proofChain.append(receipt);
    }

    return workItem;
  }

  async startTask(
    caseId: string,
    taskId: string,
    userId?: string
  ): Promise<WorkItem> {
    const workItem = await startTask(this.store, caseId, taskId, userId);

    this.emit(ENGINE_EVENTS.TASK_STARTED, { caseId, taskId, workItem });

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_STARTED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.proofChain.getLatestHash(),
      });
      this.proofChain.append(receipt);
    }

    return workItem;
  }

  async completeTask(
    caseId: string,
    taskId: string,
    outputData?: Record<string, unknown>
  ): Promise<WorkItem> {
    const caseInstance = this.cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    const workItem = await completeTask(this.store, caseId, taskId, outputData);

    this.emit(ENGINE_EVENTS.TASK_COMPLETED, { caseId, taskId, workItem });

    if (this.config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_COMPLETED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.proofChain.getLatestHash(),
      });
      this.proofChain.append(receipt);
    }

    // Evaluate control flow and enable next tasks
    await this.evaluateControlFlow(caseInstance, taskId, outputData);

    return workItem;
  }

  async listWorkItems(filter?: {
    caseId?: string;
    taskId?: string;
    status?: string;
  }): Promise<WorkItem[]> {
    // Query work items from RDF store
    let query = `
      PREFIX yawl: <${YAWL_NS}>
      SELECT ?workItemId ?taskId ?caseId ?status ?owner
      WHERE {
        ?workItem a yawl:WorkItem ;
                  yawl:workItemId ?workItemId ;
                  yawl:taskRef ?task ;
                  yawl:caseRef ?case ;
                  yawl:status ?statusNode .
        ?task yawl:taskId ?taskId .
        ?case yawl:caseId ?caseId .
        ?statusNode rdfs:label ?status .
        OPTIONAL { ?workItem yawl:owner ?owner }
    `;

    if (filter?.caseId) {
      query += `FILTER(?caseId = "${filter.caseId}")`;
    }
    if (filter?.taskId) {
      query += `FILTER(?taskId = "${filter.taskId}")`;
    }
    if (filter?.status) {
      query += `FILTER(?status = "${filter.status}")`;
    }

    query += `}`;

    const results = await executeSparqlSelect(this.store, query);
    return results.map(row => ({
      workItemId: row['?workItemId'],
      taskId: row['?taskId'],
      caseId: row['?caseId'],
      status: row['?status'],
      owner: row['?owner'],
    })) as WorkItem[];
  }

  // ---------------------------------------------------------------------------
  // Control Flow Evaluation
  // ---------------------------------------------------------------------------

  private async evaluateControlFlow(
    caseInstance: YawlCase,
    completedTaskId: string,
    taskOutput?: Record<string, unknown>
  ): Promise<void> {
    const workflow = this.workflows.get(caseInstance.specId);
    if (!workflow) return;

    // Get task definition to determine split behavior
    const task = workflow.tasks.find(t => t.taskId === completedTaskId);
    if (!task) return;

    // Merge task output into case data
    const caseData = {
      ...caseInstance.caseData,
      ...taskOutput,
    };

    // Get outgoing flows
    const flows: FlowEvaluation[] = workflow.flows
      .filter(f => f.sourceTaskId === completedTaskId)
      .map(f => ({
        flowId: f.flowId || `${f.sourceTaskId}-${f.targetTaskId}`,
        sourceTaskId: f.sourceTaskId,
        targetTaskId: f.targetTaskId,
        condition: f.condition,
        priority: f.priority || 1,
        isDefault: f.isDefault || false,
        evaluated: false,
        result: false,
      }));

    let nextTaskIds: string[] = [];

    // Evaluate based on split behavior
    switch (task.splitBehavior) {
      case 'XOR':
        nextTaskIds = evaluateXorSplit(completedTaskId, flows, caseData);
        break;
      case 'AND':
        nextTaskIds = evaluateAndSplit(completedTaskId, flows);
        break;
      case 'OR':
        nextTaskIds = evaluateOrSplit(completedTaskId, flows, caseData);
        break;
      default:
        // Default to sequence (single flow)
        nextTaskIds = evaluateSequence(completedTaskId, flows);
    }

    // Emit flow evaluation events
    for (const flow of flows) {
      flow.result = nextTaskIds.includes(flow.targetTaskId);
      flow.evaluated = true;
      this.emit(ENGINE_EVENTS.FLOW_EVALUATED, flow);
    }

    // Enable next tasks after checking join conditions
    for (const targetTaskId of nextTaskIds) {
      const targetTask = workflow.tasks.find(t => t.taskId === targetTaskId);
      if (!targetTask) continue;

      let canEnable = true;

      // Check join behavior
      switch (targetTask.joinBehavior) {
        case 'AND':
          canEnable = await evaluateAndJoin(targetTaskId, this.store, caseInstance.caseId);
          break;
        case 'OR':
          canEnable = await evaluateOrJoin(targetTaskId, this.store, caseInstance.caseId);
          break;
        case 'XOR':
        default:
          canEnable = true; // XOR join: first arriving token enables
      }

      if (canEnable) {
        await this.enableTask(caseInstance.caseId, targetTaskId);
      }
    }

    // Check if case is complete (output condition reached)
    if (nextTaskIds.length === 0) {
      // Check if we're at the output condition
      const hasMoreTasks = workflow.flows.some(f => f.sourceTaskId === completedTaskId);
      if (!hasMoreTasks) {
        caseInstance.status = 'completed';
        caseInstance.completedAt = new Date().toISOString();
        this.emit(ENGINE_EVENTS.CASE_COMPLETED, caseInstance);
      }
    }
  }

  private async evaluateAndEnableTasks(caseInstance: YawlCase): Promise<void> {
    const workflow = this.workflows.get(caseInstance.specId);
    if (!workflow) return;

    // Find input condition tasks (tasks with no incoming flows)
    const tasksWithIncoming = new Set(workflow.flows.map(f => f.targetTaskId));
    const startTasks = workflow.tasks.filter(t => !tasksWithIncoming.has(t.taskId));

    for (const task of startTasks) {
      await this.enableTask(caseInstance.caseId, task.taskId);
    }
  }

  // ---------------------------------------------------------------------------
  // Metrics & Admin
  // ---------------------------------------------------------------------------

  async getMetrics(): Promise<WorkflowMetrics> {
    const cases = Array.from(this.cases.values());

    return {
      activeCases: cases.filter(c => c.status === 'active').length,
      completedCases: cases.filter(c => c.status === 'completed').length,
      failedCases: cases.filter(c => c.status === 'failed').length,
      averageCompletionTime: this.calculateAverageCompletionTime(cases),
      taskMetrics: new Map(),
    };
  }

  private calculateAverageCompletionTime(cases: YawlCase[]): number {
    const completedCases = cases.filter(c => c.completedAt);
    if (completedCases.length === 0) return 0;

    const totalTime = completedCases.reduce((sum, c) => {
      const start = new Date(c.createdAt).getTime();
      const end = new Date(c.completedAt!).getTime();
      return sum + (end - start);
    }, 0);

    return totalTime / completedCases.length;
  }

  /**
   * Verify the integrity of the receipt chain
   */
  async verifyReceiptChain(): Promise<boolean> {
    return this.proofChain.verify();
  }

  /**
   * Get the RDF store for direct SPARQL queries
   */
  getStore(): ReturnType<typeof createStore> {
    return this.store;
  }
}

// =============================================================================
// Factory Function
// =============================================================================

export function createWorkflowEngine(
  config?: WorkflowEngineConfig
): WorkflowEngine {
  return new WorkflowEngine(config);
}
