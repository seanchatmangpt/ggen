---
to: "lib/engine/WorkflowEngine.mjs"
description: Main workflow engine with Van der Aalst patterns and RDF integration
vars:
  splitTypes: array
  joinTypes: array
metadata:
  category: engine
  framework: esm
  features: [van-der-aalst-patterns, rdf-integration, receipts]
---
{# =============================================================================
   WORKFLOW ENGINE TEMPLATE
   Generates the main workflow engine with Van der Aalst pattern implementations
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview YAWL Workflow Engine
 * Implements Van der Aalst workflow patterns with RDF/SPARQL integration
 * DO NOT EDIT - auto-generated by ggen sync
 * @module WorkflowEngine
 */

import { EventEmitter } from 'events';
import { z } from 'zod';
import {
  createWorkflow,
  createCase,
  enableTask,
  startTask,
  completeTask,
  cancelWorkItem,
  replayCase,
  YAWL_NS,
  YAWL_EVENT_TYPES,
  generateReceipt,
  verifyReceipt,
  ProofChain,
  createYawlStore,
  executeSparqlSelect,
  executeSparqlAsk,
} from '@unrdf/yawl';

// =============================================================================
// Zod Schemas for Runtime Validation
// =============================================================================

export const SplitBehaviorSchema = z.enum(['XOR', 'AND', 'OR']);
export const JoinBehaviorSchema = z.enum(['XOR', 'AND', 'OR']);

export const WorkflowEngineConfigSchema = z.object({
  storeType: z.enum(['memory', 'persistent']).default('memory'),
  storagePath: z.string().optional(),
  enableReceipts: z.boolean().default(true),
  enableTimeTravel: z.boolean().default(true),
});

export const WorkflowMetricsSchema = z.object({
  activeCases: z.number(),
  completedCases: z.number(),
  failedCases: z.number(),
  averageCompletionTime: z.number(),
});

export const TaskMetricsSchema = z.object({
  executionCount: z.number(),
  averageDuration: z.number(),
  failureRate: z.number(),
});

export const FlowEvaluationSchema = z.object({
  flowId: z.string(),
  sourceTaskId: z.string(),
  targetTaskId: z.string(),
  condition: z.string().optional(),
  priority: z.number(),
  isDefault: z.boolean(),
  evaluated: z.boolean(),
  result: z.boolean(),
});

// =============================================================================
// Workflow Engine Events
// =============================================================================

export const ENGINE_EVENTS = {
  CASE_CREATED: 'case:created',
  CASE_COMPLETED: 'case:completed',
  CASE_CANCELLED: 'case:cancelled',
  CASE_FAILED: 'case:failed',
  TASK_ENABLED: 'task:enabled',
  TASK_STARTED: 'task:started',
  TASK_COMPLETED: 'task:completed',
  TASK_FAILED: 'task:failed',
  FLOW_EVALUATED: 'flow:evaluated',
  RECEIPT_GENERATED: 'receipt:generated',
};

// =============================================================================
// Van der Aalst Pattern Implementations
// =============================================================================

/**
 * WP1: Sequence Pattern
 * A task is enabled after the preceding task is completed
 * @param {string} completedTaskId
 * @param {Array} flows
 * @returns {string[]}
 */
function evaluateSequence(completedTaskId, flows) {
  return flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .map(f => f.targetTaskId);
}

/**
 * WP2: Parallel Split (AND-Split)
 * Enables all outgoing branches simultaneously
 * @param {string} completedTaskId
 * @param {Array} flows
 * @returns {string[]}
 */
function evaluateAndSplit(completedTaskId, flows) {
  const outgoingFlows = flows.filter(f => f.sourceTaskId === completedTaskId);
  return outgoingFlows.map(f => f.targetTaskId);
}

/**
 * WP3: Synchronization (AND-Join)
 * Waits for all incoming branches to complete before enabling
 * @param {string} taskId
 * @param {object} store
 * @param {string} caseId
 * @returns {Promise<boolean>}
 */
async function evaluateAndJoin(taskId, store, caseId) {
  const query = `
    PREFIX yawl: <${YAWL_NS}>
    ASK {
      ?flow yawl:targetTask ?task .
      ?flow yawl:sourceTask ?source .
      ?workItem yawl:taskRef ?source ;
                yawl:caseRef <${caseId}> ;
                yawl:status yawl:WorkItem_Completed .
      FILTER NOT EXISTS {
        ?otherFlow yawl:targetTask ?task .
        ?otherFlow yawl:sourceTask ?otherSource .
        FILTER NOT EXISTS {
          ?otherWorkItem yawl:taskRef ?otherSource ;
                         yawl:caseRef <${caseId}> ;
                         yawl:status yawl:WorkItem_Completed .
        }
      }
    }
  `.replace('?task', `<${taskId}>`);

  return executeSparqlAsk(store, query);
}

/**
 * WP4: Exclusive Choice (XOR-Split)
 * Enables exactly one outgoing branch based on condition evaluation
 * @param {string} completedTaskId
 * @param {Array} flows
 * @param {object} caseData
 * @returns {string[]}
 */
function evaluateXorSplit(completedTaskId, flows, caseData) {
  const outgoingFlows = flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .sort((a, b) => a.priority - b.priority);

  for (const flow of outgoingFlows) {
    if (flow.condition) {
      const result = evaluateCondition(flow.condition, caseData);
      if (result) {
        return [flow.targetTaskId];
      }
    } else if (flow.isDefault) {
      return [flow.targetTaskId];
    }
  }

  const defaultFlow = outgoingFlows.find(f => f.isDefault);
  return defaultFlow ? [defaultFlow.targetTaskId] : [];
}

/**
 * WP5: Simple Merge (XOR-Join)
 * Enables task when any incoming branch completes
 * @param {string} completedTaskId
 * @param {Array} flows
 * @returns {boolean}
 */
function evaluateXorJoin(completedTaskId, flows) {
  return flows.some(f => f.sourceTaskId === completedTaskId);
}

/**
 * WP6: Multi-Choice (OR-Split)
 * Enables one or more outgoing branches based on conditions
 * @param {string} completedTaskId
 * @param {Array} flows
 * @param {object} caseData
 * @returns {string[]}
 */
function evaluateOrSplit(completedTaskId, flows, caseData) {
  const outgoingFlows = flows
    .filter(f => f.sourceTaskId === completedTaskId)
    .sort((a, b) => a.priority - b.priority);

  const enabledTargets = [];

  for (const flow of outgoingFlows) {
    if (flow.condition) {
      const result = evaluateCondition(flow.condition, caseData);
      if (result) {
        enabledTargets.push(flow.targetTaskId);
      }
    } else if (flow.isDefault && enabledTargets.length === 0) {
      enabledTargets.push(flow.targetTaskId);
    }
  }

  if (enabledTargets.length === 0) {
    const defaultFlow = outgoingFlows.find(f => f.isDefault);
    if (defaultFlow) {
      enabledTargets.push(defaultFlow.targetTaskId);
    }
  }

  return enabledTargets;
}

/**
 * WP7: Structured Synchronizing Merge (OR-Join)
 * Waits for all active incoming branches (that were actually taken)
 * @param {string} taskId
 * @param {object} store
 * @param {string} caseId
 * @returns {Promise<boolean>}
 */
async function evaluateOrJoin(taskId, store, caseId) {
  const query = `
    PREFIX yawl: <${YAWL_NS}>
    ASK {
      FILTER NOT EXISTS {
        ?flow yawl:targetTask <${taskId}> .
        ?flow yawl:sourceTask ?source .
        ?enabledWorkItem yawl:taskRef ?source ;
                         yawl:caseRef <${caseId}> ;
                         yawl:status ?status .
        FILTER(?status IN (yawl:WorkItem_Enabled, yawl:WorkItem_Started))
      }
    }
  `;

  return executeSparqlAsk(store, query);
}

/**
 * Evaluate a condition expression against case data
 * @param {string} condition
 * @param {object} caseData
 * @returns {boolean}
 */
function evaluateCondition(condition, caseData) {
  try {
    const match = condition.match(/(\w+(?:\.\w+)*)\s*(==|!=|>|<|>=|<=)\s*['"]?([^'"]+)['"]?/);

    if (!match) return false;

    const [, path, operator, expected] = match;
    const actual = getNestedValue(caseData, path);

    switch (operator) {
      case '==': return String(actual) === expected;
      case '!=': return String(actual) !== expected;
      case '>': return Number(actual) > Number(expected);
      case '<': return Number(actual) < Number(expected);
      case '>=': return Number(actual) >= Number(expected);
      case '<=': return Number(actual) <= Number(expected);
      default: return false;
    }
  } catch {
    return false;
  }
}

/**
 * Get nested value from object using dot notation
 * @param {object} obj
 * @param {string} path
 * @returns {*}
 */
function getNestedValue(obj, path) {
  return path.split('.').reduce((current, key) => {
    return current && typeof current === 'object' ? current[key] : undefined;
  }, obj);
}

// =============================================================================
// Workflow Engine Class
// =============================================================================

export class WorkflowEngine extends EventEmitter {
  /** @type {object} */
  #store;
  /** @type {Map<string, object>} */
  #workflows = new Map();
  /** @type {Map<string, object>} */
  #cases = new Map();
  /** @type {ProofChain} */
  #proofChain;
  /** @type {object} */
  #config;

  /**
   * @param {object} config
   */
  constructor(config = {}) {
    super();
    this.#config = WorkflowEngineConfigSchema.parse({
      storeType: 'memory',
      enableReceipts: true,
      enableTimeTravel: true,
      ...config,
    });
    this.#store = createYawlStore();
    this.#proofChain = new ProofChain();
  }

  // ---------------------------------------------------------------------------
  // Workflow Management
  // ---------------------------------------------------------------------------

  /**
   * @param {object} spec
   * @returns {Promise<object>}
   */
  async createWorkflow(spec) {
    const workflow = createWorkflow(spec);
    this.#workflows.set(workflow.specId, workflow);

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.WORKFLOW_CREATED,
        entityId: workflow.specId,
        data: workflow,
      });
      this.#proofChain.append(receipt);
      this.emit(ENGINE_EVENTS.RECEIPT_GENERATED, receipt);
    }

    return workflow;
  }

  /**
   * @param {string} specId
   * @returns {Promise<object|undefined>}
   */
  async getWorkflow(specId) {
    return this.#workflows.get(specId);
  }

  /**
   * @returns {Promise<object[]>}
   */
  async listWorkflows() {
    return Array.from(this.#workflows.values());
  }

  /**
   * @param {string} specId
   * @returns {Promise<void>}
   */
  async deleteWorkflow(specId) {
    this.#workflows.delete(specId);
  }

  // ---------------------------------------------------------------------------
  // Case Management
  // ---------------------------------------------------------------------------

  /**
   * @param {string} specId
   * @param {object} [initialData]
   * @returns {Promise<object>}
   */
  async createCase(specId, initialData) {
    const workflow = this.#workflows.get(specId);
    if (!workflow) {
      throw new Error(`Workflow not found: ${specId}`);
    }

    const caseInstance = await createCase(this.#store, workflow, initialData);
    this.#cases.set(caseInstance.caseId, caseInstance);

    this.emit(ENGINE_EVENTS.CASE_CREATED, caseInstance);

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.CASE_STARTED,
        entityId: caseInstance.caseId,
        data: caseInstance,
        previousHash: this.#proofChain.getLatestHash(),
      });
      this.#proofChain.append(receipt);
    }

    await this.#evaluateAndEnableTasks(caseInstance);

    return caseInstance;
  }

  /**
   * @param {string} caseId
   * @returns {Promise<object|undefined>}
   */
  async getCase(caseId) {
    return this.#cases.get(caseId);
  }

  /**
   * @param {object} [filter]
   * @returns {Promise<object[]>}
   */
  async listCases(filter) {
    let cases = Array.from(this.#cases.values());

    if (filter?.status) {
      cases = cases.filter(c => c.status === filter.status);
    }
    if (filter?.specId) {
      cases = cases.filter(c => c.specId === filter.specId);
    }

    return cases;
  }

  /**
   * @param {string} caseId
   * @returns {Promise<void>}
   */
  async cancelCase(caseId) {
    const caseInstance = this.#cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    caseInstance.status = 'cancelled';
    caseInstance.updatedAt = new Date().toISOString();

    this.emit(ENGINE_EVENTS.CASE_CANCELLED, caseInstance);

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.CASE_CANCELLED,
        entityId: caseId,
        data: { reason: 'User requested cancellation' },
        previousHash: this.#proofChain.getLatestHash(),
      });
      this.#proofChain.append(receipt);
    }
  }

  /**
   * @param {string} caseId
   * @param {Date} toTimestamp
   * @returns {Promise<object>}
   */
  async replayCase(caseId, toTimestamp) {
    if (!this.#config.enableTimeTravel) {
      throw new Error('Time travel not enabled');
    }

    const replayedCase = await replayCase(this.#store, caseId, toTimestamp);
    return replayedCase;
  }

  // ---------------------------------------------------------------------------
  // Task Management
  // ---------------------------------------------------------------------------

  /**
   * @param {string} caseId
   * @param {string} taskId
   * @returns {Promise<object>}
   */
  async enableTask(caseId, taskId) {
    const caseInstance = this.#cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    const workItem = await enableTask(this.#store, caseInstance, taskId);

    this.emit(ENGINE_EVENTS.TASK_ENABLED, { caseId, taskId, workItem });

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_ENABLED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.#proofChain.getLatestHash(),
      });
      this.#proofChain.append(receipt);
    }

    return workItem;
  }

  /**
   * @param {string} caseId
   * @param {string} taskId
   * @param {string} [userId]
   * @returns {Promise<object>}
   */
  async startTask(caseId, taskId, userId) {
    const workItem = await startTask(this.#store, caseId, taskId, userId);

    this.emit(ENGINE_EVENTS.TASK_STARTED, { caseId, taskId, workItem });

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_STARTED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.#proofChain.getLatestHash(),
      });
      this.#proofChain.append(receipt);
    }

    return workItem;
  }

  /**
   * @param {string} caseId
   * @param {string} taskId
   * @param {object} [outputData]
   * @returns {Promise<object>}
   */
  async completeTask(caseId, taskId, outputData) {
    const caseInstance = this.#cases.get(caseId);
    if (!caseInstance) {
      throw new Error(`Case not found: ${caseId}`);
    }

    const workItem = await completeTask(this.#store, caseId, taskId, outputData);

    this.emit(ENGINE_EVENTS.TASK_COMPLETED, { caseId, taskId, workItem });

    if (this.#config.enableReceipts) {
      const receipt = await generateReceipt({
        eventType: YAWL_EVENT_TYPES.TASK_COMPLETED,
        entityId: workItem.workItemId,
        data: workItem,
        previousHash: this.#proofChain.getLatestHash(),
      });
      this.#proofChain.append(receipt);
    }

    await this.#evaluateControlFlow(caseInstance, taskId, outputData);

    return workItem;
  }

  /**
   * @param {object} [filter]
   * @returns {Promise<object[]>}
   */
  async listWorkItems(filter) {
    let query = `
      PREFIX yawl: <${YAWL_NS}>
      SELECT ?workItemId ?taskId ?caseId ?status ?owner
      WHERE {
        ?workItem a yawl:WorkItem ;
                  yawl:workItemId ?workItemId ;
                  yawl:taskRef ?task ;
                  yawl:caseRef ?case ;
                  yawl:status ?statusNode .
        ?task yawl:taskId ?taskId .
        ?case yawl:caseId ?caseId .
        ?statusNode rdfs:label ?status .
        OPTIONAL { ?workItem yawl:owner ?owner }
    `;

    if (filter?.caseId) {
      query += `FILTER(?caseId = "${filter.caseId}")`;
    }
    if (filter?.taskId) {
      query += `FILTER(?taskId = "${filter.taskId}")`;
    }
    if (filter?.status) {
      query += `FILTER(?status = "${filter.status}")`;
    }

    query += `}`;

    const results = await executeSparqlSelect(this.#store, query);
    return results.map(row => ({
      workItemId: row['?workItemId'],
      taskId: row['?taskId'],
      caseId: row['?caseId'],
      status: row['?status'],
      owner: row['?owner'],
    }));
  }

  // ---------------------------------------------------------------------------
  // Control Flow Evaluation
  // ---------------------------------------------------------------------------

  /**
   * @param {object} caseInstance
   * @param {string} completedTaskId
   * @param {object} [taskOutput]
   */
  async #evaluateControlFlow(caseInstance, completedTaskId, taskOutput) {
    const workflow = this.#workflows.get(caseInstance.specId);
    if (!workflow) return;

    const task = workflow.tasks.find(t => t.taskId === completedTaskId);
    if (!task) return;

    const caseData = {
      ...caseInstance.caseData,
      ...taskOutput,
    };

    const flows = workflow.flows
      .filter(f => f.sourceTaskId === completedTaskId)
      .map(f => ({
        flowId: f.flowId || `${f.sourceTaskId}-${f.targetTaskId}`,
        sourceTaskId: f.sourceTaskId,
        targetTaskId: f.targetTaskId,
        condition: f.condition,
        priority: f.priority || 1,
        isDefault: f.isDefault || false,
        evaluated: false,
        result: false,
      }));

    let nextTaskIds = [];

    switch (task.splitBehavior) {
      case 'XOR':
        nextTaskIds = evaluateXorSplit(completedTaskId, flows, caseData);
        break;
      case 'AND':
        nextTaskIds = evaluateAndSplit(completedTaskId, flows);
        break;
      case 'OR':
        nextTaskIds = evaluateOrSplit(completedTaskId, flows, caseData);
        break;
      default:
        nextTaskIds = evaluateSequence(completedTaskId, flows);
    }

    for (const flow of flows) {
      flow.result = nextTaskIds.includes(flow.targetTaskId);
      flow.evaluated = true;
      this.emit(ENGINE_EVENTS.FLOW_EVALUATED, flow);
    }

    for (const targetTaskId of nextTaskIds) {
      const targetTask = workflow.tasks.find(t => t.taskId === targetTaskId);
      if (!targetTask) continue;

      let canEnable = true;

      switch (targetTask.joinBehavior) {
        case 'AND':
          canEnable = await evaluateAndJoin(targetTaskId, this.#store, caseInstance.caseId);
          break;
        case 'OR':
          canEnable = await evaluateOrJoin(targetTaskId, this.#store, caseInstance.caseId);
          break;
        case 'XOR':
        default:
          canEnable = true;
      }

      if (canEnable) {
        await this.enableTask(caseInstance.caseId, targetTaskId);
      }
    }

    if (nextTaskIds.length === 0) {
      const hasMoreTasks = workflow.flows.some(f => f.sourceTaskId === completedTaskId);
      if (!hasMoreTasks) {
        caseInstance.status = 'completed';
        caseInstance.completedAt = new Date().toISOString();
        this.emit(ENGINE_EVENTS.CASE_COMPLETED, caseInstance);
      }
    }
  }

  /**
   * @param {object} caseInstance
   */
  async #evaluateAndEnableTasks(caseInstance) {
    const workflow = this.#workflows.get(caseInstance.specId);
    if (!workflow) return;

    const tasksWithIncoming = new Set(workflow.flows.map(f => f.targetTaskId));
    const startTasks = workflow.tasks.filter(t => !tasksWithIncoming.has(t.taskId));

    for (const task of startTasks) {
      await this.enableTask(caseInstance.caseId, task.taskId);
    }
  }

  // ---------------------------------------------------------------------------
  // Metrics & Admin
  // ---------------------------------------------------------------------------

  /**
   * @returns {Promise<object>}
   */
  async getMetrics() {
    const cases = Array.from(this.#cases.values());

    return {
      activeCases: cases.filter(c => c.status === 'active').length,
      completedCases: cases.filter(c => c.status === 'completed').length,
      failedCases: cases.filter(c => c.status === 'failed').length,
      averageCompletionTime: this.#calculateAverageCompletionTime(cases),
      taskMetrics: new Map(),
    };
  }

  /**
   * @param {Array} cases
   * @returns {number}
   */
  #calculateAverageCompletionTime(cases) {
    const completedCases = cases.filter(c => c.completedAt);
    if (completedCases.length === 0) return 0;

    const totalTime = completedCases.reduce((sum, c) => {
      const start = new Date(c.createdAt).getTime();
      const end = new Date(c.completedAt).getTime();
      return sum + (end - start);
    }, 0);

    return totalTime / completedCases.length;
  }

  /**
   * Verify the integrity of the receipt chain
   * @returns {Promise<boolean>}
   */
  async verifyReceiptChain() {
    return this.#proofChain.verify();
  }

  /**
   * Get the RDF store for direct SPARQL queries
   * @returns {object}
   */
  getStore() {
    return this.#store;
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * @param {object} [config]
 * @returns {WorkflowEngine}
 */
export function createWorkflowEngine(config) {
  return new WorkflowEngine(config);
}
