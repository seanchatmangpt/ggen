/**
 * @fileoverview YAWL Workflow Integration Tests
 * Generated from RDF specifications with MSW mocking
 * DO NOT EDIT - auto-generated by ggen sync
 * @module tests
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { setupServer } from 'msw/node';
import { http, HttpResponse } from 'msw';

// =============================================================================
// Test Imports
// =============================================================================

import { taskRegistry, TaskRegistry } from '../definitions/tasks.mjs';
import { flowRegistry, FlowRegistry } from '../definitions/flows.mjs';
import { WORKFLOW_INDEX, getWorkflowSummary, listWorkflowIds } from '../definitions/index.mjs';
import { CaseStatus, isValidTransition } from '../types/cases.mjs';
import { WorkItemStatus, isValidWorkItemTransition, isTerminalStatus } from '../types/workitems.mjs';
import { createWorkflowEngine } from '../engine/WorkflowEngine.mjs';
import { ROUTES, getRoute, getProtectedRoutes } from '../api/routes.mjs';
import { workletRegistry, hasExceptionHandler } from '../worklets/index.mjs';

// =============================================================================
// MSW Server Setup
// =============================================================================

const handlers = [
  // Workflow endpoints
  http.get('/api/workflows', () => {
    return HttpResponse.json(WORKFLOW_INDEX);
  }),
  http.get('/api/workflows/:id', ({ params }) => {
    const workflow = getWorkflowSummary(params.id);
    if (!workflow) {
      return new HttpResponse(null, { status: 404 });
    }
    return HttpResponse.json(workflow);
  }),
  http.post('/api/workflows', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json({ workflowId: 'wf-001', status: 'created' });
  }),
  // Case endpoints
  http.get('/api/cases', () => {
    return HttpResponse.json([]);
  }),
  http.get('/api/cases/:id', ({ params }) => {
    return HttpResponse.json({
      caseId: params.id,
      specId: 'document-approval',
      status: 'active',
    });
  }),
  http.post('/api/cases', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json({ caseId: 'case-001', status: 'active' });
  }),
  http.post('/api/cases/:id/cancel', ({ params }) => {
    return HttpResponse.json({ caseId: params.id, status: 'cancelled' });
  }),
  // Task endpoints
  http.get('/api/workitems', () => {
    return HttpResponse.json([]);
  }),
  http.post('/api/tasks/:taskId/enable', ({ params }) => {
    return HttpResponse.json({ taskId: params.taskId, status: 'enabled' });
  }),
  http.post('/api/tasks/:taskId/start', ({ params }) => {
    return HttpResponse.json({ taskId: params.taskId, status: 'started' });
  }),
  http.post('/api/tasks/:taskId/complete', ({ params }) => {
    return HttpResponse.json({ taskId: params.taskId, status: 'completed' });
  }),
  // Admin endpoints
  http.get('/api/admin/metrics', () => {
    return HttpResponse.json({ activeCases: 0, completedCases: 0 });
  }),
  http.post('/api/admin/cases/:id/replay', ({ params }) => {
    return HttpResponse.json({ caseId: params.id, status: 'replayed' });
  }),
];

const server = setupServer(...handlers);

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterAll(() => server.close());
beforeEach(() => server.resetHandlers());

// =============================================================================
// Workflow Specification Tests
// =============================================================================

describe('Workflow Specifications', () => {
  describe('cicd-pipeline', () => {
    it('should have correct task count', () => {
      const tasks = taskRegistry.getWorkflowTasks('cicd-pipeline');
      expect(tasks).toHaveLength(7);
    });

    it('should have build-project with OR-split', () => {
      const task = taskRegistry.getTask('cicd-pipeline', 'build-project');
      expect(task).toBeDefined();
      expect(task.splitBehavior).toBe('OR');
    });

    it('should have merge-results with OR-join', () => {
      const task = taskRegistry.getTask('cicd-pipeline', 'merge-results');
      expect(task).toBeDefined();
      expect(task.joinBehavior).toBe('OR');
    });

    it('should have conditional flows', () => {
      const flows = flowRegistry.getFlows('cicd-pipeline');
      const conditionalFlows = flows.filter(f => f.condition);
      expect(conditionalFlows.length).toBeGreaterThan(0);
    });
  });

  describe('document-approval', () => {
    it('should have correct task count', () => {
      const tasks = taskRegistry.getWorkflowTasks('document-approval');
      expect(tasks).toHaveLength(5);
    });

    it('should have XOR decision branching', () => {
      const flows = flowRegistry.getOutgoingFlows('document-approval', 'review-document');
      expect(flows).toHaveLength(2);
      expect(flows.some(f => f.condition?.includes('approved'))).toBe(true);
      expect(flows.some(f => f.condition?.includes('rejected'))).toBe(true);
    });
  });

  describe('hr-onboarding', () => {
    it('should have correct task count', () => {
      const tasks = taskRegistry.getWorkflowTasks('hr-onboarding');
      expect(tasks).toHaveLength(5);
    });

    it('should have multiple instance task', () => {
      const task = taskRegistry.getTask('hr-onboarding', 'complete-training-module');
      expect(task).toBeDefined();
      expect(task.taskKind).toBe('multiple-instance');
      expect(task.miConfig).toBeDefined();
      expect(task.miConfig.minimum).toBe(1);
      expect(task.miConfig.maximum).toBe(10);
    });

    it('should have AND-split on assign-training', () => {
      const task = taskRegistry.getTask('hr-onboarding', 'assign-training');
      expect(task).toBeDefined();
      expect(task.splitBehavior).toBe('AND');
    });
  });

  describe('incident-management', () => {
    it('should have correct task count', () => {
      const tasks = taskRegistry.getWorkflowTasks('incident-management');
      expect(tasks).toHaveLength(6);
    });

    it('should have sequential flow', () => {
      const flows = flowRegistry.getFlows('incident-management');
      expect(flows).toHaveLength(5);
      expect(flows.every(f => f.isDefault)).toBe(true);
    });
  });

  describe('order-processing', () => {
    it('should have correct task count', () => {
      const tasks = taskRegistry.getWorkflowTasks('order-processing');
      expect(tasks).toHaveLength(5);
    });

    it('should have AND-split for parallel processing', () => {
      const task = taskRegistry.getTask('order-processing', 'receive-order');
      expect(task).toBeDefined();
      expect(task.splitBehavior).toBe('AND');
    });

    it('should have AND-join for synchronization', () => {
      const task = taskRegistry.getTask('order-processing', 'fulfill-order');
      expect(task).toBeDefined();
      expect(task.joinBehavior).toBe('AND');
    });
  });
});

// =============================================================================
// Workflow Index Tests
// =============================================================================

describe('Workflow Index', () => {
  it('should list all workflows', () => {
    expect(WORKFLOW_INDEX).toHaveLength(5);
  });

  it('should list workflow IDs', () => {
    const ids = listWorkflowIds();
    expect(ids).toContain('cicd-pipeline');
    expect(ids).toContain('document-approval');
    expect(ids).toContain('hr-onboarding');
    expect(ids).toContain('incident-management');
    expect(ids).toContain('order-processing');
  });

  it('should get workflow summary', () => {
    const summary = getWorkflowSummary('document-approval');
    expect(summary).toBeDefined();
    expect(summary.specName).toBe('Document Approval Workflow');
    expect(summary.taskCount).toBe(5);
  });
});

// =============================================================================
// Case Status Tests
// =============================================================================

describe('Case Status', () => {
  it('should have all status values', () => {
    expect(CaseStatus.ACTIVE).toBe('active');
    expect(CaseStatus.COMPLETED).toBe('completed');
    expect(CaseStatus.CANCELLED).toBe('cancelled');
    expect(CaseStatus.FAILED).toBe('failed');
    expect(CaseStatus.SUSPENDED).toBe('suspended');
  });

  it('should validate transitions from active', () => {
    expect(isValidTransition('active', 'completed')).toBe(true);
    expect(isValidTransition('active', 'cancelled')).toBe(true);
    expect(isValidTransition('active', 'failed')).toBe(true);
    expect(isValidTransition('active', 'suspended')).toBe(true);
  });

  it('should not allow transitions from terminal states', () => {
    expect(isValidTransition('completed', 'active')).toBe(false);
    expect(isValidTransition('cancelled', 'active')).toBe(false);
    expect(isValidTransition('failed', 'active')).toBe(false);
  });

  it('should allow resume from suspended', () => {
    expect(isValidTransition('suspended', 'active')).toBe(true);
    expect(isValidTransition('suspended', 'cancelled')).toBe(true);
  });
});

// =============================================================================
// WorkItem Status Tests
// =============================================================================

describe('WorkItem Status', () => {
  it('should have all status values', () => {
    expect(WorkItemStatus.ENABLED).toBe('enabled');
    expect(WorkItemStatus.FIRED).toBe('fired');
    expect(WorkItemStatus.ALLOCATED).toBe('allocated');
    expect(WorkItemStatus.STARTED).toBe('started');
    expect(WorkItemStatus.COMPLETED).toBe('completed');
    expect(WorkItemStatus.SUSPENDED).toBe('suspended');
    expect(WorkItemStatus.CANCELLED).toBe('cancelled');
    expect(WorkItemStatus.FAILED).toBe('failed');
  });

  it('should identify terminal statuses', () => {
    expect(isTerminalStatus('completed')).toBe(true);
    expect(isTerminalStatus('failed')).toBe(true);
    expect(isTerminalStatus('cancelled')).toBe(true);
    expect(isTerminalStatus('started')).toBe(false);
    expect(isTerminalStatus('enabled')).toBe(false);
  });

  it('should validate work item transitions', () => {
    expect(isValidWorkItemTransition('enabled', 'fired')).toBe(true);
    expect(isValidWorkItemTransition('fired', 'started')).toBe(true);
    expect(isValidWorkItemTransition('started', 'completed')).toBe(true);
    expect(isValidWorkItemTransition('completed', 'started')).toBe(false);
  });
});

// =============================================================================
// Workflow Engine Tests
// =============================================================================

describe('Workflow Engine', () => {
  let engine;

  beforeEach(() => {
    engine = createWorkflowEngine(taskRegistry, flowRegistry);
  });

  it('should create a case', () => {
    const result = engine.createCase('document-approval', { documentId: 'doc-001' });
    expect(result.caseId).toBeDefined();
    expect(result.status).toBe('active');
  });

  it('should execute XOR split', () => {
    const result = engine.createCase('document-approval');
    const tasks = engine.executeXorSplit(result.caseId, 'review-document', { decision: 'approved' });
    expect(tasks).toContain('approve-document');
  });

  it('should execute AND split', () => {
    const result = engine.createCase('order-processing');
    const tasks = engine.executeAndSplit(result.caseId, 'receive-order');
    expect(tasks).toHaveLength(2);
    expect(tasks).toContain('verify-payment');
    expect(tasks).toContain('check-inventory');
  });

  it('should manage tokens', () => {
    const result = engine.createCase('document-approval');
    engine.addToken(result.caseId, 'submit-document');
    const tokens = engine.getTokens(result.caseId);
    expect(tokens).toContain('submit-document');
    expect(tokens).toContain('input');
  });
});

// =============================================================================
// API Routes Tests
// =============================================================================

describe('API Routes', () => {
  it('should have all routes defined', () => {
    expect(ROUTES).toHaveLength(13);
  });

  it('should get route by servlet ID', () => {
    const route = getRoute('workflow-create');
    expect(route).toBeDefined();
    expect(route.method).toBe('POST');
    expect(route.path).toBe('/api/workflows');
  });

  it('should identify protected routes', () => {
    const protectedRoutes = getProtectedRoutes();
    expect(protectedRoutes).toHaveLength(13);
    expect(protectedRoutes.every(r => r.requiresAuth)).toBe(true);
  });

  it('should have correct HTTP methods', () => {
    const getRoutes = ROUTES.filter(r => r.method === 'GET');
    const postRoutes = ROUTES.filter(r => r.method === 'POST');
    expect(getRoutes.length).toBeGreaterThan(0);
    expect(postRoutes.length).toBeGreaterThan(0);
  });
});

// =============================================================================
// Worklet Tests
// =============================================================================

describe('Worklets', () => {
  it('should have all worklets registered', () => {
    const worklets = workletRegistry.getAllWorklets();
    expect(worklets).toHaveLength(5);
  });

  it('should find exception handler by type', () => {
    const handler = workletRegistry.getExceptionHandler('Timeout');
    expect(handler).toBeDefined();
    expect(handler.workletName).toBe('TimeoutExceptionHandler');
  });

  it('should check for exception handler existence', () => {
    expect(hasExceptionHandler('Timeout')).toBe(true);
    expect(hasExceptionHandler('Resource Unavailable')).toBe(true);
    expect(hasExceptionHandler('Unknown Exception')).toBe(false);
  });

  it('should get selection worklets', () => {
    const selectionWorklets = workletRegistry.getSelectionWorklets();
    expect(selectionWorklets).toHaveLength(1);
    expect(selectionWorklets[0].workletName).toBe('DynamicSubprocessSelector');
  });
});

// =============================================================================
// MSW Integration Tests
// =============================================================================

describe('API Integration (MSW)', () => {
  it('should fetch workflows', async () => {
    const response = await fetch('/api/workflows');
    const data = await response.json();
    expect(data).toHaveLength(5);
  });

  it('should fetch specific workflow', async () => {
    const response = await fetch('/api/workflows/document-approval');
    const data = await response.json();
    expect(data.specId).toBe('document-approval');
  });

  it('should return 404 for unknown workflow', async () => {
    const response = await fetch('/api/workflows/unknown');
    expect(response.status).toBe(404);
  });

  it('should create workflow', async () => {
    const response = await fetch('/api/workflows', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ specId: 'test', name: 'Test Workflow' }),
    });
    const data = await response.json();
    expect(data.workflowId).toBeDefined();
    expect(data.status).toBe('created');
  });

  it('should create case', async () => {
    const response = await fetch('/api/cases', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ workflowId: 'document-approval' }),
    });
    const data = await response.json();
    expect(data.caseId).toBeDefined();
    expect(data.status).toBe('active');
  });

  it('should cancel case', async () => {
    const response = await fetch('/api/cases/case-001/cancel', {
      method: 'POST',
    });
    const data = await response.json();
    expect(data.status).toBe('cancelled');
  });

  it('should complete task', async () => {
    const response = await fetch('/api/tasks/submit-document/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ outputData: {} }),
    });
    const data = await response.json();
    expect(data.status).toBe('completed');
  });
});
