/**
 * @fileoverview YAWL Receipt and Audit Trail Types
 * DO NOT EDIT - auto-generated by ggen sync
 * @module receipts
 */

import { z } from 'zod';

// =============================================================================
// Status Labels from Ontology
// =============================================================================

export const StatusLabels = [
  'Active',
  'Allocated',
  'Cancelled',
  'Completed',
  'Enabled',
  'Failed',
  'Fired',
  'Started',
  'Suspended',
];

export const StatusLabelSchema = z.enum([
  'Active',
  'Allocated',
  'Cancelled',
  'Completed',
  'Enabled',
  'Failed',
  'Fired',
  'Started',
  'Suspended',
]);

// =============================================================================
// Receipt Types
// =============================================================================

export const ReceiptEventType = {
  CASE_CREATED: 'case_created',
  CASE_COMPLETED: 'case_completed',
  CASE_CANCELLED: 'case_cancelled',
  CASE_FAILED: 'case_failed',
  CASE_SUSPENDED: 'case_suspended',
  CASE_RESUMED: 'case_resumed',
  WORKITEM_ENABLED: 'workitem_enabled',
  WORKITEM_FIRED: 'workitem_fired',
  WORKITEM_ALLOCATED: 'workitem_allocated',
  WORKITEM_STARTED: 'workitem_started',
  WORKITEM_COMPLETED: 'workitem_completed',
  WORKITEM_SUSPENDED: 'workitem_suspended',
  WORKITEM_CANCELLED: 'workitem_cancelled',
  WORKITEM_FAILED: 'workitem_failed',
  EXCEPTION_RAISED: 'exception_raised',
  EXCEPTION_HANDLED: 'exception_handled',
  WORKLET_INVOKED: 'worklet_invoked',
};

export const ReceiptEventTypeSchema = z.enum([
  'case_created',
  'case_completed',
  'case_cancelled',
  'case_failed',
  'case_suspended',
  'case_resumed',
  'workitem_enabled',
  'workitem_fired',
  'workitem_allocated',
  'workitem_started',
  'workitem_completed',
  'workitem_suspended',
  'workitem_cancelled',
  'workitem_failed',
  'exception_raised',
  'exception_handled',
  'worklet_invoked',
]);

// =============================================================================
// Receipt Schema (Blockchain-style audit trail)
// =============================================================================

export const ReceiptSchema = z.object({
  receiptId: z.string(),
  timestamp: z.string().datetime(),
  eventType: ReceiptEventTypeSchema,
  caseId: z.string(),
  workItemId: z.string().optional(),
  taskId: z.string().optional(),
  actorId: z.string().optional(),
  previousHash: z.string(),
  receiptHash: z.string(),
  eventData: z.record(z.unknown()).default({}),
});

// =============================================================================
// Receipt Chain
// =============================================================================

export class ReceiptChain {
  /** @type {Array} */
  #receipts = [];

  /** @type {string} */
  #lastHash = '0'.repeat(64);

  /**
   * Add a new receipt to the chain
   * @param {object} receiptData
   * @returns {object}
   */
  addReceipt(receiptData) {
    const receipt = {
      ...receiptData,
      receiptId: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      previousHash: this.#lastHash,
      receiptHash: this.#computeHash(receiptData, this.#lastHash),
    };

    this.#receipts.push(receipt);
    this.#lastHash = receipt.receiptHash;
    return receipt;
  }

  /**
   * Get all receipts for a case
   * @param {string} caseId
   * @returns {Array}
   */
  getReceiptsForCase(caseId) {
    return this.#receipts.filter(r => r.caseId === caseId);
  }

  /**
   * Verify chain integrity
   * @returns {boolean}
   */
  verifyChain() {
    let previousHash = '0'.repeat(64);

    for (const receipt of this.#receipts) {
      if (receipt.previousHash !== previousHash) {
        return false;
      }
      const computedHash = this.#computeHash(receipt, previousHash);
      if (receipt.receiptHash !== computedHash) {
        return false;
      }
      previousHash = receipt.receiptHash;
    }

    return true;
  }

  /**
   * @param {object} data
   * @param {string} previousHash
   * @returns {string}
   */
  #computeHash(data, previousHash) {
    const content = JSON.stringify({ ...data, previousHash });
    // In production, use crypto.subtle.digest or similar
    // This is a placeholder for the hash computation
    return this.#simpleHash(content);
  }

  /**
   * Simple hash for demonstration (use BLAKE3 in production)
   * @param {string} str
   * @returns {string}
   */
  #simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).padStart(64, '0');
  }

  /**
   * Get chain length
   * @returns {number}
   */
  get length() {
    return this.#receipts.length;
  }

  /**
   * Get last receipt
   * @returns {object|undefined}
   */
  get lastReceipt() {
    return this.#receipts[this.#receipts.length - 1];
  }
}

// =============================================================================
// Singleton Instance
// =============================================================================

export const receiptChain = new ReceiptChain();
