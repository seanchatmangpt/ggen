/**
 * @fileoverview YAWL Workflow Engine
 * Implements Van der Aalst workflow patterns
 * DO NOT EDIT - auto-generated by ggen sync
 * @module engine
 */

import { z } from 'zod';

// =============================================================================
// Split/Join Pattern Support
// =============================================================================

/**
 * Detected split types from ontology
 */
export const SPLIT_TYPES = ['AND', 'OR', 'XOR'];

/**
 * Detected join types from ontology
 */
export const JOIN_TYPES = ['AND', 'OR', 'XOR'];

// =============================================================================
// Van der Aalst Workflow Patterns
// =============================================================================

export const WorkflowPatterns = {
  // Basic Control Flow Patterns
  WP1_SEQUENCE: 'WP1: Sequence',
  WP2_PARALLEL_SPLIT: 'WP2: Parallel Split (AND-split)',
  WP3_SYNCHRONIZATION: 'WP3: Synchronization (AND-join)',
  WP4_EXCLUSIVE_CHOICE: 'WP4: Exclusive Choice (XOR-split)',
  WP5_SIMPLE_MERGE: 'WP5: Simple Merge (XOR-join)',
  WP6_MULTI_CHOICE: 'WP6: Multi-Choice (OR-split)',
  WP7_STRUCTURED_SYNC_MERGE: 'WP7: Structured Synchronizing Merge (OR-join)',

  // Advanced Branching Patterns
  WP8_MULTI_MERGE: 'WP8: Multi-Merge',
  WP9_STRUCTURED_DISCRIMINATOR: 'WP9: Structured Discriminator',

  // Multiple Instance Patterns
  WP12_MI_NO_SYNC: 'WP12: Multiple Instances without Synchronization',
  WP13_MI_DESIGN_TIME: 'WP13: Multiple Instances with a priori Design-Time Knowledge',
  WP14_MI_RUNTIME: 'WP14: Multiple Instances with a priori Run-Time Knowledge',
  WP15_MI_NO_PRIOR: 'WP15: Multiple Instances without a priori Run-Time Knowledge',
};

// =============================================================================
// Workflow Engine
// =============================================================================

export class WorkflowEngine {
  /** @type {Map<string, object>} */
  #cases = new Map();

  /** @type {Map<string, Set<string>>} */
  #tokens = new Map();

  /** @type {object} */
  #taskRegistry;

  /** @type {object} */
  #flowRegistry;

  /**
   * @param {object} taskRegistry
   * @param {object} flowRegistry
   */
  constructor(taskRegistry, flowRegistry) {
    this.#taskRegistry = taskRegistry;
    this.#flowRegistry = flowRegistry;
  }

  // ===========================================================================
  // Case Management
  // ===========================================================================

  /**
   * Create a new workflow case
   * @param {string} specId
   * @param {object} initialData
   * @returns {object}
   */
  createCase(specId, initialData = {}) {
    const caseId = crypto.randomUUID();
    const caseInstance = {
      caseId,
      specId,
      status: 'active',
      createdAt: new Date().toISOString(),
      caseData: initialData,
      workItems: new Map(),
    };

    this.#cases.set(caseId, caseInstance);
    this.#tokens.set(caseId, new Set(['input']));

    return { caseId, status: 'active' };
  }

  /**
   * Get case by ID
   * @param {string} caseId
   * @returns {object|undefined}
   */
  getCase(caseId) {
    return this.#cases.get(caseId);
  }

  // ===========================================================================
  // Split Pattern Execution
  // ===========================================================================

  /**
   * Execute XOR split (Exclusive Choice - WP4)
   * @param {string} caseId
   * @param {string} taskId
   * @param {object} context
   * @returns {string[]} - Task IDs to enable
   */
  executeXorSplit(caseId, taskId, context) {
    const flows = this.#flowRegistry.getOutgoingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    // Evaluate conditions in priority order
    const sortedFlows = [...flows].sort((a, b) => a.priority - b.priority);

    for (const flow of sortedFlows) {
      if (!flow.condition || this.#evaluateCondition(flow.condition, context)) {
        return [flow.targetTaskId];
      }
    }

    // Fall back to default flow
    const defaultFlow = flows.find(f => f.isDefault);
    return defaultFlow ? [defaultFlow.targetTaskId] : [];
  }

  /**
   * Execute AND split (Parallel Split - WP2)
   * @param {string} caseId
   * @param {string} taskId
   * @returns {string[]} - All target task IDs
   */
  executeAndSplit(caseId, taskId) {
    const flows = this.#flowRegistry.getOutgoingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    // Enable ALL outgoing branches
    return flows.map(f => f.targetTaskId);
  }

  /**
   * Execute OR split (Multi-Choice - WP6)
   * @param {string} caseId
   * @param {string} taskId
   * @param {object} context
   * @returns {string[]} - Task IDs matching conditions
   */
  executeOrSplit(caseId, taskId, context) {
    const flows = this.#flowRegistry.getOutgoingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    const enabledTasks = [];
    for (const flow of flows) {
      if (!flow.condition || this.#evaluateCondition(flow.condition, context)) {
        enabledTasks.push(flow.targetTaskId);
      }
    }

    // At least one must be enabled (fallback to default)
    if (enabledTasks.length === 0) {
      const defaultFlow = flows.find(f => f.isDefault);
      if (defaultFlow) {
        enabledTasks.push(defaultFlow.targetTaskId);
      }
    }

    return enabledTasks;
  }

  // ===========================================================================
  // Join Pattern Execution
  // ===========================================================================

  /**
   * Check XOR join (Simple Merge - WP5)
   * @param {string} caseId
   * @param {string} taskId
   * @returns {boolean} - True if any incoming token present
   */
  checkXorJoin(caseId, taskId) {
    const tokens = this.#tokens.get(caseId);
    const incomingFlows = this.#flowRegistry.getIncomingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    return incomingFlows.some(f => tokens?.has(f.sourceTaskId));
  }

  /**
   * Check AND join (Synchronization - WP3)
   * @param {string} caseId
   * @param {string} taskId
   * @returns {boolean} - True if ALL incoming tokens present
   */
  checkAndJoin(caseId, taskId) {
    const tokens = this.#tokens.get(caseId);
    const incomingFlows = this.#flowRegistry.getIncomingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    return incomingFlows.every(f => tokens?.has(f.sourceTaskId));
  }

  /**
   * Check OR join (Structured Synchronizing Merge - WP7)
   * @param {string} caseId
   * @param {string} taskId
   * @returns {boolean} - True if all expected tokens present
   */
  checkOrJoin(caseId, taskId) {
    // OR-join requires deadpath elimination
    // Wait for all tokens that COULD arrive (based on OR-split upstream)
    const tokens = this.#tokens.get(caseId);
    const incomingFlows = this.#flowRegistry.getIncomingFlows(
      this.#cases.get(caseId)?.specId,
      taskId
    );

    const expectedTokens = this.#computeExpectedTokens(caseId, taskId, incomingFlows);
    return expectedTokens.every(t => tokens?.has(t));
  }

  // ===========================================================================
  // Token Management
  // ===========================================================================

  /**
   * Add token to a place
   * @param {string} caseId
   * @param {string} place
   */
  addToken(caseId, place) {
    if (!this.#tokens.has(caseId)) {
      this.#tokens.set(caseId, new Set());
    }
    this.#tokens.get(caseId).add(place);
  }

  /**
   * Remove token from a place
   * @param {string} caseId
   * @param {string} place
   */
  removeToken(caseId, place) {
    this.#tokens.get(caseId)?.delete(place);
  }

  /**
   * Get all tokens for a case
   * @param {string} caseId
   * @returns {string[]}
   */
  getTokens(caseId) {
    return Array.from(this.#tokens.get(caseId) || []);
  }

  // ===========================================================================
  // Private Helpers
  // ===========================================================================

  /**
   * @param {string} condition
   * @param {object} context
   * @returns {boolean}
   */
  #evaluateCondition(condition, context) {
    try {
      // Simple condition evaluation (use a proper expression parser in production)
      const fn = new Function(...Object.keys(context), `return ${condition};`);
      return fn(...Object.values(context));
    } catch {
      return false;
    }
  }

  /**
   * Compute expected tokens for OR-join (simplified)
   * @param {string} caseId
   * @param {string} taskId
   * @param {Array} incomingFlows
   * @returns {string[]}
   */
  #computeExpectedTokens(caseId, taskId, incomingFlows) {
    // In a full implementation, this would trace back through the net
    // to determine which branches are still "live"
    const tokens = this.#tokens.get(caseId);
    return incomingFlows
      .map(f => f.sourceTaskId)
      .filter(t => tokens?.has(t));
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * Create a workflow engine instance
 * @param {object} taskRegistry
 * @param {object} flowRegistry
 * @returns {WorkflowEngine}
 */
export function createWorkflowEngine(taskRegistry, flowRegistry) {
  return new WorkflowEngine(taskRegistry, flowRegistry);
}
