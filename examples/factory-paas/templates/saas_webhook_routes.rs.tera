//! Generated Webhook Routes - DO NOT EDIT
//!
//! This file is automatically generated by ggen
//! To make changes, edit the ontology and run: ggen sync

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{post, get},
    Router,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::handlers::*;

/// Application state for webhook handlers
#[derive(Clone)]
pub struct WebhookState {
    // Add your state here (database, event store, etc.)
}

/// Build webhook router
pub fn webhook_routes() -> Router<WebhookState> {
    Router::new()
        .route("/webhooks/stripe/:program_id/:publisher_id", post(stripe_webhook))
        .route("/webhooks/paddle/:program_id/:publisher_id", post(paddle_webhook))
        .route("/health", get(health_check))
}

/// Stripe webhook endpoint
async fn stripe_webhook(
    Path((program_id, publisher_id)): Path<(Uuid, Uuid)>,
    State(_state): State<WebhookState>,
    Json(webhook): Json<StripeWebhook>,
) -> Result<Json<WebhookResponse>, StatusCode> {
    // TODO: Validate webhook signature

    // Process webhook
    let commands = handle_stripe_webhook(webhook, program_id, publisher_id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(WebhookResponse {
        received: true,
        processed: commands.len(),
    }))
}

/// Paddle webhook endpoint
async fn paddle_webhook(
    Path((program_id, publisher_id)): Path<(Uuid, Uuid)>,
    State(_state): State<WebhookState>,
    Json(webhook): Json<serde_json::Value>,
) -> Result<Json<WebhookResponse>, StatusCode> {
    // TODO: Implement Paddle webhook processing

    Ok(Json(WebhookResponse {
        received: true,
        processed: 0,
    }))
}

/// Health check endpoint
async fn health_check() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
    })
}

#[derive(Serialize)]
struct WebhookResponse {
    received: bool,
    processed: usize,
}

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    timestamp: chrono::DateTime<chrono::Utc>,
}
