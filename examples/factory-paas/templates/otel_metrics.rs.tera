//! Generated OpenTelemetry Metrics - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology
//! To make changes, edit the ontology and run: ggen sync
//!
//! Provides custom metrics for affiliate tracking, revenue attribution, and system performance.

use opentelemetry::{
    global,
    metrics::{Counter, Histogram, Meter, MeterProvider, ObservableGauge, Unit},
    KeyValue,
};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    metrics::{PeriodicReader, SdkMeterProvider},
    runtime,
    Resource,
};
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

/// Metrics configuration
#[derive(Debug, Clone)]
pub struct MetricsConfig {
    /// Service name for metrics
    pub service_name: String,
    /// OTLP endpoint for metrics
    pub otlp_endpoint: String,
    /// Export interval in seconds
    pub export_interval_secs: u64,
}

impl Default for MetricsConfig {
    fn default() -> Self {
        Self {
            service_name: "factory-paas".to_string(),
            otlp_endpoint: std::env::var("OTEL_EXPORTER_OTLP_ENDPOINT")
                .unwrap_or_else(|_| "http://localhost:4317".to_string()),
            export_interval_secs: 60,
        }
    }
}

/// Affiliate attribution metrics
///
/// Tracks click-through rates, conversion rates, and revenue attribution
pub struct AffiliateMetrics {
    /// Total clicks tracked
    clicks_total: Counter<u64>,
    /// Clicks by affiliate ID
    clicks_by_affiliate: Counter<u64>,
    /// Conversions (purchases after click)
    conversions_total: Counter<u64>,
    /// Revenue attributed to affiliates (in cents)
    revenue_cents: Counter<u64>,
    /// Click-to-conversion latency (seconds)
    conversion_latency: Histogram<f64>,
    /// Active attribution windows
    active_windows: Arc<RwLock<u64>>,
}

impl AffiliateMetrics {
    /// Create new affiliate metrics
    pub fn new(meter: &Meter) -> Result<Self, Box<dyn std::error::Error>> {
        let clicks_total = meter
            .u64_counter("affiliate.clicks.total")
            .with_description("Total affiliate clicks tracked")
            .with_unit(Unit::new("clicks"))
            .init();

        let clicks_by_affiliate = meter
            .u64_counter("affiliate.clicks.by_id")
            .with_description("Clicks grouped by affiliate ID")
            .with_unit(Unit::new("clicks"))
            .init();

        let conversions_total = meter
            .u64_counter("affiliate.conversions.total")
            .with_description("Total conversions from affiliate clicks")
            .with_unit(Unit::new("conversions"))
            .init();

        let revenue_cents = meter
            .u64_counter("affiliate.revenue.cents")
            .with_description("Revenue attributed to affiliates in cents")
            .with_unit(Unit::new("cents"))
            .init();

        let conversion_latency = meter
            .f64_histogram("affiliate.conversion.latency")
            .with_description("Time from click to conversion")
            .with_unit(Unit::new("s"))
            .init();

        let active_windows = Arc::new(RwLock::new(0u64));
        let active_windows_clone = Arc::clone(&active_windows);

        let _active_gauge = meter
            .u64_observable_gauge("affiliate.windows.active")
            .with_description("Number of active attribution windows")
            .with_unit(Unit::new("windows"))
            .with_callback(move |observer| {
                let windows = *active_windows_clone.blocking_read();
                observer.observe(windows, &[]);
            })
            .init();

        Ok(Self {
            clicks_total,
            clicks_by_affiliate,
            conversions_total,
            revenue_cents,
            conversion_latency,
            active_windows,
        })
    }

    /// Record click event
    pub fn record_click(&self, affiliate_id: &Uuid, click_id: &Uuid) {
        let attributes = vec![
            KeyValue::new("affiliate.id", affiliate_id.to_string()),
            KeyValue::new("click.id", click_id.to_string()),
        ];

        self.clicks_total.add(1, &[]);
        self.clicks_by_affiliate.add(1, &attributes);

        tracing::info!(
            affiliate.id = %affiliate_id,
            click.id = %click_id,
            "Recorded affiliate click"
        );
    }

    /// Record conversion event
    pub fn record_conversion(
        &self,
        affiliate_id: &Uuid,
        click_id: &Uuid,
        revenue_cents: u64,
        latency_secs: f64,
    ) {
        let attributes = vec![
            KeyValue::new("affiliate.id", affiliate_id.to_string()),
            KeyValue::new("click.id", click_id.to_string()),
        ];

        self.conversions_total.add(1, &attributes);
        self.revenue_cents.add(revenue_cents, &attributes);
        self.conversion_latency.record(latency_secs, &attributes);

        tracing::info!(
            affiliate.id = %affiliate_id,
            click.id = %click_id,
            revenue.cents = revenue_cents,
            latency.secs = latency_secs,
            "Recorded affiliate conversion"
        );
    }

    /// Update active attribution windows count
    pub async fn set_active_windows(&self, count: u64) {
        let mut windows = self.active_windows.write().await;
        *windows = count;
    }
}

/// Command handler metrics
///
/// Tracks command execution, success/failure rates, and latency
pub struct CommandMetrics {
    /// Total commands processed
    commands_total: Counter<u64>,
    /// Command processing latency
    command_latency: Histogram<f64>,
    /// Command errors
    command_errors: Counter<u64>,
}

impl CommandMetrics {
    pub fn new(meter: &Meter) -> Result<Self, Box<dyn std::error::Error>> {
        let commands_total = meter
            .u64_counter("commands.total")
            .with_description("Total commands processed")
            .with_unit(Unit::new("commands"))
            .init();

        let command_latency = meter
            .f64_histogram("commands.latency")
            .with_description("Command processing latency")
            .with_unit(Unit::new("s"))
            .init();

        let command_errors = meter
            .u64_counter("commands.errors")
            .with_description("Command processing errors")
            .with_unit(Unit::new("errors"))
            .init();

        Ok(Self {
            commands_total,
            command_latency,
            command_errors,
        })
    }

    /// Record command execution
    pub fn record_command(&self, command_name: &str, latency_secs: f64, success: bool) {
        let attributes = vec![
            KeyValue::new("command.name", command_name.to_string()),
            KeyValue::new("command.success", success.to_string()),
        ];

        self.commands_total.add(1, &attributes);
        self.command_latency.record(latency_secs, &attributes);

        if !success {
            self.command_errors.add(1, &attributes);
        }

        tracing::info!(
            command.name = command_name,
            command.latency_secs = latency_secs,
            command.success = success,
            "Recorded command execution"
        );
    }
}

/// Receipt metrics
///
/// Tracks receipt generation and verification
pub struct ReceiptMetrics {
    /// Total receipts generated
    receipts_total: Counter<u64>,
    /// Receipt verification successes
    verifications_success: Counter<u64>,
    /// Receipt verification failures
    verifications_failed: Counter<u64>,
}

impl ReceiptMetrics {
    pub fn new(meter: &Meter) -> Result<Self, Box<dyn std::error::Error>> {
        let receipts_total = meter
            .u64_counter("receipts.total")
            .with_description("Total receipts generated")
            .with_unit(Unit::new("receipts"))
            .init();

        let verifications_success = meter
            .u64_counter("receipts.verifications.success")
            .with_description("Successful receipt verifications")
            .with_unit(Unit::new("verifications"))
            .init();

        let verifications_failed = meter
            .u64_counter("receipts.verifications.failed")
            .with_description("Failed receipt verifications")
            .with_unit(Unit::new("verifications"))
            .init();

        Ok(Self {
            receipts_total,
            verifications_success,
            verifications_failed,
        })
    }

    /// Record receipt generation
    pub fn record_receipt(&self, receipt_id: &Uuid, aggregate_type: &str) {
        let attributes = vec![
            KeyValue::new("receipt.id", receipt_id.to_string()),
            KeyValue::new("aggregate.type", aggregate_type.to_string()),
        ];

        self.receipts_total.add(1, &attributes);

        tracing::info!(
            receipt.id = %receipt_id,
            aggregate.type = aggregate_type,
            "Generated receipt"
        );
    }

    /// Record receipt verification result
    pub fn record_verification(&self, receipt_id: &Uuid, success: bool) {
        let attributes = vec![KeyValue::new("receipt.id", receipt_id.to_string())];

        if success {
            self.verifications_success.add(1, &attributes);
        } else {
            self.verifications_failed.add(1, &attributes);
        }

        tracing::info!(
            receipt.id = %receipt_id,
            verification.success = success,
            "Verified receipt"
        );
    }
}

/// Global metrics registry
pub struct MetricsRegistry {
    pub affiliate: AffiliateMetrics,
    pub commands: CommandMetrics,
    pub receipts: ReceiptMetrics,
}

impl MetricsRegistry {
    /// Create new metrics registry
    pub fn new(meter: &Meter) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            affiliate: AffiliateMetrics::new(meter)?,
            commands: CommandMetrics::new(meter)?,
            receipts: ReceiptMetrics::new(meter)?,
        })
    }
}

/// Initialize OpenTelemetry metrics pipeline
pub fn init_otel_metrics(
    config: MetricsConfig,
) -> Result<(SdkMeterProvider, MetricsRegistry), Box<dyn std::error::Error>> {
    // Create resource
    let resource = Resource::new(vec![KeyValue::new("service.name", config.service_name.clone())]);

    // Configure OTLP exporter
    let otlp_exporter = opentelemetry_otlp::new_exporter()
        .tonic()
        .with_endpoint(&config.otlp_endpoint);

    // Create periodic reader
    let reader = PeriodicReader::builder(
        opentelemetry_otlp::new_pipeline()
            .metrics(runtime::Tokio)
            .with_exporter(otlp_exporter)
            .build()?,
        runtime::Tokio,
    )
    .with_interval(std::time::Duration::from_secs(config.export_interval_secs))
    .build();

    // Create meter provider
    let meter_provider = SdkMeterProvider::builder()
        .with_reader(reader)
        .with_resource(resource)
        .build();

    // Set global meter provider
    global::set_meter_provider(meter_provider.clone());

    // Create meter
    let meter = global::meter("factory-paas");

    // Create metrics registry
    let registry = MetricsRegistry::new(&meter)?;

    tracing::info!(
        service.name = config.service_name,
        otlp.endpoint = config.otlp_endpoint,
        export.interval_secs = config.export_interval_secs,
        "OpenTelemetry metrics initialized"
    );

    Ok((meter_provider, registry))
}

/// Shutdown metrics gracefully
pub async fn shutdown_otel_metrics(
    provider: SdkMeterProvider,
) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("Shutting down OpenTelemetry metrics...");
    provider.shutdown()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_affiliate_metrics() {
        let meter = global::meter("test");
        let metrics = AffiliateMetrics::new(&meter).unwrap();

        let affiliate_id = Uuid::new_v4();
        let click_id = Uuid::new_v4();

        metrics.record_click(&affiliate_id, &click_id);
        metrics.record_conversion(&affiliate_id, &click_id, 9999, 120.5);
        metrics.set_active_windows(42).await;

        // Metrics are recorded successfully (no panics)
    }

    #[test]
    fn test_command_metrics() {
        let meter = global::meter("test");
        let metrics = CommandMetrics::new(&meter).unwrap();

        metrics.record_command("CreateClick", 0.05, true);
        metrics.record_command("TrackConversion", 0.12, false);
    }
}
