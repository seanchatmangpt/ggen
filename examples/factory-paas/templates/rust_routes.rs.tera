//! Generated HTTP Routes - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology/commands.ttl
//! To make changes, edit the ontology and run: ggen sync

use axum::{
    extract::State,
    http::StatusCode,
    response::IntoResponse,
    routing::post,
    Json, Router,
};
use serde_json::json;

use crate::commands::*;
use crate::handlers::*;

/// Build the complete router with all command endpoints
pub fn build_router() -> Router {
    Router::new()
        .route("/health", axum::routing::get(health_check))
{% for row in sparql_results -%}
{%- set command_name = row["?commandName"] -%}
{%- set http_method = row["?httpMethod"] | default(value="POST") -%}
{%- set http_path = row["?httpPath"] | default(value="/" ~ command_name | lower) -%}
        .route("{{ http_path }}", post(handle_{{ command_name | lower }}_route))
{% endfor %}
}

/// Health check endpoint
async fn health_check() -> impl IntoResponse {
    Json(json!({
        "status": "healthy",
        "service": "Attribution",
        "version": env!("CARGO_PKG_VERSION")
    }))
}

{% for row in sparql_results -%}
{%- set command_name = row["?commandName"] -%}

/// Route handler for {{ command_name }}
async fn handle_{{ command_name | lower }}_route(
    Json(command): Json<{{ command_name }}>,
) -> Result<impl IntoResponse, StatusCode> {
    // TODO: Load aggregate from event store
    // TODO: Execute command handler
    // TODO: Persist event

    Ok((
        StatusCode::OK,
        Json(json!({
            "status": "accepted",
            "command": "{{ command_name }}"
        }))
    ))
}

{% endfor %}
