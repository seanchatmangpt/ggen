//! Generated Receipt Schema - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology/events.ttl
//! To make changes, edit the ontology and run: ggen sync
//!
//! Receipts are cryptographic proofs of all system actions.
//! Every event is a receipt - immutable, auditable, verifiable.

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Receipt envelope - wraps all domain events
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Receipt<T> {
    /// Unique receipt ID
    pub receipt_id: Uuid,
    /// Timestamp of receipt creation
    pub timestamp: DateTime<Utc>,
    /// Event sequence number (monotonic)
    pub sequence: u64,
    /// Correlation ID for tracing
    pub correlation_id: Uuid,
    /// Causation ID (what caused this event)
    pub causation_id: Uuid,
    /// Aggregate ID this receipt belongs to
    pub aggregate_id: Uuid,
    /// Aggregate type
    pub aggregate_type: String,
    /// The actual event data
    pub payload: T,
    /// Cryptographic hash of payload
    pub payload_hash: String,
    /// Digital signature (optional)
    pub signature: Option<String>,
    /// OpenTelemetry trace ID for distributed tracing
    pub trace_id: Uuid,
    /// OpenTelemetry span ID
    pub span_id: Uuid,
}

impl<T: Serialize> Receipt<T> {
    /// Create new receipt from event payload with trace context
    pub fn new(
        aggregate_id: Uuid,
        aggregate_type: String,
        sequence: u64,
        correlation_id: Uuid,
        causation_id: Uuid,
        payload: T,
        trace_id: Uuid,
        span_id: Uuid,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let payload_json = serde_json::to_string(&payload)?;
        let payload_hash = format!("{:x}", md5::compute(&payload_json));

        Ok(Self {
            receipt_id: Uuid::new_v4(),
            timestamp: Utc::now(),
            sequence,
            correlation_id,
            causation_id,
            aggregate_id,
            aggregate_type,
            payload,
            payload_hash,
            signature: None,
            trace_id,
            span_id,
        })
    }

    /// Verify receipt integrity
    pub fn verify(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let payload_json = serde_json::to_string(&self.payload)?;
        let computed_hash = format!("{:x}", md5::compute(&payload_json));
        Ok(computed_hash == self.payload_hash)
    }
}

// Re-export events for convenience
pub use crate::events::*;
