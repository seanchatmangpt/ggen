{% include "_header.erl.tera" %}

-module({{ module_prefix }}_signal_normalizer).
-export([init/0, handle_pubsub/1, normalize/1, route/1]).

-include("{{ module_prefix }}_types.hrl").

%% SECURITY: Whitelist of allowed signal names to prevent atom table exhaustion (DoS)
%% Only these signal names can be converted to atoms - all others are rejected
-define(ALLOWED_SIGNALS, [
  quota_exceeded,
  rate_limit_hit,
  cost_spike_detected,
  deployment_failed,
  api_error_spike,
  security_alert,
  health_check_failed,
  unknown_signal
]).

%% SECURITY: Whitelist of allowed source systems
-define(ALLOWED_SOURCES, [
  billing,
  monitoring,
  deployment,
  security,
  health,
  unknown
]).

%% @doc Initialize the normalizer by pre-populating atom table with whitelisted values.
%% MUST be called during application startup (in your app's start/2 callback).
%% This ensures binary_to_existing_atom/2 works for allowed signals/sources.
-spec init() -> ok.
init() ->
  %% Pre-populate atom table with allowed signals
  lists:foreach(fun(Signal) ->
    _ = Signal  %% Atoms in ?ALLOWED_SIGNALS are already in atom table
  end, ?ALLOWED_SIGNALS),

  %% Pre-populate atom table with allowed sources
  lists:foreach(fun(Source) ->
    _ = Source  %% Atoms in ?ALLOWED_SOURCES are already in atom table
  end, ?ALLOWED_SOURCES),

  logger:info("Signal normalizer initialized with ~p allowed signals and ~p allowed sources",
              [length(?ALLOWED_SIGNALS), length(?ALLOWED_SOURCES)]),
  ok.

%% Type specifications for all public functions
-type pubsub_envelope() :: #{
  message => #{
    attributes => #{binary() => binary()},
    data => binary()
  },
  name => binary(),
  payload => map()
}.

-type normalized_event() :: #{
  tenant_id := binary(),
  source := atom(),
  name := atom(),
  payload := map()
}.

-type route_reply() :: term().

%% @doc Handle incoming Pub/Sub push envelope by normalizing and routing it.
%% Expects a map decoded from JSON with message/attributes structure.
%% Returns the reply from the governor FSM.
-spec handle_pubsub(pubsub_envelope()) -> route_reply().
handle_pubsub(Envelope) ->
  Event = normalize(Envelope),
  route(Event).

%% @doc Normalize Pub/Sub envelope into standardized event structure.
%% Extracts tenant_id, source, signal name, and payload from envelope.
%% Uses whitelisting to prevent atom table exhaustion attacks.
-spec normalize(pubsub_envelope()) -> normalized_event().
normalize(Envelope) ->
%% #{tenant_id => ..., source => ..., name => ..., payload => #{...}}
normalize(Envelope) ->
  %% Example Pub/Sub push envelope:
  %% #{message := #{attributes := #{tenant_id := "...", source := "billing"},
  %%               data := Base64Data}}
  Msg = maps:get(message, Envelope, #{}),
  Attr = maps:get(attributes, Msg, #{}),

  TenantId = to_bin(maps:get({{ tenant_key }}, Attr, <<"unknown">>)),
  Source   = to_atom(maps:get(source, Attr, <<"unknown">>)),

  %% For simplicity: assume data already decoded to map or passed as map
  Payload = maps:get(payload, Envelope, #{}),
  Name    = to_atom(maps:get(name, Envelope, <<"unknown_signal">>)),

  #{
    tenant_id => TenantId,
    source => Source,
    name => Name,
    payload => Payload
  }.

%% @doc Route normalized event to tenant governor FSM.
%% Ensures tenant exists in registry, routes signal to governor, emits receipt.
%% Returns reply from the governor's FSM.
-spec route(normalized_event()) -> route_reply().
route(#{tenant_id := TenantId, name := Name, payload := Payload} = Event) ->
  %% Ensure tenant governor exists
  _ = {{ module_prefix }}_tenant_registry:ensure_tenant(TenantId, #{
    {{ tenant_key }} => TenantId,
    profile => standard,
    entitlement => active
  }),

  %% Route signal to governor FSM
  Reply = {{ module_prefix }}_tenant_registry:route_call(
    TenantId,
    {{ module_prefix }}_governor_statem,
    {signal, Name, Payload}
  ),

  %% Emit a receipt about ingestion (optional but useful)
  _ = {{ module_prefix }}_receipt_ledger:append(
    TenantId,
    #{
      kind => signal_ingest,
      tenant_id => TenantId,
      sku => <<"{{ sku }}">>,
      event => Event,
      decision => accepted
    }
  ),

  Reply.

to_bin(B) when is_binary(B) -> B;
to_bin(L) when is_list(L) -> list_to_binary(L);
to_bin(A) when is_atom(A) -> atom_to_binary(A, utf8);
to_bin(I) when is_integer(I) -> integer_to_binary(I);
to_bin(_) -> <<"unknown">>.

%% SECURITY FIX: Use binary_to_existing_atom/2 to prevent atom table exhaustion
%% This prevents DoS attacks where malicious actors send arbitrary signal names
%% Reference: https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion
to_atom(A) when is_atom(A) ->
  A;
to_atom(B) when is_binary(B) ->
  try
    binary_to_existing_atom(B, utf8)
  catch
    error:badarg ->
      %% Signal name not in atom table = not whitelisted
      %% Log the attempt and return safe default
      logger:warning("Rejected unknown signal name: ~p", [B]),
      unknown_signal
  end;
to_atom(L) when is_list(L) ->
  to_atom(list_to_binary(L));
to_atom(_) ->
  unknown.
