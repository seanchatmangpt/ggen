{% include "_header.erl.tera" %}

%%%-------------------------------------------------------------------
%%% AUTOGENERATED ADVERSARIAL TEST SUITE â€” TPS BLACK-BOX
%%% SKU: {{ sku }}
%%% Module prefix: {{ module_prefix }}
%%%
%%% Pure black-box tests against deployed service.
%%% No mocks. No internal hooks. Real HTTP.
%%% Stop-the-line: any 5xx is a FAIL.
%%%-------------------------------------------------------------------
-module({{ module_prefix }}_adversarial_SUITE).
-compile(export_all).

-include_lib("common_test/include/ct.hrl").

%% Suite definition ====================================================

all() ->
  [
    %% Baseline
    t_health_ok,

    %% Pub/Sub malformed input
    t_pubsub_invalid_json,
    t_pubsub_missing_message,
    t_pubsub_missing_data,
    t_pubsub_invalid_base64,
    t_pubsub_missing_tenant_id,
    t_pubsub_missing_source,
    t_pubsub_missing_name,
    t_pubsub_empty_tenant_id,
    t_pubsub_extra_fields_ignored,

    %% Marketplace abuse
    t_marketplace_invalid_transition,
    t_entitlement_activate_flow,
    t_signal_without_entitlement,

    %% Required keys and schema
    t_signal_required_keys,

    %% Chaos & concurrency
    t_storm_pubsub_concurrent,
    t_replay_same_payload,

    %% Payload size abuse
    t_large_payload_rejected,

    %% State machine robustness
    t_rapid_entitlement_flips
  ].

init_per_suite(Config) ->
  application:ensure_all_started(hackney),
  application:ensure_all_started(jiffy),
  Config.

end_per_suite(_Config) ->
  ok.

%% Helpers =============================================================

service_url(Config) ->
  {{ module_prefix }}_ct_helpers:service_url(Config).

tenant_id(Config) ->
  {{ module_prefix }}_ct_helpers:tenant_id(Config).

timeout(Config) ->
  {{ module_prefix }}_ct_helpers:timeout_ms(Config).

url(Config, Path) ->
  list_to_binary(service_url(Config) ++ Path).

post(Config, Path, Map) ->
  {{ module_prefix }}_ct_helpers:post_json(
    url(Config, Path),
    [],
    Map,
    timeout(Config)
  ).

get(Config, Path) ->
  {{ module_prefix }}_ct_helpers:get(
    url(Config, Path),
    [],
    timeout(Config)
  ).

%% Assertion: no 5xx ===================================================

require_not_5xx({ok, Status, _H, Body}) when Status >= 500 ->
  ct:fail({unexpected_5xx, Status, Body});
require_not_5xx({ok, _Status, _H, _Body}) ->
  ok;
require_not_5xx({error, Why}) ->
  ct:fail({http_error, Why}).

%% Tests ===============================================================

%% t_health_ok: Service responds to health check
t_health_ok(Config) ->
  case get(Config, "/health") of
    {ok, 200, _H, Body} ->
      %% Must be valid JSON, but we don't mandate internal schema
      _ = jiffy:decode(Body, [return_maps]),
      ok;
    Other ->
      ct:fail({health_failed, Other})
  end.

%% t_pubsub_invalid_json: Send raw invalid JSON
t_pubsub_invalid_json(Config) ->
  Url = url(Config, "/pubsub"),
  Opts = [{connect_timeout, timeout(Config)}, {recv_timeout, timeout(Config)}],
  RawBody = <<"{not-json">>,

  case hackney:request(post, Url, [{<<"content-type">>, <<"application/json">>}], RawBody, Opts) of
    {ok, Status, _H, Ref} ->
      {ok, Body} = hackney:body(Ref),
      require_not_5xx({ok, Status, [], Body}),
      case Status of
        400 -> ok;
        _ -> ct:fail({expected_400, got, Status})
      end;
    {error, Why} ->
      ct:fail({http_error, Why})
  end.

%% t_pubsub_missing_message: Empty object
t_pubsub_missing_message(Config) ->
  Res = post(Config, "/pubsub", #{}),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_missing_data: Message has attributes but no data
t_pubsub_missing_data(Config) ->
  Tenant = tenant_id(Config),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"source">> => <<"monitoring">>,
        <<"name">> => <<"quota_exceeded">>
      }
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_invalid_base64: Data field has invalid base64
t_pubsub_invalid_base64(Config) ->
  Tenant = tenant_id(Config),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"source">> => <<"monitoring">>,
        <<"name">> => <<"quota_exceeded">>
      },
      <<"data">> => <<"%%%NOTBASE64%%%">>
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_missing_tenant_id: Required field missing
t_pubsub_missing_tenant_id(Config) ->
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"source">> => <<"monitoring">>,
        <<"name">> => <<"quota_exceeded">>
      },
      <<"data">> => base64:encode(jiffy:encode(#{<<"severity">> => 1}))
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_missing_source: source attribute missing
t_pubsub_missing_source(Config) ->
  Tenant = tenant_id(Config),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"name">> => <<"quota_exceeded">>
      },
      <<"data">> => base64:encode(jiffy:encode(#{<<"severity">> => 1}))
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_missing_name: name attribute missing
t_pubsub_missing_name(Config) ->
  Tenant = tenant_id(Config),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"source">> => <<"monitoring">>
      },
      <<"data">> => base64:encode(jiffy:encode(#{<<"severity">> => 1}))
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_empty_tenant_id: tenant_id is empty string
t_pubsub_empty_tenant_id(Config) ->
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => <<"">>,
        <<"source">> => <<"monitoring">>,
        <<"name">> => <<"quota_exceeded">>
      },
      <<"data">> => base64:encode(jiffy:encode(#{<<"severity">> => 1}))
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    400 -> ok;
    _ -> ct:fail({expected_400, got, Status})
  end.

%% t_pubsub_extra_fields_ignored: Valid message with extra fields (must accept)
t_pubsub_extra_fields_ignored(Config) ->
  Tenant = tenant_id(Config),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"source">> => <<"monitoring">>,
        <<"name">> => <<"quota_exceeded">>,
        <<"extra">> => <<"ignored">>,
        <<"also">> => 123
      },
      <<"data">> => base64:encode(jiffy:encode(#{<<"severity">> => 1}))
    }
  },
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  case Status of
    200 -> ok;
    _ -> ct:fail({expected_200, got, Status})
  end.

%% t_marketplace_invalid_transition: Suspend before approval
t_marketplace_invalid_transition(Config) ->
  Tenant = tenant_id(Config),
  Event = {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_suspended">>),
  Res = post(Config, "/marketplace", Event),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  %% Should accept (200) but internally refuse, or return 400
  case Status of
    200 -> ok;
    400 -> ok;
    _ -> ct:fail({expected_200_or_400, got, Status})
  end.

%% t_entitlement_activate_flow: Normal entitlement flow
t_entitlement_activate_flow(Config) ->
  Tenant = tenant_id(Config),

  %% created
  Res1 = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_created">>)),
  require_not_5xx(Res1),

  %% approved
  Res2 = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_approved">>)),
  require_not_5xx(Res2),
  {ok, 200, _H, _Body} = Res2,

  ok.

%% t_signal_without_entitlement: Send signal before entitlement active
t_signal_without_entitlement(Config) ->
  Tenant = <<"tenant_no_ent_", (base64:encode(crypto:strong_rand_bytes(4)))/binary>>,
  Env = {{ module_prefix }}_ct_helpers:pubsub_envelope(Tenant, <<"monitoring">>, <<"quota_exceeded">>, #{<<"severity">> => 1}),
  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  %% Must not crash; 200 (ingest + refusal) is correct
  case Status of
    200 -> ok;
    _ -> ct:fail({expected_200, got, Status})
  end.

%% t_signal_required_keys: Signals with missing required keys
t_signal_required_keys(Config) ->
  Tenant = tenant_id(Config),

  %% Ensure entitled
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_created">>)),
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_approved">>)),

{% for sig in signals %}
  %% Test signal: {{ sig.name }}
  begin
    SignalName = <<"{{ sig.name }}">>,
    SignalSource = <<"{{ sig.source }}">>,
    Payload = #{<<"severity">> => 1},
    Env = {{ module_prefix }}_ct_helpers:pubsub_envelope(Tenant, SignalSource, SignalName, Payload),
    Res = post(Config, "/pubsub", Env),
    require_not_5xx(Res),
    {ok, Status, _H, _Body} = Res,
    case Status of
      200 -> ok;
      _ -> ct:fail({expected_200, signal, SignalName, got, Status})
    end
  end,
{% endfor %}

  ok.

%% t_storm_pubsub_concurrent: Concurrent Pub/Sub message flood
t_storm_pubsub_concurrent(Config) ->
  Tenant = tenant_id(Config),

  %% Ensure entitled
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_created">>)),
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_approved">>)),

  Aut = proplists:get_value(autonomics, Config),
  N = proplists:get_value(storm_n, Aut, 200),
  C = proplists:get_value(storm_concurrency, Aut, 50),

  Payload = #{<<"severity">> => 1},

  Fun = fun() ->
    Env = {{ module_prefix }}_ct_helpers:pubsub_envelope(Tenant, <<"monitoring">>, <<"quota_exceeded">>, Payload),
    Res = post(Config, "/pubsub", Env),
    require_not_5xx(Res),
    ok
  end,

  run_concurrent(N, C, Fun),
  ok.

%% t_replay_same_payload: Repeated identical messages
t_replay_same_payload(Config) ->
  Tenant = tenant_id(Config),
  {SignalName, SignalSource} = pick_signal(),
  Payload = #{<<"severity">> => 1},

  Env = {{ module_prefix }}_ct_helpers:pubsub_envelope(Tenant, SignalSource, SignalName, Payload),

  lists:foreach(fun(_I) ->
    Res = post(Config, "/pubsub", Env),
    require_not_5xx(Res),
    ok
  end, lists:seq(1, 25)),

  ok.

%% t_large_payload_rejected: 2MB+ payload
t_large_payload_rejected(Config) ->
  Tenant = tenant_id(Config),
  {SignalName, SignalSource} = pick_signal(),

  %% Generate a 2MB binary
  BigBin = binary:copy(<<"X">>, 2097152),
  Env = #{
    <<"message">> => #{
      <<"attributes">> => #{
        <<"tenant_id">> => Tenant,
        <<"source">> => SignalSource,
        <<"name">> => SignalName
      },
      <<"data">> => base64:encode(BigBin)
    }
  },

  Res = post(Config, "/pubsub", Env),
  require_not_5xx(Res),
  {ok, Status, _H, _Body} = Res,
  %% Either 400 (reject) or 200 (accept). Both are lawful. Must not be 5xx.
  case Status of
    200 -> ok;
    400 -> ok;
    _ -> ct:fail({unexpected_status, Status})
  end.

%% t_rapid_entitlement_flips: Rapid active/suspended/active transitions
t_rapid_entitlement_flips(Config) ->
  Tenant = <<"tenant_flip_", (base64:encode(crypto:strong_rand_bytes(4)))/binary>>,

  %% Create and approve
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_created">>)),
  _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_approved">>)),

  %% Rapid flips
  lists:foreach(fun(_I) ->
    _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_suspended">>)),
    _ = post(Config, "/marketplace", {{ module_prefix }}_ct_helpers:marketplace_event(Tenant, <<"entitlement_approved">>)),
    ok
  end, lists:seq(1, 10)),

  ok.

%% Concurrency utils ===================================================

pick_signal() ->
{% if signals | length > 0 %}
  {<<"{{ signals[0].name }}">>, <<"{{ signals[0].source }}">>}.
{% else %}
  {<<"unknown_signal">>, <<"unknown">>}.
{% endif %}

run_concurrent(N, Concurrency, Fun) ->
  Parent = self(),
  Work = lists:seq(1, N),
  Pids = spawn_workers(Work, Concurrency, Fun, Parent),
  await_workers(Pids).

spawn_workers(Work, Concurrency, Fun, Parent) ->
  Batches = chunk(Work, Concurrency),
  [spawn_link(fun() -> batch_run(B, Fun, Parent) end) || B <- Batches].

batch_run(Batch, Fun, Parent) ->
  lists:foreach(fun(_X) ->
    try Fun() of
      ok -> ok
    catch
      _:Why ->
        Parent ! {worker_failed, Why},
        ok
    end
  end, Batch),
  Parent ! worker_done.

await_workers(Pids) ->
  await_workers(Pids, 0).

await_workers(Pids, Done) ->
  receive
    worker_done ->
      NewDone = Done + 1,
      case NewDone =:= length(Pids) of
        true -> ok;
        false -> await_workers(Pids, NewDone)
      end;
    {worker_failed, Why} ->
      ct:fail({storm_worker_failed, Why})
  after 120000 ->
      ct:fail(storm_timeout)
  end.

chunk(List, K) when K =< 0 -> [List];
chunk([], _K) -> [];
chunk(List, K) ->
  {A, B} = lists:split(min(K, length(List)), List),
  [A | chunk(B, K)].
