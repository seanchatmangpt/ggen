//! Generated OpenTelemetry Structured Logging - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology
//! To make changes, edit the ontology and run: ggen sync
//!
//! Provides structured logging with automatic trace ID correlation.

use serde::Serialize;
use tracing::{error, info, warn};
use uuid::Uuid;

/// Structured log event
///
/// All log events are serialized as JSON with consistent fields
#[derive(Debug, Clone, Serialize)]
pub struct LogEvent {
    /// Log level (info, warn, error)
    pub level: String,
    /// ISO 8601 timestamp
    pub timestamp: String,
    /// Trace ID for correlation
    pub trace_id: Option<Uuid>,
    /// Span ID for correlation
    pub span_id: Option<Uuid>,
    /// Log message
    pub message: String,
    /// Structured fields
    pub fields: serde_json::Value,
}

impl LogEvent {
    /// Create info log event
    pub fn info(message: impl Into<String>, fields: serde_json::Value) -> Self {
        Self {
            level: "info".to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            trace_id: None,
            span_id: None,
            message: message.into(),
            fields,
        }
    }

    /// Create warn log event
    pub fn warn(message: impl Into<String>, fields: serde_json::Value) -> Self {
        Self {
            level: "warn".to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            trace_id: None,
            span_id: None,
            message: message.into(),
            fields,
        }
    }

    /// Create error log event
    pub fn error(message: impl Into<String>, fields: serde_json::Value) -> Self {
        Self {
            level: "error".to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            trace_id: None,
            span_id: None,
            message: message.into(),
            fields,
        }
    }

    /// Add trace context
    pub fn with_trace(mut self, trace_id: Uuid, span_id: Uuid) -> Self {
        self.trace_id = Some(trace_id);
        self.span_id = Some(span_id);
        self
    }

    /// Emit log via tracing
    pub fn emit(&self) {
        let json = serde_json::to_string(self).unwrap_or_else(|_| "{}".to_string());

        match self.level.as_str() {
            "info" => info!("{}", json),
            "warn" => warn!("{}", json),
            "error" => error!("{}", json),
            _ => info!("{}", json),
        }
    }
}

/// Command execution log
pub fn log_command_start(
    command_name: &str,
    command_id: &Uuid,
    aggregate_id: &Uuid,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Command execution started",
        serde_json::json!({
            "command.name": command_name,
            "command.id": command_id.to_string(),
            "aggregate.id": aggregate_id.to_string(),
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

pub fn log_command_success(
    command_name: &str,
    command_id: &Uuid,
    aggregate_id: &Uuid,
    duration_ms: u64,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Command executed successfully",
        serde_json::json!({
            "command.name": command_name,
            "command.id": command_id.to_string(),
            "aggregate.id": aggregate_id.to_string(),
            "duration.ms": duration_ms,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

pub fn log_command_error(
    command_name: &str,
    command_id: &Uuid,
    aggregate_id: &Uuid,
    error: &str,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::error(
        "Command execution failed",
        serde_json::json!({
            "command.name": command_name,
            "command.id": command_id.to_string(),
            "aggregate.id": aggregate_id.to_string(),
            "error.message": error,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

/// Event emission log
pub fn log_event_emitted(
    event_name: &str,
    event_id: &Uuid,
    aggregate_id: &Uuid,
    sequence: u64,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Event emitted",
        serde_json::json!({
            "event.name": event_name,
            "event.id": event_id.to_string(),
            "aggregate.id": aggregate_id.to_string(),
            "sequence": sequence,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

/// Receipt generation log
pub fn log_receipt_generated(
    receipt_id: &Uuid,
    aggregate_type: &str,
    payload_hash: &str,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Receipt generated",
        serde_json::json!({
            "receipt.id": receipt_id.to_string(),
            "aggregate.type": aggregate_type,
            "payload.hash": payload_hash,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

/// Affiliate tracking log
pub fn log_click_tracked(
    affiliate_id: &Uuid,
    click_id: &Uuid,
    ip_address: &str,
    user_agent: &str,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Affiliate click tracked",
        serde_json::json!({
            "affiliate.id": affiliate_id.to_string(),
            "click.id": click_id.to_string(),
            "http.client.ip": ip_address,
            "http.user_agent": user_agent,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

pub fn log_conversion_tracked(
    affiliate_id: &Uuid,
    click_id: &Uuid,
    order_id: &Uuid,
    revenue_cents: u64,
    latency_secs: f64,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "Affiliate conversion tracked",
        serde_json::json!({
            "affiliate.id": affiliate_id.to_string(),
            "click.id": click_id.to_string(),
            "order.id": order_id.to_string(),
            "revenue.cents": revenue_cents,
            "conversion.latency.secs": latency_secs,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

/// HTTP request log
pub fn log_http_request(
    method: &str,
    path: &str,
    status_code: u16,
    duration_ms: u64,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::info(
        "HTTP request processed",
        serde_json::json!({
            "http.method": method,
            "http.route": path,
            "http.status_code": status_code,
            "duration.ms": duration_ms,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

/// Business rule violation log
pub fn log_business_rule_violation(
    rule_name: &str,
    aggregate_id: &Uuid,
    reason: &str,
    trace_id: Uuid,
    span_id: Uuid,
) {
    LogEvent::warn(
        "Business rule violation",
        serde_json::json!({
            "rule.name": rule_name,
            "aggregate.id": aggregate_id.to_string(),
            "violation.reason": reason,
        }),
    )
    .with_trace(trace_id, span_id)
    .emit();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_log_event_serialization() {
        let event = LogEvent::info(
            "Test message",
            serde_json::json!({"key": "value"}),
        );

        let json = serde_json::to_string(&event).unwrap();
        assert!(json.contains("info"));
        assert!(json.contains("Test message"));
    }

    #[test]
    fn test_log_with_trace_context() {
        let trace_id = Uuid::new_v4();
        let span_id = Uuid::new_v4();

        let event = LogEvent::info("Test", serde_json::json!({}))
            .with_trace(trace_id, span_id);

        assert_eq!(event.trace_id, Some(trace_id));
        assert_eq!(event.span_id, Some(span_id));
    }
}
