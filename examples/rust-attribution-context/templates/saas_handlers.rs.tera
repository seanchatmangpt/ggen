//! Generated SaaS Handlers - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology/saas_*.ttl
//! To make changes, edit the ontology and run: ggen sync

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::commands::*;
use crate::events::*;
use crate::aggregates::*;

/// Result type for handler operations
pub type HandlerResult<T> = Result<T, HandlerError>;

/// Handler error types
#[derive(Debug, thiserror::Error)]
pub enum HandlerError {
    #[error("Subscription not found: {0}")]
    SubscriptionNotFound(Uuid),

    #[error("Program not found: {0}")]
    ProgramNotFound(Uuid),

    #[error("Invalid subscription status: {0}")]
    InvalidStatus(String),

    #[error("Commission calculation failed: {0}")]
    CommissionCalculationFailed(String),

    #[error("Webhook validation failed")]
    WebhookValidationFailed,
}

/// Track subscription command handler
pub async fn handle_track_subscription(
    cmd: TrackSubscription,
    aggregate: &mut RevenueAggregate,
) -> HandlerResult<SubscriptionCreated> {
    // Create new subscription ID
    let subscription_id = Uuid::new_v4();

    // Update aggregate state
    aggregate.total_mrr += cmd.mrr_amount;
    aggregate.active_subscriptions += 1;
    aggregate.total_subscriptions += 1;
    aggregate.projected_arr = aggregate.total_mrr * Decimal::from(12);
    aggregate.updated_at = Utc::now();

    // Emit event
    Ok(SubscriptionCreated {
        subscription_id,
        program_id: cmd.program_id,
        publisher_id: cmd.publisher_id,
        customer_id: cmd.customer_id,
        plan: cmd.plan,
        mrr: cmd.mrr_amount,
        start_date: cmd.start_date,
        created_at: Utc::now(),
    })
}

/// Record recurring commission handler
pub async fn handle_record_recurring_commission(
    cmd: RecordRecurringCommission,
    aggregate: &mut RevenueAggregate,
    subscription: &Subscription,
    program: &SaasProgram,
) -> HandlerResult<RecurringCommissionRecorded> {
    // Verify subscription is active
    if subscription.status != "active" {
        return Err(HandlerError::InvalidStatus(subscription.status.clone()));
    }

    // Calculate commission
    let commission_amount = subscription.mrr_amount * program.commission_rate;

    // Update aggregate
    aggregate.lifetime_commissions += commission_amount;
    aggregate.updated_at = Utc::now();

    // Emit event
    Ok(RecurringCommissionRecorded {
        commission_id: Uuid::new_v4(),
        subscription_id: cmd.subscription_id,
        publisher_id: subscription.publisher_id,
        amount: commission_amount,
        period_start: cmd.period_start,
        period_end: cmd.period_end,
        recorded_at: Utc::now(),
    })
}

/// Cancel subscription handler
pub async fn handle_cancel_subscription(
    cmd: CancelSubscription,
    aggregate: &mut RevenueAggregate,
    subscription: &Subscription,
) -> HandlerResult<SubscriptionCanceled> {
    // Update aggregate
    aggregate.total_mrr -= subscription.mrr_amount;
    aggregate.active_subscriptions -= 1;
    aggregate.canceled_subscriptions += 1;
    aggregate.projected_arr = aggregate.total_mrr * Decimal::from(12);
    aggregate.updated_at = Utc::now();

    // Emit event
    Ok(SubscriptionCanceled {
        subscription_id: cmd.subscription_id,
        publisher_id: subscription.publisher_id,
        cancel_date: cmd.cancel_date,
        lifetime_commission: subscription.lifetime_commission,
        canceled_at: Utc::now(),
    })
}

/// Webhook receiver for Stripe integration
#[derive(Debug, Deserialize)]
pub struct StripeWebhook {
    pub r#type: String,
    pub data: serde_json::Value,
}

/// Handle Stripe webhook and map to commands
pub async fn handle_stripe_webhook(
    webhook: StripeWebhook,
    program_id: Uuid,
    publisher_id: Uuid,
) -> HandlerResult<Vec<Box<dyn std::any::Any>>> {
    let mut commands: Vec<Box<dyn std::any::Any>> = vec![];

    match webhook.r#type.as_str() {
        "customer.subscription.created" => {
            let sub_data = &webhook.data["object"];
            commands.push(Box::new(TrackSubscription {
                program_id,
                publisher_id,
                customer_id: sub_data["customer"].as_str().unwrap_or("").to_string(),
                plan: sub_data["plan"]["nickname"].as_str().unwrap_or("default").to_string(),
                mrr_amount: Decimal::from_f64_retain(
                    sub_data["plan"]["amount"].as_f64().unwrap_or(0.0) / 100.0
                ).unwrap_or_default(),
                currency: sub_data["currency"].as_str().map(String::from),
                start_date: Utc::now(),
            }));
        },
        "invoice.payment_succeeded" => {
            // Map to RecordRecurringCommission
            // Implementation depends on invoice data structure
        },
        "customer.subscription.deleted" => {
            let sub_data = &webhook.data["object"];
            let subscription_id = Uuid::parse_str(
                sub_data["id"].as_str().unwrap_or("")
            ).unwrap_or_else(|_| Uuid::new_v4());

            commands.push(Box::new(CancelSubscription {
                subscription_id,
                cancel_date: Utc::now(),
            }));
        },
        _ => {
            // Unknown webhook type, log and ignore
        }
    }

    Ok(commands)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_track_subscription_creates_event() {
        // Arrange
        let mut aggregate = RevenueAggregate {
            id: Uuid::new_v4(),
            total_mrr: Decimal::ZERO,
            active_subscriptions: 0,
            lifetime_commissions: Decimal::ZERO,
            total_subscriptions: 0,
            canceled_subscriptions: 0,
            projected_arr: Decimal::ZERO,
            updated_at: Utc::now(),
        };

        let cmd = TrackSubscription {
            program_id: Uuid::new_v4(),
            publisher_id: Uuid::new_v4(),
            customer_id: "cus_test123".to_string(),
            plan: "pro".to_string(),
            mrr_amount: Decimal::from(99),
            currency: Some("USD".to_string()),
            start_date: Utc::now(),
        };

        // Act
        let result = handle_track_subscription(cmd.clone(), &mut aggregate).await;

        // Assert
        assert!(result.is_ok());
        let event = result.unwrap();
        assert_eq!(event.plan, "pro");
        assert_eq!(event.mrr, Decimal::from(99));
        assert_eq!(aggregate.total_mrr, Decimal::from(99));
        assert_eq!(aggregate.active_subscriptions, 1);
        assert_eq!(aggregate.projected_arr, Decimal::from(99 * 12));
    }

    #[tokio::test]
    async fn test_record_commission_calculates_correctly() {
        // Arrange
        let mut aggregate = RevenueAggregate {
            id: Uuid::new_v4(),
            total_mrr: Decimal::from(99),
            active_subscriptions: 1,
            lifetime_commissions: Decimal::ZERO,
            total_subscriptions: 1,
            canceled_subscriptions: 0,
            projected_arr: Decimal::from(99 * 12),
            updated_at: Utc::now(),
        };

        let subscription = Subscription {
            id: Uuid::new_v4(),
            program_id: Uuid::new_v4(),
            publisher_id: Uuid::new_v4(),
            customer_id: "cus_test123".to_string(),
            plan: "pro".to_string(),
            mrr_amount: Decimal::from(99),
            currency: "USD".to_string(),
            status: "active".to_string(),
            start_date: Utc::now(),
            next_billing_date: Some(Utc::now()),
            cancel_date: None,
            lifetime_commission: Decimal::ZERO,
            created_at: Utc::now(),
        };

        let program = SaasProgram {
            id: Uuid::new_v4(),
            name: "Test Program".to_string(),
            commission_rate: Decimal::from_str("0.30").unwrap(), // 30%
            billing_cycle: "monthly".to_string(),
            api_integration: "stripe".to_string(),
            webhook_secret: None,
            active: true,
            created_at: Utc::now(),
        };

        let cmd = RecordRecurringCommission {
            subscription_id: subscription.id,
            period_start: Utc::now(),
            period_end: Utc::now(),
        };

        // Act
        let result = handle_record_recurring_commission(
            cmd,
            &mut aggregate,
            &subscription,
            &program,
        ).await;

        // Assert
        assert!(result.is_ok());
        let event = result.unwrap();
        // 99 * 0.30 = 29.7
        assert_eq!(event.amount, Decimal::from_str("29.7").unwrap());
        assert_eq!(aggregate.lifetime_commissions, Decimal::from_str("29.7").unwrap());
    }
}
