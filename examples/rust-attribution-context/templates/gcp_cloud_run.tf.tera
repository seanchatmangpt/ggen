# Generated GCP Cloud Run Configuration - DO NOT EDIT
#
# This file is automatically generated by ggen from ontology/infra.ttl
# To make changes, edit the ontology and run: ggen sync

{% for row in sparql_results -%}
{%- set service_name = row["?serviceName"] -%}
{%- set region = row["?region"] | default(value="us-central1") -%}
{%- set container_image = row["?containerImage"] | default(value="gcr.io/PROJECT_ID/attribution-service:latest") -%}
{%- set min_instances = row["?minInstances"] | default(value="1") -%}
{%- set max_instances = row["?maxInstances"] | default(value="10") -%}
{%- set cpu = row["?cpu"] | default(value="2") -%}
{%- set memory = row["?memory"] | default(value="2Gi") -%}
{%- set timeout = row["?timeout"] | default(value="300") -%}
{%- set concurrency = row["?concurrency"] | default(value="80") -%}

resource "google_cloud_run_v2_service" "{{ service_name | replace(from="-", to="_") }}" {
  name     = "{{ service_name }}"
  location = "{{ region }}"
  ingress  = "INGRESS_TRAFFIC_ALL"

  template {
    service_account = google_service_account.{{ service_name | replace(from="-", to="_") }}_sa.email

    scaling {
      min_instance_count = {{ min_instances }}
      max_instance_count = {{ max_instances }}
    }

    timeout = "{{ timeout }}s"
    max_instance_request_concurrency = {{ concurrency }}

    containers {
      image = "{{ container_image }}"

      resources {
        limits = {
          cpu    = "{{ cpu }}"
          memory = "{{ memory }}"
        }
        cpu_idle          = false
        startup_cpu_boost = true
      }

      ports {
        name           = "http1"
        container_port = 8080
      }

      env {
        name  = "DATABASE_URL"
        value_source {
          secret_key_ref {
            secret  = google_secret_manager_secret.db_connection_string.secret_id
            version = "latest"
          }
        }
      }

      env {
        name  = "RUST_LOG"
        value = "info,attribution_context=debug"
      }

      env {
        name  = "OTEL_EXPORTER_OTLP_ENDPOINT"
        value = "https://cloudtrace.googleapis.com"
      }

      startup_probe {
        initial_delay_seconds = 5
        timeout_seconds       = 3
        period_seconds        = 10
        failure_threshold     = 3
        http_get {
          path = "/health/startup"
          port = 8080
        }
      }

      liveness_probe {
        initial_delay_seconds = 30
        timeout_seconds       = 3
        period_seconds        = 30
        failure_threshold     = 3
        http_get {
          path = "/health/live"
          port = 8080
        }
      }
    }

    vpc_access {
      connector = google_vpc_access_connector.connector.id
      egress    = "PRIVATE_RANGES_ONLY"
    }
  }

  traffic {
    type    = "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"
    percent = 100
  }

  lifecycle {
    ignore_changes = [
      template[0].containers[0].image,
    ]
  }

  depends_on = [
    google_project_service.run_api,
    google_sql_database_instance.event_store,
  ]
}

# Service Account for Cloud Run
resource "google_service_account" "{{ service_name | replace(from="-", to="_") }}_sa" {
  account_id   = "{{ service_name }}-sa"
  display_name = "Service Account for {{ service_name }}"
  description  = "Managed by Terraform - Production-ready service account with least privilege"
}

# IAM binding for Cloud Run invoker (public access)
resource "google_cloud_run_service_iam_member" "{{ service_name | replace(from="-", to="_") }}_public" {
  location = google_cloud_run_v2_service.{{ service_name | replace(from="-", to="_") }}.location
  service  = google_cloud_run_v2_service.{{ service_name | replace(from="-", to="_") }}.name
  role     = "roles/run.invoker"
  member   = "allUsers"
}

# Cloud SQL Client permissions
resource "google_project_iam_member" "{{ service_name | replace(from="-", to="_") }}_cloudsql_client" {
  project = var.project_id
  role    = "roles/cloudsql.client"
  member  = "serviceAccount:${google_service_account.{{ service_name | replace(from="-", to="_") }}_sa.email}"
}

# Cloud Trace Agent permissions
resource "google_project_iam_member" "{{ service_name | replace(from="-", to="_") }}_trace_agent" {
  project = var.project_id
  role    = "roles/cloudtrace.agent"
  member  = "serviceAccount:${google_service_account.{{ service_name | replace(from="-", to="_") }}_sa.email}"
}

# Cloud Monitoring Metric Writer permissions
resource "google_project_iam_member" "{{ service_name | replace(from="-", to="_") }}_monitoring_writer" {
  project = var.project_id
  role    = "roles/monitoring.metricWriter"
  member  = "serviceAccount:${google_service_account.{{ service_name | replace(from="-", to="_") }}_sa.email}"
}

# Secret Manager Secret Accessor permissions
resource "google_project_iam_member" "{{ service_name | replace(from="-", to="_") }}_secret_accessor" {
  project = var.project_id
  role    = "roles/secretmanager.secretAccessor"
  member  = "serviceAccount:${google_service_account.{{ service_name | replace(from="-", to="_") }}_sa.email}"
}

{% endfor %}

# Enable required APIs
resource "google_project_service" "run_api" {
  service            = "run.googleapis.com"
  disable_on_destroy = false
}

resource "google_project_service" "vpcaccess_api" {
  service            = "vpcaccess.googleapis.com"
  disable_on_destroy = false
}

# VPC Access Connector for private Cloud SQL access
resource "google_vpc_access_connector" "connector" {
  name          = "attribution-vpc-connector"
  region        = var.region
  network       = google_compute_network.vpc.name
  ip_cidr_range = "10.8.0.0/28"

  min_instances = 2
  max_instances = 3
  machine_type  = "e2-micro"

  depends_on = [
    google_project_service.vpcaccess_api,
  ]
}
