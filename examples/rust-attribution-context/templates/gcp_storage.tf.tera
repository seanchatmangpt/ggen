# Generated GCP Cloud Storage Configuration - DO NOT EDIT
#
# This file is automatically generated by ggen from ontology/infra.ttl
# To make changes, edit the ontology and run: ggen sync

{% for row in sparql_results -%}
{%- set bucket_name = row["?bucketName"] | default(value="attribution-static-content") -%}
{%- set location = row["?location"] | default(value="US") -%}
{%- set storage_class = row["?storageClass"] | default(value="STANDARD") -%}

# Static content bucket with CDN integration
resource "google_storage_bucket" "{{ bucket_name | replace(from="-", to="_") }}" {
  name          = "${var.project_id}-{{ bucket_name }}"
  location      = "{{ location }}"
  storage_class = "{{ storage_class }}"

  uniform_bucket_level_access = true
  force_destroy              = false

  versioning {
    enabled = true
  }

  lifecycle_rule {
    condition {
      num_newer_versions = 3
      with_state        = "ARCHIVED"
    }
    action {
      type = "Delete"
    }
  }

  lifecycle_rule {
    condition {
      days_since_noncurrent_time = 30
    }
    action {
      type = "Delete"
    }
  }

  cors {
    origin          = ["https://*"]
    method          = ["GET", "HEAD", "OPTIONS"]
    response_header = ["Content-Type", "Cache-Control"]
    max_age_seconds = 3600
  }

  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
}

# Make bucket publicly readable for CDN
resource "google_storage_bucket_iam_member" "{{ bucket_name | replace(from="-", to="_") }}_public_read" {
  bucket = google_storage_bucket.{{ bucket_name | replace(from="-", to="_") }}.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

# Backend bucket for Cloud CDN
resource "google_compute_backend_bucket" "{{ bucket_name | replace(from="-", to="_") }}_cdn" {
  name        = "{{ bucket_name }}-cdn-backend"
  bucket_name = google_storage_bucket.{{ bucket_name | replace(from="-", to="_") }}.name
  enable_cdn  = true

  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400

    cache_key_policy {
      include_host           = true
      include_protocol       = true
      include_query_string   = false
    }

    negative_caching_policy {
      code = 404
      ttl  = 120
    }

    negative_caching_policy {
      code = 410
      ttl  = 120
    }
  }

  compression_mode = "AUTOMATIC"
}

# URL map for CDN
resource "google_compute_url_map" "{{ bucket_name | replace(from="-", to="_") }}_cdn" {
  name            = "{{ bucket_name }}-cdn-url-map"
  default_service = google_compute_backend_bucket.{{ bucket_name | replace(from="-", to="_") }}_cdn.id

  host_rule {
    hosts        = ["static.attribution.example.com"]
    path_matcher = "allpaths"
  }

  path_matcher {
    name            = "allpaths"
    default_service = google_compute_backend_bucket.{{ bucket_name | replace(from="-", to="_") }}_cdn.id
  }
}

# HTTPS certificate for CDN
resource "google_compute_managed_ssl_certificate" "{{ bucket_name | replace(from="-", to="_") }}_cdn" {
  name = "{{ bucket_name }}-cdn-cert"

  managed {
    domains = ["static.attribution.example.com"]
  }
}

# HTTPS proxy
resource "google_compute_target_https_proxy" "{{ bucket_name | replace(from="-", to="_") }}_cdn" {
  name             = "{{ bucket_name }}-cdn-https-proxy"
  url_map          = google_compute_url_map.{{ bucket_name | replace(from="-", to="_") }}_cdn.id
  ssl_certificates = [google_compute_managed_ssl_certificate.{{ bucket_name | replace(from="-", to="_") }}_cdn.id]
}

# Global forwarding rule for HTTPS
resource "google_compute_global_forwarding_rule" "{{ bucket_name | replace(from="-", to="_") }}_cdn_https" {
  name                  = "{{ bucket_name }}-cdn-https-rule"
  ip_protocol           = "TCP"
  load_balancing_scheme = "EXTERNAL"
  port_range            = "443"
  target                = google_compute_target_https_proxy.{{ bucket_name | replace(from="-", to="_") }}_cdn.id
  ip_address            = google_compute_global_address.{{ bucket_name | replace(from="-", to="_") }}_cdn.id
}

# Global IP address
resource "google_compute_global_address" "{{ bucket_name | replace(from="-", to="_") }}_cdn" {
  name = "{{ bucket_name }}-cdn-ip"
}

{% endfor %}

# Event store backup bucket (private)
resource "google_storage_bucket" "event_store_backups" {
  name          = "${var.project_id}-event-store-backups"
  location      = var.region
  storage_class = "STANDARD"

  uniform_bucket_level_access = true
  force_destroy              = false

  versioning {
    enabled = true
  }

  lifecycle_rule {
    condition {
      age = 90
    }
    action {
      type          = "SetStorageClass"
      storage_class = "NEARLINE"
    }
  }

  lifecycle_rule {
    condition {
      age = 365
    }
    action {
      type          = "SetStorageClass"
      storage_class = "COLDLINE"
    }
  }

  lifecycle_rule {
    condition {
      age = 2555
    }
    action {
      type = "Delete"
    }
  }

  encryption {
    default_kms_key_name = google_kms_crypto_key.event_store_key.id
  }
}

# KMS key for backup encryption
resource "google_kms_key_ring" "event_store" {
  name     = "event-store-keyring"
  location = var.region
}

resource "google_kms_crypto_key" "event_store_key" {
  name            = "event-store-backup-key"
  key_ring        = google_kms_key_ring.event_store.id
  rotation_period = "7776000s" # 90 days

  lifecycle {
    prevent_destroy = true
  }
}

# Grant Cloud Storage service account access to KMS key
resource "google_kms_crypto_key_iam_member" "storage_sa_kms" {
  crypto_key_id = google_kms_crypto_key.event_store_key.id
  role          = "roles/cloudkms.cryptoKeyEncrypterDecrypter"
  member        = "serviceAccount:service-${data.google_project.project.number}@gs-project-accounts.iam.gserviceaccount.com"
}

data "google_project" "project" {
  project_id = var.project_id
}
