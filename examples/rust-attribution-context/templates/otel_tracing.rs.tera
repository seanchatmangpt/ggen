//! Generated OpenTelemetry Tracing - DO NOT EDIT
//!
//! This file is automatically generated by ggen from ontology
//! To make changes, edit the ontology and run: ggen sync
//!
//! Provides distributed tracing with context propagation for all commands and events.

use opentelemetry::{
    global,
    trace::{Span, SpanKind, Status, Tracer, TracerProvider},
    Context, KeyValue,
};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    runtime,
    trace::{Config, Sampler},
    Resource,
};
use std::collections::HashMap;
use tracing::Level;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use uuid::Uuid;

/// OpenTelemetry configuration
#[derive(Debug, Clone)]
pub struct OtelConfig {
    /// Service name for tracing
    pub service_name: String,
    /// Service version
    pub service_version: String,
    /// Environment (dev, staging, prod)
    pub environment: String,
    /// OTLP endpoint (gRPC)
    pub otlp_endpoint: String,
    /// Sampling ratio (0.0 to 1.0)
    pub sampling_ratio: f64,
}

impl Default for OtelConfig {
    fn default() -> Self {
        Self {
            service_name: "factory-paas".to_string(),
            service_version: env!("CARGO_PKG_VERSION").to_string(),
            environment: std::env::var("ENVIRONMENT").unwrap_or_else(|_| "dev".to_string()),
            otlp_endpoint: std::env::var("OTEL_EXPORTER_OTLP_ENDPOINT")
                .unwrap_or_else(|_| "http://localhost:4317".to_string()),
            sampling_ratio: std::env::var("OTEL_SAMPLING_RATIO")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(1.0),
        }
    }
}

/// Initialize OpenTelemetry tracing pipeline
///
/// Sets up:
/// - OTLP exporter (gRPC) for GCP Cloud Trace
/// - Trace sampling
/// - Resource attributes (service.name, service.version, deployment.environment)
/// - Context propagation (W3C Trace Context)
pub fn init_otel_tracing(config: OtelConfig) -> Result<(), Box<dyn std::error::Error>> {
    // Create resource with service information
    let resource = Resource::new(vec![
        KeyValue::new("service.name", config.service_name.clone()),
        KeyValue::new("service.version", config.service_version.clone()),
        KeyValue::new("deployment.environment", config.environment.clone()),
    ]);

    // Configure OTLP exporter
    let otlp_exporter = opentelemetry_otlp::new_exporter()
        .tonic()
        .with_endpoint(&config.otlp_endpoint);

    // Create trace provider with sampling
    let tracer_provider = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(otlp_exporter)
        .with_trace_config(
            Config::default()
                .with_sampler(Sampler::TraceIdRatioBased(config.sampling_ratio))
                .with_resource(resource),
        )
        .install_batch(runtime::Tokio)?;

    // Set global tracer provider
    global::set_tracer_provider(tracer_provider);

    // Create tracing-opentelemetry layer
    let telemetry_layer = tracing_opentelemetry::layer()
        .with_tracer(global::tracer("factory-paas"));

    // Create env filter for log levels
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));

    // Initialize tracing subscriber with OpenTelemetry
    tracing_subscriber::registry()
        .with(env_filter)
        .with(tracing_subscriber::fmt::layer().json())
        .with(telemetry_layer)
        .init();

    tracing::info!(
        service.name = config.service_name,
        service.version = config.service_version,
        environment = config.environment,
        otlp.endpoint = config.otlp_endpoint,
        sampling.ratio = config.sampling_ratio,
        "OpenTelemetry tracing initialized"
    );

    Ok(())
}

/// Shutdown OpenTelemetry gracefully
///
/// Flushes all pending spans before shutdown
pub async fn shutdown_otel_tracing() -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("Shutting down OpenTelemetry tracing...");
    opentelemetry::global::shutdown_tracer_provider();
    Ok(())
}

/// Span context for distributed tracing
///
/// Carries trace ID and span ID across service boundaries
#[derive(Debug, Clone)]
pub struct SpanContext {
    /// Trace ID (UUID format for compatibility)
    pub trace_id: Uuid,
    /// Span ID (UUID format)
    pub span_id: Uuid,
    /// Parent span ID (if this is a child span)
    pub parent_span_id: Option<Uuid>,
}

impl SpanContext {
    /// Create new root span context
    pub fn new_root() -> Self {
        Self {
            trace_id: Uuid::new_v4(),
            span_id: Uuid::new_v4(),
            parent_span_id: None,
        }
    }

    /// Create child span context
    pub fn new_child(&self) -> Self {
        Self {
            trace_id: self.trace_id,
            span_id: Uuid::new_v4(),
            parent_span_id: Some(self.span_id),
        }
    }

    /// Extract from HTTP headers (W3C Trace Context format)
    pub fn from_headers(headers: &HashMap<String, String>) -> Option<Self> {
        let traceparent = headers.get("traceparent")?;
        Self::parse_traceparent(traceparent)
    }

    /// Inject into HTTP headers (W3C Trace Context format)
    pub fn to_headers(&self) -> HashMap<String, String> {
        let mut headers = HashMap::new();
        headers.insert("traceparent".to_string(), self.to_traceparent());
        headers
    }

    /// Parse W3C traceparent header
    /// Format: 00-{trace-id}-{parent-id}-{flags}
    fn parse_traceparent(traceparent: &str) -> Option<Self> {
        let parts: Vec<&str> = traceparent.split('-').collect();
        if parts.len() != 4 || parts[0] != "00" {
            return None;
        }

        let trace_id = Uuid::parse_str(parts[1]).ok()?;
        let parent_span_id = Uuid::parse_str(parts[2]).ok()?;

        Some(Self {
            trace_id,
            span_id: Uuid::new_v4(),
            parent_span_id: Some(parent_span_id),
        })
    }

    /// Format as W3C traceparent header
    fn to_traceparent(&self) -> String {
        format!(
            "00-{}-{}-01",
            self.trace_id.as_simple(),
            self.span_id.as_simple()
        )
    }
}

/// Create instrumented span for command handler
///
/// Usage:
/// ```rust
/// let span = create_command_span("CreateClick", &command_id, &aggregate_id);
/// let _guard = span.enter();
/// // ... command handling logic ...
/// ```
#[must_use]
pub fn create_command_span(
    command_name: &str,
    command_id: &Uuid,
    aggregate_id: &Uuid,
) -> tracing::Span {
    tracing::info_span!(
        "command",
        otel.kind = "server",
        command.name = command_name,
        command.id = %command_id,
        aggregate.id = %aggregate_id,
        span.kind = "command_handler"
    )
}

/// Create instrumented span for event emission
#[must_use]
pub fn create_event_span(
    event_name: &str,
    event_id: &Uuid,
    aggregate_id: &Uuid,
) -> tracing::Span {
    tracing::info_span!(
        "event",
        otel.kind = "producer",
        event.name = event_name,
        event.id = %event_id,
        aggregate.id = %aggregate_id,
        span.kind = "event_emission"
    )
}

/// Create instrumented span for HTTP request
#[must_use]
pub fn create_http_span(
    method: &str,
    path: &str,
    request_id: &Uuid,
) -> tracing::Span {
    tracing::info_span!(
        "http.request",
        otel.kind = "server",
        http.method = method,
        http.route = path,
        http.request_id = %request_id,
        span.kind = "http_handler"
    )
}

/// Create instrumented span for database operation
#[must_use]
pub fn create_db_span(
    operation: &str,
    table: &str,
) -> tracing::Span {
    tracing::info_span!(
        "db.operation",
        otel.kind = "client",
        db.system = "postgres",
        db.operation = operation,
        db.table = table,
        span.kind = "db_query"
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_span_context_roundtrip() {
        let ctx = SpanContext::new_root();
        let headers = ctx.to_headers();
        let parsed = SpanContext::from_headers(&headers);

        assert!(parsed.is_some());
        let parsed = parsed.unwrap();
        assert_eq!(parsed.trace_id, ctx.trace_id);
    }

    #[test]
    fn test_child_span_context() {
        let parent = SpanContext::new_root();
        let child = parent.new_child();

        assert_eq!(child.trace_id, parent.trace_id);
        assert_ne!(child.span_id, parent.span_id);
        assert_eq!(child.parent_span_id, Some(parent.span_id));
    }

    #[test]
    fn test_traceparent_format() {
        let ctx = SpanContext::new_root();
        let traceparent = ctx.to_traceparent();

        assert!(traceparent.starts_with("00-"));
        assert!(traceparent.ends_with("-01"));

        let parts: Vec<&str> = traceparent.split('-').collect();
        assert_eq!(parts.len(), 4);
    }
}
