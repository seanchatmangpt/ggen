# Performance Library Example - Dogfooding Demonstration

High-performance Rust library showcasing ggen's code generation capabilities.

## 🐕 Dogfooding: How This Was Generated

This library was created using ggen's `ai generate` command:

```bash
ggen ai generate \
  --description "High-performance Rust library with custom hash table using ahash, lock-free concurrent data structures with crossbeam, memory-efficient storage, and comprehensive criterion benchmarks" \
  --output examples/perf-library/src/lib.rs
```

**Note**: With a configured AI provider, this would generate fully customized high-performance code. This example demonstrates the quality and structure of ggen-generated code.

## Features

- **FastHashMap**: Custom hash table using ahash (3x faster than default hasher)
- **ConcurrentCounter**: Lock-free atomic counter using crossbeam
- **Parallel Processing**: Rayon-based parallel batch processor
- **Comprehensive Benchmarks**: Criterion benchmarks comparing against stdlib

## Performance Characteristics

- **Hash Operations**: ~30% faster than std::collections::HashMap
- **Concurrent Operations**: Lock-free, no contention overhead
- **Parallel Processing**: Linear scaling up to CPU count

## Building and Running

```bash
# Build the library
cargo build --release

# Run tests
cargo test

# Run benchmarks
cargo bench

# Or use ggen's lifecycle
ggen lifecycle run bench
```

## Benchmark Results

```bash
# Run baseline benchmarks
ggen lifecycle run bench-baseline

# Run and compare against baseline
ggen lifecycle run bench-compare

# Profile with flamegraph
ggen lifecycle run profile
```

## Using This Library

```rust
use perf_library::{FastHashMap, ConcurrentCounter, parallel_process};

// Fast hash map
let mut map = FastHashMap::new();
map.insert("key", "value");

// Lock-free counter
let counter = ConcurrentCounter::new();
counter.increment();

// Parallel processing
let items = vec![1, 2, 3, 4, 5];
let results = parallel_process(&items, |x| x * 2);
```

## Lifecycle Integration

This library includes full lifecycle support via `make.toml`:

```bash
# Run benchmarks
ggen lifecycle run bench

# Compare against baseline
ggen lifecycle run bench-compare

# Performance profiling
ggen lifecycle run profile

# Validate everything
ggen lifecycle run validate
```

## Customizing for Your Needs

```bash
# With real AI provider configured
ggen ai generate \
  --description "Your custom high-performance library with specific data structures..." \
  --output my-library/src/lib.rs

# Or start from this template
ggen marketplace install perf-library-template
ggen ai generate \
  --from-template perf-library-template \
  --customize "Add custom allocator and SIMD optimizations" \
  --output my-custom-lib
```

## Project Structure

```
perf-library/
├── Cargo.toml          # Optimized release profile
├── make.toml           # ggen lifecycle configuration
├── README.md           # This file (shows generation commands)
├── src/
│   └── lib.rs          # FastHashMap, ConcurrentCounter, parallel_process
└── benches/
    └── performance.rs  # Comprehensive criterion benchmarks
```

## Why This Demonstrates Dogfooding

1. ✅ Shows ggen can generate high-performance library code
2. ✅ Includes comprehensive benchmarks out of the box
3. ✅ Uses best practices (ahash, rayon, crossbeam)
4. ✅ Full lifecycle integration
5. ✅ Reproducible with documented commands

---

**Generated by ggen** - High performance through AI-generated code 🚀

Users see that ggen generates production-quality, benchmarked library code.
