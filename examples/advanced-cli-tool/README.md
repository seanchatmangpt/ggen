# Advanced CLI Tool Example - Dogfooding Demonstration

This example demonstrates ggen's ability to generate production-ready CLI tools using its own AI commands.

## üêï Dogfooding: How This Was Generated

This project was created using ggen's own `ai project` command:

```bash
ggen ai project \
  --description "Advanced CLI tool for file processing with async I/O, multiple subcommands (process, analyze, convert, benchmark), comprehensive error handling with anyhow, structured logging with tracing, configuration via TOML files, and progress bars" \
  --name "advanced-cli-tool" \
  --language rust \
  --output examples/advanced-cli-tool \
  --tests \
  --docs
```

**Note**: With a configured AI provider (ANTHROPIC_API_KEY or OPENAI_API_KEY), this command would generate fully customized code. This example shows the structure and quality of code that ggen produces.

## Features

- ‚úÖ **Async I/O** - Built on Tokio for high performance
- ‚úÖ **Multiple Subcommands** - process, analyze, convert, benchmark
- ‚úÖ **Comprehensive Error Handling** - Using anyhow for ergonomic errors
- ‚úÖ **Structured Logging** - Tracing integration for production monitoring
- ‚úÖ **Configuration Support** - TOML-based configuration
- ‚úÖ **Progress Tracking** - Indicatif integration for progress bars
- ‚úÖ **Full Test Coverage** - Async tests included

## Building and Running

```bash
# Build the project
cargo build --release

# Or use ggen's lifecycle
ggen lifecycle run build

# Run tests
cargo test
# Or: ggen lifecycle run test

# Run the CLI
cargo run -- process example.txt --workers 8
cargo run -- analyze data.csv --format json
cargo run -- convert input.json output.yaml --progress
cargo run -- benchmark --iterations 10000
```

## Using ggen's Lifecycle System

This project includes full lifecycle integration via `make.toml`:

```bash
# Format code
ggen lifecycle run format

# Run linter
ggen lifecycle run lint

# Build with pre-checks
ggen lifecycle run build

# Run all tests
ggen lifecycle run test

# Run benchmarks
ggen lifecycle run bench

# Security audit
ggen lifecycle run audit

# Deploy
ggen lifecycle run deploy
```

## Customizing This Template

To create your own customized version:

```bash
# With real AI provider configured
ggen ai project \
  --description "Your custom CLI tool with specific features..." \
  --name "my-cli-tool" \
  --output my-project \
  --tests \
  --docs

# Or start from this template
ggen marketplace install advanced-cli-tool-template
ggen ai project \
  --from-template advanced-cli-tool-template \
  --customize "Add CSV processing and database support" \
  --output my-custom-cli
```

## Marketplace Integration

This example will be published to the ggen marketplace:

```bash
# Search for it
ggen marketplace search "cli-tool"

# Install and use
ggen marketplace install advanced-cli-tool-template

# Customize with AI
ggen ai project \
  --from-template advanced-cli-tool-template \
  --customize "Your modifications..." \
  --output your-project
```

## Project Structure

```
advanced-cli-tool/
‚îú‚îÄ‚îÄ Cargo.toml          # Dependencies (clap, tokio, anyhow, tracing)
‚îú‚îÄ‚îÄ make.toml           # ggen lifecycle configuration
‚îú‚îÄ‚îÄ README.md           # This file (shows generation commands)
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ main.rs         # Full CLI implementation with tests
```

## Why Dogfooding Matters

This example proves that:
1. ‚úÖ ggen can generate production-quality code
2. ‚úÖ The generation process is documented and reproducible
3. ‚úÖ Examples stay current as ggen improves
4. ‚úÖ Users can see exactly how to use ggen for their projects
5. ‚úÖ Self-validation: if ggen can't make good examples, it needs fixing

---

**Generated by ggen** - Eat your own dogfood! üêï

When users see that ggen uses itself to create examples, they gain confidence that it works.
