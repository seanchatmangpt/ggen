---
to: lib/api/routes.ts
description: Next.js API route handlers with Zod validation
vars:
  entityName: string
  path: string
  method: string
metadata:
  category: api
  output_type: routes
---
{# =============================================================================
   API ROUTES - Generated from RDF ontology
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview Next.js API route handlers
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { eq } from "drizzle-orm";
import { z } from "zod";
import * as schema from "@/db/schema";
import * as schemas from "@/schemas";

{%- set current_entity = "" -%}
{%- for row in sparql_results -%}
{%- set entityName = row["?entityName"] | default(value="") -%}
{%- set path = row["?path"] | default(value="") -%}
{%- set method = row["?method"] | default(value="GET") -%}
{%- set operationId = row["?operationId"] | default(value="") -%}
{%- set description = row["?description"] | default(value="") -%}

{%- if entityName != current_entity -%}
{%- set_global current_entity = entityName %}

// =============================================================================
// {{ entityName }} API Handlers
// =============================================================================
{%- endif %}

/**
 * {{ method }} {{ path }}
 * {{ description }}
 */
export async function {{ operationId }}(
  request: NextRequest,
  {% if "[id]" in path %}{ params }: { params: { id: string } }{% endif %}
): Promise<NextResponse> {
  try {
{%- if method == "GET" and "[id]" not in path %}
    const records = await db.select().from(schema.{{ entityName | lower }}Table);
    return NextResponse.json(records);
{%- elif method == "GET" and "[id]" in path %}
    const record = await db
      .select()
      .from(schema.{{ entityName | lower }}Table)
      .where(eq(schema.{{ entityName | lower }}Table.id, params.id))
      .limit(1);
    if (record.length === 0) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }
    return NextResponse.json(record[0]);
{%- elif method == "POST" %}
    const body = await request.json();
    const validated = schemas.create{{ entityName }}Schema.parse(body);
    const [created] = await db
      .insert(schema.{{ entityName | lower }}Table)
      .values({ ...validated, id: crypto.randomUUID(), createdAt: new Date().toISOString() })
      .returning();
    return NextResponse.json(created, { status: 201 });
{%- elif method == "PUT" %}
    const body = await request.json();
    const validated = schemas.update{{ entityName }}Schema.parse(body);
    const [updated] = await db
      .update(schema.{{ entityName | lower }}Table)
      .set(validated)
      .where(eq(schema.{{ entityName | lower }}Table.id, params.id))
      .returning();
    if (!updated) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }
    return NextResponse.json(updated);
{%- elif method == "DELETE" %}
    const [deleted] = await db
      .delete(schema.{{ entityName | lower }}Table)
      .where(eq(schema.{{ entityName | lower }}Table.id, params.id))
      .returning();
    if (!deleted) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }
    return NextResponse.json({ success: true });
{%- endif %}
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: "Validation failed", details: error.errors }, { status: 400 });
    }
    console.error("{{ operationId }} error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
{%- endfor %}
