---
to: lib/tests/integration.test.ts
description: Vitest integration tests with mocked network and snapshots
vars:
  entityName: string
  path: string
  method: string
metadata:
  category: testing
  framework: vitest
  features: [mocked-network, snapshots, msw]
---
{# =============================================================================
   INTEGRATION TESTS - Mocked Network + Snapshots
   DO NOT EDIT - auto-generated by ggen sync
   ============================================================================= #}
/**
 * @fileoverview Vitest integration tests with mocked network and snapshots
 * Uses MSW (Mock Service Worker) pattern for network mocking
 * DO NOT EDIT - auto-generated by ggen sync
 */

import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll } from "vitest";
import { http, HttpResponse } from "msw";
import { setupServer } from "msw/node";

// =============================================================================
// Mock Data Fixtures
// =============================================================================

const mockData = {
{%- set seen_entities = "" -%}
{%- for row in sparql_results -%}
{%- set entityName = row["?entityName"] | default(value="") -%}
{%- if entityName != "" and entityName not in seen_entities -%}
{%- set_global seen_entities = seen_entities ~ "," ~ entityName %}
  {{ entityName | lower }}s: [
    {
      id: "{{ entityName | lower }}-1",
      createdAt: "2024-01-01T00:00:00.000Z",
      name: "Test {{ entityName }} 1",
    },
    {
      id: "{{ entityName | lower }}-2",
      createdAt: "2024-01-02T00:00:00.000Z",
      name: "Test {{ entityName }} 2",
    },
  ],
  {{ entityName | lower }}: {
    id: "{{ entityName | lower }}-1",
    createdAt: "2024-01-01T00:00:00.000Z",
    name: "Test {{ entityName }} 1",
  },
{%- endif -%}
{%- endfor %}
};

// =============================================================================
// MSW Server Setup - Mocked Network Handlers
// =============================================================================

const handlers = [
{%- set seen_paths = "" -%}
{%- for row in sparql_results -%}
{%- set entityName = row["?entityName"] | default(value="") -%}
{%- set path = row["?path"] | default(value="") -%}
{%- set method = row["?method"] | default(value="GET") | lower -%}

{%- set pathKey = method ~ path -%}
{%- if pathKey != "" and pathKey not in seen_paths -%}
{%- set_global seen_paths = seen_paths ~ "," ~ pathKey %}
  // {{ method | upper }} {{ path }}
  http.{{ method }}("http://localhost:3000{{ path | replace(from="[id]", to=":id") }}", ({ params }) => {
{%- if method == "get" and "[id]" not in path %}
    return HttpResponse.json(mockData.{{ entityName | lower }}s);
{%- elif method == "get" and "[id]" in path %}
    const { id } = params;
    if (id === "not-found") {
      return HttpResponse.json({ error: "Not found" }, { status: 404 });
    }
    return HttpResponse.json({ ...mockData.{{ entityName | lower }}, id });
{%- elif method == "post" %}
    return HttpResponse.json(
      { ...mockData.{{ entityName | lower }}, id: "new-{{ entityName | lower }}-id" },
      { status: 201 }
    );
{%- elif method == "put" %}
    const { id } = params;
    if (id === "not-found") {
      return HttpResponse.json({ error: "Not found" }, { status: 404 });
    }
    return HttpResponse.json({ ...mockData.{{ entityName | lower }}, id });
{%- elif method == "delete" %}
    const { id } = params;
    if (id === "not-found") {
      return HttpResponse.json({ error: "Not found" }, { status: 404 });
    }
    return HttpResponse.json({ success: true });
{%- endif %}
  }),
{%- endif -%}
{%- endfor %}
];

const server = setupServer(...handlers);

// =============================================================================
// Test Lifecycle
// =============================================================================

beforeAll(() => {
  server.listen({ onUnhandledRequest: "error" });
});

afterEach(() => {
  server.resetHandlers();
});

afterAll(() => {
  server.close();
});

// =============================================================================
// API Client Helper
// =============================================================================

async function apiClient<T>(
  path: string,
  options: RequestInit = {}
): Promise<{ data: T | null; status: number; error?: string }> {
  const response = await fetch(`http://localhost:3000${path}`, {
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
    ...options,
  });

  const data = await response.json();

  if (!response.ok) {
    return { data: null, status: response.status, error: data.error };
  }

  return { data, status: response.status };
}

// =============================================================================
// Integration Tests with Mocked Network
// =============================================================================

{%- set current_entity = "" -%}
{%- for row in sparql_results -%}
{%- set entityName = row["?entityName"] | default(value="") -%}
{%- set path = row["?path"] | default(value="") -%}
{%- set method = row["?method"] | default(value="GET") -%}
{%- set operationId = row["?operationId"] | default(value="") -%}

{%- if entityName != current_entity and entityName != "" -%}
{%- if current_entity != "" %}
  });

  describe("snapshot tests", () => {
    it("should match list response snapshot", async () => {
      const { data } = await apiClient("/api/{{ current_entity | lower }}s");
      expect(data).toMatchSnapshot();
    });

    it("should match single item response snapshot", async () => {
      const { data } = await apiClient("/api/{{ current_entity | lower }}s/{{ current_entity | lower }}-1");
      expect(data).toMatchSnapshot();
    });

    it("should match error response snapshot", async () => {
      const { data, error, status } = await apiClient("/api/{{ current_entity | lower }}s/not-found");
      expect({ error, status }).toMatchSnapshot();
    });
  });
});

{% endif -%}
{%- set_global current_entity = entityName %}
describe("{{ entityName }} API (Mocked Network)", () => {
  describe("successful operations", () => {
{%- endif %}

{%- if method == "GET" and "[id]" not in path %}
    it("{{ operationId }}: should list all {{ entityName | lower }}s", async () => {
      // Act
      const { data, status } = await apiClient<typeof mockData.{{ entityName | lower }}s>("{{ path }}");

      // Assert
      expect(status).toBe(200);
      expect(data).toHaveLength(2);
      expect(data?.[0]).toHaveProperty("id");
    });
{%- elif method == "GET" and "[id]" in path %}

    it("{{ operationId }}: should get {{ entityName | lower }} by id", async () => {
      // Act
      const { data, status } = await apiClient<typeof mockData.{{ entityName | lower }}>("{{ path | replace(from="[id]", to="test-id") }}");

      // Assert
      expect(status).toBe(200);
      expect(data).toHaveProperty("id", "test-id");
    });
{%- elif method == "POST" %}

    it("{{ operationId }}: should create new {{ entityName | lower }}", async () => {
      // Arrange
      const newItem = { name: "New {{ entityName }}" };

      // Act
      const { data, status } = await apiClient<typeof mockData.{{ entityName | lower }}>("{{ path }}", {
        method: "POST",
        body: JSON.stringify(newItem),
      });

      // Assert
      expect(status).toBe(201);
      expect(data).toHaveProperty("id", "new-{{ entityName | lower }}-id");
    });
{%- elif method == "PUT" %}

    it("{{ operationId }}: should update {{ entityName | lower }}", async () => {
      // Arrange
      const updates = { name: "Updated {{ entityName }}" };

      // Act
      const { data, status } = await apiClient<typeof mockData.{{ entityName | lower }}>("{{ path | replace(from="[id]", to="test-id") }}", {
        method: "PUT",
        body: JSON.stringify(updates),
      });

      // Assert
      expect(status).toBe(200);
      expect(data).toHaveProperty("id", "test-id");
    });
{%- elif method == "DELETE" %}

    it("{{ operationId }}: should delete {{ entityName | lower }}", async () => {
      // Act
      const { data, status } = await apiClient("{{ path | replace(from="[id]", to="test-id") }}", {
        method: "DELETE",
      });

      // Assert
      expect(status).toBe(200);
      expect(data).toHaveProperty("success", true);
    });
{%- endif -%}
{%- endfor %}
  });

  describe("error handling", () => {
    it("should return 404 for non-existent {{ current_entity | lower }}", async () => {
      const { status, error } = await apiClient("/api/{{ current_entity | lower }}s/not-found");
      expect(status).toBe(404);
      expect(error).toBe("Not found");
    });

    it("should handle network errors gracefully", async () => {
      // Override handler to simulate network error
      server.use(
        http.get("http://localhost:3000/api/{{ current_entity | lower }}s", () => {
          return HttpResponse.error();
        })
      );

      await expect(apiClient("/api/{{ current_entity | lower }}s")).rejects.toThrow();
    });

    it("should handle server errors", async () => {
      // Override handler to return 500
      server.use(
        http.get("http://localhost:3000/api/{{ current_entity | lower }}s", () => {
          return HttpResponse.json({ error: "Internal server error" }, { status: 500 });
        })
      );

      const { status, error } = await apiClient("/api/{{ current_entity | lower }}s");
      expect(status).toBe(500);
      expect(error).toBe("Internal server error");
    });
  });

  describe("snapshot tests", () => {
    it("should match list response snapshot", async () => {
      const { data } = await apiClient("/api/{{ current_entity | lower }}s");
      expect(data).toMatchSnapshot();
    });

    it("should match single item response snapshot", async () => {
      const { data } = await apiClient("/api/{{ current_entity | lower }}s/{{ current_entity | lower }}-1");
      expect(data).toMatchSnapshot();
    });

    it("should match error response snapshot", async () => {
      const { data, error, status } = await apiClient("/api/{{ current_entity | lower }}s/not-found");
      expect({ error, status }).toMatchSnapshot();
    });
  });
});
