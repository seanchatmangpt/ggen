---
to: output/job-map-data.mjs
description: Job map visualization data
metadata:
  category: jtbd
  output_type: visualization
---
/**
 * @fileoverview JTBD Job Map Visualization Data
 * Data structure for rendering job maps and opportunity charts
 * DO NOT EDIT - auto-generated by ggen sync
 * @module jtbd/job-map-data
 */

/**
 * @typedef {Object} JobMapPoint
 * @property {string} avatar
 * @property {number} stepOrder
 * @property {string} stepType
 * @property {number} importance
 * @property {number} satisfaction
 * @property {number} opportunityScore
 * @property {number} gap - Importance minus Satisfaction
 */

/**
 * Job map data points for all avatars
 * @type {JobMapPoint[]}
 */
export const jobMapData = [
{%- for row in sparql_results %}
  {
    avatar: "{{ row["?avatarName"] }}",
    stepOrder: {{ row["?stepOrder"] }},
    stepType: "{{ row["?stepType"] }}",
    importance: {{ row["?importance"] }},
    satisfaction: {{ row["?satisfaction"] }},
    opportunityScore: {{ row["?opportunityScore"] }},
    gap: {{ row["?importance"] }} - {{ row["?satisfaction"] }},
  },
{%- endfor %}
];

/**
 * Universal job step order
 */
export const jobSteps = [
  { order: 1, name: "1. Define", description: "Determine goals and plan approach" },
  { order: 2, name: "2. Locate", description: "Gather items and information needed" },
  { order: 3, name: "3. Prepare", description: "Set up the environment and inputs" },
  { order: 4, name: "4. Confirm", description: "Verify readiness before execution" },
  { order: 5, name: "5. Execute", description: "Perform the core job" },
  { order: 6, name: "6. Monitor", description: "Track progress and results" },
  { order: 7, name: "7. Modify", description: "Make adjustments as needed" },
  { order: 8, name: "8. Conclude", description: "Finish and clean up" },
];

/**
 * Get job map for specific avatar
 * @param {string} avatarName
 * @returns {JobMapPoint[]}
 */
export function getAvatarJobMap(avatarName) {
  return jobMapData
    .filter(p => p.avatar === avatarName)
    .sort((a, b) => a.stepOrder - b.stepOrder);
}

/**
 * Get aggregated data by step (average across all avatars)
 * @returns {Array<{stepType: string, avgImportance: number, avgSatisfaction: number, avgGap: number}>}
 */
export function getAggregatedByStep() {
  const byStep = {};

  for (const point of jobMapData) {
    if (!byStep[point.stepType]) {
      byStep[point.stepType] = {
        stepType: point.stepType,
        stepOrder: point.stepOrder,
        importance: [],
        satisfaction: [],
        gap: []
      };
    }
    byStep[point.stepType].importance.push(point.importance);
    byStep[point.stepType].satisfaction.push(point.satisfaction);
    byStep[point.stepType].gap.push(point.gap);
  }

  return Object.values(byStep)
    .map(s => ({
      stepType: s.stepType,
      stepOrder: s.stepOrder,
      avgImportance: s.importance.reduce((a, b) => a + b, 0) / s.importance.length,
      avgSatisfaction: s.satisfaction.reduce((a, b) => a + b, 0) / s.satisfaction.length,
      avgGap: s.gap.reduce((a, b) => a + b, 0) / s.gap.length,
    }))
    .sort((a, b) => a.stepOrder - b.stepOrder);
}

/**
 * Get data formatted for Chart.js radar chart
 * @param {string} avatarName
 * @returns {{labels: string[], importance: number[], satisfaction: number[]}}
 */
export function getRadarChartData(avatarName) {
  const points = getAvatarJobMap(avatarName);
  return {
    labels: points.map(p => p.stepType),
    importance: points.map(p => p.importance),
    satisfaction: points.map(p => p.satisfaction),
  };
}

/**
 * Get data formatted for opportunity scatter plot
 * @returns {Array<{x: number, y: number, label: string, avatar: string}>}
 */
export function getScatterPlotData() {
  return jobMapData.map(p => ({
    x: p.satisfaction,
    y: p.importance,
    label: `${p.avatar} - ${p.stepType}`,
    avatar: p.avatar,
    opportunityScore: p.opportunityScore,
  }));
}
