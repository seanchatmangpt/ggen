# Documentation Generation Example for Erlang Jobs Library

**This document demonstrates how ggen sync generates Diataxis documentation from RDF ontology.**

---

## Overview

The Erlang Jobs Library uses **RDF-driven documentation generation** to maintain comprehensive, consistent documentation across all 4 Diataxis quadrants:
- **Tutorials** (learning-oriented)
- **How-To Guides** (task-oriented)
- **Reference** (information-oriented)
- **Explanation** (understanding-oriented)

**Core principle:** Documentation is code. Documentation is generated from the same RDF ontology that generates Erlang code.

---

## Documentation Generation Workflow

### Step 1: Define Documentation in RDF

The documentation structure is defined in `.specify/docs/erlang-jobs-docs.ttl`:

```turtle
@prefix docs: <http://ggen.dev/ontology/docs#> .
@prefix diataxis: <http://diataxis.fr/ontology#> .

docs:ErlangJobsDocumentation a docs:DocumentationSet ;
    docs:version "1.0.0" ;
    docs:framework diataxis:Framework ;
    docs:outputDirectory "docs/erlang_jobs" ;
    docs:hasTutorials docs:Tutorials ;
    docs:hasHowToGuides docs:HowToGuides ;
    docs:hasReference docs:Reference ;
    docs:hasExplanation docs:Explanation .

docs:Tutorial01 a diataxis:Tutorial ;
    rdfs:label "Getting Started with ggen for Erlang" ;
    docs:filename "01-getting-started.md" ;
    docs:learningObjective "Install ggen, initialize project, generate first Erlang job queue" ;
    docs:outcome "Working job queue in 15 minutes" ;
    docs:timeEstimate 15 ;
    docs:steps (
        "Install ggen from repository"
        "Initialize Erlang project with ggen init"
        "Explore RDF specification in .specify/"
        "Generate Erlang code with ggen sync"
        "Examine generated modules"
        "Run tests with rebar3 ct"
        "Start application and test manually"
    ) .
```

**This RDF encodes:**
- Tutorial title, filename, learning objective, outcome
- Time estimate (15 minutes)
- Step-by-step instructions (7 steps)

---

### Step 2: Create Tera Template for Tutorials

The tutorial template `templates/docs/tutorial.md.tera` renders markdown from RDF:

```markdown
# {{ tutorial.label }}

**Learning Objective:** {{ tutorial.learningObjective }}

**Prerequisites:** {{ tutorial.prerequisites }}

**Outcome:** {{ tutorial.outcome }}

**Time:** ~{{ tutorial.timeEstimate }} minutes

---

## What You'll Build

By the end of this tutorial, you'll have:
{% for step in tutorial.steps %}
- ✅ {{ step }}
{% endfor %}

---

{% for step in tutorial.steps %}
## Step {{ loop.index }}: {{ step }}

{{ tutorial.stepContent[loop.index0] }}

**Checkpoint:** {{ tutorial.checkpoints[loop.index0] }}

---
{% endfor %}

## Congratulations!

You've completed this tutorial and now have {{ tutorial.outcome }}.

---

**Generated by ggen v6.0.0 | {{ generation_date }}**
```

**Key features:**
- Variables populated from RDF (e.g., `{{ tutorial.label }}`)
- Loops over RDF lists (e.g., `{% for step in tutorial.steps %}`)
- Conditional rendering
- Automatic step numbering

---

### Step 3: Run ggen sync to Generate Documentation

Execute the five-stage pipeline:

```bash
cd /home/user/ggen/examples/erlang_jobs
ggen sync --audit true

# Expected output:
# [μ₁] Normalizing RDF ontology... ✓ (52ms)
#      - Loaded 87 triples from .specify/docs/erlang-jobs-docs.ttl
#      - SHACL validation passed (2 shapes)
#
# [μ₂] Extracting entities via SPARQL... ✓ (35ms)
#      - Extracted 4 tutorials
#      - Extracted 5 how-to guides
#      - Extracted 5 reference docs
#      - Extracted 5 explanation articles
#
# [μ₃] Rendering templates (Tera)... ✓ (98ms)
#      - Rendered docs/erlang_jobs/INDEX.md
#      - Rendered docs/erlang_jobs/tutorials/01-getting-started.md
#      - Rendered docs/erlang_jobs/tutorials/02-first-job-queue.md
#      - Rendered docs/erlang_jobs/tutorials/03-supervised-worker-pool.md
#      - Rendered docs/erlang_jobs/tutorials/04-rdf-to-running-app.md
#      - Rendered docs/erlang_jobs/howto/01-custom-job-backend.md
#      - Rendered docs/erlang_jobs/howto/02-rate-limiting.md
#      - Rendered docs/erlang_jobs/howto/03-benchmarks.md
#      - Rendered docs/erlang_jobs/howto/04-stress-testing.md
#      - Rendered docs/erlang_jobs/howto/05-customize-templates.md
#      - Rendered docs/erlang_jobs/reference/01-api-reference.md
#      - Rendered docs/erlang_jobs/reference/02-rdf-ontology.md
#      - Rendered docs/erlang_jobs/reference/03-template-variables.md
#      - Rendered docs/erlang_jobs/reference/04-configuration.md
#      - Rendered docs/erlang_jobs/reference/05-cli-reference.md
#      - Rendered docs/erlang_jobs/explanation/01-why-rdf.md
#      - Rendered docs/erlang_jobs/explanation/02-otp-patterns.md
#      - Rendered docs/erlang_jobs/explanation/03-supervision-tree.md
#      - Rendered docs/erlang_jobs/explanation/04-performance.md
#      - Rendered docs/erlang_jobs/explanation/05-deterministic-generation.md
#
# [μ₄] Canonicalizing outputs... ✓ (18ms)
#      - Formatted 20 markdown files
#      - Content hashing complete (SHA-256)
#
# [μ₅] Generating receipt... ✓ (9ms)
#      - Execution ID: exec-doc-1738155678-abc123
#      - Documentation hash: sha256:7f8e9d0c...
#      - Receipt: .ggen/receipts/exec-doc-1738155678-abc123.json
#
# Documentation generation complete in 212ms.
```

**What happened:**
- **μ₁ (Normalize):** Loaded and validated documentation RDF
- **μ₂ (Extract):** Extracted 19 documentation entities via SPARQL
- **μ₃ (Emit):** Rendered 20 markdown files from Tera templates
- **μ₄ (Canonicalize):** Formatted and hashed all markdown files
- **μ₅ (Receipt):** Generated cryptographic proof of documentation generation

---

### Step 4: Examine Generated Documentation

The generated documentation structure:

```
docs/erlang_jobs/
├── INDEX.md                          # Main navigation (generated)
├── tutorials/
│   ├── 01-getting-started.md         # Generated from Tutorial01 RDF
│   ├── 02-first-job-queue.md         # Generated from Tutorial02 RDF
│   ├── 03-supervised-worker-pool.md  # Generated from Tutorial03 RDF
│   └── 04-rdf-to-running-app.md      # Generated from Tutorial04 RDF
├── howto/
│   ├── 01-custom-job-backend.md
│   ├── 02-rate-limiting.md
│   ├── 03-benchmarks.md
│   ├── 04-stress-testing.md
│   └── 05-customize-templates.md
├── reference/
│   ├── 01-api-reference.md
│   ├── 02-rdf-ontology.md
│   ├── 03-template-variables.md
│   ├── 04-configuration.md
│   └── 05-cli-reference.md
└── explanation/
    ├── 01-why-rdf.md
    ├── 02-otp-patterns.md
    ├── 03-supervision-tree.md
    ├── 04-performance.md
    └── 05-deterministic-generation.md
```

**All files generated from RDF. None written by hand.**

---

## Benefits of RDF-Driven Documentation

### 1. Single Source of Truth

**Code and docs generated from same ontology:**

```turtle
# In .specify/specs/001-job-queue/feature.ttl:
jobs:JobQueue a rdfs:Class ;
    rdfs:label "Job Queue" ;
    rdfs:comment "A priority-based job queue with pull semantics" .
```

This RDF triple drives:
- **Code generation:** `job_queue.erl` module with `@doc` comment
- **API reference:** Reference docs with module description
- **Tutorials:** Tutorial text explaining job queue concept
- **Explanation:** Explanation article on pull-based architecture

**Result:** Change ontology → all artifacts update automatically. No drift.

---

### 2. Deterministic Documentation

**Same RDF → same docs, always:**

```bash
# First generation
$ ggen sync --audit true
Documentation hash: sha256:7f8e9d0c1b2a3f4e...

# Second generation (no changes)
$ ggen sync --audit true
Documentation hash: sha256:7f8e9d0c1b2a3f4e...  # Identical!
```

**Benefit:** Version control RDF, not markdown. Markdown is ephemeral (regenerated on demand).

---

### 3. SHACL-Validated Documentation

**Documentation structure validated before generation:**

```turtle
docs:TutorialShape a sh:NodeShape ;
    sh:targetClass diataxis:Tutorial ;
    sh:property [
        sh:path docs:learningObjective ;
        sh:datatype xsd:string ;
        sh:minCount 1  # REQUIRED: Every tutorial must have learning objective
    ] ;
    sh:property [
        sh:path docs:timeEstimate ;
        sh:datatype xsd:integer ;
        sh:minInclusive 1 ;
        sh:maxInclusive 120  # Time estimate must be 1-120 minutes
    ] .
```

**If RDF violates SHACL:**
- Generation fails at μ₁ (Normalize)
- Error message shows missing fields
- Fix RDF, regenerate

**Benefit:** No incomplete documentation. SHACL enforces quality.

---

### 4. Multi-Target Documentation

**One RDF ontology → multiple outputs:**

```
.specify/docs/erlang-jobs-docs.ttl
    ↓
ggen sync (with different templates)
    ↓
├── docs/erlang_jobs/*.md       # Markdown for GitHub/GitBook
├── docs/html/*.html            # HTML for website
├── docs/pdf/manual.pdf         # PDF for offline reading
└── docs/json/docs.json         # JSON for search indexing
```

**All generated from same RDF. Always in sync.**

---

### 5. Queryable Documentation

**Use SPARQL to query documentation:**

```sparql
# Find all tutorials that take less than 30 minutes
SELECT ?tutorial ?label ?timeEstimate WHERE {
    ?tutorial a diataxis:Tutorial ;
              rdfs:label ?label ;
              docs:timeEstimate ?timeEstimate .
    FILTER (?timeEstimate < 30)
}

# Results:
# - Tutorial 1: Getting Started (15 minutes)
# - Tutorial 2: Building Your First Job Queue (30 minutes)
```

**Benefit:** Generate custom documentation subsets (e.g., "quick start guide" with only <30min tutorials).

---

## Updating Documentation

### Example: Add a New Tutorial

**Step 1:** Add RDF triple to `.specify/docs/erlang-jobs-docs.ttl`:

```turtle
docs:Tutorial05 a diataxis:Tutorial ;
    rdfs:label "Deploying to Kubernetes" ;
    docs:filename "05-kubernetes-deployment.md" ;
    docs:learningObjective "Deploy Erlang job queue to Kubernetes with Helm" ;
    docs:outcome "Running job queue in production Kubernetes cluster" ;
    docs:timeEstimate 45 ;
    docs:prerequisites "Completed Tutorial 4, kubectl installed" ;
    docs:steps (
        "Create Helm chart for job queue"
        "Configure resource limits and replicas"
        "Deploy to Kubernetes with helm install"
        "Verify deployment with kubectl"
        "Test with production traffic"
    ) .
```

**Step 2:** Run `ggen sync`:

```bash
ggen sync --audit true

# Output:
# [μ₃] Rendering templates (Tera)... ✓
#      - Generated docs/erlang_jobs/tutorials/05-kubernetes-deployment.md (new)
#      - Updated docs/erlang_jobs/INDEX.md (added Tutorial 5 to TOC)
```

**Step 3:** Done! Tutorial 5 is now in the documentation.

---

## Integration with Code Generation

**Documentation and code share the same ontology:**

```turtle
# .specify/specs/001-job-queue/feature.ttl
jobs:JobQueue a rdfs:Class ;
    jobs:hasProperty jobs:priority ;
    jobs:hasProperty jobs:maxRetries .
```

**This drives both:**

1. **Code generation:**
   ```erlang
   %% src/job_queue.erl
   -record(state, {
       priority :: atom(),
       max_retries :: integer()
   }).
   ```

2. **API reference:**
   ```markdown
   ## job_queue Module

   ### Configuration

   - `priority` (atom) - Job priority level
   - `max_retries` (integer) - Maximum retry attempts
   ```

**Same RDF → code and docs always match.**

---

## Best Practices

### 1. Edit RDF, Never Edit Generated Markdown

**❌ Wrong:**
```bash
$ vim docs/erlang_jobs/tutorials/01-getting-started.md  # Editing generated file
```

**✅ Correct:**
```bash
$ vim .specify/docs/erlang-jobs-docs.ttl  # Editing RDF source
$ ggen sync --audit true                   # Regenerate
```

---

### 2. Validate with SHACL Before Committing

```bash
# Pre-commit hook
ggen validate .specify/docs/erlang-jobs-docs.ttl

# If SHACL validation fails, commit is rejected
```

---

### 3. Version Control RDF, Not Markdown

**.gitignore:**
```
# Generated documentation (regenerated by CI)
docs/erlang_jobs/**/*.md
```

**CI pipeline:**
```yaml
# .github/workflows/docs.yml
- name: Generate documentation
  run: ggen sync --audit true
- name: Publish to GitHub Pages
  uses: peaceiris/actions-gh-pages@v3
  with:
    publish_dir: ./docs/erlang_jobs
```

---

## Summary

**RDF-driven documentation provides:**
- **Single source of truth:** Code and docs from same ontology
- **Deterministic generation:** Same RDF → same docs (proven with hashes)
- **SHACL validation:** Enforce documentation quality
- **Multi-target output:** Markdown, HTML, PDF from one RDF
- **Queryable:** Use SPARQL to generate custom subsets
- **No drift:** Regenerate on every commit via CI

**Documentation is code. Documentation is generated, not written.**

---

**Next Steps:**

1. Read [Why Use RDF for Code Generation](../docs/erlang_jobs/explanation/01-why-rdf.md)
2. Explore [Template Variable Reference](../docs/erlang_jobs/reference/03-template-variables.md)
3. Try [How to Customize Generated Templates](../docs/erlang_jobs/howto/05-customize-templates.md)

---

**Generated by ggen v6.0.0 | 2026-01-29**
