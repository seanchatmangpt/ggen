---
to: "{{ name | snake_case }}_mcp_tools.rs"
vars:
  name: "AiTools"
  description: "AI-powered MCP tools for {{ name }}"
  provider_type: "ollama"  # openai, anthropic, ollama
  enable_streaming: true
  enable_tools: true
  enable_prompts: true
rdf:
  - "{{ name | snake_case }}_mcp_tools.ttl"
---

// AI-Powered MCP Tools: {{ description }}
// Generated by ggen-ai for {{ provider_type }} provider

use anyhow::Result;
use async_trait::async_trait;
use ggen_ai::mcp::tools::AiMcpTools;
use ggen_ai::providers::{OpenAIClient, AnthropicClient, OllamaClient};
use ggen_core::Graph;
use serde_json::Value;

/// {{ name }} MCP Tools implementation
#[derive(Debug)]
pub struct {{ name }}McpTools {
    tools: AiMcpTools,
    config: {{ name }}Config,
}

/// Configuration for {{ name }} MCP tools
#[derive(Debug, Clone)]
pub struct {{ name }}Config {
    pub provider_api_key: String,
    pub provider_type: String,
    pub model: String,
    pub max_tokens: Option<u32>,
    pub temperature: Option<f32>,
    pub enable_streaming: bool,
    pub enable_tools: bool,
    pub enable_prompts: bool,
}

impl {{ name }}McpTools {
    /// Create new {{ name }} MCP tools with configuration
    pub fn new(config: {{ name }}Config) -> Result<Self> {
        let mut tools = AiMcpTools::new();

        // Initialize with the specified provider
        match config.provider_type.as_str() {
            "openai" => {
                tools = tools.with_openai(config.provider_api_key.clone());
            }
            "anthropic" => {
                tools = tools.with_anthropic(config.provider_api_key.clone());
            }
            "ollama" => {
                tools = tools.with_ollama();
            }
            _ => {
                return Err(anyhow::anyhow!("Unsupported provider type: {}", config.provider_type));
            }
        }

        Ok(Self { tools, config })
    }

    /// Generate a template using AI
    pub async fn generate_template(
        &self,
        description: &str,
        examples: Vec<&str>,
    ) -> Result<ggen_core::Template> {
        if let Some(generator) = &self.tools.template_generator {
            generator.generate_template(description, examples).await
        } else {
            Err(anyhow::anyhow!("Template generator not initialized"))
        }
    }

    /// Generate SPARQL queries using AI
    pub async fn generate_sparql(
        &self,
        description: &str,
        graph: &Graph,
    ) -> Result<String> {
        if let Some(generator) = &self.tools.sparql_generator {
            generator.generate_sparql(description, graph).await
        } else {
            Err(anyhow::anyhow!("SPARQL generator not initialized"))
        }
    }

    /// Generate ontologies using AI
    pub async fn generate_ontology(
        &self,
        description: &str,
        base_iri: &str,
    ) -> Result<String> {
        if let Some(generator) = &self.tools.ontology_generator {
            generator.generate_ontology(description, base_iri).await
        } else {
            Err(anyhow::anyhow!("Ontology generator not initialized"))
        }
    }

    /// Refactor code using AI
    pub async fn refactor_code(
        &self,
        code: &str,
        refactoring_type: &str,
    ) -> Result<String> {
        if let Some(assistant) = &self.tools.refactor_assistant {
            assistant.refactor_code(code, refactoring_type).await
        } else {
            Err(anyhow::anyhow!("Refactor assistant not initialized"))
        }
    }

    /// Get available tools
    pub fn get_available_tools(&self) -> Vec<&str> {
        let mut tools = Vec::new();

        if self.tools.template_generator.is_some() {
            tools.push("template_generation");
        }
        if self.tools.sparql_generator.is_some() {
            tools.push("sparql_generation");
        }
        if self.tools.ontology_generator.is_some() {
            tools.push("ontology_generation");
        }
        if self.tools.refactor_assistant.is_some() {
            tools.push("code_refactoring");
        }

        tools
    }

    /// Check if a specific tool is available
    pub fn has_tool(&self, tool_name: &str) -> bool {
        match tool_name {
            "template_generation" => self.tools.template_generator.is_some(),
            "sparql_generation" => self.tools.sparql_generator.is_some(),
            "ontology_generation" => self.tools.ontology_generator.is_some(),
            "code_refactoring" => self.tools.refactor_assistant.is_some(),
            _ => false,
        }
    }
}

impl Default for {{ name }}Config {
    fn default() -> Self {
        Self {
            provider_api_key: std::env::var("AI_PROVIDER_API_KEY")
                .unwrap_or_else(|_| "your-api-key-here".to_string()),
            provider_type: "{{ provider_type }}".to_string(),
            model: "qwen3-coder:30b".to_string(),
            max_tokens: Some(2000),
            temperature: Some(0.7),
            enable_streaming: {{ enable_streaming | lower }},
            enable_tools: {{ enable_tools | lower }},
            enable_prompts: {{ enable_prompts | lower }},
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_default() {
        let config = {{ name }}Config::default();
        assert_eq!(config.provider_type, "{{ provider_type }}");
        assert!(config.enable_streaming);
        assert!(config.enable_tools);
        assert!(config.enable_prompts);
    }

    #[test]
    fn test_tools_creation() {
        let config = {{ name }}Config {
            provider_api_key: "test-key".to_string(),
            provider_type: "openai".to_string(),
            model: "gpt-4".to_string(),
            max_tokens: Some(1000),
            temperature: Some(0.5),
            enable_streaming: true,
            enable_tools: true,
            enable_prompts: true,
        };

        let tools = {{ name }}McpTools::new(config);
        assert!(tools.is_ok());
    }

    #[test]
    fn test_available_tools() {
        let config = {{ name }}Config::default();
        let tools = {{ name }}McpTools::new(config).unwrap();

        let available_tools = tools.get_available_tools();
        assert!(!available_tools.is_empty());
        assert!(tools.has_tool("template_generation"));
    }
}
