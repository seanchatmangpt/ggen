%%%-----------------------------------------------------------------------------
%%% @doc MCP+ NIF Bridge Module
%%%
%%% Erlang NIF bindings to the Rust cryptographic library.
%%% All cryptographic operations are delegated to Rust for:
%%% - Memory safety (Rust ownership model)
%%% - Performance (zero-cost abstractions)
%%% - Deterministic behavior (no GC interference)
%%%
%%% NIF functions run on dirty schedulers to prevent blocking.
%%%
%%% Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
%%%
%%% Generated by ggen - DO NOT EDIT MANUALLY
%%% Regenerate with: ggen sync --audit true
%%% @end
%%%-----------------------------------------------------------------------------
-module(mcp_nif).

%% API - Lifecycle
-export([load/0]).

%% API - Cryptographic Operations
-export([
    hash_sha256/1,
    hash_sha3_256/1,
    verify_signature/3,
    sign_data/2
]).

%% API - Receipt Operations
-export([
    create_receipt/4,
    verify_receipt/1,
    verify_receipt_chain/1,
    chain_receipts/1
]).

%% API - Envelope Operations
-export([
    check_envelope_bounds/2,
    create_envelope_nif/1,
    validate_envelope/1
]).

%% API - Bundle Operations
-export([
    generate_bundle/3,
    verify_bundle/1,
    serialize_bundle/1,
    deserialize_bundle/1
]).

%% API - Key Management
-export([
    generate_keypair/0,
    rotate_epoch/1,
    revoke_epoch/1,
    verify_epoch/1
]).

-on_load(init/0).

-define(NIF_LIB, "mcp_nif").
-define(NIF_NOT_LOADED, erlang:nif_error(nif_not_loaded)).

%%%=============================================================================
%%% NIF Loading
%%%=============================================================================

%% @doc Initialize the NIF library (called on module load)
-spec init() -> ok | {error, term()}.
init() ->
    PrivDir = case code:priv_dir(mcp) of
        {error, bad_name} ->
            %% Application not started, try relative path
            case filelib:is_dir("priv") of
                true -> "priv";
                false -> "../priv"
            end;
        Dir -> Dir
    end,

    NifPath = filename:join(PrivDir, ?NIF_LIB),

    case erlang:load_nif(NifPath, 0) of
        ok ->
            logger:info("MCP NIF library loaded from ~s", [NifPath]),
            ok;
        {error, {reload, _}} ->
            %% Already loaded
            ok;
        {error, Reason} ->
            logger:error("Failed to load MCP NIF library: ~p", [Reason]),
            {error, Reason}
    end.

%% @doc Manually load/reload the NIF library
-spec load() -> ok | {error, term()}.
load() ->
    init().

%%%=============================================================================
%%% Cryptographic Operations (NIF stubs)
%%%=============================================================================

%% @doc Compute SHA-256 hash of data
%% Runs on dirty CPU scheduler
-spec hash_sha256(binary()) -> binary().
hash_sha256(_Data) ->
    ?NIF_NOT_LOADED.

%% @doc Compute SHA3-256 hash of data
%% Runs on dirty CPU scheduler
-spec hash_sha3_256(binary()) -> binary().
hash_sha3_256(_Data) ->
    ?NIF_NOT_LOADED.

%% @doc Verify Ed25519 signature
%% @param Data The signed data
%% @param Signature The signature bytes
%% @param PubKeyHash SHA-256 hash of the public key
%% Runs on dirty CPU scheduler
-spec verify_signature(Data, Signature, PubKeyHash) -> ok | {error, Code} when
    Data :: binary(),
    Signature :: binary(),
    PubKeyHash :: binary(),
    Code :: binary().
verify_signature(_Data, _Signature, _PubKeyHash) ->
    ?NIF_NOT_LOADED.

%% @doc Sign data with private key
%% @param Data The data to sign
%% @param PrivKey The private key bytes
%% Runs on dirty CPU scheduler
-spec sign_data(binary(), binary()) -> {ok, binary()} | {error, binary()}.
sign_data(_Data, _PrivKey) ->
    ?NIF_NOT_LOADED.

%%%=============================================================================
%%% Receipt Operations (NIF stubs)
%%%=============================================================================

%% @doc Create a new receipt
%% @param ExecutionId Unique execution identifier
%% @param ManifestHash Hash of the manifest at execution time
%% @param OutcomeHash Hash of the operation outcome
%% @param PrevHash Hash of the previous receipt (for chaining)
-spec create_receipt(ExecutionId, ManifestHash, OutcomeHash, PrevHash) -> Receipt when
    ExecutionId :: binary(),
    ManifestHash :: binary(),
    OutcomeHash :: binary(),
    PrevHash :: binary(),
    Receipt :: map().
create_receipt(_ExecutionId, _ManifestHash, _OutcomeHash, _PrevHash) ->
    ?NIF_NOT_LOADED.

%% @doc Verify a single receipt's integrity
-spec verify_receipt(map()) -> ok | {error, binary()}.
verify_receipt(_Receipt) ->
    ?NIF_NOT_LOADED.

%% @doc Verify the integrity of a receipt chain
%% Checks that each receipt's previous_hash matches the prior receipt's hash
-spec verify_receipt_chain([map()]) -> ok | {error, binary()}.
verify_receipt_chain(_Receipts) ->
    ?NIF_NOT_LOADED.

%% @doc Chain a list of receipts into a Merkle structure
-spec chain_receipts([map()]) -> {ok, binary()} | {error, binary()}.
chain_receipts(_Receipts) ->
    ?NIF_NOT_LOADED.

%%%=============================================================================
%%% Envelope Operations (NIF stubs)
%%%=============================================================================

%% @doc Check if operation is within envelope bounds
%% @param Envelope The envelope specification
%% @param Usage Current resource usage
%% @returns ok or deterministic refusal
-spec check_envelope_bounds(Envelope, Usage) -> ok | {refusal, Code, Message} when
    Envelope :: map(),
    Usage :: map(),
    Code :: binary(),
    Message :: binary().
check_envelope_bounds(_Envelope, _Usage) ->
    ?NIF_NOT_LOADED.

%% @doc Create a new envelope (NIF-side validation and initialization)
-spec create_envelope_nif(map()) -> {ok, map()} | {error, binary()}.
create_envelope_nif(_Bounds) ->
    ?NIF_NOT_LOADED.

%% @doc Validate envelope specification
-spec validate_envelope(map()) -> ok | {error, binary()}.
validate_envelope(_Envelope) ->
    ?NIF_NOT_LOADED.

%%%=============================================================================
%%% Bundle Operations (NIF stubs)
%%%=============================================================================

%% @doc Generate an evidence bundle (.mcpb)
%% @param Receipts List of receipts to include
%% @param Refusals List of refusals to include
%% @param Metrics Metrics map to include
-spec generate_bundle(Receipts, Refusals, Metrics) -> {ok, Bundle} | {error, Reason} when
    Receipts :: [map()],
    Refusals :: [map()],
    Metrics :: map(),
    Bundle :: binary(),
    Reason :: binary().
generate_bundle(_Receipts, _Refusals, _Metrics) ->
    ?NIF_NOT_LOADED.

%% @doc Verify an evidence bundle
%% Text-blind verification - does not access payload content
-spec verify_bundle(binary()) -> pass | fail.
verify_bundle(_Bundle) ->
    ?NIF_NOT_LOADED.

%% @doc Serialize bundle to binary
-spec serialize_bundle(map()) -> {ok, binary()} | {error, binary()}.
serialize_bundle(_Bundle) ->
    ?NIF_NOT_LOADED.

%% @doc Deserialize bundle from binary
-spec deserialize_bundle(binary()) -> {ok, map()} | {error, binary()}.
deserialize_bundle(_BundleBytes) ->
    ?NIF_NOT_LOADED.

%%%=============================================================================
%%% Key Management (NIF stubs)
%%%=============================================================================

%% @doc Generate a new Ed25519 keypair
-spec generate_keypair() -> {ok, #{public_key := binary(),
                                   private_key := binary(),
                                   public_key_hash := binary()}}
                          | {error, binary()}.
generate_keypair() ->
    ?NIF_NOT_LOADED.

%% @doc Rotate to a new key epoch
-spec rotate_epoch(map()) -> {ok, map()} | {error, binary()}.
rotate_epoch(_EpochConfig) ->
    ?NIF_NOT_LOADED.

%% @doc Revoke a key epoch
-spec revoke_epoch(binary()) -> ok | {error, binary()}.
revoke_epoch(_EpochId) ->
    ?NIF_NOT_LOADED.

%% @doc Verify key epoch is valid (not expired, not revoked)
-spec verify_epoch(binary()) -> ok | {error, binary()}.
verify_epoch(_EpochId) ->
    ?NIF_NOT_LOADED.
