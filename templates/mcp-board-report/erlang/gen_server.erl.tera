%%%-----------------------------------------------------------------------------
%%% @doc {{ module }} - MCP+ Gen Server
%%%
%%% {{ description | default(value="MCP+ component implementing gen_server behavior") }}
%%%
%%% Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
%%%
%%% Generated by ggen - DO NOT EDIT MANUALLY
%%% Regenerate with: ggen sync --audit true
%%% @end
%%%-----------------------------------------------------------------------------
-module({{ module }}).

-behaviour(gen_server).

%% API
-export([
    start_link/0,
    start_link/1
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

-define(SERVER, ?MODULE).

%% State record
-record(state, {
    initialized :: boolean(),
    kill_switch_active :: boolean(),
    metrics :: map()
}).

-type state() :: #state{}.

%%%=============================================================================
%%% API Functions
%%%=============================================================================

%% @doc Start the server with default options
-spec start_link() -> {ok, Pid} | ignore | {error, Reason} when
    Pid :: pid(),
    Reason :: term().
start_link() ->
    start_link([]).

%% @doc Start the server with options
-spec start_link(Opts) -> {ok, Pid} | ignore | {error, Reason} when
    Opts :: proplists:proplist(),
    Pid :: pid(),
    Reason :: term().
start_link(Opts) ->
    gen_server:start_link({local, ?SERVER}, ?MODULE, Opts, []).

%%%=============================================================================
%%% gen_server Callbacks
%%%=============================================================================

%% @doc Initialize the server
-spec init(Args) -> {ok, State} | {stop, Reason} when
    Args :: proplists:proplist(),
    State :: state(),
    Reason :: term().
init(_Args) ->
    process_flag(trap_exit, true),

    logger:info("~p initializing", [?MODULE]),

    State = #state{
        initialized = true,
        kill_switch_active = false,
        metrics = #{
            started_at => erlang:system_time(millisecond),
            operations => 0,
            refusals => 0
        }
    },

    {ok, State}.

%% @doc Handle synchronous calls
-spec handle_call(Request, From, State) -> {reply, Reply, State} when
    Request :: term(),
    From :: {pid(), term()},
    State :: state(),
    Reply :: term().
handle_call({check_kill_switch}, _From, State) ->
    %% Check if kill switch is active before any operation
    case mcp_kill_switch:is_active() of
        true ->
            {reply, {refusal, <<"KILL-001">>, <<"Kill switch active">>}, State};
        false ->
            {reply, ok, State}
    end;

handle_call({get_metrics}, _From, #state{metrics = Metrics} = State) ->
    {reply, {ok, Metrics}, State};

handle_call({get_state}, _From, State) ->
    %% Return sanitized state (no secrets)
    SafeState = #{
        initialized => State#state.initialized,
        kill_switch_active => State#state.kill_switch_active,
        metrics => State#state.metrics
    },
    {reply, {ok, SafeState}, State};

handle_call(Request, From, State) ->
    logger:warning("~p received unexpected call: ~p from ~p",
                   [?MODULE, Request, From]),
    {reply, {error, unknown_request}, State}.

%% @doc Handle asynchronous casts
-spec handle_cast(Msg, State) -> {noreply, State} when
    Msg :: term(),
    State :: state().
handle_cast({kill_switch, Active}, State) ->
    logger:notice("~p kill switch set to: ~p", [?MODULE, Active]),
    {noreply, State#state{kill_switch_active = Active}};

handle_cast({increment_metric, Key}, #state{metrics = Metrics} = State) ->
    NewValue = maps:get(Key, Metrics, 0) + 1,
    NewMetrics = maps:put(Key, NewValue, Metrics),
    {noreply, State#state{metrics = NewMetrics}};

handle_cast(Msg, State) ->
    logger:warning("~p received unexpected cast: ~p", [?MODULE, Msg]),
    {noreply, State}.

%% @doc Handle system messages
-spec handle_info(Info, State) -> {noreply, State} when
    Info :: term(),
    State :: state().
handle_info({'EXIT', Pid, Reason}, State) ->
    logger:error("~p linked process ~p exited: ~p", [?MODULE, Pid, Reason]),
    {noreply, State};

handle_info(Info, State) ->
    logger:warning("~p received unexpected info: ~p", [?MODULE, Info]),
    {noreply, State}.

%% @doc Handle termination
-spec terminate(Reason, State) -> ok when
    Reason :: term(),
    State :: state().
terminate(Reason, #state{metrics = Metrics}) ->
    logger:info("~p terminating: ~p", [?MODULE, Reason]),
    logger:info("~p final metrics: ~p", [?MODULE, Metrics]),
    ok.

%% @doc Handle code changes (hot upgrades)
-spec code_change(OldVsn, State, Extra) -> {ok, State} when
    OldVsn :: term(),
    State :: state(),
    Extra :: term().
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%=============================================================================
%%% Internal Functions
%%%=============================================================================

%% Reserved for future internal functions
