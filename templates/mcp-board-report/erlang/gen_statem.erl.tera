%%%-----------------------------------------------------------------------------
%%% @doc {{ module }} - MCP+ Envelope State Machine
%%%
%%% State machine for envelope lifecycle management.
%%% States: {{ states | default(value="initializing, active, exhausted, violated, terminated") }}
%%%
%%% Implements fail-closed envelope refusal under uncertainty.
%%% All state transitions produce deterministic refusal codes.
%%%
%%% Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
%%%
%%% Generated by ggen - DO NOT EDIT MANUALLY
%%% Regenerate with: ggen sync --audit true
%%% @end
%%%-----------------------------------------------------------------------------
-module({{ module | default(value="mcp_envelope_server") }}).

-behaviour(gen_statem).

%% API
-export([
    start_link/0,
    start_link/1,
    create_envelope/1,
    check_bounds/2,
    record_usage/2,
    get_status/1,
    terminate_envelope/1
]).

%% gen_statem callbacks
-export([
    init/1,
    callback_mode/0,
    handle_event/4,
    terminate/3,
    code_change/4
]).

%% State functions
-export([
    initializing/3,
    active/3,
    exhausted/3,
    violated/3,
    terminated/3
]).

-define(SERVER, ?MODULE).

%% Envelope record
-record(envelope, {
    id :: binary(),
    contract_id :: binary(),
    time_bound :: non_neg_integer(),       %% Max duration in ms
    resource_bound :: non_neg_integer(),   %% Max memory in bytes
    scope_bound :: [binary()],             %% Allowed scopes
    capability_bound :: [binary()],        %% Allowed capabilities
    created_at :: non_neg_integer(),
    usage :: map()
}).

%% State data record
-record(data, {
    envelopes :: map(),  %% envelope_id => envelope record
    metrics :: map()
}).

-type envelope() :: #envelope{}.
-type data() :: #data{}.

%%%=============================================================================
%%% API Functions
%%%=============================================================================

-spec start_link() -> {ok, pid()} | ignore | {error, term()}.
start_link() ->
    start_link([]).

-spec start_link(proplists:proplist()) -> {ok, pid()} | ignore | {error, term()}.
start_link(Opts) ->
    gen_statem:start_link({local, ?SERVER}, ?MODULE, Opts, []).

%% @doc Create a new envelope with specified bounds
-spec create_envelope(map()) -> {ok, binary()} | {error, term()}.
create_envelope(Bounds) ->
    gen_statem:call(?SERVER, {create_envelope, Bounds}).

%% @doc Check if operation is within envelope bounds
-spec check_bounds(binary(), map()) -> ok | {refusal, binary(), binary()}.
check_bounds(EnvelopeId, Operation) ->
    gen_statem:call(?SERVER, {check_bounds, EnvelopeId, Operation}).

%% @doc Record resource usage against envelope
-spec record_usage(binary(), map()) -> ok | {refusal, binary(), binary()}.
record_usage(EnvelopeId, Usage) ->
    gen_statem:call(?SERVER, {record_usage, EnvelopeId, Usage}).

%% @doc Get envelope status
-spec get_status(binary()) -> {ok, map()} | {error, not_found}.
get_status(EnvelopeId) ->
    gen_statem:call(?SERVER, {get_status, EnvelopeId}).

%% @doc Terminate an envelope
-spec terminate_envelope(binary()) -> ok | {error, term()}.
terminate_envelope(EnvelopeId) ->
    gen_statem:call(?SERVER, {terminate_envelope, EnvelopeId}).

%%%=============================================================================
%%% gen_statem Callbacks
%%%=============================================================================

-spec init(proplists:proplist()) -> {ok, atom(), data()}.
init(_Opts) ->
    process_flag(trap_exit, true),
    logger:info("~p initializing", [?MODULE]),

    Data = #data{
        envelopes = #{},
        metrics = #{
            created => 0,
            violated => 0,
            exhausted => 0,
            terminated => 0
        }
    },

    {ok, initializing, Data}.

-spec callback_mode() -> [atom()].
callback_mode() ->
    [state_functions, state_enter].

%%%=============================================================================
%%% State Functions
%%%=============================================================================

%% @doc Initializing state - system startup
initializing(enter, _OldState, Data) ->
    logger:info("Envelope server entering initializing state"),
    {keep_state, Data, [{state_timeout, 0, ready}]};

initializing(state_timeout, ready, Data) ->
    logger:info("Envelope server ready, transitioning to active"),
    {next_state, active, Data};

initializing({call, From}, _Request, Data) ->
    %% Refuse all operations during initialization
    Reply = {refusal, <<"ENV-INIT">>, <<"Envelope server initializing">>},
    {keep_state, Data, [{reply, From, Reply}]}.

%% @doc Active state - normal operation
active(enter, _OldState, Data) ->
    logger:info("Envelope server active"),
    {keep_state, Data};

active({call, From}, {create_envelope, Bounds}, Data) ->
    case do_create_envelope(Bounds, Data) of
        {ok, EnvelopeId, NewData} ->
            {keep_state, NewData, [{reply, From, {ok, EnvelopeId}}]};
        {error, Reason} ->
            {keep_state, Data, [{reply, From, {error, Reason}}]}
    end;

active({call, From}, {check_bounds, EnvelopeId, Operation}, Data) ->
    case do_check_bounds(EnvelopeId, Operation, Data) of
        ok ->
            {keep_state, Data, [{reply, From, ok}]};
        {refusal, Code, Message} ->
            %% Envelope violated - may trigger state change
            NewData = record_violation(EnvelopeId, Code, Data),
            {keep_state, NewData, [{reply, From, {refusal, Code, Message}}]}
    end;

active({call, From}, {record_usage, EnvelopeId, Usage}, Data) ->
    case do_record_usage(EnvelopeId, Usage, Data) of
        {ok, NewData} ->
            {keep_state, NewData, [{reply, From, ok}]};
        {exhausted, NewData} ->
            {keep_state, NewData, [{reply, From, {refusal, <<"ENV-EXH">>, <<"Envelope exhausted">>}}]};
        {error, Reason} ->
            {keep_state, Data, [{reply, From, {error, Reason}}]}
    end;

active({call, From}, {get_status, EnvelopeId}, #data{envelopes = Envelopes} = Data) ->
    case maps:find(EnvelopeId, Envelopes) of
        {ok, Envelope} ->
            Status = envelope_to_status(Envelope),
            {keep_state, Data, [{reply, From, {ok, Status}}]};
        error ->
            {keep_state, Data, [{reply, From, {error, not_found}}]}
    end;

active({call, From}, {terminate_envelope, EnvelopeId}, Data) ->
    NewData = do_terminate_envelope(EnvelopeId, Data),
    {keep_state, NewData, [{reply, From, ok}]};

active({call, From}, Request, Data) ->
    logger:warning("Unexpected call in active state: ~p", [Request]),
    {keep_state, Data, [{reply, From, {error, unknown_request}}]}.

%% @doc Exhausted state - envelope resources depleted
exhausted(enter, _OldState, Data) ->
    logger:warning("Envelope server entered exhausted state"),
    {keep_state, Data};

exhausted({call, From}, _Request, Data) ->
    Reply = {refusal, <<"ENV-EXH">>, <<"Envelope exhausted">>},
    {keep_state, Data, [{reply, From, Reply}]}.

%% @doc Violated state - envelope bounds were breached
violated(enter, _OldState, Data) ->
    logger:error("Envelope server entered violated state"),
    {keep_state, Data};

violated({call, From}, _Request, Data) ->
    Reply = {refusal, <<"ENV-VIO">>, <<"Envelope violated">>},
    {keep_state, Data, [{reply, From, Reply}]}.

%% @doc Terminated state - envelope has been terminated
terminated(enter, _OldState, Data) ->
    logger:info("Envelope server entered terminated state"),
    {keep_state, Data};

terminated({call, From}, _Request, Data) ->
    Reply = {refusal, <<"ENV-TRM">>, <<"Envelope terminated">>},
    {keep_state, Data, [{reply, From, Reply}]}.

%%%=============================================================================
%%% Generic Event Handler
%%%=============================================================================

handle_event(EventType, EventContent, State, Data) ->
    logger:warning("Unhandled event ~p:~p in state ~p",
                   [EventType, EventContent, State]),
    {keep_state, Data}.

terminate(Reason, State, #data{metrics = Metrics}) ->
    logger:info("Envelope server terminating: ~p (state: ~p)", [Reason, State]),
    logger:info("Final metrics: ~p", [Metrics]),
    ok.

code_change(_OldVsn, State, Data, _Extra) ->
    {ok, State, Data}.

%%%=============================================================================
%%% Internal Functions
%%%=============================================================================

-spec do_create_envelope(map(), data()) -> {ok, binary(), data()} | {error, term()}.
do_create_envelope(Bounds, #data{envelopes = Envelopes, metrics = Metrics} = Data) ->
    EnvelopeId = generate_envelope_id(),

    Envelope = #envelope{
        id = EnvelopeId,
        contract_id = maps:get(contract_id, Bounds, <<>>),
        time_bound = maps:get(time_bound, Bounds, 30000),
        resource_bound = maps:get(resource_bound, Bounds, 104857600),  %% 100MB default
        scope_bound = maps:get(scope_bound, Bounds, []),
        capability_bound = maps:get(capability_bound, Bounds, []),
        created_at = erlang:system_time(millisecond),
        usage = #{memory => 0, time => 0}
    },

    NewEnvelopes = maps:put(EnvelopeId, Envelope, Envelopes),
    NewMetrics = maps:update_with(created, fun(V) -> V + 1 end, 1, Metrics),
    NewData = Data#data{envelopes = NewEnvelopes, metrics = NewMetrics},

    logger:info("Created envelope ~s for contract ~s",
                [EnvelopeId, Envelope#envelope.contract_id]),

    {ok, EnvelopeId, NewData}.

-spec do_check_bounds(binary(), map(), data()) -> ok | {refusal, binary(), binary()}.
do_check_bounds(EnvelopeId, Operation, #data{envelopes = Envelopes}) ->
    case maps:find(EnvelopeId, Envelopes) of
        {ok, Envelope} ->
            check_operation_bounds(Envelope, Operation);
        error ->
            {refusal, <<"ENV-404">>, <<"Envelope not found">>}
    end.

-spec check_operation_bounds(envelope(), map()) -> ok | {refusal, binary(), binary()}.
check_operation_bounds(Envelope, Operation) ->
    %% Check time bound
    Now = erlang:system_time(millisecond),
    Elapsed = Now - Envelope#envelope.created_at,

    case Elapsed > Envelope#envelope.time_bound of
        true ->
            {refusal, <<"ENV-TIME">>, <<"Time bound exceeded">>};
        false ->
            %% Check capability bound
            RequestedCap = maps:get(capability, Operation, <<>>),
            case RequestedCap =:= <<>> orelse
                 lists:member(RequestedCap, Envelope#envelope.capability_bound) of
                true ->
                    %% Check scope bound
                    RequestedScope = maps:get(scope, Operation, <<>>),
                    case RequestedScope =:= <<>> orelse
                         lists:member(RequestedScope, Envelope#envelope.scope_bound) of
                        true -> ok;
                        false -> {refusal, <<"ENV-SCOPE">>, <<"Scope not allowed">>}
                    end;
                false ->
                    {refusal, <<"ENV-CAP">>, <<"Capability not allowed">>}
            end
    end.

-spec do_record_usage(binary(), map(), data()) ->
    {ok, data()} | {exhausted, data()} | {error, term()}.
do_record_usage(EnvelopeId, Usage, #data{envelopes = Envelopes} = Data) ->
    case maps:find(EnvelopeId, Envelopes) of
        {ok, Envelope} ->
            CurrentUsage = Envelope#envelope.usage,
            NewMemory = maps:get(memory, CurrentUsage, 0) +
                        maps:get(memory, Usage, 0),

            case NewMemory > Envelope#envelope.resource_bound of
                true ->
                    logger:warning("Envelope ~s exhausted (memory: ~p > ~p)",
                                  [EnvelopeId, NewMemory, Envelope#envelope.resource_bound]),
                    {exhausted, Data};
                false ->
                    NewUsage = maps:put(memory, NewMemory, CurrentUsage),
                    NewEnvelope = Envelope#envelope{usage = NewUsage},
                    NewEnvelopes = maps:put(EnvelopeId, NewEnvelope, Envelopes),
                    {ok, Data#data{envelopes = NewEnvelopes}}
            end;
        error ->
            {error, not_found}
    end.

-spec record_violation(binary(), binary(), data()) -> data().
record_violation(_EnvelopeId, Code, #data{metrics = Metrics} = Data) ->
    logger:error("Envelope violation recorded: ~s", [Code]),
    NewMetrics = maps:update_with(violated, fun(V) -> V + 1 end, 1, Metrics),
    Data#data{metrics = NewMetrics}.

-spec do_terminate_envelope(binary(), data()) -> data().
do_terminate_envelope(EnvelopeId, #data{envelopes = Envelopes, metrics = Metrics} = Data) ->
    NewEnvelopes = maps:remove(EnvelopeId, Envelopes),
    NewMetrics = maps:update_with(terminated, fun(V) -> V + 1 end, 1, Metrics),
    logger:info("Envelope ~s terminated", [EnvelopeId]),
    Data#data{envelopes = NewEnvelopes, metrics = NewMetrics}.

-spec envelope_to_status(envelope()) -> map().
envelope_to_status(Envelope) ->
    #{
        id => Envelope#envelope.id,
        contract_id => Envelope#envelope.contract_id,
        time_remaining => max(0, Envelope#envelope.time_bound -
                             (erlang:system_time(millisecond) - Envelope#envelope.created_at)),
        resource_remaining => max(0, Envelope#envelope.resource_bound -
                                 maps:get(memory, Envelope#envelope.usage, 0)),
        usage => Envelope#envelope.usage
    }.

-spec generate_envelope_id() -> binary().
generate_envelope_id() ->
    %% UUID v7 style (time-ordered)
    Timestamp = erlang:system_time(millisecond),
    Random = rand:uniform(16#FFFFFFFFFFFF),
    list_to_binary(io_lib:format("env-~.16b-~.12b", [Timestamp, Random])).
