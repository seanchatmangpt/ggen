%%%-----------------------------------------------------------------------------
%%% @doc MCP+ Kill Switch Server
%%%
%%% Emergency control server providing instant halt capability.
%%% Implements board-grade control authority:
%%% - Global disable (all contracts)
%%% - Family disable (contract group)
%%% - Capability disable (specific operation)
%%% - Epoch revocation (signing key)
%%%
%%% FAIL-CLOSED: Any uncertainty results in refusal.
%%%
%%% Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
%%%
%%% Generated by ggen - DO NOT EDIT MANUALLY
%%% Regenerate with: ggen sync --audit true
%%% @end
%%%-----------------------------------------------------------------------------
-module(mcp_kill_switch).

-behaviour(gen_server).

%% API
-export([
    start_link/0,
    start_link/1
]).

%% Kill Switch Control API
-export([
    disable_global/0,
    enable_global/0,
    disable_family/1,
    enable_family/1,
    disable_capability/1,
    enable_capability/1,
    revoke_epoch/1,
    status/0,
    is_active/0,
    is_allowed/1,
    drill/1
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

-define(SERVER, ?MODULE).

%% Kill switch state
-record(state, {
    global_disabled :: boolean(),
    disabled_families :: sets:set(binary()),
    disabled_capabilities :: sets:set(binary()),
    revoked_epochs :: sets:set(binary()),
    last_drill :: non_neg_integer() | undefined,
    drill_history :: [map()],
    metrics :: map()
}).

-type state() :: #state{}.

%%%=============================================================================
%%% API Functions
%%%=============================================================================

-spec start_link() -> {ok, pid()} | ignore | {error, term()}.
start_link() ->
    start_link([]).

-spec start_link(proplists:proplist()) -> {ok, pid()} | ignore | {error, term()}.
start_link(Opts) ->
    gen_server:start_link({local, ?SERVER}, ?MODULE, Opts, []).

%% @doc Disable ALL contract execution globally
%% This is the emergency "red button" - stops everything immediately
-spec disable_global() -> ok.
disable_global() ->
    logger:critical("KILL SWITCH: Global disable activated"),
    gen_server:call(?SERVER, disable_global).

%% @doc Re-enable global contract execution
%% Requires explicit authorization
-spec enable_global() -> ok.
enable_global() ->
    logger:warning("KILL SWITCH: Global enable requested"),
    gen_server:call(?SERVER, enable_global).

%% @doc Disable a specific contract family
-spec disable_family(binary()) -> ok.
disable_family(FamilyId) ->
    logger:critical("KILL SWITCH: Family ~s disabled", [FamilyId]),
    gen_server:call(?SERVER, {disable_family, FamilyId}).

%% @doc Re-enable a specific contract family
-spec enable_family(binary()) -> ok.
enable_family(FamilyId) ->
    logger:warning("KILL SWITCH: Family ~s enable requested", [FamilyId]),
    gen_server:call(?SERVER, {enable_family, FamilyId}).

%% @doc Disable a specific capability
-spec disable_capability(binary()) -> ok.
disable_capability(CapabilityId) ->
    logger:critical("KILL SWITCH: Capability ~s disabled", [CapabilityId]),
    gen_server:call(?SERVER, {disable_capability, CapabilityId}).

%% @doc Re-enable a specific capability
-spec enable_capability(binary()) -> ok.
enable_capability(CapabilityId) ->
    logger:warning("KILL SWITCH: Capability ~s enable requested", [CapabilityId]),
    gen_server:call(?SERVER, {enable_capability, CapabilityId}).

%% @doc Revoke a signing key epoch
%% Contracts signed with this epoch will be refused
-spec revoke_epoch(binary()) -> ok.
revoke_epoch(EpochId) ->
    logger:critical("KILL SWITCH: Epoch ~s revoked", [EpochId]),
    gen_server:call(?SERVER, {revoke_epoch, EpochId}).

%% @doc Get current kill switch status
-spec status() -> map().
status() ->
    gen_server:call(?SERVER, status).

%% @doc Check if global kill switch is active
-spec is_active() -> boolean().
is_active() ->
    gen_server:call(?SERVER, is_active).

%% @doc Check if a specific operation is allowed
%% Returns true if allowed, {refusal, Code, Message} if blocked
-spec is_allowed(map()) -> true | {refusal, binary(), binary()}.
is_allowed(Operation) ->
    gen_server:call(?SERVER, {is_allowed, Operation}).

%% @doc Execute a drill (for quarterly testing)
%% @param DrillType :: global | family | capability | epoch
-spec drill(atom()) -> {ok, map()}.
drill(DrillType) ->
    logger:notice("KILL SWITCH: Drill initiated - ~p", [DrillType]),
    gen_server:call(?SERVER, {drill, DrillType}).

%%%=============================================================================
%%% gen_server Callbacks
%%%=============================================================================

-spec init(proplists:proplist()) -> {ok, state()}.
init(_Opts) ->
    process_flag(trap_exit, true),

    logger:info("Kill switch server initializing"),

    State = #state{
        global_disabled = false,
        disabled_families = sets:new([{version, 2}]),
        disabled_capabilities = sets:new([{version, 2}]),
        revoked_epochs = sets:new([{version, 2}]),
        last_drill = undefined,
        drill_history = [],
        metrics = #{
            global_disables => 0,
            family_disables => 0,
            capability_disables => 0,
            epoch_revocations => 0,
            drills_executed => 0,
            refusals_issued => 0
        }
    },

    {ok, State}.

handle_call(disable_global, _From, State) ->
    NewState = State#state{
        global_disabled = true,
        metrics = increment_metric(global_disables, State#state.metrics)
    },
    emit_kill_switch_receipt(global_disable, NewState),
    {reply, ok, NewState};

handle_call(enable_global, _From, State) ->
    NewState = State#state{global_disabled = false},
    emit_kill_switch_receipt(global_enable, NewState),
    {reply, ok, NewState};

handle_call({disable_family, FamilyId}, _From, State) ->
    NewFamilies = sets:add_element(FamilyId, State#state.disabled_families),
    NewState = State#state{
        disabled_families = NewFamilies,
        metrics = increment_metric(family_disables, State#state.metrics)
    },
    emit_kill_switch_receipt({family_disable, FamilyId}, NewState),
    {reply, ok, NewState};

handle_call({enable_family, FamilyId}, _From, State) ->
    NewFamilies = sets:del_element(FamilyId, State#state.disabled_families),
    NewState = State#state{disabled_families = NewFamilies},
    emit_kill_switch_receipt({family_enable, FamilyId}, NewState),
    {reply, ok, NewState};

handle_call({disable_capability, CapabilityId}, _From, State) ->
    NewCaps = sets:add_element(CapabilityId, State#state.disabled_capabilities),
    NewState = State#state{
        disabled_capabilities = NewCaps,
        metrics = increment_metric(capability_disables, State#state.metrics)
    },
    emit_kill_switch_receipt({capability_disable, CapabilityId}, NewState),
    {reply, ok, NewState};

handle_call({enable_capability, CapabilityId}, _From, State) ->
    NewCaps = sets:del_element(CapabilityId, State#state.disabled_capabilities),
    NewState = State#state{disabled_capabilities = NewCaps},
    emit_kill_switch_receipt({capability_enable, CapabilityId}, NewState),
    {reply, ok, NewState};

handle_call({revoke_epoch, EpochId}, _From, State) ->
    NewEpochs = sets:add_element(EpochId, State#state.revoked_epochs),
    NewState = State#state{
        revoked_epochs = NewEpochs,
        metrics = increment_metric(epoch_revocations, State#state.metrics)
    },
    emit_kill_switch_receipt({epoch_revoke, EpochId}, NewState),
    {reply, ok, NewState};

handle_call(status, _From, State) ->
    Status = #{
        global_disabled => State#state.global_disabled,
        disabled_families => sets:to_list(State#state.disabled_families),
        disabled_capabilities => sets:to_list(State#state.disabled_capabilities),
        revoked_epochs => sets:to_list(State#state.revoked_epochs),
        last_drill => State#state.last_drill,
        metrics => State#state.metrics
    },
    {reply, Status, State};

handle_call(is_active, _From, State) ->
    {reply, State#state.global_disabled, State};

handle_call({is_allowed, Operation}, _From, State) ->
    Result = check_operation_allowed(Operation, State),
    NewState = case Result of
        true -> State;
        {refusal, _, _} ->
            State#state{
                metrics = increment_metric(refusals_issued, State#state.metrics)
            }
    end,
    {reply, Result, NewState};

handle_call({drill, DrillType}, _From, State) ->
    DrillResult = execute_drill(DrillType, State),
    Now = erlang:system_time(millisecond),
    DrillRecord = #{
        type => DrillType,
        timestamp => Now,
        result => DrillResult
    },
    NewState = State#state{
        last_drill = Now,
        drill_history = [DrillRecord | lists:sublist(State#state.drill_history, 99)],
        metrics = increment_metric(drills_executed, State#state.metrics)
    },
    emit_kill_switch_receipt({drill, DrillType, DrillResult}, NewState),
    {reply, {ok, DrillResult}, NewState};

handle_call(Request, From, State) ->
    logger:warning("Kill switch received unexpected call: ~p from ~p",
                   [Request, From]),
    {reply, {error, unknown_request}, State}.

handle_cast(Msg, State) ->
    logger:warning("Kill switch received unexpected cast: ~p", [Msg]),
    {noreply, State}.

handle_info(Info, State) ->
    logger:warning("Kill switch received unexpected info: ~p", [Info]),
    {noreply, State}.

terminate(Reason, State) ->
    logger:info("Kill switch terminating: ~p", [Reason]),
    logger:info("Final metrics: ~p", [State#state.metrics]),
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%=============================================================================
%%% Internal Functions
%%%=============================================================================

-spec check_operation_allowed(map(), state()) -> true | {refusal, binary(), binary()}.
check_operation_allowed(_Operation, #state{global_disabled = true}) ->
    {refusal, <<"KILL-001">>, <<"Global kill switch active">>};

check_operation_allowed(#{family := FamilyId} = Operation, State) ->
    case sets:is_element(FamilyId, State#state.disabled_families) of
        true ->
            {refusal, <<"KILL-002">>, <<"Contract family disabled">>};
        false ->
            check_capability(Operation, State)
    end;

check_operation_allowed(Operation, State) ->
    check_capability(Operation, State).

-spec check_capability(map(), state()) -> true | {refusal, binary(), binary()}.
check_capability(#{capability := CapabilityId} = Operation, State) ->
    case sets:is_element(CapabilityId, State#state.disabled_capabilities) of
        true ->
            {refusal, <<"KILL-003">>, <<"Capability disabled">>};
        false ->
            check_epoch(Operation, State)
    end;

check_capability(Operation, State) ->
    check_epoch(Operation, State).

-spec check_epoch(map(), state()) -> true | {refusal, binary(), binary()}.
check_epoch(#{epoch := EpochId}, State) ->
    case sets:is_element(EpochId, State#state.revoked_epochs) of
        true ->
            {refusal, <<"KILL-004">>, <<"Signing epoch revoked">>};
        false ->
            true
    end;

check_epoch(_Operation, _State) ->
    true.

-spec execute_drill(atom(), state()) -> map().
execute_drill(global, _State) ->
    %% Simulate global kill switch activation
    #{
        type => global,
        simulated => true,
        response_time_ms => 1,
        all_contracts_would_halt => true
    };

execute_drill(family, _State) ->
    TestFamily = <<"drill-test-family">>,
    #{
        type => family,
        family_id => TestFamily,
        simulated => true,
        response_time_ms => 1
    };

execute_drill(capability, _State) ->
    TestCap = <<"drill-test-capability">>,
    #{
        type => capability,
        capability_id => TestCap,
        simulated => true,
        response_time_ms => 1
    };

execute_drill(epoch, _State) ->
    TestEpoch = <<"drill-test-epoch">>,
    #{
        type => epoch,
        epoch_id => TestEpoch,
        simulated => true,
        response_time_ms => 1
    };

execute_drill(Unknown, _State) ->
    #{
        type => Unknown,
        error => unknown_drill_type
    }.

-spec emit_kill_switch_receipt(term(), state()) -> ok.
emit_kill_switch_receipt(Action, _State) ->
    %% Emit receipt via receipt server
    case whereis(mcp_receipt_server) of
        undefined ->
            logger:warning("Receipt server not available for kill switch action: ~p",
                          [Action]);
        _Pid ->
            %% Generate receipt asynchronously
            spawn(fun() ->
                Receipt = #{
                    type => kill_switch,
                    action => Action,
                    timestamp => erlang:system_time(millisecond)
                },
                catch mcp_receipt_server:emit(Receipt)
            end)
    end,
    ok.

-spec increment_metric(atom(), map()) -> map().
increment_metric(Key, Metrics) ->
    maps:update_with(Key, fun(V) -> V + 1 end, 1, Metrics).
