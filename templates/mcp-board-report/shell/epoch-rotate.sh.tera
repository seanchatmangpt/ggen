#!/usr/bin/env bash
# =============================================================================
# MCP+ Key Epoch Rotation Script
#
# Rotates signing key epochs for contract signing.
# Default rotation: Quarterly (90 days).
#
# Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
#
# Generated by ggen - DO NOT EDIT MANUALLY
# Regenerate with: ggen sync --audit true
# =============================================================================

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly KEY_DIR="${SCRIPT_DIR}/../keys"
readonly EPOCH_DIR="${KEY_DIR}/epochs"
readonly LOG_DIR="${SCRIPT_DIR}/../logs"
readonly ROTATION_DAYS="${ROTATION_DAYS:-90}"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m'

# Ensure directories exist
mkdir -p "${EPOCH_DIR}" "${LOG_DIR}"

# Logging
log() {
    local level="$1"
    shift
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
    echo -e "${timestamp} [${level}] $*" | tee -a "${LOG_DIR}/epoch-rotation.log"
}

log_info() { log "INFO" "$*"; }
log_warn() { log "WARN" "${YELLOW}$*${NC}"; }
log_error() { log "ERROR" "${RED}$*${NC}"; }
log_success() { log "SUCCESS" "${GREEN}$*${NC}"; }

# Get current epoch
get_current_epoch() {
    local current_link="${EPOCH_DIR}/current"
    if [[ -L "${current_link}" ]]; then
        basename "$(readlink "${current_link}")"
    else
        echo "none"
    fi
}

# Generate new epoch
generate_epoch() {
    local epoch_id
    local epoch_dir
    local start_date
    local end_date

    epoch_id="epoch-$(date +%Y)-Q$(( ($(date +%-m) - 1) / 3 + 1 ))-$(date +%s | sha256sum | head -c 8)"
    epoch_dir="${EPOCH_DIR}/${epoch_id}"
    start_date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    end_date=$(date -u -d "+${ROTATION_DAYS} days" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")

    log_info "Generating new epoch: ${epoch_id}"

    mkdir -p "${epoch_dir}"

    # Generate keypair (in production, use HSM)
    log_info "Generating Ed25519 keypair..."

    # Simulate key generation (in production, call HSM or Rust NIF)
    local private_key_hash
    local public_key_hash

    private_key_hash=$(dd if=/dev/urandom bs=32 count=1 2>/dev/null | sha256sum | cut -d' ' -f1)
    public_key_hash=$(echo -n "${private_key_hash}" | sha256sum | cut -d' ' -f1)

    # Create epoch metadata
    cat > "${epoch_dir}/epoch.json" << EOF
{
    "epoch_id": "${epoch_id}",
    "public_key_hash": "${public_key_hash}",
    "epoch_start": "${start_date}",
    "epoch_end": "${end_date}",
    "is_revoked": false,
    "created_by": "${USER}",
    "created_at": "${start_date}",
    "rotation_days": ${ROTATION_DAYS}
}
EOF

    # Generate receipt
    cat > "${epoch_dir}/creation-receipt.json" << EOF
{
    "type": "epoch_creation",
    "epoch_id": "${epoch_id}",
    "timestamp": "${start_date}",
    "public_key_hash": "${public_key_hash}",
    "rotation_days": ${ROTATION_DAYS}
}
EOF

    log_success "Epoch created: ${epoch_id}"
    log_info "Public key hash: ${public_key_hash}"

    echo "${epoch_id}"
}

# Activate epoch
activate_epoch() {
    local epoch_id="$1"
    local epoch_dir="${EPOCH_DIR}/${epoch_id}"
    local current_link="${EPOCH_DIR}/current"

    if [[ ! -d "${epoch_dir}" ]]; then
        log_error "Epoch not found: ${epoch_id}"
        return 1
    fi

    log_info "Activating epoch: ${epoch_id}"

    # Remove old symlink
    rm -f "${current_link}"

    # Create new symlink
    ln -s "${epoch_id}" "${current_link}"

    # Update epoch metadata
    jq '.activated_at = "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"' \
        "${epoch_dir}/epoch.json" > "${epoch_dir}/epoch.json.tmp"
    mv "${epoch_dir}/epoch.json.tmp" "${epoch_dir}/epoch.json"

    log_success "Epoch activated: ${epoch_id}"
}

# Rotate to new epoch
rotate_epoch() {
    local old_epoch
    local new_epoch

    old_epoch=$(get_current_epoch)
    log_info "Current epoch: ${old_epoch}"

    # Generate new epoch
    new_epoch=$(generate_epoch)

    # Activate new epoch
    activate_epoch "${new_epoch}"

    # Mark old epoch as superseded (not revoked)
    if [[ "${old_epoch}" != "none" ]]; then
        local old_epoch_file="${EPOCH_DIR}/${old_epoch}/epoch.json"
        if [[ -f "${old_epoch_file}" ]]; then
            jq '.superseded_by = "'${new_epoch}'" | .superseded_at = "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"' \
                "${old_epoch_file}" > "${old_epoch_file}.tmp"
            mv "${old_epoch_file}.tmp" "${old_epoch_file}"
            log_info "Old epoch ${old_epoch} superseded by ${new_epoch}"
        fi
    fi

    log_success "Epoch rotation complete: ${old_epoch} -> ${new_epoch}"
}

# List epochs
list_epochs() {
    echo ""
    echo "MCP+ Key Epochs"
    echo "==============="
    echo ""

    local current
    current=$(get_current_epoch)

    for epoch_dir in "${EPOCH_DIR}"/epoch-*; do
        if [[ -d "${epoch_dir}" ]]; then
            local epoch_id
            local status
            local end_date
            local is_revoked

            epoch_id=$(basename "${epoch_dir}")
            end_date=$(jq -r '.epoch_end // "unknown"' "${epoch_dir}/epoch.json" 2>/dev/null || echo "unknown")
            is_revoked=$(jq -r '.is_revoked // false' "${epoch_dir}/epoch.json" 2>/dev/null || echo "false")

            if [[ "${epoch_id}" == "${current}" ]]; then
                status="${GREEN}[ACTIVE]${NC}"
            elif [[ "${is_revoked}" == "true" ]]; then
                status="${RED}[REVOKED]${NC}"
            else
                status="${YELLOW}[INACTIVE]${NC}"
            fi

            echo -e "  ${epoch_id}  ${status}  expires: ${end_date}"
        fi
    done

    echo ""
}

# Show epoch details
show_epoch() {
    local epoch_id="${1:-$(get_current_epoch)}"
    local epoch_file="${EPOCH_DIR}/${epoch_id}/epoch.json"

    if [[ ! -f "${epoch_file}" ]]; then
        log_error "Epoch not found: ${epoch_id}"
        return 1
    fi

    echo ""
    echo "Epoch: ${epoch_id}"
    echo "================================"
    jq '.' "${epoch_file}"
    echo ""
}

# Check epoch expiration
check_expiration() {
    local current
    local epoch_file
    local end_date
    local end_ts
    local now_ts
    local days_remaining

    current=$(get_current_epoch)
    if [[ "${current}" == "none" ]]; then
        log_warn "No active epoch"
        return 1
    fi

    epoch_file="${EPOCH_DIR}/${current}/epoch.json"
    end_date=$(jq -r '.epoch_end' "${epoch_file}")

    # Calculate days remaining
    end_ts=$(date -d "${end_date}" +%s 2>/dev/null || echo "0")
    now_ts=$(date +%s)
    days_remaining=$(( (end_ts - now_ts) / 86400 ))

    if [[ ${days_remaining} -lt 0 ]]; then
        log_error "Current epoch ${current} has EXPIRED!"
        return 1
    elif [[ ${days_remaining} -lt 14 ]]; then
        log_warn "Current epoch ${current} expires in ${days_remaining} days - rotation recommended"
        return 0
    else
        log_info "Current epoch ${current} expires in ${days_remaining} days"
        return 0
    fi
}

# Usage
usage() {
    cat << EOF
MCP+ Key Epoch Rotation

Usage: $(basename "$0") <command> [options]

Commands:
    rotate              Generate and activate a new epoch
    generate            Generate a new epoch (without activating)
    activate <id>       Activate a specific epoch
    list                List all epochs
    show [id]           Show epoch details (current if no id)
    check               Check current epoch expiration
    status              Show current epoch status

Options:
    -h, --help          Show this help message

Environment:
    ROTATION_DAYS       Days until epoch expires (default: 90)

Examples:
    $(basename "$0") rotate
    $(basename "$0") list
    $(basename "$0") show epoch-2026-Q1-abc12345
    $(basename "$0") check

EOF
}

# Main
main() {
    local command="${1:-}"

    case "${command}" in
        rotate)
            rotate_epoch
            ;;
        generate)
            generate_epoch
            ;;
        activate)
            activate_epoch "${2:-}"
            ;;
        list)
            list_epochs
            ;;
        show)
            show_epoch "${2:-}"
            ;;
        check)
            check_expiration
            ;;
        status)
            local current
            current=$(get_current_epoch)
            echo "Current epoch: ${current}"
            [[ "${current}" != "none" ]] && check_expiration
            ;;
        -h|--help)
            usage
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

main "$@"
