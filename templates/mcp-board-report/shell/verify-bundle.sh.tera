#!/usr/bin/env bash
# =============================================================================
# MCP+ Evidence Bundle Verification Script
#
# Text-blind verification of .mcpb evidence bundles.
# Produces deterministic PASS/FAIL without accessing payload content.
#
# Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
#
# Generated by ggen - DO NOT EDIT MANUALLY
# Regenerate with: ggen sync --audit true
# =============================================================================

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly VERIFIER_BIN="${SCRIPT_DIR}/../bin/mcp_verifier"
readonly OUTPUT_DIR="${SCRIPT_DIR}/../verification-reports"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Ensure output directory exists
mkdir -p "${OUTPUT_DIR}"

# Print with color
print_pass() { echo -e "${GREEN}PASS${NC}: $*"; }
print_fail() { echo -e "${RED}FAIL${NC}: $*"; }
print_info() { echo -e "${BLUE}INFO${NC}: $*"; }
print_warn() { echo -e "${YELLOW}WARN${NC}: $*"; }

# Verification steps
verify_bundle_format() {
    local bundle_file="$1"
    print_info "Verifying bundle format..."

    # Check file exists
    if [[ ! -f "${bundle_file}" ]]; then
        print_fail "Bundle file not found: ${bundle_file}"
        return 1
    fi

    # Check file extension
    if [[ "${bundle_file}" != *.mcpb && "${bundle_file}" != *.json ]]; then
        print_warn "Unexpected file extension (expected .mcpb or .json)"
    fi

    # Check file is valid JSON
    if ! jq empty "${bundle_file}" 2>/dev/null; then
        print_fail "Bundle is not valid JSON"
        return 1
    fi

    print_pass "Bundle format valid"
    return 0
}

verify_bundle_version() {
    local bundle_file="$1"
    local expected_version="1.0.0"

    print_info "Verifying bundle version..."

    local version
    version=$(jq -r '.version // "unknown"' "${bundle_file}")

    if [[ "${version}" != "${expected_version}" ]]; then
        print_fail "Version mismatch: expected ${expected_version}, got ${version}"
        return 1
    fi

    print_pass "Bundle version: ${version}"
    return 0
}

verify_bundle_hash() {
    local bundle_file="$1"

    print_info "Verifying bundle hash integrity..."

    # Extract stored hash
    local stored_hash
    stored_hash=$(jq -r '.bundle_hash // "none"' "${bundle_file}")

    if [[ "${stored_hash}" == "none" ]]; then
        print_fail "No bundle hash found"
        return 1
    fi

    # Compute hash from bundle fields (excluding bundle_hash and attestations)
    local computed_hash
    computed_hash=$(jq -r '[.version, .bundle_id, .created_at, .period_start, .period_end, .contract_family, .receipt_chain_root, (.receipts | length), (.refusals | length)] | join("|")' "${bundle_file}" | sha256sum | cut -d' ' -f1)

    if [[ "${stored_hash}" != "${computed_hash}" ]]; then
        print_fail "Hash mismatch"
        print_info "  Stored:   ${stored_hash}"
        print_info "  Computed: ${computed_hash}"
        return 1
    fi

    print_pass "Bundle hash verified"
    return 0
}

verify_receipt_chain() {
    local bundle_file="$1"

    print_info "Verifying receipt chain integrity..."

    local receipt_count
    receipt_count=$(jq '.receipts | length' "${bundle_file}")

    if [[ "${receipt_count}" -eq 0 ]]; then
        print_warn "Empty receipt chain"
        return 0
    fi

    # Verify chain linkage
    local prev_hash="$(echo -n "genesis" | sha256sum | cut -d' ' -f1)"
    local i=0

    while [[ $i -lt $receipt_count ]]; do
        local receipt_prev_hash
        local receipt_hash

        receipt_prev_hash=$(jq -r ".receipts[$i].previous_receipt_hash" "${bundle_file}")
        receipt_hash=$(jq -r ".receipts[$i].receipt_hash" "${bundle_file}")

        if [[ "${receipt_prev_hash}" != "${prev_hash}" ]]; then
            print_fail "Chain broken at receipt $i"
            print_info "  Expected previous: ${prev_hash}"
            print_info "  Got: ${receipt_prev_hash}"
            return 1
        fi

        prev_hash="${receipt_hash}"
        ((i++))
    done

    print_pass "Receipt chain verified (${receipt_count} receipts)"
    return 0
}

verify_receipts() {
    local bundle_file="$1"

    print_info "Verifying individual receipts..."

    local receipt_count
    receipt_count=$(jq '.receipts | length' "${bundle_file}")

    local verified=0
    local failed=0

    for ((i=0; i<receipt_count; i++)); do
        # Verify each receipt has required fields
        local has_fields
        has_fields=$(jq ".receipts[$i] | has(\"execution_id\") and has(\"timestamp\") and has(\"receipt_hash\")" "${bundle_file}")

        if [[ "${has_fields}" == "true" ]]; then
            ((verified++))
        else
            ((failed++))
            print_fail "Receipt $i missing required fields"
        fi
    done

    if [[ $failed -gt 0 ]]; then
        print_fail "Receipt verification: ${failed}/${receipt_count} failed"
        return 1
    fi

    print_pass "All ${verified} receipts verified"
    return 0
}

verify_refusals() {
    local bundle_file="$1"

    print_info "Verifying refusals..."

    local refusal_count
    refusal_count=$(jq '.refusals | length' "${bundle_file}")

    if [[ "${refusal_count}" -eq 0 ]]; then
        print_info "No refusals in bundle"
        return 0
    fi

    # Verify each refusal has valid code format
    local valid=0
    local invalid=0

    for ((i=0; i<refusal_count; i++)); do
        local code
        code=$(jq -r ".refusals[$i].code" "${bundle_file}")

        # Code format: PREFIX-NNN
        if [[ "${code}" =~ ^(ENV|KEY|CAP|VAL|RES|KILL)-[0-9]{3}$ ]]; then
            ((valid++))
        else
            ((invalid++))
            print_warn "Invalid refusal code format: ${code}"
        fi
    done

    if [[ $invalid -gt 0 ]]; then
        print_warn "Refusal verification: ${invalid}/${refusal_count} have invalid format"
    fi

    print_pass "Refusals checked: ${valid} valid, ${invalid} warnings"
    return 0
}

verify_metrics() {
    local bundle_file="$1"

    print_info "Verifying metrics consistency..."

    local total_ops successful_ops refused_ops
    total_ops=$(jq '.metrics.total_operations' "${bundle_file}")
    successful_ops=$(jq '.metrics.successful_operations' "${bundle_file}")
    refused_ops=$(jq '.metrics.refused_operations' "${bundle_file}")

    local receipt_count refusal_count
    receipt_count=$(jq '.receipts | length' "${bundle_file}")
    refusal_count=$(jq '.refusals | length' "${bundle_file}")

    # Check consistency
    if [[ "${total_ops}" -ne "${receipt_count}" ]]; then
        print_warn "Metrics total_operations (${total_ops}) != receipt count (${receipt_count})"
    fi

    if [[ "${refused_ops}" -ne "${refusal_count}" ]]; then
        print_warn "Metrics refused_operations (${refused_ops}) != refusal count (${refusal_count})"
    fi

    print_pass "Metrics verified"
    return 0
}

# Generate verification report
generate_report() {
    local bundle_file="$1"
    local result="$2"
    local timestamp
    local report_file

    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    report_file="${OUTPUT_DIR}/verification-$(date +%s).json"

    local bundle_id
    bundle_id=$(jq -r '.bundle_id' "${bundle_file}")

    cat > "${report_file}" << EOF
{
    "verification_timestamp": "${timestamp}",
    "bundle_file": "${bundle_file}",
    "bundle_id": "${bundle_id}",
    "result": "${result}",
    "verifier": "mcp-bundle-verifier",
    "verifier_version": "1.0.0",
    "text_blind": true
}
EOF

    echo "${report_file}"
}

# Main verification function
verify_bundle() {
    local bundle_file="$1"
    local failures=0

    echo ""
    echo "=============================================="
    echo "MCP+ Evidence Bundle Verification"
    echo "=============================================="
    echo "Bundle: ${bundle_file}"
    echo "Time:   $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    echo "----------------------------------------------"
    echo ""

    verify_bundle_format "${bundle_file}" || ((failures++))
    verify_bundle_version "${bundle_file}" || ((failures++))
    verify_bundle_hash "${bundle_file}" || ((failures++))
    verify_receipt_chain "${bundle_file}" || ((failures++))
    verify_receipts "${bundle_file}" || ((failures++))
    verify_refusals "${bundle_file}" || ((failures++))
    verify_metrics "${bundle_file}" || ((failures++))

    echo ""
    echo "----------------------------------------------"

    local result
    if [[ $failures -eq 0 ]]; then
        result="PASS"
        echo -e "${GREEN}VERIFICATION RESULT: PASS${NC}"
    else
        result="FAIL"
        echo -e "${RED}VERIFICATION RESULT: FAIL (${failures} failures)${NC}"
    fi

    local report_file
    report_file=$(generate_report "${bundle_file}" "${result}")
    echo "Report: ${report_file}"
    echo "=============================================="
    echo ""

    if [[ "${result}" == "PASS" ]]; then
        return 0
    else
        return 1
    fi
}

# Usage
usage() {
    cat << EOF
MCP+ Evidence Bundle Verification

Performs text-blind verification of .mcpb evidence bundles.
No payload content is accessed during verification.

Usage: $(basename "$0") <bundle-file> [options]

Options:
    -o, --output DIR   Output directory for reports (default: ./verification-reports)
    -q, --quiet        Quiet mode (only output PASS/FAIL)
    -h, --help         Show this help message

Examples:
    $(basename "$0") evidence-2026-q1.mcpb
    $(basename "$0") /path/to/bundle.json -o /reports

Exit codes:
    0 - Verification PASS
    1 - Verification FAIL
    2 - Error (invalid input, missing file, etc.)

EOF
}

# Main entry point
main() {
    local bundle_file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                mkdir -p "${OUTPUT_DIR}"
                shift 2
                ;;
            -q|--quiet)
                exec > /dev/null 2>&1
                shift
                ;;
            *)
                bundle_file="$1"
                shift
                ;;
        esac
    done

    if [[ -z "${bundle_file}" ]]; then
        usage
        exit 2
    fi

    verify_bundle "${bundle_file}"
}

main "$@"
