//! Cryptographic Receipt Module
//!
//! Implements verifiable receipts for MCP+ operations.
//! Receipts provide tamper-evident proof of operation without
//! exposing payload content (text-blind verification).
//!
//! Features:
//! - Merkle-chained receipts
//! - Deterministic generation
//! - Text-blind verification
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

use crate::crypto::hash_sha256;
use crate::{McpError, McpResult};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Receipt generation error
#[derive(Debug, thiserror::Error)]
pub enum ReceiptError {
    #[error("Receipt chain broken at index {index}: expected {expected}, got {actual}")]
    ChainBroken {
        index: usize,
        expected: String,
        actual: String,
    },

    #[error("Receipt hash mismatch")]
    HashMismatch,

    #[error("Invalid receipt format: {0}")]
    InvalidFormat(String),

    #[error("Empty receipt chain")]
    EmptyChain,
}

/// Receipt outcome
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReceiptOutcome {
    Success,
    Refusal { code: String, message: String },
    Error { message: String },
}

impl ReceiptOutcome {
    /// Get hash of the outcome for receipt
    pub fn hash(&self) -> String {
        let json = serde_json::to_string(self).unwrap_or_default();
        hash_sha256(json.as_bytes())
    }
}

/// Cryptographic receipt for an operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Receipt {
    /// Unique execution identifier (UUID v7)
    pub execution_id: String,

    /// ISO 8601 timestamp with microsecond precision
    pub timestamp: DateTime<Utc>,

    /// Contract ID this receipt is for
    pub contract_id: String,

    /// Envelope ID used for this execution
    pub envelope_id: String,

    /// SHA-256 hash of the manifest at execution time
    pub manifest_hash: String,

    /// SHA-256 hash of the operation outcome
    pub outcome_hash: String,

    /// Hash of previous receipt (for Merkle chain)
    pub previous_receipt_hash: String,

    /// Hash of this receipt (computed from all fields)
    pub receipt_hash: String,

    /// Outcome summary (no payload data)
    pub outcome: ReceiptOutcome,

    /// Execution duration in microseconds
    pub duration_us: u64,
}

impl Receipt {
    /// Create a new receipt
    pub fn new(
        contract_id: String,
        envelope_id: String,
        manifest_hash: String,
        outcome: ReceiptOutcome,
        previous_receipt_hash: String,
        duration_us: u64,
    ) -> Self {
        let execution_id = Uuid::now_v7().to_string();
        let timestamp = Utc::now();
        let outcome_hash = outcome.hash();

        // Compute receipt hash from all fields (deterministic)
        let receipt_hash = Self::compute_hash(
            &execution_id,
            &timestamp,
            &contract_id,
            &envelope_id,
            &manifest_hash,
            &outcome_hash,
            &previous_receipt_hash,
        );

        Self {
            execution_id,
            timestamp,
            contract_id,
            envelope_id,
            manifest_hash,
            outcome_hash,
            previous_receipt_hash,
            receipt_hash,
            outcome,
            duration_us,
        }
    }

    /// Compute the hash of a receipt from its components
    fn compute_hash(
        execution_id: &str,
        timestamp: &DateTime<Utc>,
        contract_id: &str,
        envelope_id: &str,
        manifest_hash: &str,
        outcome_hash: &str,
        previous_receipt_hash: &str,
    ) -> String {
        let data = format!(
            "{}|{}|{}|{}|{}|{}|{}",
            execution_id,
            timestamp.to_rfc3339(),
            contract_id,
            envelope_id,
            manifest_hash,
            outcome_hash,
            previous_receipt_hash
        );
        hash_sha256(data.as_bytes())
    }

    /// Verify the receipt hash is valid
    pub fn verify(&self) -> Result<(), ReceiptError> {
        let computed = Self::compute_hash(
            &self.execution_id,
            &self.timestamp,
            &self.contract_id,
            &self.envelope_id,
            &self.manifest_hash,
            &self.outcome_hash,
            &self.previous_receipt_hash,
        );

        if computed != self.receipt_hash {
            Err(ReceiptError::HashMismatch)
        } else {
            Ok(())
        }
    }

    /// Convert to JSON for serialization
    pub fn to_json(&self) -> McpResult<String> {
        serde_json::to_string(self)
            .map_err(|e| McpError::SerializationError(e.to_string()))
    }

    /// Parse from JSON
    pub fn from_json(json: &str) -> McpResult<Self> {
        serde_json::from_str(json)
            .map_err(|e| McpError::SerializationError(e.to_string()))
    }
}

/// Merkle-chained receipt collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReceiptChain {
    receipts: Vec<Receipt>,
    root_hash: String,
}

impl ReceiptChain {
    /// Create a new empty chain
    pub fn new() -> Self {
        Self {
            receipts: Vec::new(),
            root_hash: hash_sha256(b"genesis"),
        }
    }

    /// Create chain from existing receipts
    pub fn from_receipts(receipts: Vec<Receipt>) -> McpResult<Self> {
        let mut chain = Self::new();
        for receipt in receipts {
            chain.receipts.push(receipt);
        }
        chain.recompute_root()?;
        Ok(chain)
    }

    /// Add a receipt to the chain
    pub fn add(&mut self, receipt: Receipt) {
        self.receipts.push(receipt);
        self.root_hash = self.compute_root();
    }

    /// Get the previous receipt hash for a new receipt
    pub fn previous_hash(&self) -> String {
        self.receipts
            .last()
            .map(|r| r.receipt_hash.clone())
            .unwrap_or_else(|| hash_sha256(b"genesis"))
    }

    /// Compute Merkle root of all receipts
    fn compute_root(&self) -> String {
        if self.receipts.is_empty() {
            return hash_sha256(b"empty");
        }

        // Simple Merkle tree: hash pairs iteratively
        let mut hashes: Vec<String> = self.receipts.iter().map(|r| r.receipt_hash.clone()).collect();

        while hashes.len() > 1 {
            let mut new_hashes = Vec::new();
            for chunk in hashes.chunks(2) {
                let combined = if chunk.len() == 2 {
                    format!("{}{}", chunk[0], chunk[1])
                } else {
                    format!("{}{}", chunk[0], chunk[0]) // Duplicate odd element
                };
                new_hashes.push(hash_sha256(combined.as_bytes()));
            }
            hashes = new_hashes;
        }

        hashes.pop().unwrap_or_else(|| hash_sha256(b"empty"))
    }

    /// Recompute root hash
    fn recompute_root(&mut self) -> McpResult<()> {
        self.root_hash = self.compute_root();
        Ok(())
    }

    /// Verify the entire chain
    pub fn verify(&self) -> Result<(), ReceiptError> {
        if self.receipts.is_empty() {
            return Ok(());
        }

        // Verify each receipt's hash
        for receipt in &self.receipts {
            receipt.verify()?;
        }

        // Verify chain linkage
        let mut expected_prev = hash_sha256(b"genesis");
        for (i, receipt) in self.receipts.iter().enumerate() {
            if receipt.previous_receipt_hash != expected_prev {
                return Err(ReceiptError::ChainBroken {
                    index: i,
                    expected: expected_prev,
                    actual: receipt.previous_receipt_hash.clone(),
                });
            }
            expected_prev = receipt.receipt_hash.clone();
        }

        // Verify Merkle root
        let computed_root = self.compute_root();
        if computed_root != self.root_hash {
            return Err(ReceiptError::HashMismatch);
        }

        Ok(())
    }

    /// Get number of receipts
    pub fn len(&self) -> usize {
        self.receipts.len()
    }

    /// Check if chain is empty
    pub fn is_empty(&self) -> bool {
        self.receipts.is_empty()
    }

    /// Get the root hash
    pub fn root_hash(&self) -> &str {
        &self.root_hash
    }

    /// Get all receipts
    pub fn receipts(&self) -> &[Receipt] {
        &self.receipts
    }

    /// Serialize chain to JSON
    pub fn to_json(&self) -> McpResult<String> {
        serde_json::to_string(self)
            .map_err(|e| McpError::SerializationError(e.to_string()))
    }

    /// Deserialize chain from JSON
    pub fn from_json(json: &str) -> McpResult<Self> {
        serde_json::from_str(json)
            .map_err(|e| McpError::SerializationError(e.to_string()))
    }
}

impl Default for ReceiptChain {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_receipt(contract_id: &str, prev_hash: &str) -> Receipt {
        Receipt::new(
            contract_id.to_string(),
            "env-001".to_string(),
            hash_sha256(b"manifest"),
            ReceiptOutcome::Success,
            prev_hash.to_string(),
            1000,
        )
    }

    #[test]
    fn test_receipt_creation() {
        let receipt = make_receipt("contract-001", "prev-hash");

        assert!(!receipt.execution_id.is_empty());
        assert!(!receipt.receipt_hash.is_empty());
        assert_eq!(receipt.contract_id, "contract-001");
    }

    #[test]
    fn test_receipt_verification() {
        let receipt = make_receipt("contract-001", "prev-hash");
        assert!(receipt.verify().is_ok());
    }

    #[test]
    fn test_receipt_chain() {
        let mut chain = ReceiptChain::new();

        let r1 = make_receipt("contract-001", &chain.previous_hash());
        chain.add(r1);

        let r2 = make_receipt("contract-001", &chain.previous_hash());
        chain.add(r2);

        let r3 = make_receipt("contract-001", &chain.previous_hash());
        chain.add(r3);

        assert_eq!(chain.len(), 3);
        assert!(chain.verify().is_ok());
    }

    #[test]
    fn test_chain_verification_failure() {
        let mut chain = ReceiptChain::new();

        let r1 = make_receipt("contract-001", &chain.previous_hash());
        chain.add(r1);

        // Create receipt with wrong previous hash
        let r2 = make_receipt("contract-001", "wrong-hash");
        chain.add(r2);

        assert!(chain.verify().is_err());
    }

    #[test]
    fn test_outcome_hash() {
        let success = ReceiptOutcome::Success;
        let refusal = ReceiptOutcome::Refusal {
            code: "ENV-001".to_string(),
            message: "Envelope violated".to_string(),
        };

        // Different outcomes should have different hashes
        assert_ne!(success.hash(), refusal.hash());

        // Same outcome should have same hash (deterministic)
        let success2 = ReceiptOutcome::Success;
        assert_eq!(success.hash(), success2.hash());
    }

    #[test]
    fn test_receipt_serialization() {
        let receipt = make_receipt("contract-001", "prev-hash");

        let json = receipt.to_json().unwrap();
        let parsed = Receipt::from_json(&json).unwrap();

        assert_eq!(receipt.execution_id, parsed.execution_id);
        assert_eq!(receipt.receipt_hash, parsed.receipt_hash);
    }
}
