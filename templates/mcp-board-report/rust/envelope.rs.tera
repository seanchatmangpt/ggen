//! Envelope Enforcement Module
//!
//! Implements bounded operation envelopes for MCP+ contracts.
//! Envelopes define quantified limits within which contracts may operate:
//! - Time bounds (maximum execution duration)
//! - Resource bounds (memory, CPU, IO limits)
//! - Scope bounds (allowed data domains)
//! - Capability bounds (allowed operations)
//!
//! FAIL-CLOSED: Any uncertainty or violation produces deterministic refusal.
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

use crate::refusal::{Refusal, RefusalCategory, RefusalCode};
use crate::{McpError, McpResult};
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use uuid::Uuid;

/// Envelope bound types
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum EnvelopeBound {
    /// Maximum execution time in milliseconds
    Time { max_duration_ms: u64 },

    /// Maximum resource consumption
    Resource {
        max_memory_bytes: u64,
        max_cpu_percent: Option<u8>,
        max_io_bytes: Option<u64>,
    },

    /// Allowed data scopes
    Scope { allowed_scopes: HashSet<String> },

    /// Allowed capabilities/operations
    Capability { allowed_capabilities: HashSet<String> },
}

/// Envelope violation error
#[derive(Debug, thiserror::Error)]
pub enum EnvelopeError {
    #[error("Time bound exceeded: elapsed {elapsed_ms}ms > max {max_ms}ms")]
    TimeExceeded { elapsed_ms: u64, max_ms: u64 },

    #[error("Memory bound exceeded: used {used_bytes} > max {max_bytes}")]
    MemoryExceeded { used_bytes: u64, max_bytes: u64 },

    #[error("Scope not allowed: {scope}")]
    ScopeNotAllowed { scope: String },

    #[error("Capability not allowed: {capability}")]
    CapabilityNotAllowed { capability: String },

    #[error("Envelope not found: {envelope_id}")]
    NotFound { envelope_id: String },

    #[error("Envelope expired")]
    Expired,

    #[error("Envelope terminated")]
    Terminated,
}

impl EnvelopeError {
    /// Convert to deterministic refusal
    pub fn to_refusal(&self, envelope_id: &str) -> Refusal {
        let (code, category) = match self {
            EnvelopeError::TimeExceeded { .. } => {
                (RefusalCode::EnvTime, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::MemoryExceeded { .. } => {
                (RefusalCode::EnvResource, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::ScopeNotAllowed { .. } => {
                (RefusalCode::EnvScope, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::CapabilityNotAllowed { .. } => {
                (RefusalCode::EnvCapability, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::NotFound { .. } => {
                (RefusalCode::EnvNotFound, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::Expired => {
                (RefusalCode::EnvExpired, RefusalCategory::EnvelopeViolation)
            }
            EnvelopeError::Terminated => {
                (RefusalCode::EnvTerminated, RefusalCategory::EnvelopeViolation)
            }
        };

        Refusal::new(code, category, envelope_id.to_string(), self.to_string())
    }
}

/// Current usage tracking
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub memory_bytes: u64,
    pub cpu_time_ms: u64,
    pub io_bytes: u64,
    pub operations: u64,
}

impl Usage {
    /// Add usage from an operation
    pub fn add(&mut self, other: &Usage) {
        self.memory_bytes = self.memory_bytes.saturating_add(other.memory_bytes);
        self.cpu_time_ms = self.cpu_time_ms.saturating_add(other.cpu_time_ms);
        self.io_bytes = self.io_bytes.saturating_add(other.io_bytes);
        self.operations = self.operations.saturating_add(other.operations);
    }
}

/// Envelope state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum EnvelopeState {
    Initializing,
    Active,
    Exhausted,
    Violated,
    Terminated,
}

/// Operating envelope for bounded contract execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Envelope {
    pub id: String,
    pub contract_id: String,
    pub state: EnvelopeState,
    pub bounds: Vec<EnvelopeBound>,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
    pub usage: Usage,
}

impl Envelope {
    /// Create a new envelope with specified bounds
    pub fn new(contract_id: String, bounds: Vec<EnvelopeBound>, duration_ms: u64) -> Self {
        let now = Utc::now();
        let expires_at = now + Duration::milliseconds(duration_ms as i64);

        Self {
            id: format!("env-{}", Uuid::now_v7()),
            contract_id,
            state: EnvelopeState::Active,
            bounds,
            created_at: now,
            expires_at,
            usage: Usage::default(),
        }
    }

    /// Check if envelope is still valid (not expired, not terminated)
    pub fn is_valid(&self) -> bool {
        matches!(self.state, EnvelopeState::Active) && Utc::now() < self.expires_at
    }

    /// Get remaining time in milliseconds
    pub fn remaining_time_ms(&self) -> u64 {
        let now = Utc::now();
        if now >= self.expires_at {
            0
        } else {
            (self.expires_at - now).num_milliseconds().max(0) as u64
        }
    }

    /// Check if an operation is allowed within bounds
    pub fn check_operation(
        &self,
        scope: Option<&str>,
        capability: Option<&str>,
    ) -> Result<(), EnvelopeError> {
        // Check state first
        match self.state {
            EnvelopeState::Terminated => return Err(EnvelopeError::Terminated),
            EnvelopeState::Exhausted | EnvelopeState::Violated => {
                return Err(EnvelopeError::Expired)
            }
            EnvelopeState::Initializing => return Err(EnvelopeError::Expired),
            EnvelopeState::Active => {}
        }

        // Check time bound
        let now = Utc::now();
        if now >= self.expires_at {
            return Err(EnvelopeError::Expired);
        }

        // Check scope and capability bounds
        for bound in &self.bounds {
            match bound {
                EnvelopeBound::Scope { allowed_scopes } => {
                    if let Some(s) = scope {
                        if !allowed_scopes.contains(s) {
                            return Err(EnvelopeError::ScopeNotAllowed {
                                scope: s.to_string(),
                            });
                        }
                    }
                }
                EnvelopeBound::Capability { allowed_capabilities } => {
                    if let Some(c) = capability {
                        if !allowed_capabilities.contains(c) {
                            return Err(EnvelopeError::CapabilityNotAllowed {
                                capability: c.to_string(),
                            });
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(())
    }

    /// Record usage and check if bounds are exceeded
    pub fn record_usage(&mut self, usage: &Usage) -> Result<(), EnvelopeError> {
        self.usage.add(usage);

        // Check resource bounds
        for bound in &self.bounds {
            if let EnvelopeBound::Resource { max_memory_bytes, .. } = bound {
                if self.usage.memory_bytes > *max_memory_bytes {
                    self.state = EnvelopeState::Exhausted;
                    return Err(EnvelopeError::MemoryExceeded {
                        used_bytes: self.usage.memory_bytes,
                        max_bytes: *max_memory_bytes,
                    });
                }
            }
        }

        Ok(())
    }

    /// Mark envelope as violated
    pub fn mark_violated(&mut self) {
        self.state = EnvelopeState::Violated;
    }

    /// Terminate the envelope
    pub fn terminate(&mut self) {
        self.state = EnvelopeState::Terminated;
    }

    /// Get envelope status as a map (for Erlang interop)
    pub fn to_status_map(&self) -> serde_json::Value {
        serde_json::json!({
            "id": self.id,
            "contract_id": self.contract_id,
            "state": format!("{:?}", self.state),
            "remaining_time_ms": self.remaining_time_ms(),
            "usage": {
                "memory_bytes": self.usage.memory_bytes,
                "operations": self.usage.operations
            },
            "is_valid": self.is_valid()
        })
    }
}

/// Builder for creating envelopes with fluent API
pub struct EnvelopeBuilder {
    contract_id: String,
    bounds: Vec<EnvelopeBound>,
    duration_ms: u64,
}

impl EnvelopeBuilder {
    pub fn new(contract_id: impl Into<String>) -> Self {
        Self {
            contract_id: contract_id.into(),
            bounds: Vec::new(),
            duration_ms: 30_000, // 30 second default
        }
    }

    pub fn with_time_bound(mut self, max_duration_ms: u64) -> Self {
        self.duration_ms = max_duration_ms;
        self.bounds.push(EnvelopeBound::Time { max_duration_ms });
        self
    }

    pub fn with_memory_bound(mut self, max_memory_bytes: u64) -> Self {
        self.bounds.push(EnvelopeBound::Resource {
            max_memory_bytes,
            max_cpu_percent: None,
            max_io_bytes: None,
        });
        self
    }

    pub fn with_scopes(mut self, scopes: impl IntoIterator<Item = impl Into<String>>) -> Self {
        self.bounds.push(EnvelopeBound::Scope {
            allowed_scopes: scopes.into_iter().map(Into::into).collect(),
        });
        self
    }

    pub fn with_capabilities(
        mut self,
        capabilities: impl IntoIterator<Item = impl Into<String>>,
    ) -> Self {
        self.bounds.push(EnvelopeBound::Capability {
            allowed_capabilities: capabilities.into_iter().map(Into::into).collect(),
        });
        self
    }

    pub fn build(self) -> Envelope {
        Envelope::new(self.contract_id, self.bounds, self.duration_ms)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_envelope_creation() {
        let envelope = EnvelopeBuilder::new("contract-001")
            .with_time_bound(5000)
            .with_memory_bound(1024 * 1024)
            .build();

        assert!(envelope.is_valid());
        assert_eq!(envelope.state, EnvelopeState::Active);
    }

    #[test]
    fn test_scope_check() {
        let envelope = EnvelopeBuilder::new("contract-001")
            .with_scopes(["read", "write"])
            .build();

        // Allowed scope
        assert!(envelope.check_operation(Some("read"), None).is_ok());

        // Disallowed scope
        assert!(envelope.check_operation(Some("delete"), None).is_err());
    }

    #[test]
    fn test_capability_check() {
        let envelope = EnvelopeBuilder::new("contract-001")
            .with_capabilities(["query", "insert"])
            .build();

        // Allowed capability
        assert!(envelope.check_operation(None, Some("query")).is_ok());

        // Disallowed capability
        assert!(envelope.check_operation(None, Some("drop_table")).is_err());
    }

    #[test]
    fn test_memory_bound_enforcement() {
        let mut envelope = EnvelopeBuilder::new("contract-001")
            .with_memory_bound(1000)
            .build();

        // Under limit
        let usage1 = Usage {
            memory_bytes: 500,
            ..Default::default()
        };
        assert!(envelope.record_usage(&usage1).is_ok());

        // Over limit
        let usage2 = Usage {
            memory_bytes: 600,
            ..Default::default()
        };
        assert!(envelope.record_usage(&usage2).is_err());
        assert_eq!(envelope.state, EnvelopeState::Exhausted);
    }

    #[test]
    fn test_envelope_termination() {
        let mut envelope = EnvelopeBuilder::new("contract-001").build();

        assert!(envelope.is_valid());

        envelope.terminate();

        assert!(!envelope.is_valid());
        assert_eq!(envelope.state, EnvelopeState::Terminated);
    }

    #[test]
    fn test_error_to_refusal() {
        let error = EnvelopeError::ScopeNotAllowed {
            scope: "admin".to_string(),
        };

        let refusal = error.to_refusal("env-123");

        assert_eq!(refusal.code, RefusalCode::EnvScope);
        assert_eq!(refusal.category, RefusalCategory::EnvelopeViolation);
    }
}
