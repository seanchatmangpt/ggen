//! Deterministic Refusal Module
//!
//! Implements structured failure codes for MCP+ operations.
//! All refusals are:
//! - Deterministic (same input = same refusal)
//! - Categorized (maps to remediation playbooks)
//! - Text-blind (no payload exposure)
//!
//! Refusal Code Format: {PREFIX}-{NUMBER}
//! - ENV: Envelope violations
//! - KEY: Key/signing issues
//! - CAP: Capability denials
//! - VAL: Validation failures
//! - RES: Resource exhaustion
//! - KILL: Kill switch activations
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Refusal code enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RefusalCode {
    // Envelope violations (ENV-xxx)
    #[serde(rename = "ENV-001")]
    EnvTime,
    #[serde(rename = "ENV-002")]
    EnvResource,
    #[serde(rename = "ENV-003")]
    EnvScope,
    #[serde(rename = "ENV-004")]
    EnvCapability,
    #[serde(rename = "ENV-005")]
    EnvNotFound,
    #[serde(rename = "ENV-006")]
    EnvExpired,
    #[serde(rename = "ENV-007")]
    EnvTerminated,
    #[serde(rename = "ENV-008")]
    EnvInitializing,

    // Key/signing issues (KEY-xxx)
    #[serde(rename = "KEY-001")]
    KeyExpired,
    #[serde(rename = "KEY-002")]
    KeyRevoked,
    #[serde(rename = "KEY-003")]
    KeyInvalid,
    #[serde(rename = "KEY-004")]
    KeyNotFound,
    #[serde(rename = "KEY-005")]
    SignatureInvalid,

    // Capability denials (CAP-xxx)
    #[serde(rename = "CAP-001")]
    CapabilityDenied,
    #[serde(rename = "CAP-002")]
    CapabilityNotFound,
    #[serde(rename = "CAP-003")]
    CapabilityDisabled,

    // Validation failures (VAL-xxx)
    #[serde(rename = "VAL-001")]
    ValidationFailed,
    #[serde(rename = "VAL-002")]
    ContractInvalid,
    #[serde(rename = "VAL-003")]
    ManifestInvalid,
    #[serde(rename = "VAL-004")]
    InputInvalid,

    // Resource exhaustion (RES-xxx)
    #[serde(rename = "RES-001")]
    ResourceMemory,
    #[serde(rename = "RES-002")]
    ResourceCpu,
    #[serde(rename = "RES-003")]
    ResourceIo,
    #[serde(rename = "RES-004")]
    ResourceQuota,

    // Kill switch (KILL-xxx)
    #[serde(rename = "KILL-001")]
    KillGlobal,
    #[serde(rename = "KILL-002")]
    KillFamily,
    #[serde(rename = "KILL-003")]
    KillCapability,
    #[serde(rename = "KILL-004")]
    KillEpoch,
}

impl RefusalCode {
    /// Get the string representation of the code
    pub fn as_str(&self) -> &'static str {
        match self {
            RefusalCode::EnvTime => "ENV-001",
            RefusalCode::EnvResource => "ENV-002",
            RefusalCode::EnvScope => "ENV-003",
            RefusalCode::EnvCapability => "ENV-004",
            RefusalCode::EnvNotFound => "ENV-005",
            RefusalCode::EnvExpired => "ENV-006",
            RefusalCode::EnvTerminated => "ENV-007",
            RefusalCode::EnvInitializing => "ENV-008",
            RefusalCode::KeyExpired => "KEY-001",
            RefusalCode::KeyRevoked => "KEY-002",
            RefusalCode::KeyInvalid => "KEY-003",
            RefusalCode::KeyNotFound => "KEY-004",
            RefusalCode::SignatureInvalid => "KEY-005",
            RefusalCode::CapabilityDenied => "CAP-001",
            RefusalCode::CapabilityNotFound => "CAP-002",
            RefusalCode::CapabilityDisabled => "CAP-003",
            RefusalCode::ValidationFailed => "VAL-001",
            RefusalCode::ContractInvalid => "VAL-002",
            RefusalCode::ManifestInvalid => "VAL-003",
            RefusalCode::InputInvalid => "VAL-004",
            RefusalCode::ResourceMemory => "RES-001",
            RefusalCode::ResourceCpu => "RES-002",
            RefusalCode::ResourceIo => "RES-003",
            RefusalCode::ResourceQuota => "RES-004",
            RefusalCode::KillGlobal => "KILL-001",
            RefusalCode::KillFamily => "KILL-002",
            RefusalCode::KillCapability => "KILL-003",
            RefusalCode::KillEpoch => "KILL-004",
        }
    }

    /// Get severity level (for alerting)
    pub fn severity(&self) -> RefusalSeverity {
        match self {
            // Critical - immediate action required
            RefusalCode::KillGlobal
            | RefusalCode::KillFamily
            | RefusalCode::KillCapability
            | RefusalCode::KillEpoch
            | RefusalCode::KeyRevoked => RefusalSeverity::Critical,

            // High - should investigate
            RefusalCode::EnvTime
            | RefusalCode::EnvResource
            | RefusalCode::KeyExpired
            | RefusalCode::SignatureInvalid => RefusalSeverity::High,

            // Medium - normal operations
            RefusalCode::EnvScope
            | RefusalCode::EnvCapability
            | RefusalCode::CapabilityDenied
            | RefusalCode::ValidationFailed => RefusalSeverity::Medium,

            // Low - informational
            _ => RefusalSeverity::Low,
        }
    }
}

impl std::fmt::Display for RefusalCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Refusal severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum RefusalSeverity {
    Critical,
    High,
    Medium,
    Low,
}

/// Refusal category for grouping
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RefusalCategory {
    EnvelopeViolation,
    KeyIssue,
    CapabilityDenial,
    ValidationFailure,
    ResourceExhaustion,
    KillSwitch,
}

impl RefusalCategory {
    /// Get the prefix for this category
    pub fn prefix(&self) -> &'static str {
        match self {
            RefusalCategory::EnvelopeViolation => "ENV",
            RefusalCategory::KeyIssue => "KEY",
            RefusalCategory::CapabilityDenial => "CAP",
            RefusalCategory::ValidationFailure => "VAL",
            RefusalCategory::ResourceExhaustion => "RES",
            RefusalCategory::KillSwitch => "KILL",
        }
    }

    /// Get remediation playbook reference
    pub fn playbook(&self) -> &'static str {
        match self {
            RefusalCategory::EnvelopeViolation => "playbook/envelope-violation.md",
            RefusalCategory::KeyIssue => "playbook/key-issue.md",
            RefusalCategory::CapabilityDenial => "playbook/capability-denial.md",
            RefusalCategory::ValidationFailure => "playbook/validation-failure.md",
            RefusalCategory::ResourceExhaustion => "playbook/resource-exhaustion.md",
            RefusalCategory::KillSwitch => "playbook/kill-switch.md",
        }
    }
}

/// A deterministic refusal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Refusal {
    /// Refusal code (e.g., ENV-001)
    pub code: RefusalCode,

    /// Refusal category
    pub category: RefusalCategory,

    /// Envelope ID that was violated (if applicable)
    pub envelope_id: String,

    /// Human-readable message (no sensitive data)
    pub message: String,

    /// Timestamp of refusal
    pub timestamp: DateTime<Utc>,

    /// Severity level
    pub severity: RefusalSeverity,

    /// Playbook reference for remediation
    pub playbook: String,
}

impl Refusal {
    /// Create a new refusal
    pub fn new(
        code: RefusalCode,
        category: RefusalCategory,
        envelope_id: String,
        message: String,
    ) -> Self {
        Self {
            code,
            category,
            envelope_id,
            message,
            timestamp: Utc::now(),
            severity: code.severity(),
            playbook: category.playbook().to_string(),
        }
    }

    /// Create a refusal from an envelope violation
    pub fn envelope_violation(code: RefusalCode, envelope_id: &str, message: &str) -> Self {
        Self::new(
            code,
            RefusalCategory::EnvelopeViolation,
            envelope_id.to_string(),
            message.to_string(),
        )
    }

    /// Create a kill switch refusal
    pub fn kill_switch(code: RefusalCode, message: &str) -> Self {
        Self::new(
            code,
            RefusalCategory::KillSwitch,
            String::new(),
            message.to_string(),
        )
    }

    /// Convert to Erlang-compatible tuple format
    pub fn to_erlang_tuple(&self) -> (String, String, String) {
        (
            self.code.as_str().to_string(),
            self.category.prefix().to_string(),
            self.message.clone(),
        )
    }

    /// Serialize to JSON
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }
}

impl std::fmt::Display for Refusal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{}] {}: {}", self.code, self.category.prefix(), self.message)
    }
}

/// Collect multiple refusals for batch reporting
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct RefusalBatch {
    refusals: Vec<Refusal>,
}

impl RefusalBatch {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add(&mut self, refusal: Refusal) {
        self.refusals.push(refusal);
    }

    pub fn is_empty(&self) -> bool {
        self.refusals.is_empty()
    }

    pub fn len(&self) -> usize {
        self.refusals.len()
    }

    pub fn iter(&self) -> impl Iterator<Item = &Refusal> {
        self.refusals.iter()
    }

    /// Get count by category
    pub fn count_by_category(&self) -> std::collections::HashMap<RefusalCategory, usize> {
        let mut counts = std::collections::HashMap::new();
        for refusal in &self.refusals {
            *counts.entry(refusal.category).or_insert(0) += 1;
        }
        counts
    }

    /// Get highest severity in batch
    pub fn max_severity(&self) -> Option<RefusalSeverity> {
        self.refusals
            .iter()
            .map(|r| r.severity)
            .max_by_key(|s| match s {
                RefusalSeverity::Critical => 4,
                RefusalSeverity::High => 3,
                RefusalSeverity::Medium => 2,
                RefusalSeverity::Low => 1,
            })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_refusal_code_string() {
        assert_eq!(RefusalCode::EnvTime.as_str(), "ENV-001");
        assert_eq!(RefusalCode::KillGlobal.as_str(), "KILL-001");
    }

    #[test]
    fn test_refusal_severity() {
        assert_eq!(RefusalCode::KillGlobal.severity(), RefusalSeverity::Critical);
        assert_eq!(RefusalCode::EnvTime.severity(), RefusalSeverity::High);
        assert_eq!(RefusalCode::EnvScope.severity(), RefusalSeverity::Medium);
    }

    #[test]
    fn test_refusal_creation() {
        let refusal = Refusal::envelope_violation(
            RefusalCode::EnvTime,
            "env-123",
            "Time bound exceeded",
        );

        assert_eq!(refusal.code, RefusalCode::EnvTime);
        assert_eq!(refusal.category, RefusalCategory::EnvelopeViolation);
        assert_eq!(refusal.envelope_id, "env-123");
    }

    #[test]
    fn test_refusal_batch() {
        let mut batch = RefusalBatch::new();

        batch.add(Refusal::envelope_violation(
            RefusalCode::EnvTime,
            "env-1",
            "Time exceeded",
        ));
        batch.add(Refusal::kill_switch(RefusalCode::KillGlobal, "Kill switch"));

        assert_eq!(batch.len(), 2);
        assert_eq!(batch.max_severity(), Some(RefusalSeverity::Critical));

        let counts = batch.count_by_category();
        assert_eq!(counts.get(&RefusalCategory::EnvelopeViolation), Some(&1));
        assert_eq!(counts.get(&RefusalCategory::KillSwitch), Some(&1));
    }

    #[test]
    fn test_refusal_json() {
        let refusal = Refusal::envelope_violation(
            RefusalCode::EnvScope,
            "env-456",
            "Scope not allowed",
        );

        let json = refusal.to_json().unwrap();
        assert!(json.contains("ENV-003"));
        assert!(json.contains("env-456"));
    }
}
