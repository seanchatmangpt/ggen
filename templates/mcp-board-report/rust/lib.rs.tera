//! MCP+ Cryptographic NIF Library
//!
//! Rust implementation of cryptographic operations for the MCP+
//! Board Report Generation System. Provides:
//!
//! - SHA-256/SHA3-256 hashing
//! - Ed25519 signing/verification
//! - Receipt generation and chaining
//! - Envelope bound enforcement
//! - Evidence bundle generation
//!
//! Core axiom: A = μ(O), μ ∘ μ = μ, hash(A) = hash(μ(O)), O ⊨ Σ
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

#![forbid(unsafe_code)]
#![deny(clippy::unwrap_used, clippy::expect_used)]
#![warn(clippy::pedantic, clippy::nursery)]

mod bundle;
mod crypto;
mod envelope;
mod nif;
mod receipt;
mod refusal;

pub use bundle::{Bundle, BundleBuilder, BundleError};
pub use crypto::{hash_sha256, hash_sha3_256, sign_data, verify_signature, KeyPair};
pub use envelope::{Envelope, EnvelopeBound, EnvelopeError};
pub use nif::*;
pub use receipt::{Receipt, ReceiptChain, ReceiptError};
pub use refusal::{Refusal, RefusalCategory, RefusalCode};

use rustler::{Encoder, Env, NifResult, Term};
use std::panic;

/// Initialize the NIF module
rustler::init!("mcp_nif");

/// Panic safety wrapper for NIF functions
///
/// Catches any panics and converts them to Erlang errors
/// to prevent BEAM VM crashes.
fn safe_nif<F, T>(env: Env<'_>, f: F) -> NifResult<T>
where
    F: FnOnce() -> Result<T, McpError> + panic::UnwindSafe,
    T: Encoder,
{
    match panic::catch_unwind(f) {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(e)) => Err(rustler::Error::Term(Box::new(e.to_error_tuple(env)))),
        Err(_) => Err(rustler::Error::Term(Box::new(
            McpError::InternalPanic.to_error_tuple(env),
        ))),
    }
}

/// Core error type for MCP+ operations
#[derive(Debug, thiserror::Error)]
pub enum McpError {
    #[error("Cryptographic operation failed: {0}")]
    CryptoError(String),

    #[error("Envelope violation: {code} - {message}")]
    EnvelopeViolation { code: String, message: String },

    #[error("Receipt chain invalid: {0}")]
    ReceiptChainError(String),

    #[error("Bundle error: {0}")]
    BundleError(String),

    #[error("Serialization error: {0}")]
    SerializationError(String),

    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("Key epoch error: {0}")]
    KeyEpochError(String),

    #[error("Internal panic caught")]
    InternalPanic,
}

impl McpError {
    /// Convert to Erlang error tuple
    fn to_error_tuple(&self, env: Env<'_>) -> Term<'_> {
        let error_atom = rustler::Atom::from_str(env, "error")
            .unwrap_or_else(|_| rustler::Atom::from_str(env, "error").unwrap());
        let message = self.to_string();
        (error_atom, message).encode(env)
    }

    /// Extract refusal code if this is an envelope violation
    pub fn refusal_code(&self) -> Option<&str> {
        match self {
            McpError::EnvelopeViolation { code, .. } => Some(code),
            _ => None,
        }
    }
}

/// Result type for MCP+ operations
pub type McpResult<T> = Result<T, McpError>;

/// Version information
pub const VERSION: &str = "1.0.0";

/// Axiom set for verification
pub mod axioms {
    pub const CORE: &str = "A = μ(O)";
    pub const IDEMPOTENT: &str = "μ ∘ μ = μ";
    pub const DETERMINISTIC: &str = "hash(A) = hash(μ(O))";
    pub const VALID: &str = "O ⊨ Σ";
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version() {
        assert_eq!(VERSION, "1.0.0");
    }

    #[test]
    fn test_axioms() {
        assert_eq!(axioms::CORE, "A = μ(O)");
        assert_eq!(axioms::IDEMPOTENT, "μ ∘ μ = μ");
    }
}
