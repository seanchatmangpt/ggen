//! Erlang NIF Bindings
//!
//! Provides NIF (Native Implemented Functions) for Erlang integration.
//! Uses Rustler for safe, zero-copy bindings where possible.
//!
//! All NIF functions run on dirty schedulers to prevent blocking
//! the BEAM VM's normal schedulers.
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

use crate::bundle::{Bundle, BundleBuilder, VerificationResult};
use crate::crypto::{hash_sha256, hash_sha3_256, sign_data, verify_signature, KeyEpoch, KeyPair};
use crate::envelope::{Envelope, EnvelopeBound, EnvelopeBuilder};
use crate::receipt::{Receipt, ReceiptChain, ReceiptOutcome};
use crate::refusal::{Refusal, RefusalCategory, RefusalCode};
use rustler::{Atom, Encoder, Env, NifResult, Term};
use std::collections::HashMap;

mod atoms {
    rustler::atoms! {
        ok,
        error,
        pass,
        fail,
        refusal,

        // Envelope states
        initializing,
        active,
        exhausted,
        violated,
        terminated,

        // Outcome types
        success,
    }
}

// =============================================================================
// Cryptographic Operations
// =============================================================================

/// Hash data using SHA-256
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_hash_sha256(data: rustler::Binary) -> String {
    hash_sha256(data.as_slice())
}

/// Hash data using SHA3-256
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_hash_sha3_256(data: rustler::Binary) -> String {
    hash_sha3_256(data.as_slice())
}

/// Verify Ed25519 signature
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_verify_signature<'a>(
    env: Env<'a>,
    data: rustler::Binary,
    signature: rustler::Binary,
    public_key: rustler::Binary,
) -> Term<'a> {
    match verify_signature(data.as_slice(), signature.as_slice(), public_key.as_slice()) {
        Ok(()) => atoms::ok().encode(env),
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Sign data with private key
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_sign_data<'a>(
    env: Env<'a>,
    data: rustler::Binary,
    private_key: rustler::Binary,
) -> Term<'a> {
    match sign_data(data.as_slice(), private_key.as_slice()) {
        Ok(sig) => (atoms::ok(), sig).encode(env),
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Generate a new keypair
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_generate_keypair<'a>(env: Env<'a>) -> Term<'a> {
    match KeyPair::generate() {
        Ok(keypair) => {
            let mut result = HashMap::new();
            result.insert("public_key", hex::encode(keypair.public_key_bytes()));
            result.insert("public_key_hash", keypair.public_key_hash());
            (atoms::ok(), result).encode(env)
        }
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

// =============================================================================
// Receipt Operations
// =============================================================================

/// Create a new receipt
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_create_receipt<'a>(
    env: Env<'a>,
    contract_id: String,
    envelope_id: String,
    manifest_hash: String,
    previous_hash: String,
    duration_us: u64,
) -> Term<'a> {
    let receipt = Receipt::new(
        contract_id,
        envelope_id,
        manifest_hash,
        ReceiptOutcome::Success,
        previous_hash,
        duration_us,
    );

    match receipt.to_json() {
        Ok(json) => (atoms::ok(), json).encode(env),
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Verify a receipt
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_verify_receipt<'a>(env: Env<'a>, receipt_json: String) -> Term<'a> {
    match Receipt::from_json(&receipt_json) {
        Ok(receipt) => match receipt.verify() {
            Ok(()) => atoms::ok().encode(env),
            Err(e) => (atoms::error(), e.to_string()).encode(env),
        },
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Verify a receipt chain
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_verify_receipt_chain<'a>(env: Env<'a>, receipts_json: Vec<String>) -> Term<'a> {
    let receipts: Result<Vec<Receipt>, _> = receipts_json
        .iter()
        .map(|j| Receipt::from_json(j))
        .collect();

    match receipts {
        Ok(receipts) => match ReceiptChain::from_receipts(receipts) {
            Ok(chain) => match chain.verify() {
                Ok(()) => atoms::ok().encode(env),
                Err(e) => (atoms::error(), e.to_string()).encode(env),
            },
            Err(e) => (atoms::error(), e.to_string()).encode(env),
        },
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

// =============================================================================
// Envelope Operations
// =============================================================================

/// Check envelope bounds
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_check_envelope_bounds<'a>(
    env: Env<'a>,
    envelope_json: String,
    scope: Option<String>,
    capability: Option<String>,
) -> Term<'a> {
    match serde_json::from_str::<Envelope>(&envelope_json) {
        Ok(envelope) => {
            match envelope.check_operation(scope.as_deref(), capability.as_deref()) {
                Ok(()) => atoms::ok().encode(env),
                Err(e) => {
                    let refusal = e.to_refusal(&envelope.id);
                    (
                        atoms::refusal(),
                        refusal.code.as_str(),
                        refusal.message,
                    )
                        .encode(env)
                }
            }
        }
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Create a new envelope
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_create_envelope<'a>(
    env: Env<'a>,
    contract_id: String,
    time_bound_ms: u64,
    memory_bound_bytes: u64,
    scopes: Vec<String>,
    capabilities: Vec<String>,
) -> Term<'a> {
    let envelope = EnvelopeBuilder::new(contract_id)
        .with_time_bound(time_bound_ms)
        .with_memory_bound(memory_bound_bytes)
        .with_scopes(scopes)
        .with_capabilities(capabilities)
        .build();

    match serde_json::to_string(&envelope) {
        Ok(json) => (atoms::ok(), json).encode(env),
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

// =============================================================================
// Bundle Operations
// =============================================================================

/// Generate an evidence bundle
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_generate_bundle<'a>(
    env: Env<'a>,
    contract_family: String,
    receipts_json: Vec<String>,
    refusals_json: Vec<String>,
) -> Term<'a> {
    let receipts: Result<Vec<Receipt>, _> = receipts_json
        .iter()
        .map(|j| Receipt::from_json(j))
        .collect();

    let refusals: Result<Vec<Refusal>, _> = refusals_json
        .iter()
        .map(|j| serde_json::from_str(j))
        .collect();

    match (receipts, refusals) {
        (Ok(receipts), Ok(refusals)) => {
            match BundleBuilder::new(contract_family)
                .with_receipts(receipts)
                .with_refusals(refusals)
                .build()
            {
                Ok(bundle) => match bundle.to_json() {
                    Ok(json) => (atoms::ok(), json).encode(env),
                    Err(e) => (atoms::error(), e.to_string()).encode(env),
                },
                Err(e) => (atoms::error(), e.to_string()).encode(env),
            }
        }
        (Err(e), _) => (atoms::error(), format!("Receipt parse error: {e}")).encode(env),
        (_, Err(e)) => (atoms::error(), format!("Refusal parse error: {e}")).encode(env),
    }
}

/// Verify an evidence bundle (text-blind)
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_verify_bundle<'a>(env: Env<'a>, bundle_json: String) -> Term<'a> {
    match Bundle::from_json(&bundle_json) {
        Ok(bundle) => match bundle.verify() {
            Ok(result) => {
                if result.passed {
                    atoms::pass().encode(env)
                } else {
                    atoms::fail().encode(env)
                }
            }
            Err(_) => atoms::fail().encode(env),
        },
        Err(_) => atoms::fail().encode(env),
    }
}

// =============================================================================
// Key Epoch Operations
// =============================================================================

/// Create a new key epoch
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_create_epoch<'a>(
    env: Env<'a>,
    epoch_id: String,
    public_key_hash: String,
    duration_days: i64,
) -> Term<'a> {
    let epoch = KeyEpoch::new(epoch_id, public_key_hash, duration_days);

    match serde_json::to_string(&epoch) {
        Ok(json) => (atoms::ok(), json).encode(env),
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

/// Verify key epoch is valid
#[rustler::nif(schedule = "DirtyCpu")]
fn nif_verify_epoch<'a>(env: Env<'a>, epoch_json: String) -> Term<'a> {
    match serde_json::from_str::<KeyEpoch>(&epoch_json) {
        Ok(epoch) => {
            if epoch.is_valid() {
                atoms::ok().encode(env)
            } else if epoch.is_revoked {
                (atoms::error(), "epoch_revoked").encode(env)
            } else {
                (atoms::error(), "epoch_expired").encode(env)
            }
        }
        Err(e) => (atoms::error(), e.to_string()).encode(env),
    }
}

// =============================================================================
// NIF Registration
// =============================================================================

rustler::init!(
    "mcp_nif",
    [
        // Crypto
        nif_hash_sha256,
        nif_hash_sha3_256,
        nif_verify_signature,
        nif_sign_data,
        nif_generate_keypair,
        // Receipts
        nif_create_receipt,
        nif_verify_receipt,
        nif_verify_receipt_chain,
        // Envelopes
        nif_check_envelope_bounds,
        nif_create_envelope,
        // Bundles
        nif_generate_bundle,
        nif_verify_bundle,
        // Key epochs
        nif_create_epoch,
        nif_verify_epoch,
    ]
);
