//! Evidence Bundle Module (.mcpb)
//!
//! Implements self-describing evidence bundles for MCP+.
//! Bundles contain receipts, refusals, and metrics for
//! text-blind verification by auditors and regulators.
//!
//! Bundle Format:
//! - Self-describing header with version
//! - Receipts array (Merkle-chained)
//! - Refusals array
//! - Metrics summary
//! - Attestation signatures
//! - Bundle hash (SHA-256)
//!
//! Generated by ggen - DO NOT EDIT MANUALLY
//! Regenerate with: ggen sync --audit true

use crate::crypto::hash_sha256;
use crate::receipt::{Receipt, ReceiptChain};
use crate::refusal::{Refusal, RefusalBatch};
use crate::{McpError, McpResult};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Bundle format version
pub const BUNDLE_VERSION: &str = "1.0.0";

/// Bundle file extension
pub const BUNDLE_EXTENSION: &str = ".mcpb";

/// Bundle error types
#[derive(Debug, thiserror::Error)]
pub enum BundleError {
    #[error("Bundle version mismatch: expected {expected}, got {actual}")]
    VersionMismatch { expected: String, actual: String },

    #[error("Bundle hash invalid")]
    HashInvalid,

    #[error("Bundle signature invalid")]
    SignatureInvalid,

    #[error("Bundle receipt chain invalid: {0}")]
    ReceiptChainInvalid(String),

    #[error("Bundle serialization failed: {0}")]
    SerializationFailed(String),
}

/// Metrics summary for the bundle
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct BundleMetrics {
    /// Total operations executed
    pub total_operations: u64,

    /// Successful operations
    pub successful_operations: u64,

    /// Refused operations
    pub refused_operations: u64,

    /// Total execution time in microseconds
    pub total_duration_us: u64,

    /// Average execution time in microseconds
    pub avg_duration_us: u64,

    /// Peak memory usage in bytes
    pub peak_memory_bytes: u64,

    /// Refusals by category
    pub refusals_by_category: std::collections::HashMap<String, u64>,
}

impl BundleMetrics {
    /// Create from receipts and refusals
    pub fn from_data(receipts: &[Receipt], refusals: &[Refusal]) -> Self {
        let total_operations = receipts.len() as u64;
        let successful_operations = receipts
            .iter()
            .filter(|r| matches!(r.outcome, crate::receipt::ReceiptOutcome::Success))
            .count() as u64;
        let refused_operations = refusals.len() as u64;

        let total_duration_us: u64 = receipts.iter().map(|r| r.duration_us).sum();
        let avg_duration_us = if total_operations > 0 {
            total_duration_us / total_operations
        } else {
            0
        };

        let mut refusals_by_category = std::collections::HashMap::new();
        for refusal in refusals {
            let category = refusal.category.prefix().to_string();
            *refusals_by_category.entry(category).or_insert(0) += 1;
        }

        Self {
            total_operations,
            successful_operations,
            refused_operations,
            total_duration_us,
            avg_duration_us,
            peak_memory_bytes: 0, // Would be tracked separately
            refusals_by_category,
        }
    }
}

/// Attestation signature
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attestation {
    /// Signer identity (public key hash)
    pub signer_id: String,

    /// Signature over bundle hash
    pub signature: String,

    /// Signing timestamp
    pub signed_at: DateTime<Utc>,

    /// Signing key epoch
    pub key_epoch: String,
}

/// Evidence bundle for verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bundle {
    /// Bundle format version
    pub version: String,

    /// Unique bundle ID
    pub bundle_id: String,

    /// Creation timestamp
    pub created_at: DateTime<Utc>,

    /// Time period covered (start)
    pub period_start: DateTime<Utc>,

    /// Time period covered (end)
    pub period_end: DateTime<Utc>,

    /// Contract family this bundle covers
    pub contract_family: String,

    /// Receipt chain root hash
    pub receipt_chain_root: String,

    /// All receipts (Merkle-chained)
    pub receipts: Vec<Receipt>,

    /// All refusals
    pub refusals: Vec<Refusal>,

    /// Metrics summary
    pub metrics: BundleMetrics,

    /// Attestation signatures
    pub attestations: Vec<Attestation>,

    /// SHA-256 hash of bundle (excluding this field)
    pub bundle_hash: String,
}

impl Bundle {
    /// Create a new bundle from receipts and refusals
    pub fn new(
        contract_family: String,
        receipts: Vec<Receipt>,
        refusals: Vec<Refusal>,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
    ) -> McpResult<Self> {
        let chain = ReceiptChain::from_receipts(receipts.clone())?;
        let metrics = BundleMetrics::from_data(&receipts, &refusals);

        let mut bundle = Self {
            version: BUNDLE_VERSION.to_string(),
            bundle_id: format!("bundle-{}", Uuid::now_v7()),
            created_at: Utc::now(),
            period_start,
            period_end,
            contract_family,
            receipt_chain_root: chain.root_hash().to_string(),
            receipts,
            refusals,
            metrics,
            attestations: Vec::new(),
            bundle_hash: String::new(),
        };

        bundle.bundle_hash = bundle.compute_hash();
        Ok(bundle)
    }

    /// Compute the hash of the bundle (for signing)
    fn compute_hash(&self) -> String {
        // Hash all fields except bundle_hash and attestations
        let data = format!(
            "{}|{}|{}|{}|{}|{}|{}|{}|{}",
            self.version,
            self.bundle_id,
            self.created_at.to_rfc3339(),
            self.period_start.to_rfc3339(),
            self.period_end.to_rfc3339(),
            self.contract_family,
            self.receipt_chain_root,
            self.receipts.len(),
            self.refusals.len(),
        );
        hash_sha256(data.as_bytes())
    }

    /// Verify the bundle integrity
    pub fn verify(&self) -> Result<VerificationResult, BundleError> {
        let mut result = VerificationResult::default();

        // Verify version
        if self.version != BUNDLE_VERSION {
            return Err(BundleError::VersionMismatch {
                expected: BUNDLE_VERSION.to_string(),
                actual: self.version.clone(),
            });
        }
        result.version_valid = true;

        // Verify bundle hash
        let computed_hash = self.compute_hash();
        if computed_hash != self.bundle_hash {
            return Err(BundleError::HashInvalid);
        }
        result.hash_valid = true;

        // Verify receipt chain
        let chain = ReceiptChain::from_receipts(self.receipts.clone())
            .map_err(|e| BundleError::ReceiptChainInvalid(e.to_string()))?;

        if chain.root_hash() != self.receipt_chain_root {
            return Err(BundleError::ReceiptChainInvalid(
                "Root hash mismatch".to_string(),
            ));
        }

        chain
            .verify()
            .map_err(|e| BundleError::ReceiptChainInvalid(e.to_string()))?;

        result.chain_valid = true;

        // Verify individual receipts
        for receipt in &self.receipts {
            receipt
                .verify()
                .map_err(|e| BundleError::ReceiptChainInvalid(e.to_string()))?;
        }
        result.receipts_valid = true;

        result.passed = true;
        Ok(result)
    }

    /// Add an attestation signature
    pub fn add_attestation(&mut self, attestation: Attestation) {
        self.attestations.push(attestation);
    }

    /// Serialize to JSON
    pub fn to_json(&self) -> McpResult<String> {
        serde_json::to_string_pretty(self)
            .map_err(|e| McpError::SerializationError(e.to_string()))
    }

    /// Serialize to binary (for .mcpb file)
    pub fn to_bytes(&self) -> McpResult<Vec<u8>> {
        bincode::serialize(self).map_err(|e| McpError::SerializationError(e.to_string()))
    }

    /// Deserialize from JSON
    pub fn from_json(json: &str) -> McpResult<Self> {
        serde_json::from_str(json).map_err(|e| McpError::SerializationError(e.to_string()))
    }

    /// Deserialize from binary
    pub fn from_bytes(bytes: &[u8]) -> McpResult<Self> {
        bincode::deserialize(bytes).map_err(|e| McpError::SerializationError(e.to_string()))
    }
}

/// Verification result
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct VerificationResult {
    pub passed: bool,
    pub version_valid: bool,
    pub hash_valid: bool,
    pub chain_valid: bool,
    pub receipts_valid: bool,
    pub attestations_valid: bool,
}

impl VerificationResult {
    /// Convert to pass/fail for Erlang
    pub fn to_erlang(&self) -> &'static str {
        if self.passed {
            "pass"
        } else {
            "fail"
        }
    }
}

/// Builder for creating bundles
pub struct BundleBuilder {
    contract_family: String,
    receipts: Vec<Receipt>,
    refusals: Vec<Refusal>,
    period_start: Option<DateTime<Utc>>,
    period_end: Option<DateTime<Utc>>,
}

impl BundleBuilder {
    pub fn new(contract_family: impl Into<String>) -> Self {
        Self {
            contract_family: contract_family.into(),
            receipts: Vec::new(),
            refusals: Vec::new(),
            period_start: None,
            period_end: None,
        }
    }

    pub fn with_receipts(mut self, receipts: Vec<Receipt>) -> Self {
        self.receipts = receipts;
        self
    }

    pub fn with_refusals(mut self, refusals: Vec<Refusal>) -> Self {
        self.refusals = refusals;
        self
    }

    pub fn add_receipt(mut self, receipt: Receipt) -> Self {
        self.receipts.push(receipt);
        self
    }

    pub fn add_refusal(mut self, refusal: Refusal) -> Self {
        self.refusals.push(refusal);
        self
    }

    pub fn with_period(mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Self {
        self.period_start = Some(start);
        self.period_end = Some(end);
        self
    }

    pub fn build(self) -> McpResult<Bundle> {
        let period_start = self.period_start.unwrap_or_else(|| {
            self.receipts
                .first()
                .map(|r| r.timestamp)
                .unwrap_or_else(Utc::now)
        });

        let period_end = self.period_end.unwrap_or_else(|| {
            self.receipts
                .last()
                .map(|r| r.timestamp)
                .unwrap_or_else(Utc::now)
        });

        Bundle::new(
            self.contract_family,
            self.receipts,
            self.refusals,
            period_start,
            period_end,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::hash_sha256;
    use crate::receipt::ReceiptOutcome;
    use crate::refusal::{RefusalCategory, RefusalCode};

    fn make_receipt(contract_id: &str, prev_hash: &str) -> Receipt {
        Receipt::new(
            contract_id.to_string(),
            "env-001".to_string(),
            hash_sha256(b"manifest"),
            ReceiptOutcome::Success,
            prev_hash.to_string(),
            1000,
        )
    }

    #[test]
    fn test_bundle_creation() {
        let receipts = vec![
            make_receipt("contract-001", &hash_sha256(b"genesis")),
        ];

        let bundle = BundleBuilder::new("test-family")
            .with_receipts(receipts)
            .build()
            .unwrap();

        assert_eq!(bundle.version, BUNDLE_VERSION);
        assert!(!bundle.bundle_id.is_empty());
        assert!(!bundle.bundle_hash.is_empty());
    }

    #[test]
    fn test_bundle_verification() {
        let r1 = make_receipt("contract-001", &hash_sha256(b"genesis"));
        let r2_prev = r1.receipt_hash.clone();
        let r2 = make_receipt("contract-001", &r2_prev);

        let bundle = BundleBuilder::new("test-family")
            .with_receipts(vec![r1, r2])
            .build()
            .unwrap();

        let result = bundle.verify().unwrap();
        assert!(result.passed);
        assert!(result.version_valid);
        assert!(result.hash_valid);
        assert!(result.chain_valid);
    }

    #[test]
    fn test_bundle_with_refusals() {
        let receipts = vec![make_receipt("contract-001", &hash_sha256(b"genesis"))];
        let refusals = vec![Refusal::new(
            RefusalCode::EnvTime,
            RefusalCategory::EnvelopeViolation,
            "env-001".to_string(),
            "Time exceeded".to_string(),
        )];

        let bundle = BundleBuilder::new("test-family")
            .with_receipts(receipts)
            .with_refusals(refusals)
            .build()
            .unwrap();

        assert_eq!(bundle.metrics.refused_operations, 1);
        assert!(bundle
            .metrics
            .refusals_by_category
            .contains_key("ENV"));
    }

    #[test]
    fn test_bundle_serialization() {
        let receipts = vec![make_receipt("contract-001", &hash_sha256(b"genesis"))];

        let bundle = BundleBuilder::new("test-family")
            .with_receipts(receipts)
            .build()
            .unwrap();

        // JSON round-trip
        let json = bundle.to_json().unwrap();
        let parsed = Bundle::from_json(&json).unwrap();
        assert_eq!(bundle.bundle_id, parsed.bundle_id);

        // Binary round-trip
        let bytes = bundle.to_bytes().unwrap();
        let parsed = Bundle::from_bytes(&bytes).unwrap();
        assert_eq!(bundle.bundle_hash, parsed.bundle_hash);
    }
}
