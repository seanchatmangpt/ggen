---
to: "{{ project_name }}/src/cmds/{{ noun }}/{{ verb }}.rs"
vars:
  noun: "resource"
  verb: "delete"
  noun_description: "resource"
---
//! {{ verb | capitalize }} {{ noun_description }} command

use clap_noun_verb_macros::verb;
use clap_noun_verb::Result;
use serde::Serialize;

#[derive(Debug, Serialize)]
pub struct DeleteResult {
    id: String,
    message: String,
    deleted: bool,
    dry_run: bool,
}

/// Delete a {{ noun_description }}
#[verb] // Verb "delete" auto-inferred, noun "{{ noun }}" auto-inferred from directory
pub fn delete_{{ noun }}(
    /// ID or name of the {{ noun_description }}
    #[arg(index = 0)]
    id: String,
    /// Force deletion without confirmation
    #[arg(short, long)]
    force: bool,
    /// Dry run (don't actually delete)
    #[arg(long)]
    dry_run: bool,
    /// Enable verbose output
    #[arg(short, long)]
    verbose: bool,
) -> Result<DeleteResult> {
    if verbose {
        eprintln!("Deleting {{ noun_description }}: {}", id);
    }

    // TODO: Implement delete logic here
    let (deleted, message) = if dry_run {
        (false, format!("Would delete {{ noun_description }}: {}", id))
    } else if !force {
        (
            false,
            format!(
                "Deletion requires --force flag. Use --force to confirm deletion of '{}'",
                id
            ),
        )
    } else {
        (
            true,
            format!("{{ noun | capitalize }} '{}' deleted successfully!", id),
        )
    };

    Ok(DeleteResult {
        id,
        message,
        deleted,
        dry_run,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_{{ verb }}_dry_run() {
        let result = delete_{{ noun }}("test-123".to_string(), true, true, false);
        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(output.dry_run);
        assert!(!output.deleted);
    }
}
