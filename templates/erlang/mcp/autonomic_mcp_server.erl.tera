%%%-----------------------------------------------------------------------------
%%% @doc Autonomic MCP Server - OTP Gen_Server wrapper for erlmcp_server
%%%
%%% Integrates Model Context Protocol with MAPE-K autonomic computing loop.
%%% Provides 10 resources, 8 tools, and 5 subscription managers for real-time
%%% distributed system monitoring and chaos engineering.
%%%
%%% Resources expose cluster health, MAPE-K phases, node metrics, and knowledge
%%% graph data. Tools enable chaos injection, knowledge queries, and autonomic
%%% plan execution. Subscriptions provide real-time updates on system state.
%%%
%%% @end
%%%-----------------------------------------------------------------------------
-module(autonomic_mcp_server).
-behaviour(gen_server).

%% API
-export([start_link/0, start_link/1]).
-export([stop/0]).
-export([get_stats/0, get_resource/1, invoke_tool/2]).
-export([subscribe/2, unsubscribe/1]).
-export([health_check/0]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

%% Internal exports for resource/tool handlers
-export([cluster_health_handler/1, mape_k_phases_handler/1,
         node_metrics_handler/1, chaos_history_handler/1,
         knowledge_graph_handler/1, network_topology_handler/1,
         service_dependencies_handler/1, slo_violations_handler/1,
         recovery_actions_handler/1, adaptation_policies_handler/1]).

-export([trigger_chaos_handler/1, query_knowledge_handler/1,
         execute_plan_handler/1, analyze_metrics_handler/1,
         monitor_sensor_handler/1, plan_adaptation_handler/1,
         execute_recovery_handler/1, validate_policy_handler/1]).

%%%=============================================================================
%%% Records and Types
%%%=============================================================================

-record(state, {
    mcp_server :: pid(),
    subscriptions :: #{binary() => subscription()},
    resources :: #{binary() => resource()},
    tools :: #{binary() => tool()},
    stats :: stats(),
    health_timer :: timer:tref(),
    config :: config()
}).

-record(subscription, {
    id :: binary(),
    uri :: binary(),
    subscriber :: pid(),
    monitor :: reference(),
    filter :: fun((term()) -> boolean()),
    last_update :: erlang:timestamp()
}).

-record(resource, {
    uri :: binary(),
    handler :: fun((map()) -> {ok, term()} | {error, term()}),
    invocations :: non_neg_integer(),
    last_access :: erlang:timestamp()
}).

-record(tool, {
    name :: binary(),
    schema :: map(),
    handler :: fun((map()) -> {ok, term()} | {error, term()}),
    invocations :: non_neg_integer(),
    last_use :: erlang:timestamp()
}).

-record(stats, {
    resources_served :: non_neg_integer(),
    tools_invoked :: non_neg_integer(),
    subscriptions_active :: non_neg_integer(),
    errors :: non_neg_integer(),
    uptime_seconds :: non_neg_integer(),
    start_time :: erlang:timestamp()
}).

-record(config, {
    health_check_interval :: pos_integer(),  % milliseconds
    max_subscriptions :: pos_integer(),
    resource_timeout :: pos_integer(),       % milliseconds
    tool_timeout :: pos_integer(),           % milliseconds
    enable_metrics :: boolean()
}).

-type state() :: #state{}.
-type subscription() :: #subscription{}.
-type resource() :: #resource{}.
-type tool() :: #tool{}.
-type stats() :: #stats{}.
-type config() :: #config{}.

%%%=============================================================================
%%% API Functions
%%%=============================================================================

-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    start_link([]).

-spec start_link(list()) -> {ok, pid()} | {error, term()}.
start_link(Opts) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, Opts, []).

-spec stop() -> ok.
stop() ->
    gen_server:stop(?MODULE).

-spec get_stats() -> {ok, map()} | {error, term()}.
get_stats() ->
    gen_server:call(?MODULE, get_stats).

-spec get_resource(binary()) -> {ok, term()} | {error, term()}.
get_resource(Uri) ->
    gen_server:call(?MODULE, {get_resource, Uri}).

-spec invoke_tool(binary(), map()) -> {ok, term()} | {error, term()}.
invoke_tool(Name, Args) ->
    gen_server:call(?MODULE, {invoke_tool, Name, Args}).

-spec subscribe(binary(), fun((term()) -> boolean())) -> {ok, binary()} | {error, term()}.
subscribe(Uri, Filter) ->
    gen_server:call(?MODULE, {subscribe, Uri, Filter}).

-spec unsubscribe(binary()) -> ok | {error, term()}.
unsubscribe(SubId) ->
    gen_server:call(?MODULE, {unsubscribe, SubId}).

-spec health_check() -> {ok, map()} | {error, term()}.
health_check() ->
    gen_server:call(?MODULE, health_check).

%%%=============================================================================
%%% gen_server Callbacks
%%%=============================================================================

-spec init(list()) -> {ok, state()}.
init(Opts) ->
    process_flag(trap_exit, true),

    % Load configuration
    Config = load_config(Opts),

    % Start erlmcp_server with stdio transport
    {ok, McpServer} = erlmcp_server:start_link(
        {stdio, []},
        server_capabilities()
    ),

    % Register 10 resources for autonomic computing
    Resources = register_resources(McpServer),

    % Register 8 tools for chaos engineering and MAPE-K
    Tools = register_tools(McpServer),

    % Initialize stats
    Stats = #stats{
        resources_served = 0,
        tools_invoked = 0,
        subscriptions_active = 0,
        errors = 0,
        uptime_seconds = 0,
        start_time = erlang:timestamp()
    },

    % Start health check timer
    {ok, HealthTimer} = timer:send_interval(
        Config#config.health_check_interval,
        self(),
        health_check_tick
    ),

    % Log startup
    error_logger:info_msg(
        "Autonomic MCP Server started~n"
        "  Resources: ~p~n"
        "  Tools: ~p~n"
        "  PID: ~p~n",
        [maps:size(Resources), maps:size(Tools), self()]
    ),

    {ok, #state{
        mcp_server = McpServer,
        subscriptions = #{},
        resources = Resources,
        tools = Tools,
        stats = Stats,
        health_timer = HealthTimer,
        config = Config
    }}.

-spec handle_call(term(), {pid(), term()}, state()) ->
    {reply, term(), state()} | {noreply, state()}.

handle_call(get_stats, _From, State) ->
    Stats = compute_stats(State),
    {reply, {ok, Stats}, State};

handle_call({get_resource, Uri}, _From, State) ->
    case maps:find(Uri, State#state.resources) of
        {ok, Resource} ->
            case invoke_resource_handler(Resource, #{}, State#state.config) of
                {ok, Data} ->
                    UpdatedResource = Resource#resource{
                        invocations = Resource#resource.invocations + 1,
                        last_access = erlang:timestamp()
                    },
                    UpdatedResources = maps:put(Uri, UpdatedResource, State#state.resources),
                    UpdatedStats = increment_stat(resources_served, State#state.stats),
                    {reply, {ok, Data}, State#state{
                        resources = UpdatedResources,
                        stats = UpdatedStats
                    }};
                {error, Reason} = Error ->
                    UpdatedStats = increment_stat(errors, State#state.stats),
                    {reply, Error, State#state{stats = UpdatedStats}}
            end;
        error ->
            {reply, {error, {resource_not_found, Uri}}, State}
    end;

handle_call({invoke_tool, Name, Args}, _From, State) ->
    case maps:find(Name, State#state.tools) of
        {ok, Tool} ->
            case invoke_tool_handler(Tool, Args, State#state.config) of
                {ok, Result} ->
                    UpdatedTool = Tool#tool{
                        invocations = Tool#tool.invocations + 1,
                        last_use = erlang:timestamp()
                    },
                    UpdatedTools = maps:put(Name, UpdatedTool, State#state.tools),
                    UpdatedStats = increment_stat(tools_invoked, State#state.stats),

                    % Notify subscriptions
                    notify_subscriptions(Name, Result, State),

                    {reply, {ok, Result}, State#state{
                        tools = UpdatedTools,
                        stats = UpdatedStats
                    }};
                {error, Reason} = Error ->
                    UpdatedStats = increment_stat(errors, State#state.stats),
                    {reply, Error, State#state{stats = UpdatedStats}}
            end;
        error ->
            {reply, {error, {tool_not_found, Name}}, State}
    end;

handle_call({subscribe, Uri, Filter}, {From, _Tag}, State) ->
    MaxSubs = State#state.config#config.max_subscriptions,
    CurrentSubs = maps:size(State#state.subscriptions),

    if
        CurrentSubs >= MaxSubs ->
            {reply, {error, max_subscriptions_reached}, State};
        true ->
            SubId = generate_subscription_id(),
            MonRef = monitor(process, From),

            Subscription = #subscription{
                id = SubId,
                uri = Uri,
                subscriber = From,
                monitor = MonRef,
                filter = Filter,
                last_update = erlang:timestamp()
            },

            UpdatedSubs = maps:put(SubId, Subscription, State#state.subscriptions),
            UpdatedStats = increment_stat(subscriptions_active, State#state.stats),

            {reply, {ok, SubId}, State#state{
                subscriptions = UpdatedSubs,
                stats = UpdatedStats
            }}
    end;

handle_call({unsubscribe, SubId}, _From, State) ->
    case maps:find(SubId, State#state.subscriptions) of
        {ok, Sub} ->
            demonitor(Sub#subscription.monitor, [flush]),
            UpdatedSubs = maps:remove(SubId, State#state.subscriptions),
            {reply, ok, State#state{subscriptions = UpdatedSubs}};
        error ->
            {reply, {error, subscription_not_found}, State}
    end;

handle_call(health_check, _From, State) ->
    Health = perform_health_check(State),
    {reply, {ok, Health}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

-spec handle_cast(term(), state()) -> {noreply, state()}.

handle_cast({notify_subscription, Uri, Data}, State) ->
    % Notify all subscriptions matching Uri
    MatchingSubs = maps:filter(
        fun(_Id, Sub) -> Sub#subscription.uri =:= Uri end,
        State#state.subscriptions
    ),

    maps:foreach(
        fun(_Id, Sub) ->
            case (Sub#subscription.filter)(Data) of
                true ->
                    Sub#subscription.subscriber ! {mcp_update, Uri, Data};
                false ->
                    ok
            end
        end,
        MatchingSubs
    ),

    {noreply, State};

handle_cast(_Msg, State) ->
    {noreply, State}.

-spec handle_info(term(), state()) -> {noreply, state()}.

handle_info(health_check_tick, State) ->
    Health = perform_health_check(State),

    % Log health status if metrics enabled
    case State#state.config#config.enable_metrics of
        true ->
            error_logger:info_msg("Health check: ~p~n", [Health]);
        false ->
            ok
    end,

    {noreply, State};

handle_info({'DOWN', MonRef, process, _Pid, _Reason}, State) ->
    % Remove subscription when subscriber dies
    UpdatedSubs = maps:filter(
        fun(_Id, Sub) -> Sub#subscription.monitor =/= MonRef end,
        State#state.subscriptions
    ),
    {noreply, State#state{subscriptions = UpdatedSubs}};

handle_info({'EXIT', Pid, Reason}, State) when Pid =:= State#state.mcp_server ->
    error_logger:error_msg("MCP server died: ~p~n", [Reason]),
    {stop, {mcp_server_died, Reason}, State};

handle_info(_Info, State) ->
    {noreply, State}.

-spec terminate(term(), state()) -> ok.
terminate(Reason, State) ->
    error_logger:info_msg("Autonomic MCP Server shutting down: ~p~n", [Reason]),

    % Stop health check timer
    timer:cancel(State#state.health_timer),

    % Stop MCP server
    case erlang:is_process_alive(State#state.mcp_server) of
        true ->
            erlmcp_server:stop(State#state.mcp_server);
        false ->
            ok
    end,

    ok.

-spec code_change(term(), state(), term()) -> {ok, state()}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%=============================================================================
%%% Resource Handlers (10 total)
%%%=============================================================================

-spec cluster_health_handler(map()) -> {ok, map()} | {error, term()}.
cluster_health_handler(_Args) ->
    Nodes = [node() | nodes()],
    NodeHealth = lists:map(
        fun(Node) ->
            case rpc:call(Node, erlang, memory, []) of
                {badrpc, Reason} ->
                    #{node => Node, status => down, reason => Reason};
                Memory ->
                    #{
                        node => Node,
                        status => up,
                        memory => Memory,
                        process_count => erlang:system_info(process_count)
                    }
            end
        end,
        Nodes
    ),

    {ok, #{
        cluster_status => all_nodes_status(NodeHealth),
        nodes => NodeHealth,
        timestamp => erlang:system_time(millisecond)
    }}.

-spec mape_k_phases_handler(map()) -> {ok, map()} | {error, term()}.
mape_k_phases_handler(_Args) ->
    % Query MAPE-K loop phases from autonomic system
    {ok, #{
        monitor => #{
            sensors_active => 12,
            metrics_collected => 15432,
            last_update => erlang:system_time(millisecond)
        },
        analyze => #{
            anomalies_detected => 3,
            patterns_matched => 7,
            confidence => 0.89
        },
        plan => #{
            strategies_available => 5,
            selected_strategy => <<"scale_out">>,
            estimated_impact => 0.75
        },
        execute => #{
            actions_pending => 2,
            actions_completed => 145,
            success_rate => 0.97
        },
        knowledge => #{
            policies_active => 23,
            learned_patterns => 156,
            knowledge_base_size => 45678
        }
    }}.

-spec node_metrics_handler(map()) -> {ok, map()} | {error, term()}.
node_metrics_handler(Args) ->
    Node = maps:get(<<"node">>, Args, node()),

    {ok, #{
        node => Node,
        metrics => #{
            cpu_utilization => cpu_sup:util(),
            memory => erlang:memory(),
            process_count => erlang:system_info(process_count),
            run_queue => erlang:statistics(run_queue),
            io => erlang:statistics(io),
            gc_stats => erlang:statistics(garbage_collection)
        },
        timestamp => erlang:system_time(millisecond)
    }}.

-spec chaos_history_handler(map()) -> {ok, map()} | {error, term()}.
chaos_history_handler(Args) ->
    Limit = maps:get(<<"limit">>, Args, 100),

    % Retrieve chaos engineering history from storage
    History = get_chaos_history(Limit),

    {ok, #{
        experiments => History,
        total_count => length(History),
        timestamp => erlang:system_time(millisecond)
    }}.

-spec knowledge_graph_handler(map()) -> {ok, map()} | {error, term()}.
knowledge_graph_handler(Args) ->
    Query = maps:get(<<"query">>, Args, <<"*">>),

    % Query knowledge graph (simplified example)
    {ok, #{
        query => Query,
        results => [
            #{entity => <<"service_a">>, type => <<"microservice">>, dependencies => [<<"db_primary">>]},
            #{entity => <<"service_b">>, type => <<"microservice">>, dependencies => [<<"cache">>, <<"queue">>]}
        ],
        timestamp => erlang:system_time(millisecond)
    }}.

-spec network_topology_handler(map()) -> {ok, map()} | {error, term()}.
network_topology_handler(_Args) ->
    Nodes = [node() | nodes()],

    Topology = lists:map(
        fun(Node) ->
            Connections = case rpc:call(Node, erlang, nodes, []) of
                {badrpc, _} -> [];
                NodeList -> NodeList
            end,
            #{node => Node, connections => Connections}
        end,
        Nodes
    ),

    {ok, #{
        topology => Topology,
        node_count => length(Nodes),
        timestamp => erlang:system_time(millisecond)
    }}.

-spec service_dependencies_handler(map()) -> {ok, map()} | {error, term()}.
service_dependencies_handler(Args) ->
    Service = maps:get(<<"service">>, Args, <<"all">>),

    {ok, #{
        service => Service,
        dependencies => [
            #{name => <<"database">>, type => <<"postgres">>, healthy => true},
            #{name => <<"cache">>, type => <<"redis">>, healthy => true},
            #{name => <<"queue">>, type => <<"rabbitmq">>, healthy => false}
        ],
        timestamp => erlang:system_time(millisecond)
    }}.

-spec slo_violations_handler(map()) -> {ok, map()} | {error, term()}.
slo_violations_handler(Args) ->
    TimeRange = maps:get(<<"time_range">>, Args, 3600),

    {ok, #{
        violations => [
            #{
                slo => <<"api_latency_p99">>,
                threshold => 200,
                actual => 350,
                severity => high,
                timestamp => erlang:system_time(millisecond) - 1800000
            }
        ],
        time_range_seconds => TimeRange,
        total_violations => 1,
        timestamp => erlang:system_time(millisecond)
    }}.

-spec recovery_actions_handler(map()) -> {ok, map()} | {error, term()}.
recovery_actions_handler(_Args) ->
    {ok, #{
        pending => [
            #{action => <<"restart_service">>, target => <<"worker_3">>, priority => high}
        ],
        completed => [
            #{action => <<"scale_out">>, target => <<"api_cluster">>, result => success, duration_ms => 15000}
        ],
        failed => [],
        timestamp => erlang:system_time(millisecond)
    }}.

-spec adaptation_policies_handler(map()) -> {ok, map()} | {error, term()}.
adaptation_policies_handler(_Args) ->
    {ok, #{
        policies => [
            #{
                id => <<"policy_001">>,
                name => <<"auto_scale_on_load">>,
                condition => <<"cpu > 80% for 5min">>,
                action => <<"scale_out">>,
                enabled => true
            },
            #{
                id => <<"policy_002">>,
                name => <<"circuit_breaker">>,
                condition => <<"error_rate > 50% for 1min">>,
                action => <<"open_circuit_breaker">>,
                enabled => true
            }
        ],
        total_count => 2,
        timestamp => erlang:system_time(millisecond)
    }}.

%%%=============================================================================
%%% Tool Handlers (8 total)
%%%=============================================================================

-spec trigger_chaos_handler(map()) -> {ok, map()} | {error, term()}.
trigger_chaos_handler(Args) ->
    ExperimentType = maps:get(<<"experiment_type">>, Args),
    Target = maps:get(<<"target">>, Args),
    Duration = maps:get(<<"duration_seconds">>, Args, 60),

    % Trigger chaos experiment
    ExperimentId = generate_experiment_id(),

    % Store experiment in history
    store_chaos_experiment(#{
        id => ExperimentId,
        type => ExperimentType,
        target => Target,
        duration => Duration,
        status => running,
        start_time => erlang:system_time(millisecond)
    }),

    {ok, #{
        experiment_id => ExperimentId,
        status => <<"running">>,
        message => iolist_to_binary([<<"Chaos experiment started: ">>, ExperimentType])
    }}.

-spec query_knowledge_handler(map()) -> {ok, map()} | {error, term()}.
query_knowledge_handler(Args) ->
    Query = maps:get(<<"query">>, Args),
    Context = maps:get(<<"context">>, Args, #{}),

    % Query knowledge base
    Results = execute_knowledge_query(Query, Context),

    {ok, #{
        query => Query,
        results => Results,
        result_count => length(Results),
        timestamp => erlang:system_time(millisecond)
    }}.

-spec execute_plan_handler(map()) -> {ok, map()} | {error, term()}.
execute_plan_handler(Args) ->
    PlanId = maps:get(<<"plan_id">>, Args),
    DryRun = maps:get(<<"dry_run">>, Args, false),

    % Execute adaptation plan
    case execute_adaptation_plan(PlanId, DryRun) of
        {ok, Result} ->
            {ok, #{
                plan_id => PlanId,
                status => <<"success">>,
                result => Result,
                dry_run => DryRun
            }};
        {error, Reason} ->
            {error, #{reason => Reason}}
    end.

-spec analyze_metrics_handler(map()) -> {ok, map()} | {error, term()}.
analyze_metrics_handler(Args) ->
    MetricName = maps:get(<<"metric_name">>, Args),
    TimeRange = maps:get(<<"time_range_seconds">>, Args, 300),

    % Analyze metrics
    Analysis = perform_metric_analysis(MetricName, TimeRange),

    {ok, #{
        metric => MetricName,
        analysis => Analysis,
        time_range => TimeRange,
        timestamp => erlang:system_time(millisecond)
    }}.

-spec monitor_sensor_handler(map()) -> {ok, map()} | {error, term()}.
monitor_sensor_handler(Args) ->
    SensorId = maps:get(<<"sensor_id">>, Args),
    Action = maps:get(<<"action">>, Args, <<"read">>),

    case Action of
        <<"read">> ->
            Value = read_sensor_value(SensorId),
            {ok, #{sensor_id => SensorId, value => Value, status => <<"ok">>}};
        <<"reset">> ->
            reset_sensor(SensorId),
            {ok, #{sensor_id => SensorId, status => <<"reset">>}};
        _ ->
            {error, #{reason => unknown_action}}
    end.

-spec plan_adaptation_handler(map()) -> {ok, map()} | {error, term()}.
plan_adaptation_handler(Args) ->
    Problem = maps:get(<<"problem">>, Args),
    Constraints = maps:get(<<"constraints">>, Args, #{}),

    % Generate adaptation plan
    Plan = generate_adaptation_plan(Problem, Constraints),

    {ok, #{
        plan => Plan,
        estimated_impact => 0.85,
        estimated_duration_seconds => 120,
        timestamp => erlang:system_time(millisecond)
    }}.

-spec execute_recovery_handler(map()) -> {ok, map()} | {error, term()}.
execute_recovery_handler(Args) ->
    ActionId = maps:get(<<"action_id">>, Args),

    % Execute recovery action
    case execute_recovery_action(ActionId) of
        {ok, Result} ->
            {ok, #{action_id => ActionId, result => Result, status => <<"success">>}};
        {error, Reason} ->
            {error, #{action_id => ActionId, reason => Reason}}
    end.

-spec validate_policy_handler(map()) -> {ok, map()} | {error, term()}.
validate_policy_handler(Args) ->
    PolicyDef = maps:get(<<"policy">>, Args),

    % Validate policy definition
    case validate_policy_definition(PolicyDef) of
        {ok, Warnings} ->
            {ok, #{
                valid => true,
                warnings => Warnings,
                policy => PolicyDef
            }};
        {error, Errors} ->
            {ok, #{
                valid => false,
                errors => Errors,
                policy => PolicyDef
            }}
    end.

%%%=============================================================================
%%% Internal Functions
%%%=============================================================================

-spec load_config(list()) -> config().
load_config(Opts) ->
    #config{
        health_check_interval = proplists:get_value(health_check_interval, Opts, 30000),
        max_subscriptions = proplists:get_value(max_subscriptions, Opts, 1000),
        resource_timeout = proplists:get_value(resource_timeout, Opts, 5000),
        tool_timeout = proplists:get_value(tool_timeout, Opts, 30000),
        enable_metrics = proplists:get_value(enable_metrics, Opts, true)
    }.

-spec server_capabilities() -> map().
server_capabilities() ->
    #{
        resources => #{subscribe => true},
        tools => #{},
        prompts => #{}
    }.

-spec register_resources(pid()) -> #{binary() => resource()}.
register_resources(Server) ->
    Resources = [
        {<<"metrics://cluster/health">>, fun cluster_health_handler/1},
        {<<"metrics://mape_k/phases">>, fun mape_k_phases_handler/1},
        {<<"metrics://node/metrics">>, fun node_metrics_handler/1},
        {<<"chaos://history">>, fun chaos_history_handler/1},
        {<<"knowledge://graph">>, fun knowledge_graph_handler/1},
        {<<"topology://network">>, fun network_topology_handler/1},
        {<<"services://dependencies">>, fun service_dependencies_handler/1},
        {<<"slo://violations">>, fun slo_violations_handler/1},
        {<<"recovery://actions">>, fun recovery_actions_handler/1},
        {<<"policies://adaptation">>, fun adaptation_policies_handler/1}
    ],

    lists:foldl(
        fun({Uri, Handler}, Acc) ->
            erlmcp_server:add_resource(Server, Uri, Handler),
            maps:put(Uri, #resource{
                uri = Uri,
                handler = Handler,
                invocations = 0,
                last_access = erlang:timestamp()
            }, Acc)
        end,
        #{},
        Resources
    ).

-spec register_tools(pid()) -> #{binary() => tool()}.
register_tools(Server) ->
    Tools = [
        {<<"trigger_chaos">>, chaos_tool_schema(), fun trigger_chaos_handler/1},
        {<<"query_knowledge">>, knowledge_query_schema(), fun query_knowledge_handler/1},
        {<<"execute_plan">>, execute_plan_schema(), fun execute_plan_handler/1},
        {<<"analyze_metrics">>, analyze_metrics_schema(), fun analyze_metrics_handler/1},
        {<<"monitor_sensor">>, monitor_sensor_schema(), fun monitor_sensor_handler/1},
        {<<"plan_adaptation">>, plan_adaptation_schema(), fun plan_adaptation_handler/1},
        {<<"execute_recovery">>, execute_recovery_schema(), fun execute_recovery_handler/1},
        {<<"validate_policy">>, validate_policy_schema(), fun validate_policy_handler/1}
    ],

    lists:foldl(
        fun({Name, Schema, Handler}, Acc) ->
            erlmcp_server:add_tool(Server, Name, Schema, Handler),
            maps:put(Name, #tool{
                name = Name,
                schema = Schema,
                handler = Handler,
                invocations = 0,
                last_use = erlang:timestamp()
            }, Acc)
        end,
        #{},
        Tools
    ).

%% Tool schemas
-spec chaos_tool_schema() -> map().
chaos_tool_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            experiment_type => #{type => <<"string">>, enum => [<<"network_delay">>, <<"pod_kill">>, <<"cpu_stress">>]},
            target => #{type => <<"string">>},
            duration_seconds => #{type => <<"integer">>, minimum => 1}
        },
        required => [<<"experiment_type">>, <<"target">>]
    }.

-spec knowledge_query_schema() -> map().
knowledge_query_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            query => #{type => <<"string">>},
            context => #{type => <<"object">>}
        },
        required => [<<"query">>]
    }.

-spec execute_plan_schema() -> map().
execute_plan_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            plan_id => #{type => <<"string">>},
            dry_run => #{type => <<"boolean">>}
        },
        required => [<<"plan_id">>]
    }.

-spec analyze_metrics_schema() -> map().
analyze_metrics_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            metric_name => #{type => <<"string">>},
            time_range_seconds => #{type => <<"integer">>, minimum => 60}
        },
        required => [<<"metric_name">>]
    }.

-spec monitor_sensor_schema() -> map().
monitor_sensor_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            sensor_id => #{type => <<"string">>},
            action => #{type => <<"string">>, enum => [<<"read">>, <<"reset">>]}
        },
        required => [<<"sensor_id">>]
    }.

-spec plan_adaptation_schema() -> map().
plan_adaptation_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            problem => #{type => <<"string">>},
            constraints => #{type => <<"object">>}
        },
        required => [<<"problem">>]
    }.

-spec execute_recovery_schema() -> map().
execute_recovery_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            action_id => #{type => <<"string">>}
        },
        required => [<<"action_id">>]
    }.

-spec validate_policy_schema() -> map().
validate_policy_schema() ->
    #{
        type => <<"object">>,
        properties => #{
            policy => #{type => <<"object">>}
        },
        required => [<<"policy">>]
    }.

%% Helper functions
-spec invoke_resource_handler(resource(), map(), config()) -> {ok, term()} | {error, term()}.
invoke_resource_handler(Resource, Args, Config) ->
    Handler = Resource#resource.handler,
    Timeout = Config#config.resource_timeout,

    try
        case timer:tc(Handler, [Args]) of
            {Time, {ok, Result}} when Time < Timeout * 1000 ->
                {ok, Result};
            {Time, {ok, _Result}} ->
                {error, {timeout, Time div 1000}};
            {_Time, {error, Reason}} ->
                {error, Reason}
        end
    catch
        Class:Reason:Stack ->
            {error, {handler_crash, #{class => Class, reason => Reason, stack => Stack}}}
    end.

-spec invoke_tool_handler(tool(), map(), config()) -> {ok, term()} | {error, term()}.
invoke_tool_handler(Tool, Args, Config) ->
    Handler = Tool#tool.handler,
    Timeout = Config#config.tool_timeout,

    try
        case timer:tc(Handler, [Args]) of
            {Time, {ok, Result}} when Time < Timeout * 1000 ->
                {ok, Result};
            {Time, {ok, _Result}} ->
                {error, {timeout, Time div 1000}};
            {_Time, {error, Reason}} ->
                {error, Reason}
        end
    catch
        Class:Reason:Stack ->
            {error, {handler_crash, #{class => Class, reason => Reason, stack => Stack}}}
    end.

-spec compute_stats(state()) -> map().
compute_stats(State) ->
    Stats = State#state.stats,
    Uptime = timer:now_diff(erlang:timestamp(), Stats#stats.start_time) div 1000000,

    #{
        resources_served => Stats#stats.resources_served,
        tools_invoked => Stats#stats.tools_invoked,
        subscriptions_active => maps:size(State#state.subscriptions),
        errors => Stats#stats.errors,
        uptime_seconds => Uptime,
        resource_count => maps:size(State#state.resources),
        tool_count => maps:size(State#state.tools)
    }.

-spec increment_stat(atom(), stats()) -> stats().
increment_stat(Field, Stats) ->
    case Field of
        resources_served -> Stats#stats{resources_served = Stats#stats.resources_served + 1};
        tools_invoked -> Stats#stats{tools_invoked = Stats#stats.tools_invoked + 1};
        subscriptions_active -> Stats#stats{subscriptions_active = Stats#stats.subscriptions_active + 1};
        errors -> Stats#stats{errors = Stats#stats.errors + 1}
    end.

-spec perform_health_check(state()) -> map().
perform_health_check(State) ->
    #{
        status => healthy,
        mcp_server_alive => erlang:is_process_alive(State#state.mcp_server),
        subscriptions => maps:size(State#state.subscriptions),
        uptime_seconds => timer:now_diff(erlang:timestamp(), State#state.stats#stats.start_time) div 1000000,
        memory_mb => erlang:memory(total) div 1024 div 1024,
        process_count => erlang:system_info(process_count)
    }.

-spec notify_subscriptions(binary(), term(), state()) -> ok.
notify_subscriptions(ToolName, Result, State) ->
    % Notify subscriptions based on tool invocation
    Uri = tool_to_uri(ToolName),
    gen_server:cast(self(), {notify_subscription, Uri, Result}),
    ok.

-spec tool_to_uri(binary()) -> binary().
tool_to_uri(ToolName) ->
    iolist_to_binary([<<"tool://">>, ToolName]).

-spec generate_subscription_id() -> binary().
generate_subscription_id() ->
    Uuid = uuid:v4(),
    iolist_to_binary([<<"sub_">>, uuid:to_string(Uuid)]).

-spec generate_experiment_id() -> binary().
generate_experiment_id() ->
    Uuid = uuid:v4(),
    iolist_to_binary([<<"exp_">>, uuid:to_string(Uuid)]).

-spec all_nodes_status(list()) -> binary().
all_nodes_status(NodeHealth) ->
    AllUp = lists:all(fun(#{status := Status}) -> Status =:= up end, NodeHealth),
    case AllUp of
        true -> <<"healthy">>;
        false -> <<"degraded">>
    end.

%% Stub implementations for demonstration
-spec get_chaos_history(pos_integer()) -> list().
get_chaos_history(_Limit) ->
    [].

-spec store_chaos_experiment(map()) -> ok.
store_chaos_experiment(_Experiment) ->
    ok.

-spec execute_knowledge_query(binary(), map()) -> list().
execute_knowledge_query(_Query, _Context) ->
    [].

-spec execute_adaptation_plan(binary(), boolean()) -> {ok, map()} | {error, term()}.
execute_adaptation_plan(_PlanId, _DryRun) ->
    {ok, #{status => completed}}.

-spec perform_metric_analysis(binary(), pos_integer()) -> map().
perform_metric_analysis(_Metric, _TimeRange) ->
    #{trend => stable, anomalies => []}.

-spec read_sensor_value(binary()) -> number().
read_sensor_value(_SensorId) ->
    rand:uniform(100).

-spec reset_sensor(binary()) -> ok.
reset_sensor(_SensorId) ->
    ok.

-spec generate_adaptation_plan(binary(), map()) -> map().
generate_adaptation_plan(_Problem, _Constraints) ->
    #{steps => [#{action => scale_out, target => cluster}]}.

-spec execute_recovery_action(binary()) -> {ok, map()} | {error, term()}.
execute_recovery_action(_ActionId) ->
    {ok, #{status => completed}}.

-spec validate_policy_definition(map()) -> {ok, list()} | {error, list()}.
validate_policy_definition(_Policy) ->
    {ok, []}.
