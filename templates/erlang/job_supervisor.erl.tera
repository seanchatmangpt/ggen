{% set module_name = module_name | default(value="job_supervisor") -%}
{% set description = description | default(value="Job worker pool supervisor") -%}
{% set author = author | default(value="Generated by ggen") -%}
{% set pool_size = pool_size | default(value=4) -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Supervisor for a pool of job worker processes.
%%% Implements simple_one_for_one strategy for dynamic worker creation.
%%%
%%% Pool size: {{ pool_size }} workers
%%%
%%% Features:
%%% - Dynamic worker pool management
%%% - Automatic worker restart on failure
%%% - Worker health monitoring
%%% - Load balancing across workers
%%%
%%% SPARQL Integration:
%%% Can query ontologies for:
%%% - Pool size and scaling policies
%%% - Worker configuration
%%% - Supervision strategy parameters
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-behaviour(supervisor).

%% API
-export([
    start_link/1,
    start_link/2,
    start_worker/2,
    stop_worker/2,
    count_workers/1,
    which_workers/1
]).

%% Supervisor callbacks
-export([init/1]).

-define(SERVER, ?MODULE).

-record(pool_opts, {
    queue :: atom() | pid(),
    pool_size :: pos_integer(),
    worker_module :: module(),
    worker_opts :: list()
}).

%%%===================================================================
%%% API functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Start the supervisor with default pool size.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Queue :: atom() | pid()) ->
    {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Queue) ->
    start_link(Queue, []).

%%--------------------------------------------------------------------
%% @doc
%% Start the supervisor with options.
%%
%% Options:
%%   {pool_size, N} - Number of workers to start (default: {{ pool_size }})
%%   {worker_module, Module} - Worker module (default: job_worker)
%%   {worker_opts, Opts} - Options to pass to workers
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Queue :: atom() | pid(), Options :: list()) ->
    {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Queue, Options) ->
    PoolSize = proplists:get_value(pool_size, Options, {{ pool_size }}),
    WorkerModule = proplists:get_value(worker_module, Options, job_worker),
    WorkerOpts = proplists:get_value(worker_opts, Options, []),

    PoolOpts = #pool_opts{
        queue = Queue,
        pool_size = PoolSize,
        worker_module = WorkerModule,
        worker_opts = WorkerOpts
    },

    case supervisor:start_link({local, ?SERVER}, ?MODULE, PoolOpts) of
        {ok, Pid} = Result ->
            %% Start initial pool of workers
            start_initial_workers(Pid, PoolOpts),
            Result;
        {error, _} = Error ->
            Error
    end.

%%--------------------------------------------------------------------
%% @doc
%% Start a new worker in the pool.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_worker(Supervisor :: atom() | pid(), Queue :: atom() | pid()) ->
    {ok, Child :: pid()} | {error, Reason :: term()}.
start_worker(Supervisor, Queue) ->
    supervisor:start_child(Supervisor, [Queue]).

%%--------------------------------------------------------------------
%% @doc
%% Stop a worker.
%%
%% @end
%%--------------------------------------------------------------------
-spec stop_worker(Supervisor :: atom() | pid(), Worker :: pid()) -> ok.
stop_worker(Supervisor, Worker) ->
    supervisor:terminate_child(Supervisor, Worker).

%%--------------------------------------------------------------------
%% @doc
%% Count active workers.
%%
%% @end
%%--------------------------------------------------------------------
-spec count_workers(Supervisor :: atom() | pid()) -> non_neg_integer().
count_workers(Supervisor) ->
    proplists:get_value(active, supervisor:count_children(Supervisor), 0).

%%--------------------------------------------------------------------
%% @doc
%% Get list of all worker PIDs.
%%
%% @end
%%--------------------------------------------------------------------
-spec which_workers(Supervisor :: atom() | pid()) -> [pid()].
which_workers(Supervisor) ->
    [Pid || {_, Pid, _, _} <- supervisor:which_children(Supervisor),
            is_pid(Pid)].

%%%===================================================================
%%% Supervisor callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initialize the supervisor.
%%
%% @end
%%--------------------------------------------------------------------
-spec init(PoolOpts :: #pool_opts{}) ->
    {ok, {supervisor:sup_flags(), [supervisor:child_spec()]}}.
init(#pool_opts{worker_module = WorkerModule, worker_opts = WorkerOpts}) ->
    SupFlags = #{
        strategy => simple_one_for_one,
        intensity => {{ intensity | default(value=10) }},
        period => {{ period | default(value=60) }}
    },

    %% Worker child specification
    ChildSpec = #{
        id => WorkerModule,
        start => {WorkerModule, start_link, [WorkerOpts]},
        restart => transient,
        shutdown => {{ shutdown | default(value=5000) }},
        type => worker,
        modules => [WorkerModule]
    },

    {ok, {SupFlags, [ChildSpec]}}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Start initial pool of workers.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_initial_workers(Supervisor :: pid(), PoolOpts :: #pool_opts{}) ->
    ok.
start_initial_workers(Supervisor, #pool_opts{queue = Queue, pool_size = PoolSize}) ->
    lists:foreach(
        fun(_) ->
            case start_worker(Supervisor, Queue) of
                {ok, _Pid} ->
                    ok;
                {error, Reason} ->
                    logger:error("Failed to start worker: ~p", [Reason])
            end
        end,
        lists:seq(1, PoolSize)
    ).

%%%===================================================================
%%% Unit Tests
%%%===================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

start_link_test() ->
    %% Mock queue
    {ok, QueuePid} = job_queue:start_link(test_queue),

    %% Start supervisor
    {ok, SupPid} = start_link(QueuePid, [{pool_size, 2}]),

    ?assert(is_pid(SupPid)),
    ?assert(is_process_alive(SupPid)),

    %% Check workers were started
    timer:sleep(100), %% Give workers time to start
    ?assertEqual(2, count_workers(SupPid)),

    %% Cleanup
    supervisor:terminate_child(SupPid, QueuePid),
    ok.

worker_management_test() ->
    {ok, QueuePid} = job_queue:start_link(test_queue2),
    {ok, SupPid} = start_link(QueuePid, [{pool_size, 1}]),

    InitialCount = count_workers(SupPid),

    %% Start additional worker
    {ok, _WorkerPid} = start_worker(SupPid, QueuePid),
    ?assertEqual(InitialCount + 1, count_workers(SupPid)),

    %% Cleanup
    supervisor:terminate_child(SupPid, QueuePid),
    ok.

-endif.
