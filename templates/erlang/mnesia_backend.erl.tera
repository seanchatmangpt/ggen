{% set module_name = module_name | default(value="mnesia_backend") -%}
{% set description = description | default(value="Mnesia storage backend for job queue") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Persistent storage backend using Mnesia distributed database.
%%% Provides ACID transactions and replication support.
%%%
%%% Features:
%%% - Persistent storage (survives restarts)
%%% - Distributed replication
%%% - ACID transactions
%%% - Automatic recovery
%%% - Query and indexing support
%%%
%%% SPARQL Integration:
%%% Can query ontologies for:
%%% - Table schema definitions
%%% - Replication strategy
%%% - Index configuration
%%% - Transaction isolation levels
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

%% Backend behavior
-export([
    init/1,
    enqueue/2,
    dequeue/1,
    peek/1,
    size/1,
    clear/1,
    terminate/1
]).

%% Mnesia table management
-export([
    create_tables/0,
    create_tables/1,
    delete_tables/0
]).

-include("job.hrl").
-include_lib("stdlib/include/qlc.hrl").

-record(backend_state, {
    table :: atom(),
    counter = 0 :: non_neg_integer()
}).

-record(job_queue_entry, {
    key :: {integer(), non_neg_integer()}, %% {-Priority, Counter}
    job :: job()
}).

-type backend_state() :: #backend_state{}.
-type backend_option() :: {table_name, atom()} |
                         {disc_copies, [node()]} |
                         {ram_copies, [node()]} |
                         {disc_only_copies, [node()]}.

-define(DEFAULT_TABLE, {{ table_name | default(value="job_queue_mnesia") }}).

%%%===================================================================
%%% Backend API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Initialize Mnesia backend.
%%
%% Options:
%%   {table_name, Name} - Table name (default: job_queue_mnesia)
%%   {disc_copies, Nodes} - Nodes for disc_copies storage
%%   {ram_copies, Nodes} - Nodes for ram_copies storage
%%   {disc_only_copies, Nodes} - Nodes for disc_only_copies storage
%%
%% @end
%%--------------------------------------------------------------------
-spec init(Options :: [backend_option()]) ->
    {ok, State :: backend_state()} | {error, Reason :: term()}.
init(Options) ->
    TableName = proplists:get_value(table_name, Options, ?DEFAULT_TABLE),

    %% Ensure Mnesia is started
    case mnesia:system_info(is_running) of
        yes -> ok;
        no -> mnesia:start();
        starting -> ok;
        stopping -> {error, mnesia_stopping}
    end,

    %% Wait for tables
    case mnesia:wait_for_tables([TableName], {{ wait_timeout | default(value="5000") }}) of
        ok ->
            State = #backend_state{
                table = TableName,
                counter = get_max_counter(TableName)
            },
            {ok, State};
        {timeout, _} ->
            {error, mnesia_tables_timeout};
        {error, Reason} ->
            {error, {mnesia_wait_failed, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Enqueue a job with transaction safety.
%%
%% @end
%%--------------------------------------------------------------------
-spec enqueue(Job :: job(), State :: backend_state()) ->
    {ok, NewState :: backend_state()} | {error, Reason :: term()}.
enqueue(Job, State) ->
    #backend_state{table = Table, counter = Counter} = State,

    Key = {-Job#job.priority, Counter},
    Entry = #job_queue_entry{key = Key, job = Job},

    Transaction = fun() ->
        mnesia:write(Table, Entry, write)
    end,

    case mnesia:transaction(Transaction) of
        {atomic, ok} ->
            NewState = State#backend_state{counter = Counter + 1},
            {ok, NewState};
        {aborted, Reason} ->
            {error, {transaction_aborted, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Dequeue the highest priority job with transaction safety.
%%
%% @end
%%--------------------------------------------------------------------
-spec dequeue(State :: backend_state()) ->
    {ok, Job :: job(), NewState :: backend_state()} |
    {error, empty} |
    {error, Reason :: term()}.
dequeue(State) ->
    #backend_state{table = Table} = State,

    Transaction = fun() ->
        case mnesia:first(Table) of
            '$end_of_table' ->
                {error, empty};
            Key ->
                case mnesia:read(Table, Key, write) of
                    [#job_queue_entry{job = Job}] ->
                        mnesia:delete(Table, Key, write),
                        {ok, Job};
                    [] ->
                        {error, empty}
                end
        end
    end,

    case mnesia:transaction(Transaction) of
        {atomic, {ok, Job}} ->
            {ok, Job, State};
        {atomic, {error, empty}} ->
            {error, empty};
        {aborted, Reason} ->
            {error, {transaction_aborted, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Peek at the highest priority job without removing it.
%%
%% @end
%%--------------------------------------------------------------------
-spec peek(State :: backend_state()) ->
    {ok, Job :: job()} | {error, empty}.
peek(#backend_state{table = Table}) ->
    Transaction = fun() ->
        case mnesia:first(Table) of
            '$end_of_table' ->
                {error, empty};
            Key ->
                case mnesia:read(Table, Key, read) of
                    [#job_queue_entry{job = Job}] ->
                        {ok, Job};
                    [] ->
                        {error, empty}
                end
        end
    end,

    case mnesia:transaction(Transaction) of
        {atomic, Result} ->
            Result;
        {aborted, Reason} ->
            {error, {transaction_aborted, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Get the current queue size.
%%
%% @end
%%--------------------------------------------------------------------
-spec size(State :: backend_state()) -> non_neg_integer().
size(#backend_state{table = Table}) ->
    mnesia:table_info(Table, size).

%%--------------------------------------------------------------------
%% @doc
%% Clear all jobs from the queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec clear(State :: backend_state()) -> {ok, NewState :: backend_state()}.
clear(State) ->
    #backend_state{table = Table} = State,

    Transaction = fun() ->
        mnesia:clear_table(Table)
    end,

    case mnesia:transaction(Transaction) of
        {atomic, ok} ->
            NewState = State#backend_state{counter = 0},
            {ok, NewState};
        {aborted, Reason} ->
            {error, {transaction_aborted, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Terminate the backend (no-op for Mnesia, tables persist).
%%
%% @end
%%--------------------------------------------------------------------
-spec terminate(State :: backend_state()) -> ok.
terminate(_State) ->
    %% Mnesia tables persist, no cleanup needed
    ok.

%%%===================================================================
%%% Table Management API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Create Mnesia tables for job queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec create_tables() -> ok | {error, Reason :: term()}.
create_tables() ->
    create_tables([]).

%%--------------------------------------------------------------------
%% @doc
%% Create Mnesia tables with options.
%%
%% @end
%%--------------------------------------------------------------------
-spec create_tables(Options :: [backend_option()]) ->
    ok | {error, Reason :: term()}.
create_tables(Options) ->
    TableName = proplists:get_value(table_name, Options, ?DEFAULT_TABLE),
    DiscCopies = proplists:get_value(disc_copies, Options, [node()]),
    RamCopies = proplists:get_value(ram_copies, Options, []),
    DiscOnlyCopies = proplists:get_value(disc_only_copies, Options, []),

    TableDef = [
        {attributes, record_info(fields, job_queue_entry)},
        {type, ordered_set},
        {disc_copies, DiscCopies},
        {ram_copies, RamCopies},
        {disc_only_copies, DiscOnlyCopies}
    ],

    case mnesia:create_table(TableName, TableDef) of
        {atomic, ok} ->
            ok;
        {aborted, {already_exists, _}} ->
            ok;
        {aborted, Reason} ->
            {error, {table_creation_failed, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Delete all job queue tables.
%%
%% @end
%%--------------------------------------------------------------------
-spec delete_tables() -> ok | {error, Reason :: term()}.
delete_tables() ->
    case mnesia:delete_table(?DEFAULT_TABLE) of
        {atomic, ok} ->
            ok;
        {aborted, {no_exists, _}} ->
            ok;
        {aborted, Reason} ->
            {error, {table_deletion_failed, Reason}}
    end.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Get the maximum counter value from existing entries.
%%
%% @end
%%--------------------------------------------------------------------
-spec get_max_counter(Table :: atom()) -> non_neg_integer().
get_max_counter(Table) ->
    Transaction = fun() ->
        Query = qlc:q([Counter || #job_queue_entry{key = {_Priority, Counter}} <- mnesia:table(Table)]),
        case qlc:e(Query) of
            [] ->
                0;
            Counters ->
                lists:max(Counters) + 1
        end
    end,

    case mnesia:transaction(Transaction) of
        {atomic, MaxCounter} ->
            MaxCounter;
        {aborted, _} ->
            0
    end.

%%%===================================================================
%%% Unit Tests
%%%===================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

setup_mnesia() ->
    %% Start Mnesia in memory for testing
    mnesia:create_schema([node()]),
    mnesia:start(),
    create_tables([{table_name, test_job_queue_mnesia}]),
    ok.

cleanup_mnesia() ->
    mnesia:delete_table(test_job_queue_mnesia),
    mnesia:stop(),
    mnesia:delete_schema([node()]),
    ok.

mnesia_operations_test_() ->
    {setup,
     fun setup_mnesia/0,
     fun(_) -> cleanup_mnesia() end,
     [
      ?_test(begin
          {ok, State} = init([{table_name, test_job_queue_mnesia}]),

          %% Enqueue jobs
          Job1 = #job{id = <<"job1">>, priority = 5, data = test1},
          Job2 = #job{id = <<"job2">>, priority = 10, data = test2},

          {ok, S1} = enqueue(Job1, State),
          {ok, S2} = enqueue(Job2, S1),

          ?assertEqual(2, size(S2)),

          %% Dequeue highest priority
          {ok, DequeuedJob, S3} = dequeue(S2),
          ?assertEqual(<<"job2">>, DequeuedJob#job.id),
          ?assertEqual(1, size(S3)),

          terminate(S3)
      end)
     ]
    }.

-endif.
