{% set module_name = module_name | default(value="job_system_SUITE") -%}
{% set description = description | default(value="Common Test suite for job system") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Comprehensive Common Test suite for the job processing system.
%%% Tests integration between components and end-to-end workflows.
%%%
%%% Test Groups:
%%% - Basic operations (enqueue, dequeue, queue management)
%%% - Worker pool operations (job processing, failures)
%%% - Backend operations (ETS, Mnesia)
%%% - Concurrency tests (parallel operations)
%%% - Failure scenarios (crashes, timeouts, recovery)
%%%
%%% SPARQL Context:
%%% Can query ontologies for:
%%% - Test configuration (timeouts, concurrency levels)
%%% - Test data generation parameters
%%% - Expected behaviors and invariants
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("job.hrl").

%% CT callbacks
-export([
    all/0,
    groups/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_group/2,
    end_per_group/2,
    init_per_testcase/2,
    end_per_testcase/2
]).

%% Test cases
-export([
    %% Basic operations
    test_enqueue_dequeue/1,
    test_priority_ordering/1,
    test_queue_size/1,
    test_queue_clear/1,
    test_peek_operation/1,

    %% Worker operations
    test_worker_pool/1,
    test_job_processing/1,
    test_worker_failure/1,
    test_worker_timeout/1,

    %% Backend operations
    test_ets_backend/1,
    test_mnesia_backend/1,
    test_backend_persistence/1,

    %% Concurrency
    test_concurrent_enqueue/1,
    test_concurrent_dequeue/1,
    test_parallel_workers/1,

    %% Failure scenarios
    test_queue_overflow/1,
    test_supervisor_restart/1,
    test_job_retry/1
]).

%%%===================================================================
%%% CT Callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Returns list of test cases.
%%
%% @end
%%--------------------------------------------------------------------
all() ->
    [
        {group, basic_operations},
        {group, worker_operations},
        {group, backend_operations},
        {group, concurrency},
        {group, failure_scenarios}
    ].

%%--------------------------------------------------------------------
%% @doc
%% Define test groups.
%%
%% @end
%%--------------------------------------------------------------------
groups() ->
    [
        {basic_operations, [parallel], [
            test_enqueue_dequeue,
            test_priority_ordering,
            test_queue_size,
            test_queue_clear,
            test_peek_operation
        ]},
        {worker_operations, [sequence], [
            test_worker_pool,
            test_job_processing,
            test_worker_failure,
            test_worker_timeout
        ]},
        {backend_operations, [sequence], [
            test_ets_backend,
            test_mnesia_backend,
            test_backend_persistence
        ]},
        {concurrency, [parallel], [
            test_concurrent_enqueue,
            test_concurrent_dequeue,
            test_parallel_workers
        ]},
        {failure_scenarios, [sequence], [
            test_queue_overflow,
            test_supervisor_restart,
            test_job_retry
        ]}
    ].

%%--------------------------------------------------------------------
%% @doc
%% Suite initialization.
%%
%% @end
%%--------------------------------------------------------------------
init_per_suite(Config) ->
    ct:pal("Initializing test suite"),

    %% Start applications
    ok = application:start(sasl),

    %% Setup test data directory
    DataDir = ?config(priv_dir, Config),
    ct:pal("Data directory: ~s", [DataDir]),

    [{data_dir, DataDir} | Config].

%%--------------------------------------------------------------------
%% @doc
%% Suite cleanup.
%%
%% @end
%%--------------------------------------------------------------------
end_per_suite(_Config) ->
    ct:pal("Cleaning up test suite"),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Group initialization.
%%
%% @end
%%--------------------------------------------------------------------
init_per_group(backend_operations, Config) ->
    %% Initialize Mnesia for backend tests
    mnesia:create_schema([node()]),
    mnesia:start(),
    mnesia_backend:create_tables(),
    Config;
init_per_group(_Group, Config) ->
    Config.

%%--------------------------------------------------------------------
%% @doc
%% Group cleanup.
%%
%% @end
%%--------------------------------------------------------------------
end_per_group(backend_operations, _Config) ->
    mnesia_backend:delete_tables(),
    mnesia:stop(),
    mnesia:delete_schema([node()]),
    ok;
end_per_group(_Group, _Config) ->
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test case initialization.
%%
%% @end
%%--------------------------------------------------------------------
init_per_testcase(TestCase, Config) ->
    ct:pal("Starting test case: ~p", [TestCase]),
    Config.

%%--------------------------------------------------------------------
%% @doc
%% Test case cleanup.
%%
%% @end
%%--------------------------------------------------------------------
end_per_testcase(TestCase, _Config) ->
    ct:pal("Finished test case: ~p", [TestCase]),
    ok.

%%%===================================================================
%%% Test Cases - Basic Operations
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Test basic enqueue and dequeue operations.
%%
%% @end
%%--------------------------------------------------------------------
test_enqueue_dequeue(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_1),

    Job = #job{id = <<"test_job_1">>, data = #{test => data}},

    %% Enqueue job
    ok = job_queue:enqueue(Queue, Job),

    %% Verify queue size
    1 = job_queue:size(Queue),

    %% Dequeue job
    {ok, DequeuedJob} = job_queue:dequeue(Queue),
    <<"test_job_1">> = DequeuedJob#job.id,

    %% Verify empty
    0 = job_queue:size(Queue),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test priority-based ordering.
%%
%% @end
%%--------------------------------------------------------------------
test_priority_ordering(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_2),

    %% Enqueue jobs with different priorities
    LowJob = #job{id = <<"low">>, priority = 1},
    HighJob = #job{id = <<"high">>, priority = 10},
    MediumJob = #job{id = <<"medium">>, priority = 5},

    ok = job_queue:enqueue(Queue, LowJob),
    ok = job_queue:enqueue(Queue, HighJob),
    ok = job_queue:enqueue(Queue, MediumJob),

    %% Dequeue in priority order
    {ok, Job1} = job_queue:dequeue(Queue),
    <<"high">> = Job1#job.id,

    {ok, Job2} = job_queue:dequeue(Queue),
    <<"medium">> = Job2#job.id,

    {ok, Job3} = job_queue:dequeue(Queue),
    <<"low">> = Job3#job.id,

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test queue size tracking.
%%
%% @end
%%--------------------------------------------------------------------
test_queue_size(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_3),

    %% Initial size
    0 = job_queue:size(Queue),

    %% Enqueue multiple jobs
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 10)],

    lists:foreach(fun(Job) ->
        ok = job_queue:enqueue(Queue, Job)
    end, Jobs),

    %% Verify size
    10 = job_queue:size(Queue),

    %% Dequeue some
    {ok, _} = job_queue:dequeue(Queue),
    {ok, _} = job_queue:dequeue(Queue),

    %% Verify updated size
    8 = job_queue:size(Queue),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test queue clear operation.
%%
%% @end
%%--------------------------------------------------------------------
test_queue_clear(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_4),

    %% Enqueue jobs
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 5)],

    lists:foreach(fun(Job) ->
        ok = job_queue:enqueue(Queue, Job)
    end, Jobs),

    5 = job_queue:size(Queue),

    %% Clear queue
    ok = job_queue:clear(Queue),

    %% Verify empty
    0 = job_queue:size(Queue),
    {error, empty} = job_queue:dequeue(Queue),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test peek operation (view without removing).
%%
%% @end
%%--------------------------------------------------------------------
test_peek_operation(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_5),

    Job = #job{id = <<"peek_job">>, priority = 10},
    ok = job_queue:enqueue(Queue, Job),

    %% Peek at job
    {ok, PeekedJob} = job_queue:peek(Queue),
    <<"peek_job">> = PeekedJob#job.id,

    %% Verify job still in queue
    1 = job_queue:size(Queue),

    %% Dequeue should return same job
    {ok, DequeuedJob} = job_queue:dequeue(Queue),
    <<"peek_job">> = DequeuedJob#job.id,

    job_queue:stop(Queue),
    ok.

%%%===================================================================
%%% Test Cases - Worker Operations
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Test worker pool creation.
%%
%% @end
%%--------------------------------------------------------------------
test_worker_pool(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_workers),

    PoolSize = {{ pool_size | default(value=4) }},
    {ok, Supervisor} = job_supervisor:start_link(Queue, [
        {pool_size, PoolSize}
    ]),

    %% Wait for workers to start
    timer:sleep(100),

    %% Verify worker count
    WorkerCount = job_supervisor:count_workers(Supervisor),
    true = WorkerCount >= PoolSize,

    ct:pal("Started ~p workers", [WorkerCount]),

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test job processing by workers.
%%
%% @end
%%--------------------------------------------------------------------
test_job_processing(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_processing),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [
        {pool_size, 2},
        {worker_opts, [{handler, test_handler}]}
    ]),

    %% Enqueue jobs
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 10)],

    lists:foreach(fun(Job) ->
        ok = job_queue:enqueue(Queue, Job)
    end, Jobs),

    %% Wait for processing
    wait_for_empty_queue(Queue, 10000),

    0 = job_queue:size(Queue),

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test worker failure and restart.
%%
%% @end
%%--------------------------------------------------------------------
test_worker_failure(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_failure),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [{pool_size, 3}]),

    InitialWorkers = job_supervisor:count_workers(Supervisor),

    %% Kill a worker
    [Worker | _] = job_supervisor:which_workers(Supervisor),
    exit(Worker, kill),

    %% Wait for supervisor to restart
    timer:sleep(500),

    %% Verify worker was restarted
    NewWorkerCount = job_supervisor:count_workers(Supervisor),
    true = NewWorkerCount >= InitialWorkers - 1,

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test worker timeout handling.
%%
%% @end
%%--------------------------------------------------------------------
test_worker_timeout(_Config) ->
    {ok, Queue} = job_queue:start_link(test_queue_timeout),

    %% Enqueue job that will timeout
    TimeoutJob = #job{
        id = <<"timeout_job">>,
        timeout = 100,
        data = #{sleep => 5000}
    },

    ok = job_queue:enqueue(Queue, TimeoutJob),

    %% Dequeue and simulate processing
    {ok, Job} = job_queue:dequeue(Queue),
    <<"timeout_job">> = Job#job.id,

    job_queue:stop(Queue),
    ok.

%%%===================================================================
%%% Test Cases - Backend Operations
%%%===================================================================

test_ets_backend(_Config) ->
    {ok, Queue} = job_queue:start_link(test_ets, [{backend, ets_backend}]),

    Job = #job{id = <<"ets_job">>},
    ok = job_queue:enqueue(Queue, Job),

    {ok, DequeuedJob} = job_queue:dequeue(Queue),
    <<"ets_job">> = DequeuedJob#job.id,

    job_queue:stop(Queue),
    ok.

test_mnesia_backend(_Config) ->
    {ok, Queue} = job_queue:start_link(test_mnesia, [{backend, mnesia_backend}]),

    Job = #job{id = <<"mnesia_job">>},
    ok = job_queue:enqueue(Queue, Job),

    {ok, DequeuedJob} = job_queue:dequeue(Queue),
    <<"mnesia_job">> = DequeuedJob#job.id,

    job_queue:stop(Queue),
    ok.

test_backend_persistence(_Config) ->
    %% Test Mnesia persistence across restarts
    {ok, Queue1} = job_queue:start_link(test_persist, [{backend, mnesia_backend}]),

    Job = #job{id = <<"persist_job">>},
    ok = job_queue:enqueue(Queue1, Job),
    job_queue:stop(Queue1),

    %% Restart queue
    {ok, Queue2} = job_queue:start_link(test_persist, [{backend, mnesia_backend}]),

    %% Job should still be there
    {ok, DequeuedJob} = job_queue:dequeue(Queue2),
    <<"persist_job">> = DequeuedJob#job.id,

    job_queue:stop(Queue2),
    ok.

%%%===================================================================
%%% Test Cases - Concurrency
%%%===================================================================

test_concurrent_enqueue(_Config) ->
    {ok, Queue} = job_queue:start_link(test_concurrent_enq),

    %% Spawn multiple enqueuers
    Pids = [spawn_enqueuer(Queue, 100) || _ <- lists:seq(1, 10)],

    %% Wait for completion
    [wait_for_done(Pid) || Pid <- Pids],

    %% Verify all jobs enqueued
    1000 = job_queue:size(Queue),

    job_queue:stop(Queue),
    ok.

test_concurrent_dequeue(_Config) ->
    {ok, Queue} = job_queue:start_link(test_concurrent_deq),

    %% Pre-populate queue
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 100)],
    lists:foreach(fun(Job) -> job_queue:enqueue(Queue, Job) end, Jobs),

    %% Spawn multiple dequeuers
    Pids = [spawn_dequeuer(Queue, 10) || _ <- lists:seq(1, 10)],

    %% Wait for completion
    [wait_for_done(Pid) || Pid <- Pids],

    %% Verify queue empty
    0 = job_queue:size(Queue),

    job_queue:stop(Queue),
    ok.

test_parallel_workers(_Config) ->
    {ok, Queue} = job_queue:start_link(test_parallel),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [{pool_size, 8}]),

    %% Enqueue many jobs
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 100)],
    lists:foreach(fun(Job) -> job_queue:enqueue(Queue, Job) end, Jobs),

    %% Wait for processing
    wait_for_empty_queue(Queue, 30000),

    0 = job_queue:size(Queue),

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%%===================================================================
%%% Test Cases - Failure Scenarios
%%%===================================================================

test_queue_overflow(_Config) ->
    {ok, Queue} = job_queue:start_link(test_overflow, [{max_size, 10}]),

    %% Fill queue to capacity
    Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
            || N <- lists:seq(1, 10)],
    lists:foreach(fun(Job) -> job_queue:enqueue(Queue, Job) end, Jobs),

    %% Try to exceed capacity
    ExtraJob = #job{id = <<"extra">>},
    {error, queue_full} = job_queue:enqueue(Queue, ExtraJob),

    job_queue:stop(Queue),
    ok.

test_supervisor_restart(_Config) ->
    {ok, Queue} = job_queue:start_link(test_sup_restart),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [{pool_size, 3}]),

    InitialWorkers = job_supervisor:which_workers(Supervisor),

    %% Kill all workers
    [exit(Worker, kill) || Worker <- InitialWorkers],

    %% Wait for restarts
    timer:sleep(1000),

    %% Verify workers restarted
    NewWorkers = job_supervisor:count_workers(Supervisor),
    true = NewWorkers > 0,

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

test_job_retry(_Config) ->
    {ok, Queue} = job_queue:start_link(test_retry),

    RetryJob = #job{
        id = <<"retry_job">>,
        retries = 0,
        max_retries = 3
    },

    ok = job_queue:enqueue(Queue, RetryJob),

    %% Simulate failures and retries
    {ok, Job1} = job_queue:dequeue(Queue),
    UpdatedJob = Job1#job{retries = Job1#job.retries + 1},
    ok = job_queue:enqueue(Queue, UpdatedJob),

    {ok, Job2} = job_queue:dequeue(Queue),
    1 = Job2#job.retries,

    job_queue:stop(Queue),
    ok.

%%%===================================================================
%%% Helper Functions
%%%===================================================================

wait_for_empty_queue(Queue, Timeout) ->
    wait_for_empty_queue(Queue, Timeout, erlang:monotonic_time()).

wait_for_empty_queue(Queue, Timeout, StartTime) ->
    case job_queue:size(Queue) of
        0 ->
            ok;
        _ ->
            Elapsed = erlang:convert_time_unit(
                erlang:monotonic_time() - StartTime,
                native,
                millisecond
            ),
            case Elapsed >= Timeout of
                true ->
                    ct:fail("Queue did not empty within timeout");
                false ->
                    timer:sleep(100),
                    wait_for_empty_queue(Queue, Timeout, StartTime)
            end
    end.

spawn_enqueuer(Queue, Count) ->
    Parent = self(),
    spawn(fun() ->
        Jobs = [#job{id = list_to_binary(io_lib:format("job_~p", [N]))}
                || N <- lists:seq(1, Count)],
        lists:foreach(fun(Job) -> job_queue:enqueue(Queue, Job) end, Jobs),
        Parent ! {done, self()}
    end).

spawn_dequeuer(Queue, Count) ->
    Parent = self(),
    spawn(fun() ->
        dequeue_n(Queue, Count),
        Parent ! {done, self()}
    end).

dequeue_n(_Queue, 0) -> ok;
dequeue_n(Queue, N) ->
    case job_queue:dequeue(Queue) of
        {ok, _} ->
            dequeue_n(Queue, N - 1);
        {error, empty} ->
            ok
    end.

wait_for_done(Pid) ->
    receive
        {done, Pid} -> ok
    after 30000 ->
        ct:fail("Process ~p did not complete", [Pid])
    end.
