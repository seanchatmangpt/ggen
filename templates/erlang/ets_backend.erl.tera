{% set module_name = module_name | default(value="ets_backend") -%}
{% set description = description | default(value="ETS storage backend for job queue") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% In-memory storage backend using ETS (Erlang Term Storage).
%%% Provides fast O(log n) operations for job queue.
%%%
%%% Features:
%%% - Priority-based ordering
%%% - Fast enqueue/dequeue operations
%%% - Low memory overhead
%%% - No persistence (in-memory only)
%%%
%%% SPARQL Context:
%%% Can query ontologies for:
%%% - ETS table configuration (type, options)
%%% - Index strategies
%%% - Memory limits
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

%% Backend behavior
-export([
    init/1,
    enqueue/2,
    dequeue/1,
    peek/1,
    size/1,
    clear/1,
    terminate/1
]).

%% Internal API
-export([
    find_by_id/2,
    find_by_priority/2,
    delete/2
]).

-include("job.hrl").

-record(backend_state, {
    table :: ets:tid(),
    counter = 0 :: non_neg_integer()
}).

-type backend_state() :: #backend_state{}.
-type backend_option() :: {table_name, atom()} |
                         {table_type, ets:type()} |
                         {table_opts, [term()]}.

%%%===================================================================
%%% Backend API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Initialize ETS backend.
%%
%% Options:
%%   {table_name, Name} - ETS table name (default: job_queue_ets)
%%   {table_type, Type} - ETS table type (default: ordered_set)
%%   {table_opts, Opts} - Additional ETS options
%%
%% @end
%%--------------------------------------------------------------------
-spec init(Options :: [backend_option()]) ->
    {ok, State :: backend_state()} | {error, Reason :: term()}.
init(Options) ->
    TableName = proplists:get_value(table_name, Options, {{ table_name | default(value="job_queue_ets") }}),
    TableType = proplists:get_value(table_type, Options, {{ table_type | default(value="ordered_set") }}),
    TableOpts = proplists:get_value(table_opts, Options, [
        public,
        named_table,
        {keypos, 1},
        {read_concurrency, {{ read_concurrency | default(value="true") }}},
        {write_concurrency, {{ write_concurrency | default(value="true") }}}
    ]),

    try
        Table = ets:new(TableName, [TableType | TableOpts]),
        State = #backend_state{
            table = Table,
            counter = 0
        },
        {ok, State}
    catch
        error:Reason ->
            {error, {ets_create_failed, Reason}}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Enqueue a job.
%%
%% Jobs are stored with a composite key: {-Priority, Counter}
%% This ensures higher priority jobs are dequeued first,
%% and jobs with same priority are FIFO ordered.
%%
%% @end
%%--------------------------------------------------------------------
-spec enqueue(Job :: job(), State :: backend_state()) ->
    {ok, NewState :: backend_state()} | {error, Reason :: term()}.
enqueue(Job, State) ->
    #backend_state{table = Table, counter = Counter} = State,

    %% Use negative priority for ordering (higher priority = lower key)
    %% Counter ensures FIFO for same priority
    Key = {-Job#job.priority, Counter},

    case ets:insert(Table, {Key, Job}) of
        true ->
            NewState = State#backend_state{counter = Counter + 1},
            {ok, NewState};
        false ->
            {error, ets_insert_failed}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Dequeue the highest priority job.
%%
%% @end
%%--------------------------------------------------------------------
-spec dequeue(State :: backend_state()) ->
    {ok, Job :: job(), NewState :: backend_state()} |
    {error, empty} |
    {error, Reason :: term()}.
dequeue(State) ->
    #backend_state{table = Table} = State,

    case ets:first(Table) of
        '$end_of_table' ->
            {error, empty};
        Key ->
            case ets:lookup(Table, Key) of
                [{Key, Job}] ->
                    ets:delete(Table, Key),
                    {ok, Job, State};
                [] ->
                    {error, empty}
            end
    end.

%%--------------------------------------------------------------------
%% @doc
%% Peek at the highest priority job without removing it.
%%
%% @end
%%--------------------------------------------------------------------
-spec peek(State :: backend_state()) ->
    {ok, Job :: job()} | {error, empty}.
peek(#backend_state{table = Table}) ->
    case ets:first(Table) of
        '$end_of_table' ->
            {error, empty};
        Key ->
            case ets:lookup(Table, Key) of
                [{Key, Job}] ->
                    {ok, Job};
                [] ->
                    {error, empty}
            end
    end.

%%--------------------------------------------------------------------
%% @doc
%% Get the current queue size.
%%
%% @end
%%--------------------------------------------------------------------
-spec size(State :: backend_state()) -> non_neg_integer().
size(#backend_state{table = Table}) ->
    ets:info(Table, size).

%%--------------------------------------------------------------------
%% @doc
%% Clear all jobs from the queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec clear(State :: backend_state()) -> {ok, NewState :: backend_state()}.
clear(State) ->
    #backend_state{table = Table} = State,
    ets:delete_all_objects(Table),
    NewState = State#backend_state{counter = 0},
    {ok, NewState}.

%%--------------------------------------------------------------------
%% @doc
%% Terminate the backend and cleanup resources.
%%
%% @end
%%--------------------------------------------------------------------
-spec terminate(State :: backend_state()) -> ok.
terminate(#backend_state{table = Table}) ->
    ets:delete(Table),
    ok.

%%%===================================================================
%%% Internal API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Find a job by its ID.
%%
%% @end
%%--------------------------------------------------------------------
-spec find_by_id(JobId :: binary(), State :: backend_state()) ->
    {ok, Job :: job()} | {error, not_found}.
find_by_id(JobId, #backend_state{table = Table}) ->
    case ets:match_object(Table, {'_', #job{id = JobId, _ = '_'}}) of
        [{_Key, Job}] ->
            {ok, Job};
        [] ->
            {error, not_found};
        Multiple when length(Multiple) > 1 ->
            %% Should not happen, but handle gracefully
            [{_Key, Job} | _] = Multiple,
            {ok, Job}
    end.

%%--------------------------------------------------------------------
%% @doc
%% Find jobs by priority.
%%
%% @end
%%--------------------------------------------------------------------
-spec find_by_priority(Priority :: integer(), State :: backend_state()) ->
    [job()].
find_by_priority(Priority, #backend_state{table = Table}) ->
    MatchSpec = [{{{'$1', '_'}, #job{priority = Priority, _ = '_'}}, [], ['$_']}],
    case ets:select(Table, MatchSpec) of
        Jobs when is_list(Jobs) ->
            [Job || {_Key, Job} <- Jobs];
        _ ->
            []
    end.

%%--------------------------------------------------------------------
%% @doc
%% Delete a specific job by ID.
%%
%% @end
%%--------------------------------------------------------------------
-spec delete(JobId :: binary(), State :: backend_state()) ->
    ok | {error, not_found}.
delete(JobId, #backend_state{table = Table}) ->
    case ets:match_object(Table, {'_', #job{id = JobId, _ = '_'}}) of
        [{Key, _Job}] ->
            ets:delete(Table, Key),
            ok;
        [] ->
            {error, not_found};
        Multiple when length(Multiple) > 1 ->
            %% Delete all matches (should not happen)
            [ets:delete(Table, Key) || {Key, _} <- Multiple],
            ok
    end.

%%%===================================================================
%%% Unit Tests
%%%===================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

basic_operations_test_() ->
    {foreach,
     fun() ->
         {ok, State} = init([{table_name, test_queue_ets}]),
         State
     end,
     fun(State) ->
         terminate(State)
     end,
     [
      fun(State) ->
          {"Enqueue and dequeue",
           ?_test(begin
               Job = #job{id = <<"job1">>, priority = 5, data = test},
               {ok, State1} = enqueue(Job, State),
               ?assertEqual(1, size(State1)),
               {ok, DequeuedJob, State2} = dequeue(State1),
               ?assertEqual(<<"job1">>, DequeuedJob#job.id),
               ?assertEqual(0, size(State2))
           end)}
      end,

      fun(State) ->
          {"Priority ordering",
           ?_test(begin
               Job1 = #job{id = <<"low">>, priority = 1, data = low},
               Job2 = #job{id = <<"high">>, priority = 10, data = high},
               Job3 = #job{id = <<"medium">>, priority = 5, data = medium},

               {ok, S1} = enqueue(Job1, State),
               {ok, S2} = enqueue(Job2, S1),
               {ok, S3} = enqueue(Job3, S2),

               {ok, First, S4} = dequeue(S3),
               ?assertEqual(<<"high">>, First#job.id),

               {ok, Second, S5} = dequeue(S4),
               ?assertEqual(<<"medium">>, Second#job.id),

               {ok, Third, _S6} = dequeue(S5),
               ?assertEqual(<<"low">>, Third#job.id)
           end)}
      end,

      fun(State) ->
          {"Peek operation",
           ?_test(begin
               Job = #job{id = <<"job1">>, priority = 5, data = test},
               {ok, State1} = enqueue(Job, State),

               {ok, PeekedJob} = peek(State1),
               ?assertEqual(<<"job1">>, PeekedJob#job.id),
               ?assertEqual(1, size(State1)), %% Size unchanged

               {ok, DequeuedJob, State2} = dequeue(State1),
               ?assertEqual(PeekedJob, DequeuedJob),
               ?assertEqual(0, size(State2))
           end)}
      end,

      fun(State) ->
          {"Clear operation",
           ?_test(begin
               Job1 = #job{id = <<"job1">>, data = test1},
               Job2 = #job{id = <<"job2">>, data = test2},

               {ok, S1} = enqueue(Job1, State),
               {ok, S2} = enqueue(Job2, S1),
               ?assertEqual(2, size(S2)),

               {ok, S3} = clear(S2),
               ?assertEqual(0, size(S3)),
               ?assertEqual({error, empty}, dequeue(S3))
           end)}
      end
     ]
    }.

find_by_id_test() ->
    {ok, State} = init([{table_name, test_find_ets}]),

    Job = #job{id = <<"unique_job">>, priority = 5, data = test},
    {ok, State1} = enqueue(Job, State),

    ?assertMatch({ok, #job{id = <<"unique_job">>}}, find_by_id(<<"unique_job">>, State1)),
    ?assertEqual({error, not_found}, find_by_id(<<"nonexistent">>, State1)),

    terminate(State1).

-endif.
