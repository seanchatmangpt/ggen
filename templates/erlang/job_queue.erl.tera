{% set module_name = module_name | default(value="job_queue") -%}
{% set description = description | default(value="Generic job queue gen_server") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% A generic job queue implementation using gen_server.
%%% Supports multiple storage backends (ETS, Mnesia, custom).
%%%
%%% Features:
%%% - Priority-based job scheduling
%%% - Job persistence (backend-dependent)
%%% - Concurrent job processing
%%% - Job status tracking
%%% - Automatic retry with backoff
%%% - Metrics and monitoring
%%%
%%% SPARQL Integration:
%%% This template can query ontologies for:
%%% - Queue configuration (capacity, priorities, timeouts)
%%% - Backend selection and parameters
%%% - Retry policies and error handling strategies
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-behaviour(gen_server).

%% API
-export([
    start_link/1,
    start_link/2,
    enqueue/2,
    enqueue/3,
    dequeue/1,
    peek/1,
    size/1,
    clear/1,
    stop/1
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

-include("job.hrl").

-record(state, {
    backend :: module(),
    backend_state :: term(),
    max_size :: pos_integer() | infinity,
    metrics :: #{
        enqueued => non_neg_integer(),
        dequeued => non_neg_integer(),
        failed => non_neg_integer()
    }
}).

-type queue_option() :: {backend, module()} |
                       {backend_opts, term()} |
                       {max_size, pos_integer() | infinity}.

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Starts the job queue with default options.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Name :: atom()) -> {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Name) ->
    start_link(Name, []).

%%--------------------------------------------------------------------
%% @doc
%% Starts the job queue with specified options.
%%
%% Options:
%%   {backend, Module} - Storage backend module (default: ets_backend)
%%   {backend_opts, Opts} - Backend-specific options
%%   {max_size, Size} - Maximum queue size (default: infinity)
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Name :: atom(), Options :: [queue_option()]) ->
    {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Name, Options) ->
    gen_server:start_link({local, Name}, ?MODULE, Options, []).

%%--------------------------------------------------------------------
%% @doc
%% Enqueue a job with default priority.
%%
%% @end
%%--------------------------------------------------------------------
-spec enqueue(Queue :: atom() | pid(), Job :: #job{}) ->
    ok | {error, Reason :: term()}.
enqueue(Queue, Job) ->
    gen_server:call(Queue, {enqueue, Job}).

%%--------------------------------------------------------------------
%% @doc
%% Enqueue a job with specified priority.
%%
%% @end
%%--------------------------------------------------------------------
-spec enqueue(Queue :: atom() | pid(), Job :: #job{}, Priority :: integer()) ->
    ok | {error, Reason :: term()}.
enqueue(Queue, Job, Priority) ->
    gen_server:call(Queue, {enqueue, Job#job{priority = Priority}}).

%%--------------------------------------------------------------------
%% @doc
%% Dequeue the highest priority job.
%%
%% @end
%%--------------------------------------------------------------------
-spec dequeue(Queue :: atom() | pid()) ->
    {ok, Job :: #job{}} | {error, empty} | {error, Reason :: term()}.
dequeue(Queue) ->
    gen_server:call(Queue, dequeue).

%%--------------------------------------------------------------------
%% @doc
%% Peek at the highest priority job without removing it.
%%
%% @end
%%--------------------------------------------------------------------
-spec peek(Queue :: atom() | pid()) ->
    {ok, Job :: #job{}} | {error, empty} | {error, Reason :: term()}.
peek(Queue) ->
    gen_server:call(Queue, peek).

%%--------------------------------------------------------------------
%% @doc
%% Get the current queue size.
%%
%% @end
%%--------------------------------------------------------------------
-spec size(Queue :: atom() | pid()) -> non_neg_integer().
size(Queue) ->
    gen_server:call(Queue, size).

%%--------------------------------------------------------------------
%% @doc
%% Clear all jobs from the queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec clear(Queue :: atom() | pid()) -> ok.
clear(Queue) ->
    gen_server:call(Queue, clear).

%%--------------------------------------------------------------------
%% @doc
%% Stop the queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec stop(Queue :: atom() | pid()) -> ok.
stop(Queue) ->
    gen_server:stop(Queue).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @end
%%--------------------------------------------------------------------
-spec init(Options :: [queue_option()]) ->
    {ok, State :: #state{}} | {stop, Reason :: term()}.
init(Options) ->
    Backend = proplists:get_value(backend, Options, {{ backend_module | default(value="ets_backend") }}),
    BackendOpts = proplists:get_value(backend_opts, Options, []),
    MaxSize = proplists:get_value(max_size, Options, {{ max_size | default(value="infinity") }}),

    case Backend:init(BackendOpts) of
        {ok, BackendState} ->
            State = #state{
                backend = Backend,
                backend_state = BackendState,
                max_size = MaxSize,
                metrics = #{
                    enqueued => 0,
                    dequeued => 0,
                    failed => 0
                }
            },
            {ok, State};
        {error, Reason} ->
            {stop, Reason}
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling call messages
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_call(Request :: term(), From :: {pid(), Tag :: term()},
                 State :: #state{}) ->
    {reply, Reply :: term(), NewState :: #state{}} |
    {stop, Reason :: term(), Reply :: term(), NewState :: #state{}}.
handle_call({enqueue, Job}, _From, State) ->
    #state{
        backend = Backend,
        backend_state = BackendState,
        max_size = MaxSize,
        metrics = Metrics
    } = State,

    case check_capacity(Backend, BackendState, MaxSize) of
        ok ->
            case Backend:enqueue(Job, BackendState) of
                {ok, NewBackendState} ->
                    NewMetrics = maps:update_with(enqueued, fun(V) -> V + 1 end, Metrics),
                    NewState = State#state{
                        backend_state = NewBackendState,
                        metrics = NewMetrics
                    },
                    {reply, ok, NewState};
                {error, Reason} = Error ->
                    NewMetrics = maps:update_with(failed, fun(V) -> V + 1 end, Metrics),
                    {reply, Error, State#state{metrics = NewMetrics}}
            end;
        {error, _} = Error ->
            {reply, Error, State}
    end;

handle_call(dequeue, _From, State) ->
    #state{
        backend = Backend,
        backend_state = BackendState,
        metrics = Metrics
    } = State,

    case Backend:dequeue(BackendState) of
        {ok, Job, NewBackendState} ->
            NewMetrics = maps:update_with(dequeued, fun(V) -> V + 1 end, Metrics),
            NewState = State#state{
                backend_state = NewBackendState,
                metrics = NewMetrics
            },
            {reply, {ok, Job}, NewState};
        {error, _} = Error ->
            {reply, Error, State}
    end;

handle_call(peek, _From, State) ->
    #state{backend = Backend, backend_state = BackendState} = State,
    Result = Backend:peek(BackendState),
    {reply, Result, State};

handle_call(size, _From, State) ->
    #state{backend = Backend, backend_state = BackendState} = State,
    Size = Backend:size(BackendState),
    {reply, Size, State};

handle_call(clear, _From, State) ->
    #state{backend = Backend, backend_state = BackendState} = State,
    {ok, NewBackendState} = Backend:clear(BackendState),
    {reply, ok, State#state{backend_state = NewBackendState}};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling cast messages
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_cast(Request :: term(), State :: #state{}) ->
    {noreply, NewState :: #state{}}.
handle_cast(_Request, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_info(Info :: term(), State :: #state{}) ->
    {noreply, NewState :: #state{}}.
handle_info(_Info, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_server when it is about to
%% terminate.
%%
%% @end
%%--------------------------------------------------------------------
-spec terminate(Reason :: term(), State :: #state{}) -> ok.
terminate(_Reason, #state{backend = Backend, backend_state = BackendState}) ->
    Backend:terminate(BackendState),
    ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @end
%%--------------------------------------------------------------------
-spec code_change(OldVsn :: term(), State :: #state{}, Extra :: term()) ->
    {ok, NewState :: #state{}}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Check if queue has capacity for new job.
%%
%% @end
%%--------------------------------------------------------------------
-spec check_capacity(Backend :: module(), BackendState :: term(),
                    MaxSize :: pos_integer() | infinity) ->
    ok | {error, queue_full}.
check_capacity(_Backend, _BackendState, infinity) ->
    ok;
check_capacity(Backend, BackendState, MaxSize) ->
    case Backend:size(BackendState) < MaxSize of
        true -> ok;
        false -> {error, queue_full}
    end.

%%%===================================================================
%%% Unit Tests
%%%===================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

basic_operations_test_() ->
    {foreach,
     fun() ->
         {ok, Pid} = start_link(test_queue, [{backend, ets_backend}]),
         Pid
     end,
     fun(Pid) ->
         stop(Pid)
     end,
     [
      fun(Pid) ->
          Job = #job{id = <<"job1">>, data = #{task => test}},
          ?_test(begin
              ?assertEqual(ok, enqueue(Pid, Job)),
              ?assertEqual(1, size(Pid)),
              ?assertMatch({ok, #job{id = <<"job1">>}}, dequeue(Pid)),
              ?assertEqual(0, size(Pid))
          end)
      end
     ]
    }.

-endif.
