{% set module_name = module_name | default(value="benchmark") -%}
{% set description = description | default(value="Performance benchmark suite") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Comprehensive benchmark suite for job queue system.
%%% Measures throughput, latency, and concurrency performance.
%%%
%%% Benchmarks:
%%% - Enqueue/dequeue throughput
%%% - Concurrent worker performance
%%% - Different backend comparisons
%%% - Priority queue overhead
%%% - Memory usage profiling
%%%
%%% SPARQL Context:
%%% Can query ontologies for:
%%% - Benchmark configuration (iterations, concurrency levels)
%%% - Performance baselines and SLOs
%%% - Test data generation parameters
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-export([
    run_all/0,
    run_all/1,
    enqueue_throughput/1,
    dequeue_throughput/1,
    concurrent_workers/1,
    backend_comparison/0,
    latency_percentiles/1
]).

-include("job.hrl").

-define(DEFAULT_ITERATIONS, {{ iterations | default(value=10000) }}).
-define(DEFAULT_WORKERS, {{ workers | default(value=4) }}).

%%%===================================================================
%%% Public API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Run all benchmarks with default configuration.
%%
%% @end
%%--------------------------------------------------------------------
-spec run_all() -> ok.
run_all() ->
    run_all(#{}).

%%--------------------------------------------------------------------
%% @doc
%% Run all benchmarks with custom configuration.
%%
%% Config:
%%   iterations - Number of operations per benchmark
%%   workers - Number of concurrent workers
%%   backends - List of backends to test
%%
%% @end
%%--------------------------------------------------------------------
-spec run_all(Config :: map()) -> ok.
run_all(Config) ->
    io:format("~n=== Job Queue Benchmark Suite ===~n~n"),

    Iterations = maps:get(iterations, Config, ?DEFAULT_ITERATIONS),

    %% Run individual benchmarks
    io:format("1. Enqueue Throughput~n"),
    enqueue_throughput(Iterations),

    io:format("~n2. Dequeue Throughput~n"),
    dequeue_throughput(Iterations),

    io:format("~n3. Concurrent Workers~n"),
    concurrent_workers(maps:get(workers, Config, ?DEFAULT_WORKERS)),

    io:format("~n4. Backend Comparison~n"),
    backend_comparison(),

    io:format("~n5. Latency Percentiles~n"),
    latency_percentiles(Iterations),

    io:format("~n=== Benchmark Complete ===~n"),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Benchmark enqueue throughput.
%%
%% @end
%%--------------------------------------------------------------------
-spec enqueue_throughput(Iterations :: pos_integer()) -> ok.
enqueue_throughput(Iterations) ->
    {ok, Queue} = job_queue:start_link(bench_enqueue),

    %% Warmup
    warmup_enqueue(Queue, 1000),
    job_queue:clear(Queue),

    %% Benchmark
    Jobs = generate_jobs(Iterations),
    {Time, _} = timer:tc(fun() ->
        lists:foreach(fun(Job) ->
            job_queue:enqueue(Queue, Job)
        end, Jobs)
    end),

    Throughput = (Iterations * 1000000) div Time,
    AvgLatency = Time div Iterations,

    io:format("  Iterations: ~p~n", [Iterations]),
    io:format("  Total time: ~p ms~n", [Time div 1000]),
    io:format("  Throughput: ~p ops/sec~n", [Throughput]),
    io:format("  Avg latency: ~p μs~n", [AvgLatency]),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Benchmark dequeue throughput.
%%
%% @end
%%--------------------------------------------------------------------
-spec dequeue_throughput(Iterations :: pos_integer()) -> ok.
dequeue_throughput(Iterations) ->
    {ok, Queue} = job_queue:start_link(bench_dequeue),

    %% Pre-populate queue
    Jobs = generate_jobs(Iterations),
    lists:foreach(fun(Job) ->
        job_queue:enqueue(Queue, Job)
    end, Jobs),

    %% Benchmark
    {Time, _} = timer:tc(fun() ->
        dequeue_all(Queue, Iterations)
    end),

    Throughput = (Iterations * 1000000) div Time,
    AvgLatency = Time div Iterations,

    io:format("  Iterations: ~p~n", [Iterations]),
    io:format("  Total time: ~p ms~n", [Time div 1000]),
    io:format("  Throughput: ~p ops/sec~n", [Throughput]),
    io:format("  Avg latency: ~p μs~n", [AvgLatency]),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Benchmark concurrent worker performance.
%%
%% @end
%%--------------------------------------------------------------------
-spec concurrent_workers(NumWorkers :: pos_integer()) -> ok.
concurrent_workers(NumWorkers) ->
    {ok, Queue} = job_queue:start_link(bench_workers),

    %% Start worker pool
    {ok, Supervisor} = job_supervisor:start_link(Queue, [
        {pool_size, NumWorkers},
        {worker_opts, [{handler, simple_handler}]}
    ]),

    %% Enqueue jobs
    Jobs = generate_jobs(?DEFAULT_ITERATIONS),
    EnqueueStart = erlang:monotonic_time(),
    lists:foreach(fun(Job) ->
        job_queue:enqueue(Queue, Job)
    end, Jobs),

    %% Wait for all jobs to complete
    wait_for_empty_queue(Queue),
    TotalTime = erlang:monotonic_time() - EnqueueStart,
    TimeMs = erlang:convert_time_unit(TotalTime, native, millisecond),

    Throughput = (?DEFAULT_ITERATIONS * 1000) div TimeMs,

    io:format("  Workers: ~p~n", [NumWorkers]),
    io:format("  Jobs: ~p~n", [?DEFAULT_ITERATIONS]),
    io:format("  Total time: ~p ms~n", [TimeMs]),
    io:format("  Throughput: ~p jobs/sec~n", [Throughput]),

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Compare performance across different backends.
%%
%% @end
%%--------------------------------------------------------------------
-spec backend_comparison() -> ok.
backend_comparison() ->
    Backends = [
        {ets_backend, "ETS Backend"},
        {mnesia_backend, "Mnesia Backend"}
    ],

    Iterations = ?DEFAULT_ITERATIONS div 10, %% Fewer iterations for comparison

    lists:foreach(fun({Backend, Name}) ->
        io:format("  Testing ~s~n", [Name]),

        %% Setup
        case Backend of
            mnesia_backend ->
                mnesia_backend:create_tables();
            _ ->
                ok
        end,

        {ok, Queue} = job_queue:start_link(bench_backend, [
            {backend, Backend}
        ]),

        %% Benchmark enqueue
        Jobs = generate_jobs(Iterations),
        {EnqueueTime, _} = timer:tc(fun() ->
            lists:foreach(fun(Job) ->
                job_queue:enqueue(Queue, Job)
            end, Jobs)
        end),

        %% Benchmark dequeue
        {DequeueTime, _} = timer:tc(fun() ->
            dequeue_all(Queue, Iterations)
        end),

        EnqueueThroughput = (Iterations * 1000000) div EnqueueTime,
        DequeueThroughput = (Iterations * 1000000) div DequeueTime,

        io:format("    Enqueue: ~p ops/sec (~p μs avg)~n",
                 [EnqueueThroughput, EnqueueTime div Iterations]),
        io:format("    Dequeue: ~p ops/sec (~p μs avg)~n",
                 [DequeueThroughput, DequeueTime div Iterations]),

        job_queue:stop(Queue),

        %% Cleanup
        case Backend of
            mnesia_backend ->
                mnesia_backend:delete_tables();
            _ ->
                ok
        end
    end, Backends),

    ok.

%%--------------------------------------------------------------------
%% @doc
%% Measure latency percentiles.
%%
%% @end
%%--------------------------------------------------------------------
-spec latency_percentiles(Iterations :: pos_integer()) -> ok.
latency_percentiles(Iterations) ->
    {ok, Queue} = job_queue:start_link(bench_latency),

    Jobs = generate_jobs(Iterations),

    %% Measure individual operation latencies
    Latencies = lists:map(fun(Job) ->
        {Time, _} = timer:tc(fun() ->
            job_queue:enqueue(Queue, Job)
        end),
        Time
    end, Jobs),

    SortedLatencies = lists:sort(Latencies),

    P50 = percentile(SortedLatencies, 50),
    P95 = percentile(SortedLatencies, 95),
    P99 = percentile(SortedLatencies, 99),
    P999 = percentile(SortedLatencies, 99.9),
    Max = lists:last(SortedLatencies),

    io:format("  p50:  ~p μs~n", [P50]),
    io:format("  p95:  ~p μs~n", [P95]),
    io:format("  p99:  ~p μs~n", [P99]),
    io:format("  p99.9: ~p μs~n", [P999]),
    io:format("  max:  ~p μs~n", [Max]),

    job_queue:stop(Queue),
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Generate test jobs.
%%
%% @end
%%--------------------------------------------------------------------
-spec generate_jobs(Count :: pos_integer()) -> [job()].
generate_jobs(Count) ->
    [#job{
        id = list_to_binary(io_lib:format("job_~p", [N])),
        type = benchmark,
        data = #{index => N},
        priority = rand:uniform(10)
    } || N <- lists:seq(1, Count)].

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Warmup phase for enqueue benchmark.
%%
%% @end
%%--------------------------------------------------------------------
-spec warmup_enqueue(Queue :: pid(), Count :: pos_integer()) -> ok.
warmup_enqueue(Queue, Count) ->
    Jobs = generate_jobs(Count),
    lists:foreach(fun(Job) ->
        job_queue:enqueue(Queue, Job)
    end, Jobs),
    ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Dequeue all jobs from queue.
%%
%% @end
%%--------------------------------------------------------------------
-spec dequeue_all(Queue :: pid(), Count :: pos_integer()) -> ok.
dequeue_all(_Queue, 0) ->
    ok;
dequeue_all(Queue, Count) ->
    case job_queue:dequeue(Queue) of
        {ok, _Job} ->
            dequeue_all(Queue, Count - 1);
        {error, empty} ->
            ok
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Wait for queue to become empty.
%%
%% @end
%%--------------------------------------------------------------------
-spec wait_for_empty_queue(Queue :: pid()) -> ok.
wait_for_empty_queue(Queue) ->
    case job_queue:size(Queue) of
        0 ->
            ok;
        _ ->
            timer:sleep(100),
            wait_for_empty_queue(Queue)
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Calculate percentile from sorted list.
%%
%% @end
%%--------------------------------------------------------------------
-spec percentile(SortedList :: [number()], Percentile :: float()) -> number().
percentile(SortedList, Percentile) ->
    Length = length(SortedList),
    Index = max(1, round(Length * Percentile / 100)),
    lists:nth(Index, SortedList).
