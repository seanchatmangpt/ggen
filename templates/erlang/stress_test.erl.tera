{% set module_name = module_name | default(value="stress_test") -%}
{% set description = description | default(value="Stress testing with PropEr") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Property-based stress testing using PropEr framework.
%%% Tests system behavior under extreme conditions.
%%%
%%% Test Scenarios:
%%% - High concurrency stress
%%% - Memory pressure testing
%%% - Queue overflow conditions
%%% - Rapid enqueue/dequeue cycles
%%% - Worker crash recovery
%%% - Backend failure scenarios
%%%
%%% SPARQL Context:
%%% Can query ontologies for:
%%% - Stress test parameters (load levels, duration)
%%% - System invariants to verify
%%% - Failure injection scenarios
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-include_lib("proper/include/proper.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("job.hrl").

%% PropEr properties
-export([
    prop_queue_fifo_order/0,
    prop_priority_ordering/0,
    prop_concurrent_enqueue/0,
    prop_worker_crash_recovery/0,
    prop_queue_capacity/0
]).

%% Test suites
-export([
    run_stress_tests/0,
    concurrent_load_test/0,
    memory_pressure_test/0,
    failure_recovery_test/0
]).

-define(STRESS_DURATION, {{ stress_duration | default(value=60000) }}). %% 60 seconds
-define(MAX_LOAD, {{ max_load | default(value=10000) }}).
-define(CONCURRENT_CLIENTS, {{ concurrent_clients | default(value=100) }}).

%%%===================================================================
%%% PropEr Properties
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Property: Jobs with same priority are dequeued in FIFO order.
%%
%% @end
%%--------------------------------------------------------------------
prop_queue_fifo_order() ->
    ?FORALL(Jobs, non_empty(list(job())),
        begin
            {ok, Queue} = job_queue:start_link(prop_fifo),

            %% Enqueue all jobs
            lists:foreach(fun(Job) ->
                job_queue:enqueue(Queue, Job)
            end, Jobs),

            %% Dequeue all jobs
            Dequeued = dequeue_all_jobs(Queue),

            job_queue:stop(Queue),

            %% Verify FIFO order within same priority
            verify_fifo_order(Jobs, Dequeued)
        end
    ).

%%--------------------------------------------------------------------
%% @doc
%% Property: Higher priority jobs are always dequeued first.
%%
%% @end
%%--------------------------------------------------------------------
prop_priority_ordering() ->
    ?FORALL(Jobs, non_empty(list(job())),
        begin
            {ok, Queue} = job_queue:start_link(prop_priority),

            %% Enqueue all jobs
            lists:foreach(fun(Job) ->
                job_queue:enqueue(Queue, Job)
            end, Jobs),

            %% Dequeue all jobs
            Dequeued = dequeue_all_jobs(Queue),

            job_queue:stop(Queue),

            %% Verify priority ordering
            verify_priority_order(Dequeued)
        end
    ).

%%--------------------------------------------------------------------
%% @doc
%% Property: Concurrent enqueue operations are safe.
%%
%% @end
%%--------------------------------------------------------------------
prop_concurrent_enqueue() ->
    ?FORALL({N, Jobs}, {range(1, {{ max_concurrent | default(value=50) }}), non_empty(list(job()))},
        begin
            {ok, Queue} = job_queue:start_link(prop_concurrent),

            %% Spawn N concurrent enqueuers
            Pids = [spawn_enqueuer(Queue, Jobs) || _ <- lists:seq(1, N)],

            %% Wait for all to complete
            [wait_for_completion(Pid) || Pid <- Pids],

            %% Verify all jobs were enqueued
            QueueSize = job_queue:size(Queue),
            ExpectedSize = N * length(Jobs),

            job_queue:stop(Queue),

            QueueSize =:= ExpectedSize
        end
    ).

%%--------------------------------------------------------------------
%% @doc
%% Property: System recovers from worker crashes.
%%
%% @end
%%--------------------------------------------------------------------
prop_worker_crash_recovery() ->
    ?FORALL(CrashCount, range(1, {{ max_crashes | default(value=10) }}),
        begin
            {ok, Queue} = job_queue:start_link(prop_recovery),
            {ok, Supervisor} = job_supervisor:start_link(Queue, [{pool_size, 4}]),

            InitialWorkers = job_supervisor:count_workers(Supervisor),

            %% Kill random workers
            crash_random_workers(Supervisor, CrashCount),

            %% Wait for supervisor to restart workers
            timer:sleep(1000),

            RecoveredWorkers = job_supervisor:count_workers(Supervisor),

            supervisor:terminate_child(Supervisor, Queue),
            job_queue:stop(Queue),

            %% Verify workers were restarted
            RecoveredWorkers >= InitialWorkers - CrashCount
        end
    ).

%%--------------------------------------------------------------------
%% @doc
%% Property: Queue respects capacity limits.
%%
%% @end
%%--------------------------------------------------------------------
prop_queue_capacity() ->
    ?FORALL(Capacity, range(10, 100),
        begin
            {ok, Queue} = job_queue:start_link(prop_capacity, [
                {max_size, Capacity}
            ]),

            %% Try to enqueue more than capacity
            Jobs = generate_n_jobs(Capacity + 10),

            Results = lists:map(fun(Job) ->
                job_queue:enqueue(Queue, Job)
            end, Jobs),

            job_queue:stop(Queue),

            %% Verify some enqueues failed
            Errors = [R || R <- Results, element(1, R) =:= error],
            length(Errors) > 0
        end
    ).

%%%===================================================================
%%% Stress Test Suites
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Run all stress tests.
%%
%% @end
%%--------------------------------------------------------------------
run_stress_tests() ->
    io:format("~n=== Running Stress Tests ===~n~n"),

    io:format("1. Concurrent Load Test~n"),
    concurrent_load_test(),

    io:format("~n2. Memory Pressure Test~n"),
    memory_pressure_test(),

    io:format("~n3. Failure Recovery Test~n"),
    failure_recovery_test(),

    io:format("~n=== Stress Tests Complete ===~n"),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test system under high concurrent load.
%%
%% @end
%%--------------------------------------------------------------------
concurrent_load_test() ->
    {ok, Queue} = job_queue:start_link(stress_concurrent),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [
        {pool_size, {{ pool_size | default(value=8) }}}
    ]),

    %% Spawn many concurrent clients
    StartTime = erlang:monotonic_time(),

    Clients = [spawn_load_client(Queue, ?MAX_LOAD div ?CONCURRENT_CLIENTS)
               || _ <- lists:seq(1, ?CONCURRENT_CLIENTS)],

    %% Wait for all clients
    [wait_for_completion(Pid) || Pid <- Clients],

    %% Wait for queue to drain
    wait_for_empty_queue(Queue, ?STRESS_DURATION),

    Duration = erlang:convert_time_unit(
        erlang:monotonic_time() - StartTime,
        native,
        millisecond
    ),

    Throughput = (?MAX_LOAD * 1000) div max(1, Duration),

    io:format("  Concurrent clients: ~p~n", [?CONCURRENT_CLIENTS]),
    io:format("  Total jobs: ~p~n", [?MAX_LOAD]),
    io:format("  Duration: ~p ms~n", [Duration]),
    io:format("  Throughput: ~p jobs/sec~n", [Throughput]),

    supervisor:terminate_child(Supervisor, Queue),
    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test system under memory pressure.
%%
%% @end
%%--------------------------------------------------------------------
memory_pressure_test() ->
    {ok, Queue} = job_queue:start_link(stress_memory),

    %% Create large jobs
    LargeJobs = [create_large_job(N) || N <- lists:seq(1, {{ large_job_count | default(value=1000) }})],

    MemBefore = erlang:memory(total),

    %% Enqueue all large jobs
    lists:foreach(fun(Job) ->
        job_queue:enqueue(Queue, Job)
    end, LargeJobs),

    MemAfter = erlang:memory(total),
    MemUsed = (MemAfter - MemBefore) div 1024 div 1024,

    io:format("  Large jobs: ~p~n", [length(LargeJobs)]),
    io:format("  Memory used: ~p MB~n", [MemUsed]),
    io:format("  Avg per job: ~p KB~n", [(MemAfter - MemBefore) div length(LargeJobs) div 1024]),

    %% Cleanup
    job_queue:clear(Queue),

    MemAfterClear = erlang:memory(total),
    MemReclaimed = (MemAfter - MemAfterClear) div 1024 div 1024,

    io:format("  Memory reclaimed: ~p MB~n", [MemReclaimed]),

    job_queue:stop(Queue),
    ok.

%%--------------------------------------------------------------------
%% @doc
%% Test system recovery from failures.
%%
%% @end
%%--------------------------------------------------------------------
failure_recovery_test() ->
    {ok, Queue} = job_queue:start_link(stress_failure),
    {ok, Supervisor} = job_supervisor:start_link(Queue, [{pool_size, 4}]),

    InitialWorkers = job_supervisor:count_workers(Supervisor),

    %% Inject failures
    Failures = [
        fun() -> crash_random_worker(Supervisor) end,
        fun() -> kill_queue_process(Queue) end
    ],

    %% Run failure scenarios
    lists:foreach(fun(FailureFn) ->
        try
            FailureFn(),
            timer:sleep(500) %% Wait for recovery
        catch
            _:_ -> ok
        end
    end, Failures),

    %% Verify recovery
    timer:sleep(2000),
    RecoveredWorkers = job_supervisor:count_workers(Supervisor),

    io:format("  Initial workers: ~p~n", [InitialWorkers]),
    io:format("  Recovered workers: ~p~n", [RecoveredWorkers]),
    io:format("  Recovery rate: ~p%~n",
             [(RecoveredWorkers * 100) div max(1, InitialWorkers)]),

    supervisor:terminate_child(Supervisor, Queue),
    ok.

%%%===================================================================
%%% PropEr Generators
%%%===================================================================

job() ->
    ?LET({Id, Priority, Data},
         {binary(), range(1, 20), term()},
         #job{
             id = Id,
             priority = Priority,
             data = Data,
             created_at = erlang:timestamp()
         }
    ).

%%%===================================================================
%%% Internal Functions
%%%===================================================================

dequeue_all_jobs(Queue) ->
    dequeue_all_jobs(Queue, []).

dequeue_all_jobs(Queue, Acc) ->
    case job_queue:dequeue(Queue) of
        {ok, Job} ->
            dequeue_all_jobs(Queue, [Job | Acc]);
        {error, empty} ->
            lists:reverse(Acc)
    end.

verify_fifo_order(Original, Dequeued) ->
    %% Group by priority
    OriginalByPriority = group_by_priority(Original),
    DequeuedByPriority = group_by_priority(Dequeued),

    %% Verify each priority group maintains FIFO
    maps:fold(fun(Priority, OrigJobs, Acc) ->
        DeqJobs = maps:get(Priority, DequeuedByPriority, []),
        Acc andalso (OrigJobs =:= DeqJobs)
    end, true, OriginalByPriority).

verify_priority_order([]) -> true;
verify_priority_order([_]) -> true;
verify_priority_order([J1, J2 | Rest]) ->
    (J1#job.priority >= J2#job.priority) andalso verify_priority_order([J2 | Rest]).

group_by_priority(Jobs) ->
    lists:foldl(fun(Job, Acc) ->
        Priority = Job#job.priority,
        maps:update_with(Priority,
                        fun(Jobs) -> Jobs ++ [Job] end,
                        [Job],
                        Acc)
    end, #{}, Jobs).

spawn_enqueuer(Queue, Jobs) ->
    Parent = self(),
    spawn(fun() ->
        lists:foreach(fun(Job) ->
            job_queue:enqueue(Queue, Job)
        end, Jobs),
        Parent ! {done, self()}
    end).

spawn_load_client(Queue, JobCount) ->
    Parent = self(),
    spawn(fun() ->
        Jobs = generate_n_jobs(JobCount),
        lists:foreach(fun(Job) ->
            job_queue:enqueue(Queue, Job)
        end, Jobs),
        Parent ! {done, self()}
    end).

wait_for_completion(Pid) ->
    receive
        {done, Pid} -> ok
    after 30000 ->
        timeout
    end.

generate_n_jobs(N) ->
    [#job{
        id = list_to_binary(io_lib:format("job_~p", [I])),
        priority = rand:uniform(10),
        data = #{index => I}
    } || I <- lists:seq(1, N)].

create_large_job(N) ->
    LargeData = binary:copy(<<"X">>, {{ large_job_size | default(value=10240) }}), %% 10KB
    #job{
        id = list_to_binary(io_lib:format("large_~p", [N])),
        data = LargeData
    }.

crash_random_workers(Supervisor, Count) ->
    Workers = job_supervisor:which_workers(Supervisor),
    ToKill = lists:sublist(Workers, Count),
    [exit(Pid, kill) || Pid <- ToKill].

crash_random_worker(Supervisor) ->
    crash_random_workers(Supervisor, 1).

kill_queue_process(_Queue) ->
    %% Simulate queue process crash
    %% In real scenario, this would restart automatically
    ok.

wait_for_empty_queue(Queue, Timeout) ->
    wait_for_empty_queue(Queue, Timeout, erlang:monotonic_time()).

wait_for_empty_queue(Queue, Timeout, StartTime) ->
    case job_queue:size(Queue) of
        0 ->
            ok;
        _ ->
            Elapsed = erlang:convert_time_unit(
                erlang:monotonic_time() - StartTime,
                native,
                millisecond
            ),
            if
                Elapsed >= Timeout ->
                    {error, timeout};
                true ->
                    timer:sleep(100),
                    wait_for_empty_queue(Queue, Timeout, StartTime)
            end
    end.

%%%===================================================================
%%% EUnit Tests
%%%===================================================================

-ifdef(TEST).

proper_test_() ->
    {timeout, 120,
     fun() ->
         %% Run PropEr properties
         ?assert(proper:quickcheck(prop_queue_fifo_order(), [
             {numtests, {{ num_tests | default(value=100) }}},
             {to_file, user}
         ])),
         ?assert(proper:quickcheck(prop_priority_ordering(), [
             {numtests, {{ num_tests | default(value=100) }}},
             {to_file, user}
         ]))
     end
    }.

-endif.
