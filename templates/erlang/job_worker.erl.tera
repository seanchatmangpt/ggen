{% set module_name = module_name | default(value="job_worker") -%}
{% set description = description | default(value="Job worker gen_server") -%}
{% set author = author | default(value="Generated by ggen") -%}
%%%-------------------------------------------------------------------
%%% @author {{ author }}
%%% @copyright (C) {% raw %}{{{% endraw %} current_year {% raw %}}}{% endraw %}, {{ author }}
%%% @doc
%%% {{ description }}
%%%
%%% Generic job worker that processes jobs from a queue.
%%% Implements automatic retry with exponential backoff.
%%%
%%% Features:
%%% - Asynchronous job processing
%%% - Automatic retry with configurable backoff
%%% - Timeout handling
%%% - Job status reporting
%%% - Error handling and logging
%%%
%%% SPARQL Context:
%%% Can query ontologies for:
%%% - Worker configuration (timeout, retry policy)
%%% - Job processing strategies
%%% - Error handling policies
%%%
%%% @end
%%% Created : {% raw %}{{{% endraw %} timestamp {% raw %}}}{% endraw %}
%%%-------------------------------------------------------------------
-module({{ module_name }}).

-behaviour(gen_server).

%% API
-export([
    start_link/1,
    start_link/2,
    process_job/2,
    get_status/1,
    stop/1
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

-include("job.hrl").

-record(state, {
    queue :: atom() | pid(),
    handler :: module(),
    current_job :: #job{} | undefined,
    timeout :: pos_integer(),
    retry_policy :: #{
        max_retries => non_neg_integer(),
        initial_delay => pos_integer(),
        max_delay => pos_integer(),
        backoff_factor => float()
    },
    metrics :: #{
        processed => non_neg_integer(),
        failed => non_neg_integer(),
        retried => non_neg_integer()
    }
}).

-type worker_option() :: {queue, atom() | pid()} |
                        {handler, module()} |
                        {timeout, pos_integer()} |
                        {retry_policy, map()}.

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Start worker with default options.
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Queue :: atom() | pid()) ->
    {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Queue) ->
    start_link(Queue, []).

%%--------------------------------------------------------------------
%% @doc
%% Start worker with options.
%%
%% Options:
%%   {handler, Module} - Job handler module (must export handle_job/1)
%%   {timeout, Millis} - Job processing timeout
%%   {retry_policy, Policy} - Retry configuration
%%
%% @end
%%--------------------------------------------------------------------
-spec start_link(Queue :: atom() | pid(), Options :: [worker_option()]) ->
    {ok, Pid :: pid()} | {error, Reason :: term()}.
start_link(Queue, Options) ->
    gen_server:start_link(?MODULE, [{queue, Queue} | Options], []).

%%--------------------------------------------------------------------
%% @doc
%% Process a job (used for direct job submission).
%%
%% @end
%%--------------------------------------------------------------------
-spec process_job(Worker :: pid(), Job :: #job{}) -> ok.
process_job(Worker, Job) ->
    gen_server:cast(Worker, {process_job, Job}).

%%--------------------------------------------------------------------
%% @doc
%% Get worker status.
%%
%% @end
%%--------------------------------------------------------------------
-spec get_status(Worker :: pid()) -> map().
get_status(Worker) ->
    gen_server:call(Worker, get_status).

%%--------------------------------------------------------------------
%% @doc
%% Stop the worker.
%%
%% @end
%%--------------------------------------------------------------------
-spec stop(Worker :: pid()) -> ok.
stop(Worker) ->
    gen_server:stop(Worker).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initialize the worker.
%%
%% @end
%%--------------------------------------------------------------------
-spec init(Options :: [worker_option()]) ->
    {ok, State :: #state{}} | {stop, Reason :: term()}.
init(Options) ->
    Queue = proplists:get_value(queue, Options),
    Handler = proplists:get_value(handler, Options, {{ handler_module | default(value="default_job_handler") }}),
    Timeout = proplists:get_value(timeout, Options, {{ timeout | default(value="5000") }}),

    DefaultRetryPolicy = #{
        max_retries => {{ max_retries | default(value="3") }},
        initial_delay => {{ initial_delay | default(value="1000") }},
        max_delay => {{ max_delay | default(value="60000") }},
        backoff_factor => {{ backoff_factor | default(value="2.0") }}
    },
    RetryPolicy = maps:merge(DefaultRetryPolicy,
                            proplists:get_value(retry_policy, Options, #{})),

    State = #state{
        queue = Queue,
        handler = Handler,
        current_job = undefined,
        timeout = Timeout,
        retry_policy = RetryPolicy,
        metrics = #{
            processed => 0,
            failed => 0,
            retried => 0
        }
    },

    %% Start processing jobs immediately
    self() ! fetch_job,

    {ok, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handle synchronous calls.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_call(Request :: term(), From :: {pid(), term()},
                 State :: #state{}) ->
    {reply, Reply :: term(), NewState :: #state{}}.
handle_call(get_status, _From, State) ->
    #state{
        current_job = CurrentJob,
        metrics = Metrics
    } = State,

    Status = #{
        current_job => case CurrentJob of
            undefined -> none;
            #job{id = Id} -> Id
        end,
        metrics => Metrics
    },

    {reply, Status, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handle asynchronous casts.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_cast(Request :: term(), State :: #state{}) ->
    {noreply, NewState :: #state{}}.
handle_cast({process_job, Job}, State) ->
    NewState = execute_job(Job, State),
    {noreply, NewState};

handle_cast(_Request, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handle messages.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_info(Info :: term(), State :: #state{}) ->
    {noreply, NewState :: #state{}}.
handle_info(fetch_job, State) ->
    #state{queue = Queue} = State,

    case job_queue:dequeue(Queue) of
        {ok, Job} ->
            NewState = execute_job(Job, State),
            %% Fetch next job
            self() ! fetch_job,
            {noreply, NewState};
        {error, empty} ->
            %% Queue is empty, wait and try again
            timer:send_after({{ poll_interval | default(value="1000") }}, fetch_job),
            {noreply, State};
        {error, Reason} ->
            logger:error("Failed to dequeue job: ~p", [Reason]),
            timer:send_after({{ error_retry_interval | default(value="5000") }}, fetch_job),
            {noreply, State}
    end;

handle_info({retry_job, Job}, State) ->
    NewState = execute_job(Job, State),
    {noreply, NewState};

handle_info(_Info, State) ->
    {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Cleanup on termination.
%%
%% @end
%%--------------------------------------------------------------------
-spec terminate(Reason :: term(), State :: #state{}) -> ok.
terminate(_Reason, _State) ->
    ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Code change handler.
%%
%% @end
%%--------------------------------------------------------------------
-spec code_change(OldVsn :: term(), State :: #state{}, Extra :: term()) ->
    {ok, NewState :: #state{}}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Execute a job with timeout and error handling.
%%
%% @end
%%--------------------------------------------------------------------
-spec execute_job(Job :: #job{}, State :: #state{}) -> #state{}.
execute_job(Job, State) ->
    #state{
        handler = Handler,
        timeout = Timeout,
        metrics = Metrics
    } = State,

    logger:info("Processing job ~s", [Job#job.id]),

    %% Update state with current job
    StateWithJob = State#state{current_job = Job},

    %% Execute with timeout
    try
        case timer:tc(Handler, handle_job, [Job]) of
            {Time, ok} ->
                logger:info("Job ~s completed in ~pms", [Job#job.id, Time div 1000]),
                NewMetrics = maps:update_with(processed, fun(V) -> V + 1 end, Metrics),
                StateWithJob#state{
                    current_job = undefined,
                    metrics = NewMetrics
                };
            {Time, {error, Reason}} ->
                logger:error("Job ~s failed after ~pms: ~p", [Job#job.id, Time div 1000, Reason]),
                handle_job_failure(Job, Reason, StateWithJob)
        end
    catch
        Class:Reason:Stacktrace ->
            logger:error("Job ~s crashed: ~p:~p~n~p",
                        [Job#job.id, Class, Reason, Stacktrace]),
            handle_job_failure(Job, {crash, Reason}, StateWithJob)
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handle job failure with retry logic.
%%
%% @end
%%--------------------------------------------------------------------
-spec handle_job_failure(Job :: #job{}, Reason :: term(), State :: #state{}) ->
    #state{}.
handle_job_failure(Job, Reason, State) ->
    #state{
        retry_policy = RetryPolicy,
        metrics = Metrics
    } = State,

    MaxRetries = maps:get(max_retries, RetryPolicy),
    CurrentRetries = Job#job.retries,

    if
        CurrentRetries < MaxRetries ->
            %% Schedule retry
            Delay = calculate_backoff(CurrentRetries, RetryPolicy),
            UpdatedJob = Job#job{
                retries = CurrentRetries + 1,
                status = retrying,
                error = Reason
            },

            logger:warning("Retrying job ~s in ~pms (attempt ~p/~p)",
                          [Job#job.id, Delay, CurrentRetries + 1, MaxRetries]),

            timer:send_after(Delay, {retry_job, UpdatedJob}),

            NewMetrics = maps:update_with(retried, fun(V) -> V + 1 end, Metrics),
            State#state{
                current_job = undefined,
                metrics = NewMetrics
            };
        true ->
            %% Max retries exceeded
            logger:error("Job ~s failed permanently after ~p retries",
                        [Job#job.id, MaxRetries]),

            NewMetrics = maps:update_with(failed, fun(V) -> V + 1 end, Metrics),
            State#state{
                current_job = undefined,
                metrics = NewMetrics
            }
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Calculate exponential backoff delay.
%%
%% @end
%%--------------------------------------------------------------------
-spec calculate_backoff(Retries :: non_neg_integer(), Policy :: map()) ->
    pos_integer().
calculate_backoff(Retries, Policy) ->
    InitialDelay = maps:get(initial_delay, Policy),
    MaxDelay = maps:get(max_delay, Policy),
    BackoffFactor = maps:get(backoff_factor, Policy),

    Delay = trunc(InitialDelay * math:pow(BackoffFactor, Retries)),
    min(Delay, MaxDelay).

%%%===================================================================
%%% Unit Tests
%%%===================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

calculate_backoff_test() ->
    Policy = #{
        initial_delay => 1000,
        max_delay => 60000,
        backoff_factor => 2.0
    },

    ?assertEqual(1000, calculate_backoff(0, Policy)),
    ?assertEqual(2000, calculate_backoff(1, Policy)),
    ?assertEqual(4000, calculate_backoff(2, Policy)),
    ?assertEqual(60000, calculate_backoff(10, Policy)). %% Capped at max

-endif.
