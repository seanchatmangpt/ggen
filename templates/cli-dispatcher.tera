/**
 * ggen-paas CLI Dispatcher
 *
 * Auto-generated from: .specify/cli-commands.ttl
 * Generated: {{ generation_time }}
 *
 * This file routes all CLI commands to their respective handlers.
 * All command definitions come from the RDF ontology.
 *
 * MANUAL EDITS WILL BE LOST on next `ggen sync`
 * Edit the RDF specification instead: .specify/cli-commands.ttl
 */

import chalk from 'chalk';
import { Logger } from './utils/logger.js';

{%- for command in commands %}
import {{ command.name | capitalize }}Command from './commands/{{ command.name }}.js';
{%- endfor %}

/**
 * CLI Dispatcher - Routes commands to handlers
 */
export class CLIDispatcher {
  constructor(config = {}) {
    this.config = config;
    this.logger = new Logger(config);
    this.commands = new Map();
    this.registerCommands();
  }

  /**
   * Register all commands from RDF specification
   */
  registerCommands() {
{%- for command in commands %}
    const {{ command.name }}Cmd = new {{ command.name | capitalize }}Command();
    this.commands.set('{{ command.name }}', {{ command.name }}Cmd);

{%- for alias in command.aliases %}
    this.commands.set('{{ alias }}', {{ command.name }}Cmd);  // Alias
{%- endfor %}

{%- endfor %}
  }

  /**
   * Parse command-line arguments
   */
  parseArgs(argv) {
    const [command, ...args] = argv;
    const options = {};
    let positionalIndex = 0;
    const positional = {};

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      if (arg === '--help' || arg === '-h') {
        options.help = true;
      } else if (arg === '--version' || arg === '-v') {
        options.version = true;
      } else if (arg === '--verbose') {
        options.verbose = (options.verbose || 0) + 1;
      } else if (arg === '-vvv') {
        options.verbose = 3;
      } else if (arg === '--quiet' || arg === '-q') {
        options.quiet = true;
      } else if (arg.startsWith('--')) {
        const [key, value] = arg.slice(2).split('=');
        options[this.camelCase(key)] = value || true;
      } else if (arg.startsWith('-') && arg.length === 2) {
        const shortForm = arg;
        const value = args[++i];
        options[shortForm] = value || true;
      } else {
        positional[`arg${positionalIndex++}`] = arg;
      }
    }

    return { command, positional, options };
  }

  /**
   * Display help for a command
   */
  async showHelp(commandName) {
    const cmd = this.commands.get(commandName);

    if (!cmd) {
      console.log(chalk.red(`Unknown command: ${commandName}`));
      await this.showGeneralHelp();
      process.exit(2);
    }

    const schema = cmd.defineSchema();
    console.log('');
    console.log(chalk.bold(`ggen paas ${commandName} - ${cmd.description}`));
    console.log('');
    console.log('USAGE');
    console.log(`  ggen paas ${commandName}${
      schema.positional.length > 0
        ? ' <' + schema.positional.map(a => a.name).join('> <') + '>'
        : ''
    } [options]`);
    console.log('');

    if (schema.positional.length > 0) {
      console.log('ARGUMENTS');
      for (const arg of schema.positional) {
        console.log(`  ${arg.name}${arg.required ? '' : ' (optional)'}`.padEnd(20));
        console.log(`                        ${arg.description}`);
        if (arg.choices && arg.choices.length > 0) {
          console.log(`                        Choices: ${arg.choices.join(', ')}`);
        }
      }
      console.log('');
    }

    console.log('OPTIONS');
    for (const [name, opt] of Object.entries(schema.options)) {
      const shortOpt = opt.shortForm ? ` ${opt.shortForm}` : '';
      console.log(`  ${opt.longForm}${shortOpt}`.padEnd(30) + opt.description);
      if (opt.default !== undefined) {
        console.log(`                                    Default: ${opt.default}`);
      }
      if (opt.choices && opt.choices.length > 0) {
        console.log(`                                    Choices: ${opt.choices.join(', ')}`);
      }
    }
    console.log('');

    if (cmd.examples) {
      console.log('EXAMPLES');
      for (const example of cmd.examples.split('\n')) {
        if (example.trim()) {
          console.log(`  ${example}`);
        }
      }
      console.log('');
    }
  }

  /**
   * Display general help
   */
  async showGeneralHelp() {
    console.log('');
    console.log(chalk.bold('ggen paas - Infrastructure generation and management'));
    console.log('');
    console.log('USAGE');
    console.log('  ggen paas <command> [options]');
    console.log('');
    console.log('COMMANDS');

    const commandsByCategory = {};
    for (const [name, cmd] of this.commands.entries()) {
      if (name === cmd.name) {  // Skip aliases
        const category = cmd.category || 'Miscellaneous';
        if (!commandsByCategory[category]) {
          commandsByCategory[category] = [];
        }
        commandsByCategory[category].push({
          name: cmd.name,
          description: cmd.description,
          aliases: cmd.aliases || [],
        });
      }
    }

    for (const [category, cmds] of Object.entries(commandsByCategory)) {
      console.log(`\n${chalk.dim(category)}`);
      for (const cmd of cmds) {
        const aliasStr = cmd.aliases.length > 0 ? ` (${cmd.aliases.join(', ')})` : '';
        console.log(`  ${cmd.name.padEnd(15)} ${cmd.description}${aliasStr}`);
      }
    }

    console.log('');
    console.log('GLOBAL OPTIONS');
    console.log('  --help, -h          Show this help message');
    console.log('  --version, -v       Show version');
    console.log('  --verbose, -vvv     Increase verbosity (stack for more)');
    console.log('  --quiet, -q         Suppress output');
    console.log('  --config, -c FILE   Config file override');
    console.log('');
    console.log('For help on a specific command:');
    console.log('  ggen paas <command> --help');
    console.log('');
  }

  /**
   * Show version
   */
  async showVersion() {
    // Version from package.json
    console.log(chalk.bold('ggen-paas v{{ version }}'));
    console.log('');
    console.log(`Generated from: .specify/cli-commands.ttl`);
    console.log(`Generated at: {{ generation_time }}`);
    console.log(`Specification closure: {{ specification_closure }}%`);
  }

  /**
   * Execute a command
   */
  async dispatch(argv) {
    const { command, positional, options } = this.parseArgs(argv);

    // Show general help
    if (!command || options.help) {
      await this.showGeneralHelp();
      process.exit(command ? 0 : 1);
    }

    // Show version
    if (options.version) {
      await this.showVersion();
      process.exit(0);
    }

    // Find command
    const handler = this.commands.get(command);
    if (!handler) {
      console.error(chalk.red(`Unknown command: ${command}`));
      await this.showGeneralHelp();
      process.exit(2);
    }

    // Show command help
    if (options.help) {
      await this.showHelp(command);
      process.exit(0);
    }

    // Execute command
    try {
      const result = await handler.execute(positional, options);
      process.exit(result.exitCode || 0);
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
      if (options.verbose) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  }

  /**
   * Convert kebab-case to camelCase
   */
  camelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }
}

/**
 * Base class for all commands
 */
export class CommandBase {
  constructor(config) {
    this.name = config.name;
    this.aliases = config.aliases || [];
    this.category = config.category;
    this.description = config.description;
    this.examples = config.examples;
    this.slo = config.slo;
    this.logger = new Logger({ name: this.name });
    this.startTime = Date.now();
  }

  /**
   * Define command schema (overridden by subclasses)
   */
  defineSchema() {
    return { positional: [], options: {} };
  }

  /**
   * Execute command (overridden by subclasses)
   */
  async execute(args, options) {
    throw new Error('execute() must be implemented by subclass');
  }

  /**
   * Return success result
   */
  success(data, format = 'text') {
    const duration = this.getDuration();
    const result = {
      exitCode: 0,
      success: true,
      duration,
      data,
    };

    if (format === 'json') {
      console.log(JSON.stringify(result, null, 2));
    } else if (format === 'yaml') {
      console.log(this.toYAML(result));
    } else {
      console.log(chalk.green(`✓ Success (${duration}ms)`));
      if (typeof data === 'string') {
        console.log(data);
      }
    }

    return result;
  }

  /**
   * Return failure result
   */
  fail(code, message, details = {}) {
    const duration = this.getDuration();
    const result = {
      exitCode: 1,
      success: false,
      code,
      message,
      details,
      duration,
    };

    console.error(chalk.red(`✗ ${code}: ${message}`));
    if (details && Object.keys(details).length > 0) {
      console.error(chalk.dim('Details:'));
      console.error(chalk.dim(JSON.stringify(details, null, 2)));
    }

    return result;
  }

  /**
   * Get elapsed duration
   */
  getDuration() {
    return Date.now() - this.startTime;
  }

  /**
   * Convert object to YAML string
   */
  toYAML(obj, indent = 0) {
    const spaces = ' '.repeat(indent);
    const lines = [];

    for (const [key, value] of Object.entries(obj)) {
      if (value === null || value === undefined) {
        lines.push(`${spaces}${key}:`);
      } else if (typeof value === 'object') {
        lines.push(`${spaces}${key}:`);
        lines.push(this.toYAML(value, indent + 2));
      } else if (typeof value === 'string' && value.includes('\n')) {
        lines.push(`${spaces}${key}: |-`);
        for (const line of value.split('\n')) {
          lines.push(`${spaces}  ${line}`);
        }
      } else {
        lines.push(`${spaces}${key}: ${value}`);
      }
    }

    return lines.join('\n');
  }
}
