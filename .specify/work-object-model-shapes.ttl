@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix ex: <http://ggen.example.org/disney#> .
@prefix wom: <http://ggen.org/work-object-model#> .

# =============================================================================
# WORK OBJECT MODEL - SHACL SHAPES FOR VALIDATION
# =============================================================================
# Validates:
#  1. Mandatory fields (e.g., every Shift MUST have shiftId, scheduledStartTime)
#  2. State machines (e.g., Shift cannot transition from completed to active)
#  3. Type constraints (e.g., assignedTo MUST reference a Resource instance)
#  4. Cardinality (e.g., Approval requires exactly one requiredAuthorityLevel)
#  5. Value ranges (e.g., priority must be one of: critical|high|normal|low)
#
# These constraints are enforceable via SPARQL validation or RDF reasoners.
# Combined with immutable events (complementary), they prevent invalid states.
# =============================================================================

<http://ggen.org/work-object-model-shapes>
  a owl:Ontology ;
  rdfs:label "Work Object Model SHACL Shapes" ;
  rdfs:comment "Validation constraints for Work Object Model types. Ensures state machine compliance and data quality." ;
  owl:versionInfo "1.0.0-phase1" ;
  .

# =============================================================================
# SHIFT SHAPE - Validation Rules
# =============================================================================
# Mandatory: shiftId, scheduledStartTime, scheduledEndTime, location, requiredRole, createdAt
# Status values: unscheduled | published | assigned | active | completed
# State transitions: ONLY forward (no backward transitions)

wom:ShiftShape
  a sh:NodeShape ;
  sh:targetClass wom:Shift ;
  sh:closed false ;  # Allow additional properties

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:shiftId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 5 ;
    sh:message "Shift must have exactly one shiftId (string, min 5 chars)" ;
  ] ;

  sh:property [
    sh:path wom:scheduledStartTime ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Shift must have exactly one scheduledStartTime (ISO 8601 dateTime)" ;
  ] ;

  sh:property [
    sh:path wom:scheduledEndTime ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Shift must have exactly one scheduledEndTime (ISO 8601 dateTime)" ;
  ] ;

  sh:property [
    sh:path wom:location ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "Hub" "Fantasyland" "SecurityCenter" "MaintenanceYard" "Tomorrowland" "Adventureland" ) ;
    sh:message "Shift location must be a canonical park area (ENUM)" ;
  ] ;

  sh:property [
    sh:path wom:requiredRole ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "SecurityLead" "Technician" "Opener" "Manager" "Supervisor" ) ;
    sh:message "Shift requiredRole must be a canonical role (ENUM)" ;
  ] ;

  sh:property [
    sh:path wom:createdAt ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Shift must have createdAt (server-set, immutable)" ;
  ] ;

  # === STATUS CONSTRAINT ===
  sh:property [
    sh:path wom:shiftStatus ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "unscheduled" "published" "assigned" "active" "completed" ) ;
    sh:message "Shift status must be one of: unscheduled | published | assigned | active | completed" ;
  ] ;

  # === OPTIONAL FIELDS ===
  sh:property [
    sh:path wom:assignedTo ;
    sh:maxCount 1 ;
    sh:class wom:Resource ;
    sh:message "assignedTo, if present, must reference a Resource instance" ;
  ] ;

  sh:property [
    sh:path wom:authorizedBy ;
    sh:maxCount 1 ;
    sh:class wom:Approval ;
    sh:message "authorizedBy, if present, must reference an Approval instance" ;
  ] ;

  sh:property [
    sh:path wom:hasTask ;
    sh:class wom:Task ;
    sh:message "All hasTask references must point to Task instances" ;
  ] ;

  sh:property [
    sh:path wom:hasIncident ;
    sh:class wom:Incident ;
    sh:message "All hasIncident references must point to Incident instances" ;
  ] ;

  # === STATE MACHINE CONSTRAINT (Logic) ===
  # Shifts cannot transition backward: once active, cannot revert to assigned
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Shift state transition invalid: cannot transition backward (completed/active → published/assigned/unscheduled)" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        # This constraint would require event history tracking
        # Simplified: Check that if status is 'completed', no earlier events show state revert
        # Actual implementation via wom:Event audit trail (see Event Shape)
      }
    """ ;
  ] ;

  # === TEMPORAL CONSISTENCY ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Shift start time must be before end time" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:scheduledStartTime ?start ;
              wom:scheduledEndTime ?end .
        FILTER (?start >= ?end)
      }
    """ ;
  ] ;

  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Shift createdAt must be before or equal to scheduledStartTime" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:createdAt ?created ;
              wom:scheduledStartTime ?start .
        FILTER (?created > ?start)
      }
    """ ;
  ] ;

  .

# =============================================================================
# TASK SHAPE - Validation Rules
# =============================================================================
# Mandatory: taskId, title, estimatedDurationMinutes, successCriteria, parentShift, createdAt
# Status: unassigned | assigned | in_progress | completed
# Immutable: cannot revert status backward

wom:TaskShape
  a sh:NodeShape ;
  sh:targetClass wom:Task ;
  sh:closed false ;

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:taskId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 5 ;
    sh:message "Task must have exactly one taskId (string, min 5 chars)" ;
  ] ;

  sh:property [
    sh:path wom:title ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:maxLength 200 ;
    sh:message "Task must have exactly one title (max 200 chars)" ;
  ] ;

  sh:property [
    sh:path wom:estimatedDurationMinutes ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:integer ;
    sh:minInclusive 1 ;
    sh:message "Task must have estimatedDurationMinutes (positive integer)" ;
  ] ;

  sh:property [
    sh:path wom:successCriteria ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 10 ;
    sh:message "Task must have explicit successCriteria (observable, testable)" ;
  ] ;

  sh:property [
    sh:path wom:parentShift ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:class wom:Shift ;
    sh:message "Task must be contained in exactly one Shift" ;
  ] ;

  sh:property [
    sh:path wom:createdAt ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Task must have createdAt (immutable)" ;
  ] ;

  # === STATUS CONSTRAINT ===
  sh:property [
    sh:path wom:taskStatus ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "unassigned" "assigned" "in_progress" "completed" ) ;
    sh:message "Task status must be one of: unassigned | assigned | in_progress | completed" ;
  ] ;

  # === PRIORITY CONSTRAINT ===
  sh:property [
    sh:path wom:priority ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "critical" "high" "normal" "low" ) ;
    sh:message "Task priority, if set, must be one of: critical | high | normal | low" ;
  ] ;

  # === OPTIONAL RELATIONSHIPS ===
  sh:property [
    sh:path wom:requiresResource ;
    sh:maxCount 1 ;
    sh:class wom:Resource ;
    sh:message "requiresResource, if present, must reference a Resource" ;
  ] ;

  sh:property [
    sh:path wom:assignedTaskTo ;
    sh:maxCount 1 ;
    sh:class wom:Resource ;
    sh:message "assignedTaskTo, if present, must reference a Resource" ;
  ] ;

  sh:property [
    sh:path wom:blockedBy ;
    sh:class wom:Task ;
    sh:message "blockedBy references must point to other Task instances" ;
  ] ;

  # === TEMPORAL CONSTRAINT ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Task createdAt must be before or equal to parentShift scheduledStartTime" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:createdAt ?created ;
              wom:parentShift ?shift .
        ?shift wom:scheduledStartTime ?shiftStart .
        FILTER (?created > ?shiftStart)
      }
    """ ;
  ] ;

  # === STATUS IMMUTABILITY ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Task status cannot revert backward (completed → in_progress is invalid)" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        # Requires event audit trail; simplified version:
        # If any event shows: completed → in_progress, FAIL
        # Actual validation via wom:Event history (see EventShape)
      }
    """ ;
  ] ;

  .

# =============================================================================
# INCIDENT SHAPE - Validation Rules
# =============================================================================
# Mandatory: incidentId, title, description, severity, reportedAt, reportedBy
# Status: reported | assigned | investigating | resolved
# Can revert: investigating ← resolved (re-open if not solved)

wom:IncidentShape
  a sh:NodeShape ;
  sh:targetClass wom:Incident ;
  sh:closed false ;

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:incidentId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:pattern "^INC-[0-9]{4}-[0-9]{5}$" ;
    sh:message "Incident must have incidentId matching INC-YYYY-NNNNN format" ;
  ] ;

  sh:property [
    sh:path wom:title ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Incident must have a title" ;
  ] ;

  sh:property [
    sh:path wom:description ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 20 ;
    sh:message "Incident description must be detailed (min 20 chars)" ;
  ] ;

  sh:property [
    sh:path wom:severity ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "critical" "high" "medium" "low" ) ;
    sh:message "Incident severity must be one of: critical | high | medium | low" ;
  ] ;

  sh:property [
    sh:path wom:reportedAt ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Incident must have reportedAt (immutable)" ;
  ] ;

  sh:property [
    sh:path wom:reportedBy ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Incident must have reportedBy (user/system ID)" ;
  ] ;

  # === STATUS CONSTRAINT ===
  sh:property [
    sh:path wom:incidentStatus ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "reported" "assigned" "investigating" "resolved" ) ;
    sh:message "Incident status must be one of: reported | assigned | investigating | resolved" ;
  ] ;

  # === OPTIONAL FIELDS ===
  sh:property [
    sh:path wom:affectedResource ;
    sh:maxCount 1 ;
    sh:class wom:Resource ;
    sh:message "affectedResource, if present, must reference a Resource" ;
  ] ;

  sh:property [
    sh:path wom:affectedShift ;
    sh:maxCount 1 ;
    sh:class wom:Shift ;
    sh:message "affectedShift, if present, must reference a Shift" ;
  ] ;

  sh:property [
    sh:path wom:assignedTo ;
    sh:maxCount 1 ;
    sh:class wom:Resource ;
    sh:message "assignedTo, if present, must reference a Resource (person)" ;
  ] ;

  # === RESOLVED INCIDENT CONSTRAINTS ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Resolved incident must have resolution text and resolvedAt timestamp" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:incidentStatus "resolved" .
        FILTER NOT EXISTS { $this wom:resolution ?res }
        FILTER NOT EXISTS { $this wom:resolvedAt ?at }
      }
    """ ;
  ] ;

  # === CRITICAL INCIDENT ESCALATION ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Critical severity incident must have escalationPath defined" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:severity "critical" .
        FILTER NOT EXISTS { $this wom:escalationPath ?path }
      }
    """ ;
  ] ;

  .

# =============================================================================
# APPROVAL SHAPE - Validation Rules
# =============================================================================
# Mandatory: approvalId, approvalType, subject, requestedAt, requestedBy, requiredAuthorityLevel
# Status: pending | approved | rejected | executed
# State machine: pending → (approved|rejected) → executed

wom:ApprovalShape
  a sh:NodeShape ;
  sh:targetClass wom:Approval ;
  sh:closed false ;

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:approvalId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:pattern "^APR-[0-9]{4}-[0-9]{5}$" ;
    sh:message "Approval must have approvalId matching APR-YYYY-NNNNN format" ;
  ] ;

  sh:property [
    sh:path wom:approvalType ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "shift_assignment" "incident_escalation" "resource_change" "policy_override" ) ;
    sh:message "Approval type must be one of: shift_assignment | incident_escalation | resource_change | policy_override" ;
  ] ;

  sh:property [
    sh:path wom:subject ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 10 ;
    sh:message "Approval subject must be descriptive (min 10 chars)" ;
  ] ;

  sh:property [
    sh:path wom:requestedAt ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Approval must have requestedAt (immutable)" ;
  ] ;

  sh:property [
    sh:path wom:requestedBy ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Approval must have requestedBy (user/role ID)" ;
  ] ;

  sh:property [
    sh:path wom:requiredAuthorityLevel ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "manager" "director" "executive" "ciso" "legal" ) ;
    sh:message "Required authority level must be one of: manager | director | executive | ciso | legal" ;
  ] ;

  # === STATUS CONSTRAINT ===
  sh:property [
    sh:path wom:approvalStatus ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "pending" "approved" "rejected" "executed" ) ;
    sh:message "Approval status must be one of: pending | approved | rejected | executed" ;
  ] ;

  # === CONDITIONAL MANDATORY FIELDS ===
  # If status=approved, must have approvedBy, approvedAt, signatureHash
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Approved approval must have approvedBy, approvedAt, and signatureHash" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:approvalStatus "approved" .
        {
          FILTER NOT EXISTS { $this wom:approvedBy ?by }
        } UNION {
          FILTER NOT EXISTS { $this wom:approvedAt ?at }
        } UNION {
          FILTER NOT EXISTS { $this wom:signatureHash ?hash }
        }
      }
    """ ;
  ] ;

  # If status=rejected, must have rejectionReason
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Rejected approval must have rejectionReason" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:approvalStatus "rejected" .
        FILTER NOT EXISTS { $this wom:rejectionReason ?reason }
      }
    """ ;
  ] ;

  # === TEMPORAL CONSTRAINT ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Approved/Rejected must have decision timestamp after requestedAt" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:requestedAt ?req ;
              wom:approvalStatus ?status .
        FILTER (?status IN ("approved", "rejected")) .
        OPTIONAL { $this wom:approvedAt ?appr . }
        OPTIONAL { $this wom:rejectionReason ?reason . BIND(NOW() AS ?appr) }
        FILTER (?appr < ?req)
      }
    """ ;
  ] ;

  .

# =============================================================================
# RESOURCE SHAPE - Validation Rules
# =============================================================================
# Mandatory: resourceId, resourceType, name, department
# Status: available | reserved | in_use | maintenance | unavailable
# Type determines additional mandatory fields (e.g., qualifications for persons)

wom:ResourceShape
  a sh:NodeShape ;
  sh:targetClass wom:Resource ;
  sh:closed false ;

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:resourceId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 5 ;
    sh:message "Resource must have exactly one resourceId (string, min 5 chars)" ;
  ] ;

  sh:property [
    sh:path wom:resourceType ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "person" "equipment" "system" "vehicle" ) ;
    sh:message "Resource type must be one of: person | equipment | system | vehicle" ;
  ] ;

  sh:property [
    sh:path wom:name ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:minLength 2 ;
    sh:message "Resource must have a name (min 2 chars)" ;
  ] ;

  sh:property [
    sh:path wom:department ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Resource must have a department" ;
  ] ;

  # === STATUS CONSTRAINT ===
  sh:property [
    sh:path wom:resourceStatus ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "available" "reserved" "in_use" "maintenance" "unavailable" ) ;
    sh:message "Resource status must be one of: available | reserved | in_use | maintenance | unavailable" ;
  ] ;

  # === PERSON-SPECIFIC CONSTRAINTS ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Person resource must have capacity constraint (e.g., '1' for single shift)" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:resourceType "person" .
        FILTER NOT EXISTS { $this wom:capacity ?cap }
      }
    """ ;
  ] ;

  # === EQUIPMENT-SPECIFIC CONSTRAINTS ===
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Equipment resource must have maintenanceSchedule" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        $this wom:resourceType "equipment" .
        FILTER NOT EXISTS { $this wom:maintenanceSchedule ?schedule }
      }
    """ ;
  ] ;

  # === OPTIONAL FIELDS ===
  sh:property [
    sh:path wom:sourceSystem ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:in ( "workday" "sap" "manual" "monitoring" ) ;
    sh:message "Source system, if present, must be one of: workday | sap | manual | monitoring" ;
  ] ;

  .

# =============================================================================
# EVENT SHAPE - Immutable Audit Trail
# =============================================================================
# Mandatory: eventId, eventType, affectedObject, changedBy, changedAt
# Ensures audit trail integrity for merge algebra

wom:EventShape
  a sh:NodeShape ;
  sh:targetClass wom:Event ;
  sh:closed false ;

  # === MANDATORY FIELDS ===
  sh:property [
    sh:path wom:eventId ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:pattern "^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$" ;
    sh:message "Event must have a UUID (version 4)" ;
  ] ;

  sh:property [
    sh:path wom:eventType ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Event must have an eventType (e.g., 'shift.status.changed')" ;
  ] ;

  sh:property [
    sh:path wom:affectedObject ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:class wom:WorkObject ;
    sh:message "Event must reference exactly one affected Work Object" ;
  ] ;

  sh:property [
    sh:path wom:changedBy ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:string ;
    sh:message "Event must have changedBy (user/system ID)" ;
  ] ;

  sh:property [
    sh:path wom:changedAt ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:message "Event must have server-generated changedAt timestamp" ;
  ] ;

  # === IMMUTABILITY ===
  # Events cannot be updated; only created once
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Event is immutable; changedAt and changedBy cannot be modified after creation" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this
      WHERE {
        # In practice: enforce at application layer (no UPDATE on Events)
        # This comment documents the constraint
      }
    """ ;
  ] ;

  .

# =============================================================================
# MERGED OBJECT SHAPE - Conflict Detection
# =============================================================================
# Detects when two teams edit the same object independently
# Requires version tracking for merge algebra

wom:MergeConflictDetection
  a sh:NodeShape ;
  rdfs:label "Merge Conflict Detection" ;
  rdfs:comment "Validates concurrent edit scenarios. Flags conflicts for manual review." ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Concurrent edits to critical fields (status, authorization) require manual merge resolution" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT $this ?event1 ?event2
      WHERE {
        # Detects: two events from different sources modifying same critical field
        # within 5-minute window (likely concurrent edit)
        $this a wom:WorkObject .
        $this (wom:shiftStatus | wom:taskStatus | wom:incidentStatus | wom:approvalStatus) ?status .

        # Would find conflicting events in history and flag for resolution
        # Simplified: requires Event audit trail implementation
      }
    """ ;
  ] ;
  .

# =============================================================================
# PROPERTY-LEVEL CARDINALITY CHECKS
# =============================================================================

wom:UniqueIdShape
  a sh:NodeShape ;
  sh:targetClass wom:WorkObject ;
  sh:closed false ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "IDs must be globally unique (within resource class)" ;
    sh:prefixes "wom: <http://ggen.org/work-object-model#>" ;
    sh:select """
      SELECT ?id (COUNT(?s) AS ?count)
      WHERE {
        ?s (wom:shiftId | wom:taskId | wom:incidentId | wom:approvalId | wom:resourceId) ?id .
      }
      GROUP BY ?id
      HAVING (?count > 1)
    """ ;
  ] ;
  .

# =============================================================================
# METADATA
# =============================================================================

wom:ShapesMetadata
  a owl:Class ;
  rdfs:label "Work Object Model SHACL Shapes Metadata" ;
  rdfs:comment "Validation rules for Work Object Model Phase 1. Enforces state machines, cardinality, and immutability." ;
  .

