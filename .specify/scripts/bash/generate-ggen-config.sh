#!/usr/bin/env bash
# ============================================================================
# generate-ggen-config.sh - Generate ggen.toml for RDF-based Spec-Kit features
# ============================================================================
# Purpose: Create ggen v6 configuration for feature branches
# Usage: generate-ggen-config.sh <branch> <feature-name> <specs-dir>
#
# Example:
#   generate-ggen-config.sh 001-photo-albums "Photo Album Organization" .specify/specs/001-photo-albums
#
# Generates: <specs-dir>/ggen.toml with complete v6 pipeline configuration
# ============================================================================

set -euo pipefail

# Arguments
BRANCH="${1:-}"
FEATURE_NAME="${2:-}"
SPECS_DIR="${3:-}"

# Validation
if [[ -z "$BRANCH" || -z "$FEATURE_NAME" || -z "$SPECS_DIR" ]]; then
    echo "Error: Missing required arguments"
    echo "Usage: $0 <branch> <feature-name> <specs-dir>"
    echo "Example: $0 001-photo-albums \"Photo Album Organization\" .specify/specs/001-photo-albums"
    exit 1
fi

# Sanitize feature name for project name (lowercase, hyphenated)
PROJECT_NAME=$(echo "$FEATURE_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')

# Output file
OUTPUT_FILE="$SPECS_DIR/ggen.toml"

# Generate ggen.toml
cat > "$OUTPUT_FILE" <<'EOF'
# ============================================================================
# ggen v6 Configuration: Spec-Kit Feature - FEATURE_NAME_PLACEHOLDER
# ============================================================================
# Generated by: vendors/spec-kit/scripts/bash/generate-ggen-config.sh
# Branch: BRANCH_PLACEHOLDER
# ============================================================================

[project]
name = "PROJECT_NAME_PLACEHOLDER"
version = "1.0.0"
description = "FEATURE_NAME_PLACEHOLDER specification"

# ----------------------------------------------------------------------------
# v6 Pipeline Configuration
# ----------------------------------------------------------------------------

[v6]
enabled = true
ontology = "ontology/spec-kit-schema.ttl,ontology/feature-content.ttl"
output_dir = "generated"

# Five-stage pipeline (μ₁ → μ₂ → μ₃ → μ₄ → μ₅)
[v6.passes]
normalization = { order = 1, type = "construct", enabled = true }
extraction = { order = 2, type = "select", enabled = true }
emission = { order = 3, type = "tera", enabled = true }
canonicalization = { order = 4, type = "format", enabled = true }
receipt = { order = 5, type = "hash", enabled = true }

# Constitutional invariants enforcement
[v6.invariants]
idempotence = true       # μ∘μ = μ (running twice produces zero changes)
determinism = true       # Same ontology → same output (cross-platform)
provenance = true        # Cryptographic receipt proves spec.md = μ(ontology)
no_edit = true          # Generated files never manually edited
substrate_only = true   # Only .ttl files version-controlled as truth

# Vocabulary governance (allowed RDF namespaces)
[v6.vocabulary]
allowed = [
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "http://www.w3.org/2000/01/rdf-schema#",
    "http://www.w3.org/2001/XMLSchema#",
    "http://www.w3.org/ns/shacl#",
    "http://github.com/github/spec-kit#",
]

# ----------------------------------------------------------------------------
# Generation Rules (SPARQL → Tera → Markdown)
# ----------------------------------------------------------------------------

# Complete Specification (Single File)
[[generation]]
name = "spec"
description = "Generate complete specification from RDF ontology"
query = """
PREFIX sk: <http://github.com/github/spec-kit#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?featureBranch ?featureName ?created ?status ?userInput
       ?storyIndex ?title ?priority ?description ?priorityRationale ?independentTest
       ?scenarioIndex ?given ?when ?then
       ?requirementId ?reqDescription ?category
       ?criterionId ?scDescription ?measurable ?metric ?target
       ?entityName ?definition ?keyAttributes
       ?edgeScenario ?expectedBehavior
       ?assumption
WHERE {
    # Feature metadata
    ?feature a sk:Feature ;
             sk:featureBranch ?featureBranch ;
             sk:featureName ?featureName ;
             sk:created ?created ;
             sk:status ?status .
    OPTIONAL { ?feature sk:userInput ?userInput }

    # User stories with nested acceptance scenarios
    OPTIONAL {
        ?feature sk:hasUserStory ?story .
        ?story sk:storyIndex ?storyIndex ;
               sk:title ?title ;
               sk:priority ?priority ;
               sk:description ?description ;
               sk:priorityRationale ?priorityRationale ;
               sk:independentTest ?independentTest ;
               sk:hasAcceptanceScenario ?scenario .
        ?scenario sk:scenarioIndex ?scenarioIndex ;
                  sk:given ?given ;
                  sk:when ?when ;
                  sk:then ?then .
    }

    # Functional requirements
    OPTIONAL {
        ?feature sk:hasFunctionalRequirement ?req .
        ?req sk:requirementId ?requirementId ;
             sk:description ?reqDescription .
        OPTIONAL { ?req sk:category ?category }
    }

    # Success criteria
    OPTIONAL {
        ?feature sk:hasSuccessCriterion ?criterion .
        ?criterion sk:criterionId ?criterionId ;
                   sk:description ?scDescription ;
                   sk:measurable ?measurable .
        OPTIONAL { ?criterion sk:metric ?metric }
        OPTIONAL { ?criterion sk:target ?target }
    }

    # Entities
    OPTIONAL {
        ?feature sk:hasEntity ?entity .
        ?entity sk:entityName ?entityName ;
                sk:definition ?definition .
        OPTIONAL { ?entity sk:keyAttributes ?keyAttributes }
    }

    # Edge cases
    OPTIONAL {
        ?feature sk:hasEdgeCase ?edgeCase .
        ?edgeCase sk:scenario ?edgeScenario ;
                  sk:expectedBehavior ?expectedBehavior .
    }

    # Assumptions
    OPTIONAL {
        ?feature sk:hasAssumption ?assumption .
        ?assumption sk:description ?assumption .
    }
}
ORDER BY ?storyIndex ?scenarioIndex ?requirementId ?criterionId ?entityName
"""
template = "templates/spec.tera"
output = "generated/spec.md"

# ----------------------------------------------------------------------------
# SHACL Validation Configuration (μ₁ Pass)
# ----------------------------------------------------------------------------

[v6.validation]
enabled = true
shapes_file = "ontology/spec-kit-schema.ttl"
fail_on_violation = true

# ----------------------------------------------------------------------------
# Guards (Forbidden Output Patterns)
# ----------------------------------------------------------------------------

[v6.guards]
enabled = true

[[v6.guards.patterns]]
pattern = 'ghp_[a-zA-Z0-9]{36}'
description = "GitHub personal access token"

[[v6.guards.patterns]]
pattern = 'sk-[a-zA-Z0-9]{48}'
description = "OpenAI API key"

[[v6.guards.patterns]]
pattern = '/Users/[a-zA-Z0-9_-]+/'
description = "macOS absolute path"

[[v6.guards.patterns]]
pattern = 'C:\\\\Users\\\\'
description = "Windows absolute path"

# ----------------------------------------------------------------------------
# Canonicalization Rules (μ₄ Pass)
# ----------------------------------------------------------------------------

[v6.canonicalization]
line_endings = "lf"
trim_trailing_whitespace = true
ensure_final_newline = true
max_line_length = 0

# ----------------------------------------------------------------------------
# Receipt Configuration (μ₅ Pass)
# ----------------------------------------------------------------------------

[v6.receipt]
enabled = true
algorithm = "SHA-256"
output_file = "generated/.receipt.json"
EOF

# Replace placeholders
sed -i.bak \
    -e "s/BRANCH_PLACEHOLDER/$BRANCH/g" \
    -e "s/FEATURE_NAME_PLACEHOLDER/$FEATURE_NAME/g" \
    -e "s/PROJECT_NAME_PLACEHOLDER/$PROJECT_NAME/g" \
    "$OUTPUT_FILE"

# Remove backup file
rm -f "$OUTPUT_FILE.bak"

echo "✅ Generated ggen.toml at: $OUTPUT_FILE"
echo "   Branch: $BRANCH"
echo "   Feature: $FEATURE_NAME"
echo "   Project: $PROJECT_NAME"
