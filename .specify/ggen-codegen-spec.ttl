@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix kgc: <http://ggen.org/kgc#> .
@prefix ggen: <http://ggen.org/ggen#> .
@prefix holo: <http://ggen.org/holographic#> .
@prefix code: <http://ggen.org/codegen#> .
@prefix sparql: <http://ggen.org/sparql#> .
@prefix template: <http://ggen.org/template#> .

# =============================================================================
# CODE GENERATION SPECIFICATION
# =============================================================================
# Formal specification of what code should be generated and how.
# This is the ontological source of truth for all code artifacts.
# Code is never written manually; it is always generated from this spec.
# =============================================================================

<http://ggen.org/codegen-spec>
  a owl:Ontology ;
  rdfs:label "ggen Code Generation Specification" ;
  rdfs:comment "Source of truth for code generation. All code flows from this ontology through the measurement function μ." ;
  owl:versionInfo "1.0.0" ;
  .

# =============================================================================
# CODE GENERATION PATTERNS
# =============================================================================
# Define what code should be generated by specifying:
# 1. What pattern to extract via SPARQL
# 2. Which template to use for emission
# 3. Output file location

code:CodeGenerationPattern
  a owl:Class ;
  rdfs:label "Code Generation Pattern" ;
  rdfs:comment "A specification of what code to generate: SPARQL pattern + Tera template + output location" ;
  .

code:hasPattern
  a owl:ObjectProperty ;
  rdfs:label "has pattern" ;
  rdfs:domain code:CodeGenerator ;
  rdfs:range code:CodeGenerationPattern ;
  rdfs:comment "Link code generator to patterns it should produce" ;
  .

code:sparqlQuery
  a owl:DatatypeProperty ;
  rdfs:label "SPARQL query" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "SPARQL CONSTRUCT query to extract pattern from RDF" ;
  .

code:teraTemplate
  a owl:DatatypeProperty ;
  rdfs:label "Tera template" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "Tera template string for code emission" ;
  .

code:outputPath
  a owl:DatatypeProperty ;
  rdfs:label "output path" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "Where to write the generated code" ;
  .

# =============================================================================
# STAGE 1: RDF PARSER SPECIFICATION
# =============================================================================
# Specification for the Rust code that parses RDF and validates schema

code:RdfParserGenerator
  a code:CodeGenerator ;
  rdfs:label "RDF Parser Code Generator" ;
  rdfs:comment "Generate Rust code for parsing and normalizing RDF graphs" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Parse RDF Snapshot" ;
    code:sparqlQuery """
      PREFIX kgc: <http://ggen.org/kgc#>
      CONSTRUCT {
        ?snapshot a kgc:ObservableSnapshot ;
          kgc:snapshotHash ?hash ;
          kgc:snapshotTimestamp ?ts .
      }
      WHERE {
        ?snapshot a kgc:ObservableSnapshot ;
          kgc:snapshotHash ?hash ;
          kgc:snapshotTimestamp ?ts .
      }
    """ ;
    code:teraTemplate """
      // Generated: Parse RDF Observable Snapshot
      use std::path::Path;
      use oxigraph::store::Store;

      pub fn parse_snapshot(snapshot_path: &str) -> Result<Store, Box<dyn std::error::Error>> {
          let store = Store::new()?;
          let path = Path::new(snapshot_path);

          // Load RDF from Turtle format
          let file = std::fs::File::open(path)?;
          store.load_graph(file, "http://ggen.org/kgc#", None)?;

          Ok(store)
      }
    """ ;
    code:outputPath "target/ggen/generated/parser.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 2: SPARQL EXECUTOR SPECIFICATION
# =============================================================================
# Specification for extracting semantic patterns via SPARQL

code:SparqlExecutorGenerator
  a code:CodeGenerator ;
  rdfs:label "SPARQL Executor Code Generator" ;
  rdfs:comment "Generate Rust code for executing SPARQL CONSTRUCT queries" ;
  kgc:stageNumber 2 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Execute SPARQL Queries" ;
    code:teraTemplate """
      // Generated: SPARQL Pattern Extraction
      use oxigraph::store::Store;
      use oxigraph::sparql::QueryResults;

      pub fn extract_patterns(store: &Store, query: &str) -> Result<String, Box<dyn std::error::Error>> {
          let results = store.query(query)?;

          match results {
              QueryResults::Graph(graph) => {
                  let mut output = String::new();
                  // Serialize results back to Turtle
                  for quad in graph {
                      output.push_str(&format!("{:?} .\\n", quad?));
                  }
                  Ok(output)
              }
              _ => Err("Expected graph results from CONSTRUCT query".into())
          }
      }
    """ ;
    code:outputPath "target/ggen/generated/executor.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 3: CODE EMITTER SPECIFICATION
# =============================================================================
# Specification for Tera template-based code emission

code:CodeEmitterGenerator
  a code:CodeGenerator ;
  rdfs:label "Code Emitter Generator" ;
  rdfs:comment "Generate Rust code for template-based code emission" ;
  kgc:stageNumber 3 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Emit Code via Templates" ;
    code:teraTemplate """
      // Generated: Template-based Code Emitter
      use tera::Tera;
      use serde_json::json;

      pub fn emit_code(template_str: &str, context: &str) -> Result<String, Box<dyn std::error::Error>> {
          let mut tera = Tera::default();
          tera.add_raw_template("codegen", template_str)?;

          let rendered = tera.render("codegen", &tera::Context::from_json(json!({"data": context}))?)?;
          Ok(rendered)
      }
    """ ;
    code:outputPath "target/ggen/generated/emitter.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 4: CANONICALIZER SPECIFICATION
# =============================================================================
# Specification for deterministic output normalization

code:CanonicalizeGenerator
  a code:CodeGenerator ;
  rdfs:label "Canonicalizer Code Generator" ;
  rdfs:comment "Generate Rust code for format normalization and determinism" ;
  kgc:stageNumber 4 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Canonicalize Output" ;
    code:teraTemplate """
      // Generated: Output Canonicalization
      use sha2::{Sha256, Digest};

      pub fn canonicalize(code: &str) -> Result<String, Box<dyn std::error::Error>> {
          // Normalize whitespace
          let normalized = code.lines()
              .map(|l| l.trim_end())
              .collect::<Vec<_>>()
              .join("\\n");

          // Ensure final newline
          let final_code = if normalized.ends_with("\\n") {
              normalized
          } else {
              format!("{}\\n", normalized)
          };

          Ok(final_code)
      }

      pub fn compute_hash(data: &str) -> String {
          let mut hasher = Sha256::new();
          hasher.update(data.as_bytes());
          format!("{:x}", hasher.finalize())
      }
    """ ;
    code:outputPath "target/ggen/generated/canonicalizer.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 5: RECEIPT GENERATOR SPECIFICATION
# =============================================================================
# Specification for cryptographic proof generation

code:ReceiptGeneratorSpec
  a code:CodeGenerator ;
  rdfs:label "Receipt Generator Code Generator" ;
  rdfs:comment "Generate Rust code for generating JSON-LD closure proofs" ;
  kgc:stageNumber 5 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Generate Receipt" ;
    code:teraTemplate """
      // Generated: Receipt Generation
      use serde_json::json;
      use chrono::Utc;

      pub fn generate_receipt(artifact_hash: &str, artifact_type: &str) -> String {
          json!({
              "@context": "http://ggen.org/context.jsonld",
              "@type": artifact_type,
              "hash": artifact_hash,
              "timestamp": Utc::now().to_rfc3339(),
              "canonicalized": true,
              "deterministic": true
          }).to_string()
      }
    """ ;
    code:outputPath "target/ggen/generated/receipt.rs" ;
  ] ;
  .

# =============================================================================
# CODE GENERATOR BASE CLASS
# =============================================================================

code:CodeGenerator
  a owl:Class ;
  rdfs:label "Code Generator" ;
  rdfs:comment "Specification for what code should be generated in each stage" ;
  .

code:stageNumber
  a owl:DatatypeProperty ;
  rdfs:domain code:CodeGenerator ;
  rdfs:range xsd:integer ;
  rdfs:comment "Which stage this generator operates in (1-5)" ;
  .

# =============================================================================
# VALIDATION CONSTRAINT
# =============================================================================
# All generated code must satisfy invariants

code:GeneratedCode
  a owl:Class ;
  rdfs:label "Generated Code" ;
  rdfs:comment "Code output by ggen-sync. Must preserve invariants." ;
  .

code:generatedFrom
  a owl:ObjectProperty ;
  rdfs:domain code:GeneratedCode ;
  rdfs:range code:CodeGenerationPattern ;
  rdfs:comment "Links code to the pattern that generated it" ;
  .

code:hasInvariant
  a owl:ObjectProperty ;
  rdfs:domain code:GeneratedCode ;
  rdfs:range kgc:Invariant ;
  rdfs:comment "Invariants preserved by generated code" ;
  .

# =============================================================================
# ADDITIONAL CLI COMMANDS (Code Generation Specs)
# =============================================================================
# These patterns extend ggen with more capabilities, all generated from specs

code:QueryCommandGenerator
  a code:CodeGenerator ;
  rdfs:label "Query Command Code Generator" ;
  rdfs:comment "Generate code for ggen query - execute SPARQL queries against specifications" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "SPARQL Query Executor" ;
    code:teraTemplate """
      // Generated: SPARQL Query Executor (ggen query)
      // Auto-generated from: ggen-codegen-spec.ttl

      use std::error::Error;

      pub fn execute_sparql_query(rdf_file: &str, query: &str) -> Result<String, Box<dyn Error>> {
          // Load RDF graph
          let content = std::fs::read_to_string(rdf_file)?;

          if !content.contains("@prefix") {
              return Err("Invalid RDF/Turtle format".into());
          }

          // In full implementation, would execute SPARQL CONSTRUCT/SELECT
          // For now, return query validation result
          if query.contains("SELECT") || query.contains("CONSTRUCT") {
              Ok(format!("Query parsed successfully: {}", query))
          } else {
              Err("Invalid SPARQL query".into())
          }
      }
    """ ;
    code:outputPath "target/ggen/generated/query_executor.rs" ;
  ] ;
  .

code:ValidateCommandGenerator
  a code:CodeGenerator ;
  rdfs:label "Validate Command Code Generator" ;
  rdfs:comment "Generate code for ggen validate - validate specs against SHACL shapes" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "SHACL Validator" ;
    code:teraTemplate """
      // Generated: SHACL Specification Validator (ggen validate)
      // Auto-generated from: ggen-codegen-spec.ttl

      use std::error::Error;
      use std::path::Path;

      pub fn validate_specification(spec_file: &str, shapes_file: &str) -> Result<bool, Box<dyn Error>> {
          let spec_path = Path::new(spec_file);
          let shapes_path = Path::new(shapes_file);

          if !spec_path.exists() {
              return Err(format!("Specification file not found: {}", spec_file).into());
          }

          if !shapes_path.exists() {
              return Err(format!("Shapes file not found: {}", shapes_file).into());
          }

          // In full implementation, would run pyshacl validation
          // For now, verify files are valid TTL
          let spec = std::fs::read_to_string(spec_path)?;
          let shapes = std::fs::read_to_string(shapes_path)?;

          Ok(spec.contains("@prefix") && shapes.contains("@prefix"))
      }

      pub fn report_violations(report: &str) -> String {
          format!("Validation Report: {}", report)
      }
    """ ;
    code:outputPath "target/ggen/generated/spec_validator.rs" ;
  ] ;
  .

code:ListCommandGenerator
  a code:CodeGenerator ;
  rdfs:label "List Command Code Generator" ;
  rdfs:comment "Generate code for ggen list - list available code patterns" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Pattern Lister" ;
    code:teraTemplate """
      // Generated: Code Pattern Lister (ggen list)
      // Auto-generated from: ggen-codegen-spec.ttl

      use std::error::Error;

      pub struct CodePattern {
          pub name: String,
          pub generator: String,
          pub stage: usize,
          pub output: String,
      }

      pub fn list_patterns(spec_file: &str) -> Result<Vec<CodePattern>, Box<dyn Error>> {
          let content = std::fs::read_to_string(spec_file)?;

          let mut patterns = Vec::new();

          if content.contains("RdfParserGenerator") {
              patterns.push(CodePattern {
                  name: "RDF Parser".to_string(),
                  generator: "RdfParserGenerator".to_string(),
                  stage: 1,
                  output: "parser.rs".to_string(),
              });
          }

          Ok(patterns)
      }

      pub fn display_patterns(patterns: &[CodePattern]) -> String {
          let mut output = String::from("Available Code Patterns:\\n");
          for p in patterns {
              output.push_str(&format!("  - {} (Stage {}) → {}\\n", p.name, p.stage, p.output));
          }
          output
      }
    """ ;
    code:outputPath "target/ggen/generated/pattern_lister.rs" ;
  ] ;
  .

code:InfoCommandGenerator
  a code:CodeGenerator ;
  rdfs:label "Info Command Code Generator" ;
  rdfs:comment "Generate code for ggen info - get specification information" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Specification Info Provider" ;
    code:teraTemplate """
      // Generated: Specification Info Provider (ggen info)
      // Auto-generated from: ggen-codegen-spec.ttl

      use std::error::Error;

      pub struct SpecInfo {
          pub file: String,
          pub size_bytes: u64,
          pub line_count: usize,
          pub has_patterns: bool,
          pub has_rules: bool,
      }

      pub fn get_spec_info(spec_file: &str) -> Result<SpecInfo, Box<dyn Error>> {
          let content = std::fs::read_to_string(spec_file)?;
          let lines = content.lines().count();

          let info = SpecInfo {
              file: spec_file.to_string(),
              size_bytes: content.len() as u64,
              line_count: lines,
              has_patterns: content.contains("CodeGenerationPattern"),
              has_rules: content.contains("sh:NodeShape"),
          };

          Ok(info)
      }

      pub fn format_info(info: &SpecInfo) -> String {
          format!(
              "Specification: {}\\n  Size: {} bytes\\n  Lines: {}\\n  Patterns: {}\\n  Rules: {}",
              info.file, info.size_bytes, info.line_count, info.has_patterns, info.has_rules
          )
      }
    """ ;
    code:outputPath "target/ggen/generated/spec_info.rs" ;
  ] ;
  .

code:RenderCommandGenerator
  a code:CodeGenerator ;
  rdfs:label "Render Command Code Generator" ;
  rdfs:comment "Generate code for ggen render - template rendering engine" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Template Renderer" ;
    code:teraTemplate """
      // Generated: Template Rendering Engine (ggen render)
      // Auto-generated from: ggen-codegen-spec.ttl

      use std::error::Error;
      use std::collections::HashMap;

      pub struct TemplateContext {
          pub variables: HashMap<String, String>,
      }

      pub fn render_template(template: &str, context: &TemplateContext) -> Result<String, Box<dyn Error>> {
          let mut output = template.to_string();

          for (key, value) in &context.variables {
              let placeholder = format!("{{{{ {} }}}}", key);
              output = output.replace(&placeholder, value);
          }

          Ok(output)
      }

      pub fn render_from_file(template_file: &str, context: &TemplateContext) -> Result<String, Box<dyn Error>> {
          let template = std::fs::read_to_string(template_file)?;
          render_template(&template, context)
      }

      impl TemplateContext {
          pub fn new() -> Self {
              TemplateContext {
                  variables: HashMap::new(),
              }
          }

          pub fn add(mut self, key: String, value: String) -> Self {
              self.variables.insert(key, value);
              self
          }
      }
    """ ;
    code:outputPath "target/ggen/generated/template_renderer.rs" ;
  ] ;
  .
