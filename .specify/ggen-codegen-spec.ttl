@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix kgc: <http://ggen.org/kgc#> .
@prefix ggen: <http://ggen.org/ggen#> .
@prefix holo: <http://ggen.org/holographic#> .
@prefix code: <http://ggen.org/codegen#> .
@prefix sparql: <http://ggen.org/sparql#> .
@prefix template: <http://ggen.org/template#> .

# =============================================================================
# CODE GENERATION SPECIFICATION
# =============================================================================
# Formal specification of what code should be generated and how.
# This is the ontological source of truth for all code artifacts.
# Code is never written manually; it is always generated from this spec.
# =============================================================================

<http://ggen.org/codegen-spec>
  a owl:Ontology ;
  rdfs:label "ggen Code Generation Specification" ;
  rdfs:comment "Source of truth for code generation. All code flows from this ontology through the measurement function Î¼." ;
  owl:versionInfo "1.0.0" ;
  .

# =============================================================================
# CODE GENERATION PATTERNS
# =============================================================================
# Define what code should be generated by specifying:
# 1. What pattern to extract via SPARQL
# 2. Which template to use for emission
# 3. Output file location

code:CodeGenerationPattern
  a owl:Class ;
  rdfs:label "Code Generation Pattern" ;
  rdfs:comment "A specification of what code to generate: SPARQL pattern + Tera template + output location" ;
  .

code:hasPattern
  a owl:ObjectProperty ;
  rdfs:label "has pattern" ;
  rdfs:domain code:CodeGenerator ;
  rdfs:range code:CodeGenerationPattern ;
  rdfs:comment "Link code generator to patterns it should produce" ;
  .

code:sparqlQuery
  a owl:DatatypeProperty ;
  rdfs:label "SPARQL query" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "SPARQL CONSTRUCT query to extract pattern from RDF" ;
  .

code:teraTemplate
  a owl:DatatypeProperty ;
  rdfs:label "Tera template" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "Tera template string for code emission" ;
  .

code:outputPath
  a owl:DatatypeProperty ;
  rdfs:label "output path" ;
  rdfs:domain code:CodeGenerationPattern ;
  rdfs:range xsd:string ;
  rdfs:comment "Where to write the generated code" ;
  .

# =============================================================================
# STAGE 1: RDF PARSER SPECIFICATION
# =============================================================================
# Specification for the Rust code that parses RDF and validates schema

code:RdfParserGenerator
  a code:CodeGenerator ;
  rdfs:label "RDF Parser Code Generator" ;
  rdfs:comment "Generate Rust code for parsing and normalizing RDF graphs" ;
  kgc:stageNumber 1 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Parse RDF Snapshot" ;
    code:sparqlQuery """
      PREFIX kgc: <http://ggen.org/kgc#>
      CONSTRUCT {
        ?snapshot a kgc:ObservableSnapshot ;
          kgc:snapshotHash ?hash ;
          kgc:snapshotTimestamp ?ts .
      }
      WHERE {
        ?snapshot a kgc:ObservableSnapshot ;
          kgc:snapshotHash ?hash ;
          kgc:snapshotTimestamp ?ts .
      }
    """ ;
    code:teraTemplate """
      // Generated: Parse RDF Observable Snapshot
      use std::path::Path;
      use oxigraph::store::Store;

      pub fn parse_snapshot(snapshot_path: &str) -> Result<Store, Box<dyn std::error::Error>> {
          let store = Store::new()?;
          let path = Path::new(snapshot_path);

          // Load RDF from Turtle format
          let file = std::fs::File::open(path)?;
          store.load_graph(file, "http://ggen.org/kgc#", None)?;

          Ok(store)
      }
    """ ;
    code:outputPath "target/ggen/generated/parser.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 2: SPARQL EXECUTOR SPECIFICATION
# =============================================================================
# Specification for extracting semantic patterns via SPARQL

code:SparqlExecutorGenerator
  a code:CodeGenerator ;
  rdfs:label "SPARQL Executor Code Generator" ;
  rdfs:comment "Generate Rust code for executing SPARQL CONSTRUCT queries" ;
  kgc:stageNumber 2 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Execute SPARQL Queries" ;
    code:teraTemplate """
      // Generated: SPARQL Pattern Extraction
      use oxigraph::store::Store;
      use oxigraph::sparql::QueryResults;

      pub fn extract_patterns(store: &Store, query: &str) -> Result<String, Box<dyn std::error::Error>> {
          let results = store.query(query)?;

          match results {
              QueryResults::Graph(graph) => {
                  let mut output = String::new();
                  // Serialize results back to Turtle
                  for quad in graph {
                      output.push_str(&format!("{:?} .\\n", quad?));
                  }
                  Ok(output)
              }
              _ => Err("Expected graph results from CONSTRUCT query".into())
          }
      }
    """ ;
    code:outputPath "target/ggen/generated/executor.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 3: CODE EMITTER SPECIFICATION
# =============================================================================
# Specification for Tera template-based code emission

code:CodeEmitterGenerator
  a code:CodeGenerator ;
  rdfs:label "Code Emitter Generator" ;
  rdfs:comment "Generate Rust code for template-based code emission" ;
  kgc:stageNumber 3 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Emit Code via Templates" ;
    code:teraTemplate """
      // Generated: Template-based Code Emitter
      use tera::Tera;
      use serde_json::json;

      pub fn emit_code(template_str: &str, context: &str) -> Result<String, Box<dyn std::error::Error>> {
          let mut tera = Tera::default();
          tera.add_raw_template("codegen", template_str)?;

          let rendered = tera.render("codegen", &tera::Context::from_json(json!({"data": context}))?)?;
          Ok(rendered)
      }
    """ ;
    code:outputPath "target/ggen/generated/emitter.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 4: CANONICALIZER SPECIFICATION
# =============================================================================
# Specification for deterministic output normalization

code:CanonicalizeGenerator
  a code:CodeGenerator ;
  rdfs:label "Canonicalizer Code Generator" ;
  rdfs:comment "Generate Rust code for format normalization and determinism" ;
  kgc:stageNumber 4 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Canonicalize Output" ;
    code:teraTemplate """
      // Generated: Output Canonicalization
      use sha2::{Sha256, Digest};

      pub fn canonicalize(code: &str) -> Result<String, Box<dyn std::error::Error>> {
          // Normalize whitespace
          let normalized = code.lines()
              .map(|l| l.trim_end())
              .collect::<Vec<_>>()
              .join("\\n");

          // Ensure final newline
          let final_code = if normalized.ends_with("\\n") {
              normalized
          } else {
              format!("{}\\n", normalized)
          };

          Ok(final_code)
      }

      pub fn compute_hash(data: &str) -> String {
          let mut hasher = Sha256::new();
          hasher.update(data.as_bytes());
          format!("{:x}", hasher.finalize())
      }
    """ ;
    code:outputPath "target/ggen/generated/canonicalizer.rs" ;
  ] ;
  .

# =============================================================================
# STAGE 5: RECEIPT GENERATOR SPECIFICATION
# =============================================================================
# Specification for cryptographic proof generation

code:ReceiptGeneratorSpec
  a code:CodeGenerator ;
  rdfs:label "Receipt Generator Code Generator" ;
  rdfs:comment "Generate Rust code for generating JSON-LD closure proofs" ;
  kgc:stageNumber 5 ;

  code:hasPattern [
    a code:CodeGenerationPattern ;
    rdfs:label "Generate Receipt" ;
    code:teraTemplate """
      // Generated: Receipt Generation
      use serde_json::json;
      use chrono::Utc;

      pub fn generate_receipt(artifact_hash: &str, artifact_type: &str) -> String {
          json!({
              "@context": "http://ggen.org/context.jsonld",
              "@type": artifact_type,
              "hash": artifact_hash,
              "timestamp": Utc::now().to_rfc3339(),
              "canonicalized": true,
              "deterministic": true
          }).to_string()
      }
    """ ;
    code:outputPath "target/ggen/generated/receipt.rs" ;
  ] ;
  .

# =============================================================================
# CODE GENERATOR BASE CLASS
# =============================================================================

code:CodeGenerator
  a owl:Class ;
  rdfs:label "Code Generator" ;
  rdfs:comment "Specification for what code should be generated in each stage" ;
  .

code:stageNumber
  a owl:DatatypeProperty ;
  rdfs:domain code:CodeGenerator ;
  rdfs:range xsd:integer ;
  rdfs:comment "Which stage this generator operates in (1-5)" ;
  .

# =============================================================================
# VALIDATION CONSTRAINT
# =============================================================================
# All generated code must satisfy invariants

code:GeneratedCode
  a owl:Class ;
  rdfs:label "Generated Code" ;
  rdfs:comment "Code output by ggen-sync. Must preserve invariants." ;
  .

code:generatedFrom
  a owl:ObjectProperty ;
  rdfs:domain code:GeneratedCode ;
  rdfs:range code:CodeGenerationPattern ;
  rdfs:comment "Links code to the pattern that generated it" ;
  .

code:hasInvariant
  a owl:ObjectProperty ;
  rdfs:domain code:GeneratedCode ;
  rdfs:range kgc:Invariant ;
  rdfs:comment "Invariants preserved by generated code" ;
  .
