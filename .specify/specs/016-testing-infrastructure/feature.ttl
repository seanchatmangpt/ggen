@prefix : <http://ggen.io/ontology/specs/016-testing-infrastructure#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix ggen: <http://ggen.io/ontology/core#> .
@prefix dc: <http://purl.org/dc/terms/> .

# Feature Definition
:TestingInfrastructureFeature a ggen:Feature ;
    dc:title "Comprehensive Testing Infrastructure" ;
    dc:description "Production-grade testing infrastructure with testcontainers, chaos engineering, performance benchmarks, and optimized CI/CD pipelines" ;
    ggen:version "1.0.0" ;
    ggen:priority "P1" ;
    ggen:status "Implemented" ;
    ggen:hasUserStory :US001, :US002, :US003, :US004, :US005 ;
    dc:created "2026-01-29"^^xsd:date .

# User Story 1: Testcontainers Integration
:US001 a ggen:UserStory ;
    dc:title "Testcontainers for Production-Readiness Validation" ;
    dc:description """
As a quality engineer,
I want Docker-based integration tests with testcontainers
So that I can validate production readiness with real dependencies
""" ;
    ggen:priority "P1" ;
    ggen:storyPoints 13 ;
    ggen:hasAcceptanceCriteria :AC001, :AC002, :AC003 ;
    ggen:hasScenario :SC001, :SC002, :SC003 .

:AC001 a ggen:AcceptanceCriteria ;
    dc:description "Support for PostgreSQL, Redis, MySQL, MongoDB containers" ;
    ggen:testable true .

:AC002 a ggen:AcceptanceCriteria ;
    dc:description "Automatic container lifecycle management (start, health check, cleanup)" ;
    ggen:testable true .

:AC003 a ggen:AcceptanceCriteria ;
    dc:description "Integration with cargo make test targets (<30s timeout)" ;
    ggen:testable true .

:SC001 a ggen:Scenario ;
    dc:title "PostgreSQL Integration Test" ;
    ggen:given "A ggen-api crate requiring PostgreSQL" ;
    ggen:when "I run cargo make test-integration" ;
    ggen:then "PostgreSQL container starts, tests execute, container cleans up automatically" ;
    ggen:priority "P1" .

:SC002 a ggen:Scenario ;
    dc:title "Redis Cache Validation" ;
    ggen:given "A Redis-dependent caching module" ;
    ggen:when "I run integration tests" ;
    ggen:then "Redis container is available, cache operations succeed, health check passes" ;
    ggen:priority "P1" .

:SC003 a ggen:Scenario ;
    dc:title "Container Health Check Timeout" ;
    ggen:given "A slow-starting container" ;
    ggen:when "Health check exceeds 30s timeout" ;
    ggen:then "Test fails fast with clear error message, container cleanup occurs" ;
    ggen:priority "P2" .

# User Story 2: Chaos Engineering
:US002 a ggen:UserStory ;
    dc:title "Chaos Testing for Resilience Validation" ;
    dc:description """
As a reliability engineer,
I want chaos engineering tests that simulate failures
So that I can validate system resilience under adverse conditions
""" ;
    ggen:priority "P1" ;
    ggen:storyPoints 8 ;
    ggen:hasAcceptanceCriteria :AC004, :AC005, :AC006 ;
    ggen:hasScenario :SC004, :SC005, :SC006 .

:AC004 a ggen:AcceptanceCriteria ;
    dc:description "Network latency injection (50ms-500ms)" ;
    ggen:testable true .

:AC005 a ggen:AcceptanceCriteria ;
    dc:description "Container kill/restart scenarios" ;
    ggen:testable true .

:AC006 a ggen:AcceptanceCriteria ;
    dc:description "Resource exhaustion simulation (CPU, memory, disk)" ;
    ggen:testable true .

:SC004 a ggen:Scenario ;
    dc:title "Network Latency Resilience" ;
    ggen:given "A distributed RDF processing pipeline" ;
    ggen:when "Network latency is injected (200ms)" ;
    ggen:then "Pipeline completes successfully with retry logic, SLOs are maintained" ;
    ggen:priority "P1" .

:SC005 a ggen:Scenario ;
    dc:title "Container Crash Recovery" ;
    ggen:given "A running PostgreSQL container" ;
    ggen:when "Container is killed mid-transaction" ;
    ggen:then "System detects failure, retries connection, transaction completes or rolls back cleanly" ;
    ggen:priority "P1" .

:SC006 a ggen:Scenario ;
    dc:title "Memory Pressure Handling" ;
    ggen:given "A memory-intensive RDF inference task" ;
    ggen:when "Available memory is limited to 50MB" ;
    ggen:then "System operates within constraints, fails gracefully if exceeded, no memory leaks" ;
    ggen:priority "P2" .

# User Story 3: Performance Benchmarking
:US003 a ggen:UserStory ;
    dc:title "Comprehensive Performance Benchmarks" ;
    dc:description """
As a performance engineer,
I want automated benchmarks measuring SLO compliance
So that I can detect regressions and validate performance targets
""" ;
    ggen:priority "P1" ;
    ggen:storyPoints 8 ;
    ggen:hasAcceptanceCriteria :AC007, :AC008, :AC009 ;
    ggen:hasScenario :SC007, :SC008, :SC009 .

:AC007 a ggen:AcceptanceCriteria ;
    dc:description "Criterion benchmarks for RDF processing (≤5s for 1k+ triples)" ;
    ggen:testable true .

:AC008 a ggen:AcceptanceCriteria ;
    dc:description "Async runtime benchmarks (Tokio vs async-std)" ;
    ggen:testable true .

:AC009 a ggen:AcceptanceCriteria ;
    dc:description "HTML reports with historical trend analysis" ;
    ggen:testable true .

:SC007 a ggen:Scenario ;
    dc:title "RDF Processing SLO Validation" ;
    ggen:given "A 1000-triple RDF ontology" ;
    ggen:when "I run cargo make bench" ;
    ggen:then "Processing completes in ≤5s, benchmark report shows SLO compliance" ;
    ggen:priority "P1" .

:SC008 a ggen:Scenario ;
    dc:title "Async Runtime Comparison" ;
    ggen:given "Identical workload on Tokio and async-std" ;
    ggen:when "Benchmarks execute" ;
    ggen:then "Performance delta is quantified, HTML report shows comparison, recommendation provided" ;
    ggen:priority "P2" .

:SC009 a ggen:Scenario ;
    dc:title "Regression Detection" ;
    ggen:given "Historical benchmark baseline" ;
    ggen:when "New code causes 20% slowdown" ;
    ggen:then "Benchmark fails with clear regression report, CI pipeline blocks merge" ;
    ggen:priority "P1" .

# User Story 4: CI/CD Optimization
:US004 a ggen:UserStory ;
    dc:title "Optimized CI/CD Pipelines" ;
    dc:description """
As a DevOps engineer,
I want optimized CI/CD pipelines with caching and parallelization
So that feedback loops are fast (<5min for standard builds)
""" ;
    ggen:priority "P1" ;
    ggen:storyPoints 13 ;
    ggen:hasAcceptanceCriteria :AC010, :AC011, :AC012 ;
    ggen:hasScenario :SC010, :SC011, :SC012 .

:AC010 a ggen:AcceptanceCriteria ;
    dc:description "Cargo build caching (target/, Cargo.lock)" ;
    ggen:testable true .

:AC011 a ggen:AcceptanceCriteria ;
    dc:description "Parallel test execution across crates" ;
    ggen:testable true .

:AC012 a ggen:AcceptanceCriteria ;
    dc:description "Fail-fast on compiler errors (Andon signal)" ;
    ggen:testable true .

:SC010 a ggen:Scenario ;
    dc:title "Incremental Build Performance" ;
    ggen:given "A cached CI environment" ;
    ggen:when "I push a single-file change" ;
    ggen:then "Build completes in ≤2min (incremental compilation), tests run in ≤3min" ;
    ggen:priority "P1" .

:SC011 a ggen:Scenario ;
    dc:title "Parallel Test Matrix" ;
    ggen:given "30 crates with independent tests" ;
    ggen:when "CI executes full test suite" ;
    ggen:then "Tests run in parallel, total time ≤5min, results aggregated correctly" ;
    ggen:priority "P1" .

:SC012 a ggen:Scenario ;
    dc:title "Andon Signal Enforcement" ;
    ggen:given "Code with compiler warnings" ;
    ggen:when "CI runs cargo make check" ;
    ggen:then "Pipeline fails immediately, clear error message, no subsequent jobs run" ;
    ggen:priority "P1" .

# User Story 5: Test Quality Metrics
:US005 a ggen:UserStory ;
    dc:title "Chicago TDD Test Quality Validation" ;
    dc:description """
As a quality assurance lead,
I want automated validation of Chicago TDD patterns
So that tests verify behavior, not implementation
""" ;
    ggen:priority "P2" ;
    ggen:storyPoints 5 ;
    ggen:hasAcceptanceCriteria :AC013, :AC014, :AC015 ;
    ggen:hasScenario :SC013, :SC014, :SC015 .

:AC013 a ggen:AcceptanceCriteria ;
    dc:description "AAA pattern enforcement (Arrange/Act/Assert)" ;
    ggen:testable true .

:AC014 a ggen:AcceptanceCriteria ;
    dc:description "Real collaborator usage (minimize mocks)" ;
    ggen:testable true .

:AC015 a ggen:AcceptanceCriteria ;
    dc:description "Behavior verification (observable outputs/state changes)" ;
    ggen:testable true .

:SC013 a ggen:Scenario ;
    dc:title "AAA Pattern Detection" ;
    ggen:given "A test module with 50 tests" ;
    ggen:when "I run cargo make test-audit" ;
    ggen:then "Tests without AAA pattern are flagged, report shows compliance percentage" ;
    ggen:priority "P2" .

:SC014 a ggen:Scenario ;
    dc:title "Mock Overuse Detection" ;
    ggen:given "Tests using mockito for all dependencies" ;
    ggen:when "Test audit runs" ;
    ggen:then "High mock usage is flagged, suggestion to use real collaborators provided" ;
    ggen:priority "P3" .

:SC015 a ggen:Scenario ;
    dc:title "Meaningless Test Detection" ;
    ggen:given "Tests with only assert_ok!() and no state verification" ;
    ggen:when "Test quality scan runs" ;
    ggen:then "Meaningless tests are identified, examples of proper assertions suggested" ;
    ggen:priority "P2" .

# SHACL Validation Shapes
:FeatureShape a sh:NodeShape ;
    sh:targetClass ggen:Feature ;
    sh:property [
        sh:path dc:title ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:priority ;
        sh:in ( "P1" "P2" "P3" ) ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:hasUserStory ;
        sh:class ggen:UserStory ;
        sh:minCount 1 ;
    ] .

:UserStoryShape a sh:NodeShape ;
    sh:targetClass ggen:UserStory ;
    sh:property [
        sh:path dc:title ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:storyPoints ;
        sh:datatype xsd:integer ;
        sh:minInclusive 1 ;
        sh:maxInclusive 21 ;
    ] ;
    sh:property [
        sh:path ggen:hasAcceptanceCriteria ;
        sh:class ggen:AcceptanceCriteria ;
        sh:minCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:hasScenario ;
        sh:class ggen:Scenario ;
        sh:minCount 1 ;
    ] .

:ScenarioShape a sh:NodeShape ;
    sh:targetClass ggen:Scenario ;
    sh:property [
        sh:path ggen:given ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:when ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:then ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path ggen:priority ;
        sh:in ( "P1" "P2" "P3" ) ;
        sh:minCount 1 ;
    ] .
