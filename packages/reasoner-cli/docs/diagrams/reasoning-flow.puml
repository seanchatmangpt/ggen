@startuml reasoning-flow
!theme blueprint
title Reasoning Flow - Classification and Realization

|User|
start
:Submit ontology for reasoning;

|Reasoner CLI|
:Parse command arguments;
:Load ontology from file/URL;

|Ontology Parser|
:Parse RDF/XML, Turtle, or OWL/XML;
:Build OWL API model;
:Validate syntax;

|Reasoner Manager|
:Select reasoner engine\n(Pellet/HermiT/FaCT++/ELK);
:Initialize reasoner;

if (Reasoner type?) then (Pellet/HermiT/FaCT++)
  :Load full OWL 2 DL axioms;
else (ELK)
  :Load OWL 2 EL subset;
endif

|Classification Engine|
:Build taxonomy structure;

partition "TBox Reasoning" {
  :Compute subsumption hierarchy;
  :Find equivalent classes;
  :Detect unsatisfiable classes;

  repeat
    :Process class expression;
    :Apply tableaux/consequence rules;
    :Update class hierarchy;
  repeat while (More classes?) is (yes)
  ->no;
}

:Store classified taxonomy;

if (Realization requested?) then (yes)
  |Realization Engine|
  partition "ABox Reasoning" {
    :Load individuals/instances;

    repeat
      :Compute direct types for individual;
      :Check class membership;
      :Derive property assertions;
    repeat while (More individuals?) is (yes)
    ->no;
  }

  :Store realized instances;
else (no)
endif

|Inference Engine|
:Materialize inferred axioms;

if (Consistency check?) then (yes)
  |Consistency Checker|
  :Check ontology consistency;

  if (Consistent?) then (no)
    :Find unsatisfiable classes;
    :Generate explanations;
    :Compute justifications;

    |Justification Generator|
    :Extract minimal axiom sets;
    :Format explanations;
  else (yes)
    :Mark as consistent;
  endif
else (no)
endif

|Output Formatter|
:Serialize results;

if (Output format?) then (RDF)
  :Write Turtle/RDF/XML;
else if (JSON)
  :Format as JSON;
else (Table)
  :Format as ASCII table;
endif

|User|
:Receive classified ontology;
stop

legend right
  **Reasoning Strategies**

  **Tableaux** (Pellet, HermiT, FaCT++)
  - Build models incrementally
  - Apply expansion rules
  - Check for contradictions

  **Consequence-based** (ELK)
  - Forward chaining
  - Polynomial time
  - Optimized for EL

  **Complexity**
  - OWL 2 DL: NExpTime-complete
  - OWL 2 EL: PTime-complete
  - OWL 2 QL: LogSpace (data)
  - OWL 2 RL: PTime
endlegend

@enduml
