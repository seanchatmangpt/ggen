# SPARQL Queries for GraphQL Schema Generation

PREFIX gql: <http://ggen.io/ontology/graphql#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

# Query 1: Generate complete GraphQL schema SDL
# CONSTRUCT {
#   ?schema gql:schemaDefinition ?sdl
# } WHERE {
#   # Generate type definitions
#   {
#     SELECT ?type (GROUP_CONCAT(?fieldDef; separator="\n  ") AS ?fields) WHERE {
#       ?type a gql:ObjectType ;
#             gql:typeName ?typeName .
#       ?type gql:hasField ?field .
#       ?field gql:fieldName ?fieldName ;
#              gql:fieldType ?fieldType .
#       OPTIONAL { ?field gql:isNullable ?nullable }
#       OPTIONAL { ?field gql:isList ?list }
#       BIND(IF(BOUND(?nullable), IF(?nullable, "", "!"), "!") AS ?nullMod)
#       BIND(IF(BOUND(?list), CONCAT("[", ?fieldType, "]"), ?fieldType) AS ?typeStr)
#       BIND(CONCAT(?fieldName, ": ", ?typeStr, ?nullMod) AS ?fieldDef)
#     } GROUP BY ?type
#   }
#   BIND(CONCAT("type ", ?typeName, " {\n  ", ?fields, "\n}") AS ?sdl)
# }

# Query 2: Extract resolver functions with DataLoader usage
SELECT ?field ?fieldName ?resolverFn ?loaderKey ?loaderEnabled
WHERE {
  ?field gql:fieldName ?fieldName ;
         gql:hasResolver ?resolver .
  ?resolver gql:resolverFunction ?resolverFn .
  OPTIONAL {
    ?resolver gql:usesDataLoader ?loader .
    ?loader gql:batchKey ?loaderKey ;
            gql:cacheEnabled ?loaderEnabled .
  }
}
ORDER BY ?fieldName

# Query 3: Generate DataLoader batch functions
SELECT ?loader ?batchKey ?cacheEnabled (GROUP_CONCAT(?field; separator=", ") AS ?fields)
WHERE {
  ?resolver gql:usesDataLoader ?loader .
  ?loader gql:batchKey ?batchKey ;
          gql:cacheEnabled ?cacheEnabled .
  ?field gql:hasResolver ?resolver ;
         gql:fieldName ?fieldName .
}
GROUP BY ?loader ?batchKey ?cacheEnabled

# Query 4: Extract connection fields for pagination
SELECT ?connection ?nodeType ?edgeType ?hasPageInfo
WHERE {
  ?connection a gql:Connection ;
              gql:typeName ?connName .
  ?connection gql:hasField ?edgesField, ?pageInfoField .
  ?edgesField gql:fieldName "edges" ;
              gql:fieldType ?edgeType .
  ?pageInfoField gql:fieldName "pageInfo" ;
                 gql:fieldType gql:PageInfo .
  ?edgeType gql:hasField ?nodeField .
  ?nodeField gql:fieldName "node" ;
             gql:fieldType ?nodeType .
  BIND(true AS ?hasPageInfo)
}

# Query 5: Extract subscription resolvers with PubSub channels
SELECT ?subscription ?fieldName ?channel ?eventType
WHERE {
  ?root a gql:SubscriptionType ;
        gql:hasField ?subscription .
  ?subscription gql:fieldName ?fieldName ;
                gql:fieldType ?eventType ;
                gql:hasResolver ?resolver .
  ?resolver a gql:SubscriptionResolver ;
            gql:pubsubChannel ?channel .
}
ORDER BY ?fieldName

# Query 6: Extract authorization directives
SELECT ?field ?fieldName ?directive ?requiredRole
WHERE {
  ?field gql:fieldName ?fieldName ;
         gql:hasDirective ?directive .
  ?directive a gql:AuthDirective ;
             gql:requiredRole ?requiredRole .
}
ORDER BY ?fieldName

# Query 7: Generate input type definitions with validation
SELECT ?inputType ?typeName ?validationRules
WHERE {
  ?inputType a gql:InputType ;
             gql:typeName ?typeName .
  OPTIONAL {
    ?inputType gql:hasValidation ?validation .
    ?validation gql:minLength ?minLen ;
                gql:maxLength ?maxLen .
    BIND(CONCAT("min: ", STR(?minLen), ", max: ", STR(?maxLen)) AS ?validationRules)
  }
}

# Query 8: Extract enum types
SELECT ?enumType ?typeName (GROUP_CONCAT(?value; separator=", ") AS ?values)
WHERE {
  ?enumType a gql:EnumType ;
            gql:typeName ?typeName ;
            gql:hasValue ?value .
}
GROUP BY ?enumType ?typeName

# Query 9: Generate resolver context requirements
SELECT ?resolver ?requiresAuth ?requiresDataSources
WHERE {
  ?resolver a gql:Resolver .
  OPTIONAL {
    ?resolver gql:usesDataLoader ?loader .
    BIND(true AS ?requiresDataSources)
  }
  OPTIONAL {
    ?field gql:hasResolver ?resolver ;
           gql:hasDirective ?authDir .
    ?authDir a gql:AuthDirective .
    BIND(true AS ?requiresAuth)
  }
}

# Query 10: Extract complete schema structure
SELECT ?queryType ?mutationType ?subscriptionType
       (COUNT(DISTINCT ?queryField) AS ?queryCount)
       (COUNT(DISTINCT ?mutationField) AS ?mutationCount)
       (COUNT(DISTINCT ?subField) AS ?subscriptionCount)
WHERE {
  ?queryType a gql:QueryType ;
             gql:hasField ?queryField .
  OPTIONAL {
    ?mutationType a gql:MutationType ;
                  gql:hasField ?mutationField .
  }
  OPTIONAL {
    ?subscriptionType a gql:SubscriptionType ;
                      gql:hasField ?subField .
  }
}
GROUP BY ?queryType ?mutationType ?subscriptionType

# Query 11: Generate field argument definitions
SELECT ?field ?fieldName ?argName ?argType ?defaultValue ?isRequired
WHERE {
  ?field gql:fieldName ?fieldName ;
         gql:hasArgument ?arg .
  ?arg gql:argumentName ?argName ;
       gql:argumentType ?argType .
  OPTIONAL { ?arg gql:defaultValue ?defaultValue }
  OPTIONAL { ?arg gql:isNullable ?nullable }
  BIND(IF(BOUND(?nullable), !?nullable, true) AS ?isRequired)
}
ORDER BY ?fieldName ?argName

# Query 12: Extract cache directives
SELECT ?field ?fieldName ?maxAge ?scope
WHERE {
  ?field gql:fieldName ?fieldName ;
         gql:hasDirective ?cacheDir .
  ?cacheDir a gql:CacheDirective ;
            gql:maxAge ?maxAge .
  OPTIONAL { ?cacheDir gql:scope ?scope }
}
ORDER BY ?fieldName
