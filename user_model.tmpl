Frontmatter { to: None, from: None, force: false, unless_exists: false, inject: false, before: None, after: None, prepend: false, append: false, at_line: None, eof_last: false, skip_if: None, sh_before: None, sh_after: None, base: None, prefixes: {}, rdf_inline: [], rdf: [], sparql: {}, vars: {}, backup: None, idempotent: false, shape: [], determinism: None }
---
---
to: "src/models/user.rs"
vars:
  - name: "user_id"
    type: "integer"
    description: "Unique identifier for the user"
  - name: "user_name"
    type: "string"
    description: "Full name of the user"
  - name: "user_email"
    type: "string"
    description: "Email address of the user"
rdf:
  - "rdf/user_schema.ttl"
sparql:
  user_validation: "SELECT ?user ?id ?name ?email WHERE { ?user <http://schema.org/id> ?id . ?user <http://schema.org/name> ?name . ?user <http://schema.org/email> ?email . }"
---
use std::fmt;

#[derive(Debug, Clone)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}

impl User {
    pub fn new(id: i32, name: String, email: String) -> Self {
        User { id, name, email }
    }

    pub fn id(&self) -> i32 {
        self.id
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn email(&self) -> &str {
        &self.email
    }

    pub fn set_name(&mut self, name: String) {
        self.name = name;
    }

    pub fn set_email(&mut self, email: String) {
        self.email = email;
    }

    pub fn is_valid(&self) -> bool {
        !self.name.is_empty() && !self.email.is_empty() && self.email.contains('@')
    }

    pub fn validate_email(&self) -> Result<(), String> {
        if self.email.is_empty() {
            return Err("Email cannot be empty".to_string());
        }
        if !self.email.contains('@') {
            return Err("Email must contain '@' symbol".to_string());
        }
        if self.email.matches('@').count() != 1 {
            return Err("Email must contain exactly one '@' symbol".to_string());
        }
        Ok(())
    }

    pub fn validate_name(&self) -> Result<(), String> {
        if self.name.is_empty() {
            return Err("Name cannot be empty".to_string());
        }
        if self.name.len() > 100 {
            return Err("Name cannot exceed 100 characters".to_string());
        }
        Ok(())
    }
}

impl fmt::Display for User {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "User {{ id: {}, name: {}, email: {} }}", self.id, self.name, self.email)
    }
}

impl PartialEq for User {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let user = User::new(1, "John Doe".to_string(), "john@example.com".to_string());
        assert_eq!(user.id(), 1);
        assert_eq!(user.name(), "John Doe");
        assert_eq!(user.email(), "john@example.com");
    }

    #[test]
    fn test_user_validation() {
        let valid_user = User::new(1, "John Doe".to_string(), "john@example.com".to_string());
        assert!(valid_user.is_valid());

        let invalid_user = User::new(2, "".to_string(), "".to_string());
        assert!(!invalid_user.is_valid());
    }

    #[test]
    fn test_email_validation() {
        let user = User::new(1, "John Doe".to_string(), "john@example.com".to_string());
        assert!(user.validate_email().is_ok());

        let invalid_email_user = User::new(2, "Jane Doe".to_string(), "invalid-email".to_string());
        assert!(invalid_email_user.validate_email().is_err());
    }

    #[test]
    fn test_name_validation() {
        let user = User::new(1, "John Doe".to_string(), "john@example.com".to_string());
        assert!(user.validate_name().is_ok());

        let long_name_user = User::new(2, "A".repeat(101).to_string(), "john@example.com".to_string());
        assert!(long_name_user.validate_name().is_err());
    }
}