{# =============================================================================
   DIVERGENCE REPORTER TEMPLATE - Generates actionable repair suggestions

   Analyzes expected vs actual execution state to identify first divergence
   point and generate structured repair suggestions.

   Formula: Î” = expected - actual â†’ diagnose â†’ repair suggestions

   Generated by ggen from ln_ctrl wizard - DO NOT EDIT MANUALLY
   Regenerate with: ggen sync --audit true
   ============================================================================= #}
/**
 * ln_ctrl Divergence Reporter
 *
 * Generates actionable repair suggestions when verification fails.
 * Compares expected vs actual execution state and produces structured
 * divergence reports with prioritized repair actions.
 *
 * @module divergence_reporter
 * @version {{ version | default(value="1.0.0") }}
 * @generated {{ timestamp | default(value="2026-02-11T21:00:00Z") }}
 */

import { createHash, randomUUID } from 'node:crypto';
import { writeFile } from 'node:fs/promises';

/**
 * Divergence types supported by the reporter
 * @enum {string}
 */
export const DivergenceType = {
  RECEIPT_CHAIN: 'receipt_chain_divergence',
  TRACE_HASH: 'trace_hash_mismatch',
  FRONTIER: 'frontier_difference',
  EFFECT: 'effect_mismatch',
  BUDGET: 'budget_violation',
  OPERATION: 'operation_mismatch',
  CAUSAL_CHAIN: 'causal_chain_broken',
  SIGNATURE: 'signature_invalid',
};

/**
 * Severity levels for divergence
 * @enum {string}
 */
export const Severity = {
  CRITICAL: 'critical',
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low',
};

/**
 * Priority levels for repair suggestions
 * @enum {string}
 */
export const Priority = {
  CRITICAL: 'critical',
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low',
};

/**
 * Finds the first divergence point between expected and actual receipts
 *
 * @param {Array<Object>} expectedReceipts - Expected receipt chain
 * @param {Array<Object>} actualReceipts - Actual receipt chain
 * @returns {Object|null} Divergence point or null if none found
 */
function findDivergencePoint(expectedReceipts, actualReceipts) {
  const minLength = Math.min(expectedReceipts.length, actualReceipts.length);

  // Check if lengths differ
  if (expectedReceipts.length !== actualReceipts.length) {
    return {
      step_index: minLength,
      reason: 'receipt_count_mismatch',
      expected_count: expectedReceipts.length,
      actual_count: actualReceipts.length,
    };
  }

  // Find first differing receipt
  for (let i = 0; i < minLength; i++) {
    const expected = expectedReceipts[i];
    const actual = actualReceipts[i];

    // Check step index match
    if (expected.step_index !== actual.step_index) {
      return {
        step_index: i,
        reason: 'step_index_mismatch',
        operation: actual.operation || 'unknown',
        redex_type: actual.redex_executed?.redex_type,
        redex_expression: actual.redex_executed?.redex_expression,
      };
    }

    // Check operation match
    if (expected.operation !== actual.operation) {
      return {
        step_index: i,
        reason: 'operation_mismatch',
        operation: actual.operation,
        expected_operation: expected.operation,
        redex_type: actual.redex_executed?.redex_type,
        redex_expression: actual.redex_executed?.redex_expression,
      };
    }

    // Check hash chain match
    if (expected.hash_chain !== actual.hash_chain) {
      return {
        step_index: i,
        reason: 'hash_chain_mismatch',
        operation: actual.operation,
        redex_type: actual.redex_executed?.redex_type,
        redex_expression: actual.redex_executed?.redex_expression,
      };
    }

    // Check frontier match
    if (expected.frontier_after?.frontier_hash !== actual.frontier_after?.frontier_hash) {
      return {
        step_index: i,
        reason: 'frontier_hash_mismatch',
        operation: actual.operation,
        redex_type: actual.redex_executed?.redex_type,
        redex_expression: actual.redex_executed?.redex_expression,
      };
    }

    // Check budget violations
    if (actual.budget_remaining?.budget_exceeded && !expected.budget_remaining?.budget_exceeded) {
      return {
        step_index: i,
        reason: 'budget_exceeded',
        operation: actual.operation,
        redex_type: actual.redex_executed?.redex_type,
        redex_expression: actual.redex_executed?.redex_expression,
      };
    }
  }

  return null;
}

/**
 * Compares two frontiers and returns differences
 *
 * @param {Object} expectedFrontier - Expected frontier state
 * @param {Object} actualFrontier - Actual frontier state
 * @returns {Object} Frontier comparison results
 */
function compareFrontiers(expectedFrontier, actualFrontier) {
  const differences = [];

  // Size mismatch
  if (expectedFrontier.frontier_size !== actualFrontier.frontier_size) {
    differences.push({
      type: 'size_mismatch',
      expected: expectedFrontier.frontier_size,
      actual: actualFrontier.frontier_size,
    });
  }

  // Hash mismatch
  if (expectedFrontier.frontier_hash !== actualFrontier.frontier_hash) {
    differences.push({
      type: 'hash_mismatch',
      expected: expectedFrontier.frontier_hash,
      actual: actualFrontier.frontier_hash,
    });
  }

  // Term differences
  const expectedTerms = expectedFrontier.frontier_terms || [];
  const actualTerms = actualFrontier.frontier_terms || [];

  const maxLen = Math.max(expectedTerms.length, actualTerms.length);
  for (let i = 0; i < maxLen; i++) {
    if (expectedTerms[i] !== actualTerms[i]) {
      differences.push({
        type: 'term_mismatch',
        index: i,
        expected: expectedTerms[i] || '<missing>',
        actual: actualTerms[i] || '<missing>',
      });
    }
  }

  return {
    has_differences: differences.length > 0,
    differences,
    expected: expectedFrontier,
    actual: actualFrontier,
  };
}

/**
 * Compares two effect lists and returns differences
 *
 * @param {Array<Object>} expectedEffects - Expected effects
 * @param {Array<Object>} actualEffects - Actual effects
 * @returns {Object} Effect comparison results
 */
function compareEffects(expectedEffects = [], actualEffects = []) {
  const differences = [];

  // Count mismatch
  if (expectedEffects.length !== actualEffects.length) {
    differences.push({
      type: 'count_mismatch',
      expected: expectedEffects.length,
      actual: actualEffects.length,
    });
  }

  // Compare each effect
  const maxLen = Math.max(expectedEffects.length, actualEffects.length);
  for (let i = 0; i < maxLen; i++) {
    const expected = expectedEffects[i];
    const actual = actualEffects[i];

    if (!expected) {
      differences.push({
        type: 'unexpected_effect',
        index: i,
        actual: actual,
      });
      continue;
    }

    if (!actual) {
      differences.push({
        type: 'missing_effect',
        index: i,
        expected: expected,
      });
      continue;
    }

    if (expected.effect_type !== actual.effect_type) {
      differences.push({
        type: 'effect_type_mismatch',
        index: i,
        expected: expected.effect_type,
        actual: actual.effect_type,
      });
    }

    if (expected.effect_data !== actual.effect_data) {
      differences.push({
        type: 'effect_data_mismatch',
        index: i,
        expected_type: expected.effect_type,
      });
    }
  }

  return {
    has_differences: differences.length > 0,
    differences,
  };
}

/**
 * Compares two budget states and returns differences
 *
 * @param {Object} expectedBudget - Expected budget state
 * @param {Object} actualBudget - Actual budget state
 * @returns {Object} Budget comparison results
 */
function compareBudgets(expectedBudget, actualBudget) {
  const differences = [];

  if (expectedBudget.budget_steps !== actualBudget.budget_steps) {
    differences.push({
      type: 'steps_mismatch',
      expected: expectedBudget.budget_steps,
      actual: actualBudget.budget_steps,
      delta: actualBudget.budget_steps - expectedBudget.budget_steps,
    });
  }

  if (expectedBudget.budget_memory !== actualBudget.budget_memory) {
    differences.push({
      type: 'memory_mismatch',
      expected: expectedBudget.budget_memory,
      actual: actualBudget.budget_memory,
      delta: actualBudget.budget_memory - expectedBudget.budget_memory,
    });
  }

  if (expectedBudget.budget_time !== actualBudget.budget_time) {
    differences.push({
      type: 'time_mismatch',
      expected: expectedBudget.budget_time,
      actual: actualBudget.budget_time,
      delta: actualBudget.budget_time - expectedBudget.budget_time,
    });
  }

  if (expectedBudget.budget_exceeded !== actualBudget.budget_exceeded) {
    differences.push({
      type: 'exceeded_flag_mismatch',
      expected: expectedBudget.budget_exceeded,
      actual: actualBudget.budget_exceeded,
    });
  }

  return {
    has_differences: differences.length > 0,
    differences,
  };
}

/**
 * Generates diagnosis string based on divergence analysis
 *
 * @param {Object} divergencePoint - Point where divergence occurred
 * @param {Object} frontierComparison - Frontier comparison results
 * @param {Object} effectComparison - Effect comparison results
 * @param {Object} budgetComparison - Budget comparison results
 * @returns {string} Human-readable diagnosis
 */
function generateDiagnosis(divergencePoint, frontierComparison, effectComparison, budgetComparison) {
  if (!divergencePoint) {
    return 'No divergence detected. Expected and actual execution match completely.';
  }

  const parts = [];
  const step = divergencePoint.step_index;
  const op = divergencePoint.operation || 'unknown';

  // Main divergence reason
  switch (divergencePoint.reason) {
    case 'receipt_count_mismatch':
      parts.push(`Receipt count mismatch: expected ${divergencePoint.expected_count} receipts but got ${divergencePoint.actual_count}.`);
      if (divergencePoint.expected_count > divergencePoint.actual_count) {
        parts.push('Execution may have terminated early or encountered an error.');
      } else {
        parts.push('Execution continued beyond expected length, suggesting infinite loop or missing termination condition.');
      }
      break;

    case 'step_index_mismatch':
      parts.push(`Step index mismatch at position ${step}: receipts are out of order or skipped.`);
      break;

    case 'operation_mismatch':
      parts.push(`Operation mismatch at step ${step}: expected '${divergencePoint.expected_operation}' but got '${op}'.`);
      parts.push('This suggests a different reduction strategy or control flow path was taken.');
      break;

    case 'hash_chain_mismatch':
      parts.push(`Hash chain divergence at step ${step} during ${op} operation.`);
      parts.push('The cryptographic chain integrity is broken, indicating non-deterministic behavior.');
      break;

    case 'frontier_hash_mismatch':
      parts.push(`Frontier divergence at step ${step} during ${op} operation.`);
      if (divergencePoint.redex_expression) {
        parts.push(`Divergence occurred while reducing: ${divergencePoint.redex_expression}`);
      }
      break;

    case 'budget_exceeded':
      parts.push(`Budget violation at step ${step}: resource limit exceeded during ${op} operation.`);
      break;

    default:
      parts.push(`Divergence detected at step ${step} during ${op} operation.`);
  }

  // Add frontier details
  if (frontierComparison.has_differences) {
    const termDiffs = frontierComparison.differences.filter(d => d.type === 'term_mismatch');
    if (termDiffs.length > 0) {
      const first = termDiffs[0];
      parts.push(`Frontier term ${first.index}: expected '${first.expected}' but found '${first.actual}'.`);
    }
  }

  // Add effect details
  if (effectComparison.has_differences) {
    const effectDiffs = effectComparison.differences;
    if (effectDiffs.length > 0) {
      parts.push(`Effect divergence: ${effectDiffs.length} effect(s) differ.`);
    }
  }

  // Add budget details
  if (budgetComparison.has_differences) {
    const stepDiff = budgetComparison.differences.find(d => d.type === 'steps_mismatch');
    if (stepDiff && Math.abs(stepDiff.delta) > 10) {
      parts.push(`Significant step count difference: ${stepDiff.delta > 0 ? 'more' : 'fewer'} steps consumed than expected.`);
    }
  }

  return parts.join(' ');
}

/**
 * Generates repair suggestions based on divergence analysis
 *
 * @param {Object} divergencePoint - Point where divergence occurred
 * @param {string} divergenceType - Type of divergence
 * @param {Object} frontierComparison - Frontier comparison results
 * @param {Object} effectComparison - Effect comparison results
 * @param {Object} budgetComparison - Budget comparison results
 * @returns {Array<Object>} Array of repair suggestions
 */
function generateRepairSuggestions(divergencePoint, divergenceType, frontierComparison, effectComparison, budgetComparison) {
  const suggestions = [];

  if (!divergencePoint) {
    return suggestions;
  }

  // Receipt chain divergence
  if (divergenceType === DivergenceType.RECEIPT_CHAIN || divergenceType === DivergenceType.TRACE_HASH) {
    suggestions.push({
      priority: Priority.CRITICAL,
      action: 'Verify cryptographic chain integrity',
      rationale: 'Hash chain divergence indicates non-deterministic execution or data corruption',
      command: 'node verify_receipts.mjs --validate-chain --step ' + divergencePoint.step_index,
      estimated_impact: 'Will identify where the causal chain was broken',
    });

    suggestions.push({
      priority: Priority.HIGH,
      action: 'Check for non-deterministic operations',
      rationale: 'Random number generation, timestamps, or I/O may introduce non-determinism',
      command: null,
      estimated_impact: 'Ensures RNG seeding and I/O mocking are correctly configured',
    });
  }

  // Frontier divergence
  if (divergenceType === DivergenceType.FRONTIER && frontierComparison.has_differences) {
    const termDiffs = frontierComparison.differences.filter(d => d.type === 'term_mismatch');

    suggestions.push({
      priority: Priority.CRITICAL,
      action: 'Verify normalizer configuration matches expected behavior',
      rationale: termDiffs.length > 0
        ? `Term '${termDiffs[0].expected}' was expected but '${termDiffs[0].actual}' was found`
        : 'Frontier state differs from expected',
      command: 'ggen validate --check-normalizer-config',
      estimated_impact: 'Ensures reduction strategy is correctly configured',
    });

    suggestions.push({
      priority: Priority.HIGH,
      action: 'Check if reduction strategy changed',
      rationale: 'Different reduction strategies (call-by-value vs call-by-name) produce different results',
      command: null,
      estimated_impact: 'May require updating replay pack with correct strategy',
    });

    if (termDiffs.length > 0) {
      suggestions.push({
        priority: Priority.MEDIUM,
        action: 'Regenerate expected trace with current settings',
        rationale: 'If normalizer was intentionally reconfigured, expected trace needs update',
        command: 'ggen sync --regenerate-trace --from-step ' + divergencePoint.step_index,
        estimated_impact: 'Will produce new expected trace matching current configuration',
      });
    }
  }

  // Effect mismatch
  if (divergenceType === DivergenceType.EFFECT && effectComparison.has_differences) {
    suggestions.push({
      priority: Priority.HIGH,
      action: 'Verify effect handlers are correctly configured',
      rationale: 'Effect execution differs from expected behavior',
      command: null,
      estimated_impact: 'Ensures I/O, state, and control effects match expectations',
    });

    const unexpectedEffects = effectComparison.differences.filter(d => d.type === 'unexpected_effect');
    if (unexpectedEffects.length > 0) {
      suggestions.push({
        priority: Priority.MEDIUM,
        action: 'Review unexpected effects',
        rationale: `${unexpectedEffects.length} unexpected effect(s) were performed`,
        command: null,
        estimated_impact: 'May indicate new functionality or unintended side effects',
      });
    }
  }

  // Budget violation
  if (divergenceType === DivergenceType.BUDGET && budgetComparison.has_differences) {
    const exceededDiff = budgetComparison.differences.find(d => d.type === 'exceeded_flag_mismatch');

    if (exceededDiff && exceededDiff.actual) {
      suggestions.push({
        priority: Priority.CRITICAL,
        action: 'Investigate budget violation',
        rationale: 'Execution exceeded resource limits unexpectedly',
        command: null,
        estimated_impact: 'May indicate infinite loop, memory leak, or performance regression',
      });
    }

    const stepDiff = budgetComparison.differences.find(d => d.type === 'steps_mismatch');
    if (stepDiff && Math.abs(stepDiff.delta) > 100) {
      suggestions.push({
        priority: Priority.HIGH,
        action: 'Analyze step count divergence',
        rationale: `Step consumption differs by ${Math.abs(stepDiff.delta)} steps`,
        command: null,
        estimated_impact: 'May indicate algorithmic change or optimization',
      });
    }
  }

  // Receipt count mismatch
  if (divergencePoint.reason === 'receipt_count_mismatch') {
    if (divergencePoint.expected_count > divergencePoint.actual_count) {
      suggestions.push({
        priority: Priority.CRITICAL,
        action: 'Investigate early termination',
        rationale: `Execution ended at step ${divergencePoint.actual_count} instead of ${divergencePoint.expected_count}`,
        command: 'node verify_receipts.mjs --check-termination',
        estimated_impact: 'Will reveal error conditions or premature exits',
      });
    } else {
      suggestions.push({
        priority: Priority.CRITICAL,
        action: 'Check for infinite loop or missing termination',
        rationale: `Execution continued beyond expected ${divergencePoint.expected_count} steps`,
        command: null,
        estimated_impact: 'May need to add or fix termination condition',
      });
    }
  }

  // Operation mismatch
  if (divergencePoint.reason === 'operation_mismatch') {
    suggestions.push({
      priority: Priority.HIGH,
      action: 'Verify control flow matches expected path',
      rationale: `Expected '${divergencePoint.expected_operation}' but got '${divergencePoint.operation}'`,
      command: null,
      estimated_impact: 'Ensures execution follows correct branching logic',
    });
  }

  // Generic suggestion if nothing specific
  if (suggestions.length === 0) {
    suggestions.push({
      priority: Priority.MEDIUM,
      action: 'Review divergence point manually',
      rationale: 'Divergence detected but specific cause unclear',
      command: null,
      estimated_impact: 'Manual analysis may reveal root cause',
    });
  }

  return suggestions;
}

/**
 * Determines divergence type from analysis
 *
 * @param {Object} divergencePoint - Divergence point details
 * @param {Object} frontierComparison - Frontier comparison
 * @param {Object} effectComparison - Effect comparison
 * @param {Object} budgetComparison - Budget comparison
 * @returns {string} Divergence type
 */
function determineDivergenceType(divergencePoint, frontierComparison, effectComparison, budgetComparison) {
  if (!divergencePoint) {
    return null;
  }

  switch (divergencePoint.reason) {
    case 'receipt_count_mismatch':
    case 'hash_chain_mismatch':
      return DivergenceType.RECEIPT_CHAIN;

    case 'step_index_mismatch':
      return DivergenceType.CAUSAL_CHAIN;

    case 'operation_mismatch':
      return DivergenceType.OPERATION;

    case 'frontier_hash_mismatch':
      return DivergenceType.FRONTIER;

    case 'budget_exceeded':
      return DivergenceType.BUDGET;

    default:
      // Determine from comparisons
      if (frontierComparison.has_differences) return DivergenceType.FRONTIER;
      if (effectComparison.has_differences) return DivergenceType.EFFECT;
      if (budgetComparison.has_differences) return DivergenceType.BUDGET;

      return DivergenceType.TRACE_HASH;
  }
}

/**
 * Determines severity based on divergence type and extent
 *
 * @param {string} divergenceType - Type of divergence
 * @param {Object} divergencePoint - Divergence point details
 * @returns {string} Severity level
 */
function determineSeverity(divergenceType, divergencePoint) {
  // Critical severity cases
  if (divergenceType === DivergenceType.CAUSAL_CHAIN) return Severity.CRITICAL;
  if (divergenceType === DivergenceType.SIGNATURE) return Severity.CRITICAL;

  if (divergencePoint?.reason === 'receipt_count_mismatch') {
    const delta = Math.abs((divergencePoint.expected_count || 0) - (divergencePoint.actual_count || 0));
    if (delta > 100) return Severity.CRITICAL;
  }

  // High severity cases
  if (divergenceType === DivergenceType.RECEIPT_CHAIN) return Severity.HIGH;
  if (divergenceType === DivergenceType.TRACE_HASH) return Severity.HIGH;
  if (divergenceType === DivergenceType.BUDGET) return Severity.HIGH;

  // Medium severity cases
  if (divergenceType === DivergenceType.FRONTIER) return Severity.MEDIUM;
  if (divergenceType === DivergenceType.OPERATION) return Severity.MEDIUM;

  // Low severity
  return Severity.LOW;
}

/**
 * Analyzes divergence between expected and actual execution
 *
 * @param {Object} expected - Expected execution state
 * @param {Object} actual - Actual execution state
 * @returns {Object} Divergence analysis report
 */
export function analyzeDivergence(expected, actual) {
  const startTime = Date.now();

  // Extract receipt chains
  const expectedReceipts = Array.isArray(expected.receipts) ? expected.receipts : [];
  const actualReceipts = Array.isArray(actual.receipts) ? actual.receipts : [];

  // Find divergence point
  const divergencePoint = findDivergencePoint(expectedReceipts, actualReceipts);

  if (!divergencePoint) {
    return {
      divergence_detected: false,
      report_id: randomUUID(),
      timestamp: new Date().toISOString(),
      workflow_id: actual.workflow_id || expected.workflow_id || 'unknown',
      diagnosis: 'No divergence detected. Expected and actual execution match completely.',
      analysis_duration_ms: Date.now() - startTime,
    };
  }

  // Get states at divergence point
  const expectedReceipt = expectedReceipts[divergencePoint.step_index] || {};
  const actualReceipt = actualReceipts[divergencePoint.step_index] || {};

  // Compare components
  const frontierComparison = compareFrontiers(
    expectedReceipt.frontier_after || {},
    actualReceipt.frontier_after || {}
  );

  const effectComparison = compareEffects(
    expectedReceipt.effects_performed || [],
    actualReceipt.effects_performed || []
  );

  const budgetComparison = compareBudgets(
    expectedReceipt.budget_remaining || {},
    actualReceipt.budget_remaining || {}
  );

  // Determine divergence type and severity
  const divergenceType = determineDivergenceType(
    divergencePoint,
    frontierComparison,
    effectComparison,
    budgetComparison
  );

  const severity = determineSeverity(divergenceType, divergencePoint);

  // Generate diagnosis and repair suggestions
  const diagnosis = generateDiagnosis(
    divergencePoint,
    frontierComparison,
    effectComparison,
    budgetComparison
  );

  const repairSuggestions = generateRepairSuggestions(
    divergencePoint,
    divergenceType,
    frontierComparison,
    effectComparison,
    budgetComparison
  );

  // Build report
  const report = {
    report_id: randomUUID(),
    timestamp: new Date().toISOString(),
    workflow_id: actual.workflow_id || expected.workflow_id || 'unknown',
    divergence_detected: true,
    divergence_point: {
      step_index: divergencePoint.step_index,
      operation: divergencePoint.operation,
      ...(divergencePoint.redex_type && { redex_type: divergencePoint.redex_type }),
      ...(divergencePoint.redex_expression && { redex_expression: divergencePoint.redex_expression }),
    },
    divergence_type: divergenceType,
    expected_state: {
      hash_chain: expectedReceipt.hash_chain,
      frontier: expectedReceipt.frontier_after,
      effects: expectedReceipt.effects_performed,
      budget: expectedReceipt.budget_remaining,
    },
    actual_state: {
      hash_chain: actualReceipt.hash_chain,
      frontier: actualReceipt.frontier_after,
      effects: actualReceipt.effects_performed,
      budget: actualReceipt.budget_remaining,
    },
    diagnosis,
    repair_suggestions: repairSuggestions,
    affected_receipts: [
      expectedReceipt.hash_chain,
      actualReceipt.hash_chain,
    ].filter(Boolean),
    severity,
    reproducible: true,
    metadata: {
      detector_version: '{{ version | default(value="1.0.0") }}',
      analysis_duration_ms: Date.now() - startTime,
      context: {
        expected_count: expectedReceipts.length,
        actual_count: actualReceipts.length,
        divergence_reason: divergencePoint.reason,
      },
    },
  };

  return report;
}

/**
 * Generates and saves divergence report to file
 *
 * @param {Object} expected - Expected execution state
 * @param {Object} actual - Actual execution state
 * @param {string} outputPath - Path to save report JSON
 * @returns {Promise<Object>} Generated divergence report
 */
export async function generateDivergenceReport(expected, actual, outputPath = './divergence.json') {
  const report = analyzeDivergence(expected, actual);

  await writeFile(
    outputPath,
    JSON.stringify(report, null, 2),
    'utf-8'
  );

  return report;
}

/**
 * Prints divergence report to console with formatting
 *
 * @param {Object} report - Divergence report to print
 */
export function printDivergenceReport(report) {
  console.log('\n' + '='.repeat(80));
  console.log('DIVERGENCE REPORT');
  console.log('='.repeat(80));
  console.log(`Report ID: ${report.report_id}`);
  console.log(`Timestamp: ${report.timestamp}`);
  console.log(`Workflow:  ${report.workflow_id}`);
  console.log(`Severity:  ${report.severity.toUpperCase()}`);
  console.log('-'.repeat(80));

  if (!report.divergence_detected) {
    console.log('\nâœ… No divergence detected. Verification passed.\n');
    console.log('='.repeat(80) + '\n');
    return;
  }

  console.log('\nðŸ”´ DIVERGENCE DETECTED\n');
  console.log(`Type: ${report.divergence_type}`);
  console.log(`Step: ${report.divergence_point.step_index}`);
  console.log(`Operation: ${report.divergence_point.operation}`);

  if (report.divergence_point.redex_expression) {
    console.log(`Redex: ${report.divergence_point.redex_expression}`);
  }

  console.log('\n' + '-'.repeat(80));
  console.log('DIAGNOSIS');
  console.log('-'.repeat(80));
  console.log(report.diagnosis);

  console.log('\n' + '-'.repeat(80));
  console.log('REPAIR SUGGESTIONS');
  console.log('-'.repeat(80));

  report.repair_suggestions.forEach((suggestion, idx) => {
    const prioritySymbol = {
      critical: 'ðŸ”´',
      high: 'ðŸŸ¡',
      medium: 'ðŸŸ¢',
      low: 'âšª',
    }[suggestion.priority] || 'âšª';

    console.log(`\n${idx + 1}. ${prioritySymbol} [${suggestion.priority.toUpperCase()}] ${suggestion.action}`);
    console.log(`   Rationale: ${suggestion.rationale}`);

    if (suggestion.command) {
      console.log(`   Command: ${suggestion.command}`);
    }

    if (suggestion.estimated_impact) {
      console.log(`   Impact: ${suggestion.estimated_impact}`);
    }
  });

  console.log('\n' + '='.repeat(80));
  console.log(`Analysis completed in ${report.metadata.analysis_duration_ms}ms`);
  console.log('='.repeat(80) + '\n');
}

// Export default for convenience
export default {
  analyzeDivergence,
  generateDivergenceReport,
  printDivergenceReport,
  DivergenceType,
  Severity,
  Priority,
};
