#!/usr/bin/env node
/**
 * ln_ctrl World Verifier v6.0.0
 * Generated by ggen wizard
 *
 * Validates all outputs in world.manifest.json against their contracts.
 * Performs deterministic, fast (<1s) verification with actionable error messages.
 *
 * Formula: V(W) = ‚àß(file_exists, hash_valid, schema_valid, format_valid, chain_valid)
 *
 * Validation Gates:
 *   1. File Existence - Verify all artifacts exist
 *   2. Hash Validation - Recompute and verify SHA-256 hashes
 *   3. Schema Validation - Validate JSON against schemas
 *   4. Format Validation - Check format-specific syntax
 *   5. Receipt Chain - Validate causal parent hashes
 *   6. Trace Validation - Check execution trace hashes
 *
 * Exit codes:
 *   0 - All validations passed
 *   1 - One or more validations failed
 */

import { readFileSync, existsSync, writeFileSync } from 'fs';
import { createHash } from 'crypto';
import { resolve, dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const MANIFEST_PATH = resolve(__dirname, 'world.manifest.json');
const VALIDATOR_VERSION = '6.0.0';
const PERFORMANCE_THRESHOLD_MS = 1000;

// Color output for terminal
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function colorize(text, color) {
  return `${colors[color]}${text}${colors.reset}`;
}

// ============================================================================
// Crypto & Hashing Utilities
// ============================================================================

function sha256(content) {
  return createHash('sha256').update(content).digest('hex');
}

function computeHash(content, algorithm = 'sha256') {
  return createHash(algorithm).update(content).digest('hex');
}

// ============================================================================
// Gate Result Tracking
// ============================================================================

class ValidationGate {
  constructor(name) {
    this.name = name;
    this.errors = [];
    this.warnings = [];
    this.duration = 0;
    this.startTime = 0;
  }

  start() {
    this.startTime = Date.now();
  }

  finish() {
    this.duration = Date.now() - this.startTime;
  }

  addError(code, message, location, severity = 'high', expected = null, actual = null) {
    this.errors.push({
      error_code: code,
      error_message: message,
      error_location: location,
      error_severity: severity,
      error_gate: this.name,
      error_expected: expected,
      error_actual: actual
    });
  }

  addWarning(code, message, location) {
    this.warnings.push({
      warning_code: code,
      warning_message: message,
      warning_location: location,
      warning_gate: this.name
    });
  }

  getResult() {
    return {
      gate_name: this.name,
      gate_passed: this.errors.length === 0,
      gate_duration_ms: this.duration,
      gate_error_count: this.errors.length,
      gate_warning_count: this.warnings.length,
      gate_details: null
    };
  }
}

// ============================================================================
// Receipt Chain Validation
// ============================================================================

class ReceiptChainValidator {
  constructor() {
    this.gate = new ValidationGate('causal_chain');
    this.receipts = new Map(); // hash -> receipt data
  }

  collectReceipts(artifacts, baseDir) {
    for (const artifact of artifacts) {
      if (artifact.path.includes('receipt') && artifact.format === 'json') {
        try {
          const fullPath = resolve(baseDir, artifact.path);
          if (existsSync(fullPath)) {
            const content = readFileSync(fullPath, 'utf8');
            const receipt = JSON.parse(content);
            const receiptHash = sha256(JSON.stringify(receipt));
            this.receipts.set(receiptHash, { receipt, path: artifact.path });
          }
        } catch (err) {
          // Skip invalid receipts - caught by other gates
        }
      }
    }
  }

  validate(artifacts, baseDir) {
    this.gate.start();
    this.collectReceipts(artifacts, baseDir);

    // Validate causal chain integrity
    for (const [hash, { receipt, path }] of this.receipts) {
      if (receipt.causal_parent) {
        // Check if parent exists
        const parentExists = Array.from(this.receipts.values()).some(
          r => sha256(JSON.stringify(r.receipt)) === receipt.causal_parent
        );

        if (!parentExists) {
          this.gate.addError(
            'BROKEN_CAUSAL_CHAIN',
            `Receipt references non-existent causal parent`,
            `${path}:$.causal_parent`,
            'critical',
            'parent receipt exists',
            'parent not found'
          );
        }

        // Validate chain_length consistency
        if (receipt.chain_length) {
          const parent = Array.from(this.receipts.values()).find(
            r => sha256(JSON.stringify(r.receipt)) === receipt.causal_parent
          );

          if (parent && parent.receipt.chain_length) {
            if (receipt.chain_length !== parent.receipt.chain_length + 1) {
              this.gate.addError(
                'CHAIN_LENGTH_MISMATCH',
                `Chain length inconsistency: expected ${parent.receipt.chain_length + 1}, got ${receipt.chain_length}`,
                `${path}:$.chain_length`,
                'high',
                `${parent.receipt.chain_length + 1}`,
                `${receipt.chain_length}`
              );
            }
          }
        }
      } else if (receipt.chain_length && receipt.chain_length !== 1) {
        // Root receipt should have chain_length = 1
        this.gate.addWarning(
          'ROOT_CHAIN_LENGTH',
          `Root receipt has chain_length=${receipt.chain_length}, expected 1`,
          `${path}:$.chain_length`
        );
      }
    }

    this.gate.finish();
    return this.gate;
  }
}

// ============================================================================
// Trace Hash Validation
// ============================================================================

class TraceValidator {
  constructor() {
    this.gate = new ValidationGate('trace');
  }

  validate(artifacts, baseDir) {
    this.gate.start();

    for (const artifact of artifacts) {
      if (artifact.path.includes('receipt') && artifact.format === 'json') {
        try {
          const fullPath = resolve(baseDir, artifact.path);
          if (!existsSync(fullPath)) continue;

          const content = readFileSync(fullPath, 'utf8');
          const receipt = JSON.parse(content);

          // Validate hash_chain format
          if (receipt.hash_chain && !/^[a-fA-F0-9]{64}$/.test(receipt.hash_chain)) {
            this.gate.addError(
              'INVALID_HASH_CHAIN',
              `Invalid hash_chain format: must be 64 hex characters`,
              `${artifact.path}:$.hash_chain`,
              'high',
              '64-character hex string',
              `${receipt.hash_chain.length}-character string`
            );
          }

          // Validate frontier_hash format
          if (receipt.frontier_after?.frontier_hash) {
            if (!/^[a-fA-F0-9]{64}$/.test(receipt.frontier_after.frontier_hash)) {
              this.gate.addError(
                'INVALID_FRONTIER_HASH',
                `Invalid frontier_hash format: must be 64 hex characters`,
                `${artifact.path}:$.frontier_after.frontier_hash`,
                'medium',
                '64-character hex string',
                `${receipt.frontier_after.frontier_hash.length}-character string`
              );
            }
          }

          // Validate frontier consistency
          if (receipt.frontier_after) {
            const { frontier_terms, frontier_size } = receipt.frontier_after;
            if (frontier_terms && frontier_size !== undefined) {
              if (frontier_terms.length !== frontier_size) {
                this.gate.addError(
                  'FRONTIER_SIZE_MISMATCH',
                  `Frontier size mismatch: frontier_size=${frontier_size} but ${frontier_terms.length} terms present`,
                  `${artifact.path}:$.frontier_after.frontier_size`,
                  'high',
                  `${frontier_terms.length}`,
                  `${frontier_size}`
                );
              }
            }
          }

        } catch (err) {
          // Skip - will be caught by other gates
        }
      }
    }

    this.gate.finish();
    return this.gate;
  }
}

// ============================================================================
// Divergence Report Generation
// ============================================================================

class DivergenceReporter {
  static generate(manifest, gateResults, allErrors, allWarnings, validationDuration) {
    if (allErrors.length === 0) return null;

    const divergencePoint = this.findFirstDivergence(allErrors);
    const affectedArtifacts = this.findAffectedArtifacts(allErrors);

    return {
      detected_at: new Date().toISOString(),
      workflow_id: manifest.workflow_id || 'unknown',
      divergence_severity: this.calculateSeverity(allErrors),
      divergence_point: divergencePoint,
      state_comparison: this.buildStateComparison(allErrors),
      diagnosis: this.generateDiagnosis(allErrors, gateResults),
      root_cause: this.identifyRootCause(allErrors),
      affected_terms: affectedArtifacts,
      stack_trace: this.buildStackTrace(allErrors),
      repair_suggestions: this.generateRepairSuggestions(allErrors),
      expected_receipt_hash: manifest.validation?.manifest_hash || 'unknown',
      actual_receipt_hash: sha256(JSON.stringify(manifest)),
      execution_context: {
        environment: {
          NODE_VERSION: process.version,
          PLATFORM: process.platform
        },
        runtime_version: VALIDATOR_VERSION,
        platform: `${process.platform}-${process.arch}`,
        rng_seed: null
      },
      is_deterministic: true,
      reproduction_steps: this.generateReproductionSteps(allErrors)
    };
  }

  static findFirstDivergence(errors) {
    const firstError = errors[0];
    return {
      step_number: 0,
      operation_at_divergence: firstError.error_gate,
      error_description: firstError.error_message
    };
  }

  static findAffectedArtifacts(errors) {
    const affected = new Set();
    for (const error of errors) {
      const pathMatch = error.error_location?.match(/^([^:]+):/);
      if (pathMatch) {
        affected.add(pathMatch[1]);
      }
    }
    return Array.from(affected);
  }

  static calculateSeverity(errors) {
    const criticalCount = errors.filter(e => e.error_severity === 'critical').length;
    if (criticalCount > 0) return 'critical';

    const highCount = errors.filter(e => e.error_severity === 'high').length;
    if (highCount > 2) return 'high';
    if (highCount > 0) return 'medium';

    return 'low';
  }

  static buildStateComparison(errors) {
    const hashErrors = errors.filter(e => e.error_gate === 'hash');
    if (hashErrors.length > 0) {
      const error = hashErrors[0];
      return {
        expected_frontier: [],
        actual_frontier: [],
        expected_hash: error.error_expected || 'unknown',
        actual_hash: error.error_actual || 'unknown'
      };
    }

    return {
      expected_frontier: [],
      actual_frontier: [],
      expected_hash: 'unknown',
      actual_hash: 'unknown'
    };
  }

  static generateDiagnosis(errors, gateResults) {
    const failedGates = gateResults.filter(g => !g.gate_passed).map(g => g.gate_name);
    return `Validation failed with ${errors.length} error(s) across ${failedGates.length} gate(s): ${failedGates.join(', ')}. ` +
           `Primary issues: ${errors.slice(0, 3).map(e => e.error_code).join(', ')}`;
  }

  static identifyRootCause(errors) {
    const errorCodes = errors.map(e => e.error_code);

    if (errorCodes.includes('FILE_NOT_FOUND')) return 'file_missing';
    if (errorCodes.includes('HASH_MISMATCH')) return 'file_modified';
    if (errorCodes.includes('JSON_PARSE_ERROR')) return 'corrupted_data';
    if (errorCodes.includes('SCHEMA_VIOLATION')) return 'schema_mismatch';
    if (errorCodes.includes('BROKEN_CAUSAL_CHAIN')) return 'chain_broken';

    return 'unknown';
  }

  static buildStackTrace(errors) {
    return errors.slice(0, 10).map((error, index) => ({
      frame_index: index,
      frame_operation: error.error_gate,
      frame_expression: error.error_message,
      frame_location: error.error_location || null
    }));
  }

  static generateRepairSuggestions(errors) {
    const suggestions = [];

    if (errors.some(e => e.error_code === 'FILE_NOT_FOUND')) {
      suggestions.push({
        suggestion_priority: 1,
        suggestion_action: 'Regenerate missing artifacts by running the code generator',
        suggestion_rationale: 'One or more expected artifacts are missing',
        suggestion_risk: 'low'
      });
    }

    if (errors.some(e => e.error_code === 'HASH_MISMATCH')) {
      suggestions.push({
        suggestion_priority: 1,
        suggestion_action: 'Verify artifacts have not been manually edited. Restore or regenerate.',
        suggestion_rationale: 'File content does not match expected hash',
        suggestion_risk: 'medium'
      });
    }

    if (errors.some(e => e.error_code === 'SCHEMA_VIOLATION')) {
      suggestions.push({
        suggestion_priority: 2,
        suggestion_action: 'Update artifacts to conform to schema specification',
        suggestion_rationale: 'Artifacts do not match their schema contracts',
        suggestion_risk: 'low'
      });
    }

    if (errors.some(e => e.error_code === 'BROKEN_CAUSAL_CHAIN')) {
      suggestions.push({
        suggestion_priority: 1,
        suggestion_action: 'Verify all receipts are present and regenerate missing chain links',
        suggestion_rationale: 'Receipt causal chain is incomplete',
        suggestion_risk: 'high'
      });
    }

    return suggestions;
  }

  static generateReproductionSteps(errors) {
    return [
      'Run verifier: node world.verify.mjs',
      `Review manifest: ${MANIFEST_PATH}`,
      `Check first error: ${errors[0]?.error_code} at ${errors[0]?.error_location}`,
      'Inspect affected artifacts and regenerate if needed'
    ];
  }
}

// ============================================================================
// Format-Specific Validators
// ============================================================================

const validators = {
  'json-schema': (content, path) => {
    try {
      const parsed = JSON.parse(content);
      if (!parsed.$schema) {
        return { valid: false, error: 'Missing $schema field' };
      }
      return { valid: true };
    } catch (e) {
      return { valid: false, error: `Invalid JSON Schema: ${e.message}` };
    }
  },

  json: (content, path) => {
    try {
      JSON.parse(content);
      return { valid: true };
    } catch (e) {
      return { valid: false, error: `Invalid JSON: ${e.message}` };
    }
  },

  javascript: (content, path) => {
    // Basic syntax check - look for obvious syntax errors
    const syntaxErrors = [
      /\bfunction\s+\(/,  // function( should have space
      /\}\s*else/,        // Missing newline/semicolon before else
    ];

    for (const pattern of syntaxErrors) {
      if (pattern.test(content)) {
        return { valid: false, error: 'Potential syntax error detected' };
      }
    }

    // Check for required Node.js patterns if it's a script
    if (content.includes('#!/usr/bin/env node')) {
      if (!content.includes('import') && !content.includes('require')) {
        return { valid: false, error: 'No module imports found in Node.js script' };
      }
    }

    return { valid: true };
  },

  ttl: (content, path) => {
    // Basic Turtle syntax validation
    const hasPrefix = /@prefix/.test(content);
    const hasTriples = /\.\s*$/.test(content.trim());

    if (!hasPrefix && content.length > 100) {
      return { valid: false, error: 'No @prefix declarations found in Turtle file' };
    }

    return { valid: true };
  },

  markdown: (content, path) => {
    // Basic markdown validation
    if (content.trim().length === 0) {
      return { valid: false, error: 'Empty markdown file' };
    }
    return { valid: true };
  },

  syntax: (content, path) => {
    // Generic syntax check
    return { valid: true };
  }
};

// ============================================================================
// Per-Artifact Verification (Gates 1-4)
// ============================================================================

function verifyArtifact(artifact, baseDir, fileGate, hashGate, schemaGate, formatGate) {
  const { path, hash, format, validator, hash_algorithm } = artifact;
  const results = [];
  const fullPath = resolve(baseDir, path);

  // Gate 1: File Existence
  if (!existsSync(fullPath)) {
    fileGate.addError(
      'FILE_NOT_FOUND',
      `Artifact file does not exist: ${path}`,
      `${path}:file`,
      'critical',
      'file exists',
      'file not found'
    );
    return { valid: false, path, errors: [`File not found`], results };
  }
  results.push({ check: 'exists', status: 'pass' });

  // Read file content
  let content;
  try {
    content = readFileSync(fullPath, 'utf8');
  } catch (e) {
    fileGate.addError(
      'FILE_NOT_READABLE',
      `Cannot read file: ${e.message}`,
      `${path}:file`,
      'critical',
      'readable file',
      'read error'
    );
    return { valid: false, path, errors: [`Cannot read file`], results };
  }

  // Gate 2: Hash Validation
  if (hash && hash.length > 0) {
    const algorithm = hash_algorithm || 'sha256';
    const actualHash = computeHash(content, algorithm);

    if (actualHash !== hash) {
      hashGate.addError(
        'HASH_MISMATCH',
        `Hash mismatch for ${path}. File may have been modified.`,
        `${path}:$.hash`,
        'critical',
        hash,
        actualHash
      );
      results.push({ check: 'hash', status: 'fail', algorithm });
    } else {
      results.push({ check: 'hash', status: 'pass', algorithm });
    }
  } else {
    hashGate.addWarning('HASH_MISSING', `No hash specified for ${path}`, `${path}:$.hash`);
    results.push({ check: 'hash', status: 'skip', reason: 'No hash provided' });
  }

  // Gate 3: Schema Validation (JSON only)
  if (format === 'json' || validator === 'json-schema') {
    try {
      const parsed = JSON.parse(content);

      // Validate receipts
      if (path.includes('receipt') && !path.includes('schema')) {
        validateReceiptSchema(parsed, path, schemaGate);
      }

      // Validate verdicts
      if (path.includes('verdict')) {
        validateVerdictSchema(parsed, path, schemaGate);
      }

      // Validate schemas themselves
      if (validator === 'json-schema') {
        if (!parsed.$schema) {
          schemaGate.addWarning('MISSING_SCHEMA_FIELD', `Missing $schema field`, `${path}:$.$schema`);
        }
      }

      results.push({ check: 'schema', status: 'pass' });
    } catch (e) {
      schemaGate.addError(
        'JSON_PARSE_ERROR',
        `Invalid JSON: ${e.message}`,
        `${path}:json`,
        'critical',
        'valid JSON',
        'parse error'
      );
      results.push({ check: 'schema', status: 'fail' });
    }
  }

  // Gate 4: Format Validation
  if (validator && validators[validator]) {
    const validatorResult = validators[validator](content, fullPath);
    if (!validatorResult.valid) {
      formatGate.addError(
        'FORMAT_VALIDATION_FAILED',
        `Validator '${validator}' failed: ${validatorResult.error}`,
        `${path}:format`,
        'high',
        'valid format',
        'validation error'
      );
      results.push({ check: 'validator', status: 'fail', name: validator });
    } else {
      results.push({ check: 'validator', status: 'pass', name: validator });
    }
  } else if (validator) {
    formatGate.addWarning('UNKNOWN_VALIDATOR', `Unknown validator: ${validator}`, `${path}:$.validator`);
    results.push({ check: 'validator', status: 'skip', reason: `Unknown: ${validator}` });
  }

  return { valid: true, path, errors: [], results };
}

// Receipt schema validation helper
function validateReceiptSchema(receipt, path, gate) {
  const required = [
    'timestamp', 'operation', 'hash_chain', 'workflow_id', 'step_index',
    'redex_executed', 'frontier_after', 'effects_performed',
    'budget_remaining', 'signature', 'public_key', 'chain_length'
  ];

  for (const field of required) {
    if (!(field in receipt)) {
      gate.addError(
        'SCHEMA_VIOLATION',
        `Missing required field '${field}' in receipt`,
        `${path}:$.${field}`,
        'high',
        `field '${field}' present`,
        'field missing'
      );
    }
  }

  // Validate operation enum
  const validOps = ['reduce', 'apply', 'evaluate', 'bind', 'substitute', 'normalize'];
  if (receipt.operation && !validOps.includes(receipt.operation)) {
    gate.addError(
      'INVALID_ENUM_VALUE',
      `Invalid operation '${receipt.operation}'`,
      `${path}:$.operation`,
      'high',
      `one of [${validOps.join(', ')}]`,
      receipt.operation
    );
  }

  // Validate redex_type enum
  if (receipt.redex_executed?.redex_type) {
    const validRedexTypes = ['beta', 'eta', 'delta', 'iota', 'zeta', 'custom'];
    if (!validRedexTypes.includes(receipt.redex_executed.redex_type)) {
      gate.addError(
        'INVALID_ENUM_VALUE',
        `Invalid redex_type '${receipt.redex_executed.redex_type}'`,
        `${path}:$.redex_executed.redex_type`,
        'high',
        `one of [${validRedexTypes.join(', ')}]`,
        receipt.redex_executed.redex_type
      );
    }
  }
}

// Verdict schema validation helper
function validateVerdictSchema(verdict, path, gate) {
  const required = [
    'valid', 'timestamp', 'errors', 'warnings', 'gate_results',
    'validated_receipt_hash', 'validator_version', 'total_error_count',
    'total_warning_count', 'validation_duration_ms', 'gates_passed', 'gates_failed'
  ];

  for (const field of required) {
    if (!(field in verdict)) {
      gate.addError(
        'SCHEMA_VIOLATION',
        `Missing required field '${field}' in verdict`,
        `${path}:$.${field}`,
        'high',
        `field '${field}' present`,
        'field missing'
      );
    }
  }
}

// ============================================================================
// Main Verification Function
// ============================================================================

function main() {
  const startTime = Date.now();

  console.log(colorize('='.repeat(80), 'cyan'));
  console.log(colorize(`  ln_ctrl World Verifier v${VALIDATOR_VERSION}`, 'cyan'));
  console.log(colorize('='.repeat(80), 'cyan'));
  console.log();

  // 1. Check manifest exists
  if (!existsSync(MANIFEST_PATH)) {
    console.error(colorize(`‚ùå Manifest not found: ${MANIFEST_PATH}`, 'red'));
    console.error(`\nExpected location: ${MANIFEST_PATH}`);
    console.error(`Current directory: ${process.cwd()}`);
    process.exit(1);
  }
  console.log(colorize(`‚úì Manifest found: ${MANIFEST_PATH}`, 'green'));

  // 2. Load and parse manifest
  let manifest;
  try {
    manifest = JSON.parse(readFileSync(MANIFEST_PATH, 'utf8'));
  } catch (e) {
    console.error(colorize(`‚ùå Failed to parse manifest: ${e.message}`, 'red'));
    process.exit(1);
  }
  console.log(colorize(`‚úì Manifest parsed successfully`, 'green'));

  // 3. Display manifest metadata
  console.log();
  console.log(colorize('Manifest Metadata:', 'blue'));
  console.log(`  Version:       ${manifest.version || 'unknown'}`);
  console.log(`  Timestamp:     ${manifest.timestamp || 'unknown'}`);
  console.log(`  Workflow ID:   ${manifest.workflow_id || 'unknown'}`);
  console.log(`  Artifacts:     ${manifest.artifacts?.length || 0}`);
  console.log();

  // 4. Initialize validation gates
  const fileGate = new ValidationGate('file_existence');
  const hashGate = new ValidationGate('hash');
  const schemaGate = new ValidationGate('schema');
  const formatGate = new ValidationGate('format_validation');

  // 5. Verify each artifact (Gates 1-4)
  const baseDir = dirname(MANIFEST_PATH);
  console.log(colorize(`üîç Running validation gates...`, 'blue'));
  console.log();

  fileGate.start();
  hashGate.start();
  schemaGate.start();
  formatGate.start();

  const artifactResults = [];

  for (const artifact of manifest.artifacts) {
    const result = verifyArtifact(artifact, baseDir, fileGate, hashGate, schemaGate, formatGate);
    artifactResults.push(result);

    if (!result.valid || result.errors.length > 0) {
      console.error(colorize(`‚ùå ${artifact.path}`, 'red'));
      for (const error of result.errors) {
        console.error(colorize(`   ${error}`, 'red'));
      }
    } else {
      console.log(colorize(`‚úì ${artifact.path}`, 'green'));
      if (result.results?.length > 0) {
        for (const check of result.results) {
          if (check.status === 'pass') {
            const detail = check.algorithm ? ` (${check.algorithm})` : check.name ? ` (${check.name})` : '';
            console.log(colorize(`  ‚úì ${check.check}${detail}`, 'green'));
          } else if (check.status === 'skip') {
            console.log(colorize(`  ‚äò ${check.check}: ${check.reason}`, 'yellow'));
          } else if (check.status === 'fail') {
            console.error(colorize(`  ‚úó ${check.check}`, 'red'));
          }
        }
      }
    }
  }

  fileGate.finish();
  hashGate.finish();
  schemaGate.finish();
  formatGate.finish();

  console.log();

  // 6. Run receipt chain validation (Gate 5)
  const chainValidator = new ReceiptChainValidator();
  const chainGate = chainValidator.validate(manifest.artifacts, baseDir);

  // 7. Run trace validation (Gate 6)
  const traceValidator = new TraceValidator();
  const traceGate = traceValidator.validate(manifest.artifacts, baseDir);

  // 8. Collect all results
  const gateResults = [
    fileGate.getResult(),
    hashGate.getResult(),
    schemaGate.getResult(),
    formatGate.getResult(),
    chainGate.getResult(),
    traceGate.getResult()
  ];

  const allErrors = [
    ...fileGate.errors,
    ...hashGate.errors,
    ...schemaGate.errors,
    ...formatGate.errors,
    ...chainGate.errors,
    ...traceGate.errors
  ];

  const allWarnings = [
    ...fileGate.warnings,
    ...hashGate.warnings,
    ...schemaGate.warnings,
    ...formatGate.warnings,
    ...chainGate.warnings,
    ...traceGate.warnings
  ];

  const validationDuration = Date.now() - startTime;

  // 9. Check performance SLO
  if (validationDuration > PERFORMANCE_THRESHOLD_MS) {
    allWarnings.push({
      warning_code: 'PERFORMANCE_SLOW',
      warning_message: `Validation took ${validationDuration}ms (threshold: ${PERFORMANCE_THRESHOLD_MS}ms)`,
      warning_location: null,
      warning_gate: 'performance'
    });
  }

  // 10. Print report
  printReport(gateResults, allErrors, allWarnings, validationDuration, manifest.artifacts.length);

  // 11. Generate divergence report if failures
  if (allErrors.length > 0) {
    generateDivergenceReport(manifest, gateResults, allErrors, allWarnings, validationDuration);
    process.exit(1);
  }

  process.exit(0);
}

// ============================================================================
// Report Printing
// ============================================================================

function printReport(gateResults, allErrors, allWarnings, duration, artifactCount) {
  console.log(colorize('‚îÄ'.repeat(80), 'cyan'));
  console.log(colorize('VALIDATION RESULTS', 'cyan'));
  console.log(colorize('‚îÄ'.repeat(80), 'cyan'));
  console.log();

  // Gate results
  console.log(colorize('Gate Results:', 'blue'));
  for (const result of gateResults) {
    const icon = result.gate_passed ? '‚úÖ' : '‚ùå';
    const duration = `${result.gate_duration_ms}ms`;
    const errors = result.gate_error_count > 0 ? ` (${result.gate_error_count} errors)` : '';
    const warnings = result.gate_warning_count > 0 ? ` (${result.gate_warning_count} warnings)` : '';

    console.log(`  ${icon} ${result.gate_name.padEnd(20)} ${duration.padStart(8)}${errors}${warnings}`);
  }
  console.log();

  // Errors
  if (allErrors.length > 0) {
    console.log(colorize(`‚ùå ERRORS (${allErrors.length}):`, 'red'));
    for (const error of allErrors) {
      console.log(colorize(`  [${error.error_severity.toUpperCase()}] ${error.error_code}`, 'red'));
      console.log(colorize(`    Message:  ${error.error_message}`, 'red'));
      console.log(colorize(`    Location: ${error.error_location}`, 'red'));
      if (error.error_expected && error.error_actual) {
        console.log(colorize(`    Expected: ${error.error_expected}`, 'yellow'));
        console.log(colorize(`    Actual:   ${error.error_actual}`, 'yellow'));
      }
      console.log();
    }
  }

  // Warnings
  if (allWarnings.length > 0) {
    console.log(colorize(`‚ö†Ô∏è  WARNINGS (${allWarnings.length}):`, 'yellow'));
    for (const warning of allWarnings) {
      console.log(colorize(`  ${warning.warning_code}: ${warning.warning_message}`, 'yellow'));
      if (warning.warning_location) {
        console.log(colorize(`    Location: ${warning.warning_location}`, 'yellow'));
      }
    }
    console.log();
  }

  // Summary
  console.log(colorize('‚îÄ'.repeat(80), 'cyan'));
  const gatesPassed = gateResults.filter(g => g.gate_passed).length;
  const gatesFailed = gateResults.filter(g => !g.gate_passed).length;

  console.log(colorize('Summary:', 'blue'));
  console.log(`  Artifacts: ${artifactCount}`);
  console.log(`  Gates:     ${gatesPassed} passed, ${gatesFailed} failed`);
  console.log(`  Errors:    ${allErrors.length}`);
  console.log(`  Warnings:  ${allWarnings.length}`);
  console.log(`  Duration:  ${duration}ms`);
  console.log();

  if (allErrors.length === 0) {
    console.log(colorize('‚úÖ All artifacts validated successfully', 'green'));
  } else {
    console.log(colorize(`‚ùå Validation failed with ${allErrors.length} error(s)`, 'red'));
  }
  console.log(colorize('‚îÄ'.repeat(80), 'cyan'));
}

function generateDivergenceReport(manifest, gateResults, allErrors, allWarnings, validationDuration) {
  const divergence = DivergenceReporter.generate(
    manifest,
    gateResults,
    allErrors,
    allWarnings,
    validationDuration
  );

  if (!divergence) return;

  const reportPath = join(dirname(MANIFEST_PATH), 'divergence-report.json');

  console.log();
  console.log(colorize('üìä Divergence Report', 'magenta'));
  console.log(colorize('‚îÄ'.repeat(80), 'cyan'));
  console.log();
  console.log(colorize('Diagnosis:', 'yellow'));
  console.log(`  ${divergence.diagnosis}`);
  console.log();
  console.log(colorize('Root Cause:', 'yellow'));
  console.log(`  ${divergence.root_cause}`);
  console.log();
  console.log(colorize('Repair Suggestions:', 'green'));
  for (const suggestion of divergence.repair_suggestions) {
    console.log(colorize(`  ${suggestion.suggestion_priority}. ${suggestion.suggestion_action}`, 'green'));
    console.log(`     Rationale: ${suggestion.suggestion_rationale}`);
    console.log(`     Risk: ${suggestion.suggestion_risk}`);
    console.log();
  }

  console.log(colorize(`Full report saved to: ${reportPath}`, 'blue'));

  try {
    writeFileSync(reportPath, JSON.stringify(divergence, null, 2));
  } catch (err) {
    console.error(colorize(`Warning: Could not write divergence report: ${err.message}`, 'yellow'));
  }
}

// Run verifier
try {
  main();
} catch (e) {
  console.error(colorize(`‚ùå Unexpected error: ${e.message}`, 'red'));
  console.error(e.stack);
  process.exit(1);
}
