#!/usr/bin/env bash
# =============================================================================
# ln_ctrl Swarm Integration Loop - Verification-Constrained Coding Agent
#
# Implements closed-loop agent-verifier cycle for ln_ctrl reducer development.
# Constrains coding agents with verification contracts using divergence feedback.
#
# Formula: Agent ‚Üí Code ‚Üí Verify ‚Üí [Pass: Commit | Fail: Feedback Loop]
#
# Generated by ggen from ln_ctrl wizard - DO NOT EDIT MANUALLY
# Regenerate with: ggen sync --audit true
# =============================================================================

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly GENERATED_DIR="${PROJECT_ROOT}/generated"
readonly LOGS_DIR="${PROJECT_ROOT}/logs"
readonly REPORTS_DIR="${PROJECT_ROOT}/reports"
readonly VERIFIER="${GENERATED_DIR}/world.verify.mjs"
readonly MAX_ITERATIONS={{ max_iterations | default(value="5") }}
readonly AGENT_TIMEOUT={{ agent_timeout_seconds | default(value="300") }}

# State tracking
ITERATION=0
LAST_VERDICT=""
CUMULATIVE_DIVERGENCE=""

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly MAGENTA='\033[0;35m'
readonly NC='\033[0m'

# Ensure directories exist
mkdir -p "${LOGS_DIR}" "${REPORTS_DIR}" "${GENERATED_DIR}"

# Print functions
print_pass() { echo -e "${GREEN}‚úÖ PASS${NC}: $*"; }
print_fail() { echo -e "${RED}‚ùå FAIL${NC}: $*"; }
print_info() { echo -e "${BLUE}‚ÑπÔ∏è  INFO${NC}: $*"; }
print_warn() { echo -e "${YELLOW}‚ö†Ô∏è  WARN${NC}: $*"; }
print_step() { echo -e "${CYAN}‚ñ∂${NC}  $*"; }
print_agent() { echo -e "${MAGENTA}ü§ñ AGENT${NC}: $*"; }

# Usage
usage() {
    cat << 'EOF'
ln_ctrl Swarm Integration Loop

Runs verification-constrained coding agent with divergence feedback.

Usage: ./run_swarm.sh [options]

Options:
    --task <description>    Task description for agent (required)
    --max-iter <N>         Maximum iterations (default: {{ max_iterations | default(value="5") }})
    --timeout <seconds>    Agent timeout per iteration (default: {{ agent_timeout_seconds | default(value="300") }})
    --no-commit            Skip commit on success
    -v, --verbose          Enable verbose output
    -h, --help             Show this help message

Examples:
    ./run_swarm.sh --task "Implement ln_ctrl reducer with beta reduction"
    ./run_swarm.sh --task "Fix causal chain verification" --max-iter 3

Exit codes:
    0 - Success (verification passed)
    1 - Failure (max iterations exceeded)
    2 - Error (invalid input, missing dependencies)

Workflow:
    1. Agent generates code (Claude Code Task tool or API)
    2. Run verifier (node generated/world.verify.mjs)
    3. If fail:
       - Generate divergence report
       - Feed report back to agent
       - Agent fixes based on report
       - Repeat (max {{ max_iterations | default(value="5") }} iterations)
    4. If pass:
       - Commit result with receipt
       - Exit with success

EOF
}

# Check dependencies
check_dependencies() {
    print_step "Checking dependencies..."

    local missing=0

    if ! command -v node &> /dev/null; then
        print_fail "node (Node.js) not found in PATH"
        ((missing++))
    fi

    if ! command -v git &> /dev/null; then
        print_fail "git not found in PATH"
        ((missing++))
    fi

    if ! command -v jq &> /dev/null; then
        print_fail "jq not found in PATH"
        ((missing++))
    fi

    # Check for Claude API credentials or Task tool
    if [[ -z "${ANTHROPIC_API_KEY:-}" ]]; then
        print_warn "ANTHROPIC_API_KEY not set - Task tool integration may fail"
    fi

    if [[ $missing -gt 0 ]]; then
        print_fail "Missing ${missing} required dependencies"
        return 1
    fi

    print_pass "All dependencies available"
    return 0
}

# Validate verifier exists
check_verifier() {
    print_step "Checking verifier..."

    if [[ ! -f "${VERIFIER}" ]]; then
        print_fail "Verifier not found: ${VERIFIER}"
        print_info "Run 'ggen sync' first to generate verifier"
        return 1
    fi

    # Test verifier can be executed
    if ! node "${VERIFIER}" --help &> /dev/null; then
        print_warn "Verifier exists but may not be executable"
    fi

    print_pass "Verifier available: ${VERIFIER}"
    return 0
}

# Run coding agent (via Claude Code Task tool or API)
run_agent() {
    local task_description="$1"
    local divergence_feedback="${2:-}"
    local iteration="$3"

    print_agent "Iteration ${iteration}/${MAX_ITERATIONS}"
    print_step "Running coding agent..."

    local agent_log="${LOGS_DIR}/agent-iter-${iteration}-$(date +%Y%m%d-%H%M%S).log"
    local agent_prompt=""

    # Construct agent prompt
    if [[ -z "$divergence_feedback" ]]; then
        # First iteration - initial task
        agent_prompt="Task: ${task_description}

Requirements:
- Implement ln_ctrl reducer according to specification
- Follow Chicago TDD (write tests first)
- Use Result<T,E> error handling (no unwrap/expect)
- Generate code in ${GENERATED_DIR}
- Ensure all artifacts match world.manifest.json

Context:
- Project: ln_ctrl (lambda calculus with receipts)
- Stack: Rust + Node.js verification
- Paradigm: Specification-driven from RDF ontologies

Success criteria:
- Code compiles without errors
- Tests pass (cargo make test)
- Verifier passes (node ${VERIFIER})

Start with RED test, then GREEN implementation."
    else
        # Subsequent iterations - with divergence feedback
        agent_prompt="Task: Fix divergence from iteration ${iteration}

Previous attempt failed verification. Fix the issues below:

${divergence_feedback}

Requirements:
- Address ALL divergence points listed above
- Maintain existing functionality that passed
- Follow repair suggestions in priority order
- Update tests to cover fixed behavior
- Verify fixes with cargo make test

Context:
- This is iteration ${iteration}/${MAX_ITERATIONS}
- Previous code is in ${GENERATED_DIR}
- Verifier: ${VERIFIER}

Success criteria:
- All divergence points resolved
- Verifier passes (exit code 0)
- No new regressions introduced"
    fi

    print_info "Agent prompt length: $(echo "$agent_prompt" | wc -c) bytes"
    print_info "Log: ${agent_log}"

    # Save prompt for debugging
    echo "$agent_prompt" > "${agent_log}.prompt"

    # =========================================================================
    # AGENT EXECUTION
    # =========================================================================
    # This section integrates with Claude Code Task tool or direct API.
    #
    # For Task tool integration:
    #   - Use Claude Code's built-in Task execution
    #   - Pass prompt via stdin or temp file
    #   - Capture output to agent_log
    #
    # For direct API integration:
    #   - Use curl with Anthropic API
    #   - Stream response to agent_log
    #   - Parse tool use blocks
    #
    # Implementation note: This template provides the STRUCTURE.
    # Actual API integration depends on deployment environment.
    # =========================================================================

    print_warn "SIMULATION MODE: Agent execution not fully integrated"
    print_info "In production, this would:"
    print_info "  1. Call Claude API with prompt"
    print_info "  2. Stream responses to ${agent_log}"
    print_info "  3. Execute tool calls (Read, Write, Edit, Bash)"
    print_info "  4. Return when agent completes task"

    # Simulate agent execution (replace with actual integration)
    cat > "$agent_log" << EOF
Agent execution simulation for iteration ${iteration}

Task: ${task_description}

Divergence feedback:
${divergence_feedback:-None (first iteration)}

Output:
[Agent would generate code here]
[Agent would write files to ${GENERATED_DIR}]
[Agent would run tests with cargo make test]
[Agent would verify output structure]

Simulation complete. Replace this with actual Claude API integration.
EOF

    # Check if agent produced expected outputs
    # (In real implementation, parse agent_log for completion signal)

    print_pass "Agent iteration completed"
    print_info "Agent log: ${agent_log}"

    return 0
}

# Run verifier on generated code
run_verifier() {
    local iteration="$1"

    print_step "Running verifier (iteration ${iteration})..."

    local verify_log="${LOGS_DIR}/verify-iter-${iteration}-$(date +%Y%m%d-%H%M%S).log"
    local verdict_file="${REPORTS_DIR}/verdict-iter-${iteration}.json"

    print_info "Verifier: ${VERIFIER}"
    print_info "Log: ${verify_log}"

    # Run verifier and capture output
    local exit_code=0
    if node "${VERIFIER}" > "$verify_log" 2>&1; then
        exit_code=0
        print_pass "Verification PASSED"
    else
        exit_code=$?
        print_fail "Verification FAILED (exit code: ${exit_code})"
    fi

    # Parse verification output to structured verdict
    # (Assumes verifier outputs JSON verdict to stdout)
    if [[ -f "$verify_log" ]]; then
        # Try to extract JSON verdict from log
        if grep -q '"valid"' "$verify_log"; then
            jq '.' "$verify_log" > "$verdict_file" 2>/dev/null || true
        else
            # Create verdict from text output
            local is_valid="false"
            [[ $exit_code -eq 0 ]] && is_valid="true"

            cat > "$verdict_file" << EOF
{
  "valid": $is_valid,
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "iteration": ${iteration},
  "verifier": "${VERIFIER}",
  "exit_code": ${exit_code},
  "log_file": "${verify_log}"
}
EOF
        fi
    fi

    LAST_VERDICT="$verdict_file"

    return $exit_code
}

# Generate divergence report from failed verification
generate_divergence_report() {
    local iteration="$1"
    local verdict_file="${LAST_VERDICT}"

    print_step "Generating divergence report (iteration ${iteration})..."

    local report_file="${REPORTS_DIR}/divergence-iter-${iteration}.json"
    local verify_log="${LOGS_DIR}/verify-iter-${iteration}-*.log"

    # Find most recent verify log for this iteration
    verify_log=$(ls -t ${LOGS_DIR}/verify-iter-${iteration}-*.log 2>/dev/null | head -1)

    if [[ ! -f "$verify_log" ]]; then
        print_warn "No verification log found for iteration ${iteration}"
        echo "No verification log available" > "$report_file"
        echo "$report_file"
        return 0
    fi

    print_info "Analyzing verification log: ${verify_log}"

    # Extract errors and divergence points from verification log
    local errors=""
    local divergence_points=""

    # Parse common error patterns
    errors=$(grep -E "‚ùå|FAIL|Error|error:" "$verify_log" | head -20 || true)
    divergence_points=$(grep -E "mismatch|expected|actual|divergence" "$verify_log" | head -20 || true)

    # Build structured divergence report
    cat > "$report_file" << EOF
{
  "detected_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "iteration": ${iteration},
  "severity": "high",
  "workflow_id": "{{ workflow_id | default(value="swarm-$(date +%Y%m%d-%H%M%S)") }}",
  "step_number": ${iteration},
  "diagnosis": "Verification failed - see errors below",
  "root_cause": "implementation_mismatch",
  "errors": $(echo "$errors" | jq -R . | jq -s .),
  "divergence_points": $(echo "$divergence_points" | jq -R . | jq -s .),
  "repair_suggestions": [
    {
      "priority": 1,
      "action": "Review all error messages above and fix each in order",
      "rationale": "Systematic fix based on verification output",
      "risk": "low"
    },
    {
      "priority": 2,
      "action": "Ensure generated artifacts match world.manifest.json schema",
      "rationale": "Structural validation prevents downstream failures",
      "risk": "low"
    },
    {
      "priority": 3,
      "action": "Run cargo make test to validate Rust implementation",
      "rationale": "Unit tests catch logic errors early",
      "risk": "medium"
    }
  ],
  "verification_log": "${verify_log}",
  "verdict_file": "${verdict_file}"
}
EOF

    print_pass "Divergence report generated: ${report_file}"
    echo "$report_file"
}

# Format divergence report for agent feedback
format_feedback() {
    local report_file="$1"

    if [[ ! -f "$report_file" ]]; then
        echo "ERROR: Divergence report not found"
        return 1
    fi

    # Extract key fields and format as human-readable feedback
    local detected_at=$(jq -r '.detected_at' "$report_file")
    local diagnosis=$(jq -r '.diagnosis' "$report_file")
    local root_cause=$(jq -r '.root_cause' "$report_file")
    local errors=$(jq -r '.errors | join("\n")' "$report_file")
    local suggestions=$(jq -r '.repair_suggestions[] | "[\(.priority)] \(.action)\n   Rationale: \(.rationale)\n   Risk: \(.risk)"' "$report_file")

    cat << EOF
=============================================================================
DIVERGENCE REPORT - Iteration $(jq -r '.iteration' "$report_file")
=============================================================================
Detected: ${detected_at}
Root Cause: ${root_cause}
Diagnosis: ${diagnosis}

ERRORS FOUND:
${errors}

REPAIR SUGGESTIONS (in priority order):
${suggestions}

VERIFICATION LOG:
$(jq -r '.verification_log' "$report_file")

NEXT STEPS:
1. Read the errors above carefully
2. Follow repair suggestions in priority order
3. Fix code in ${GENERATED_DIR}
4. Verify fixes with: cargo make test
5. Submit for re-verification

=============================================================================
EOF
}

# Commit successful result
commit_result() {
    print_step "Committing successful result..."

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_warn "Not a git repository - skipping commit"
        return 0
    fi

    local commit_msg="feat(ln_ctrl): Implement reducer with verification

Swarm integration loop completed successfully.

Iterations: ${ITERATION}/${MAX_ITERATIONS}
Verifier: ${VERIFIER}
Generated: ${GENERATED_DIR}

[Receipt] Verifier passed: ‚úÖ
[Receipt] Iterations: ${ITERATION}
[Receipt] Verdict: ${LAST_VERDICT}

https://claude.ai/code/session_$(date +%s)"

    # Stage generated files
    git add "${GENERATED_DIR}"/* 2>/dev/null || true
    git add "${REPORTS_DIR}"/* 2>/dev/null || true

    if git diff --staged --quiet; then
        print_info "No changes to commit"
        return 0
    fi

    # Commit with receipt
    if git commit -m "$commit_msg"; then
        print_pass "Changes committed successfully"
        print_info "Commit message includes verification receipt"
        return 0
    else
        print_fail "Commit failed"
        return 1
    fi
}

# Main swarm loop
run_swarm_loop() {
    local task_description="$1"
    local do_commit="${2:-true}"

    print_info "Starting swarm integration loop"
    print_info "Task: ${task_description}"
    print_info "Max iterations: ${MAX_ITERATIONS}"
    print_info "Agent timeout: ${AGENT_TIMEOUT}s"
    echo ""

    # Initial agent run (no feedback)
    ITERATION=1
    if ! run_agent "$task_description" "" "$ITERATION"; then
        print_fail "Agent execution failed on iteration ${ITERATION}"
        return 1
    fi

    # Verification loop
    while [[ $ITERATION -le $MAX_ITERATIONS ]]; do
        print_info "Verification attempt ${ITERATION}/${MAX_ITERATIONS}"

        # Run verifier
        if run_verifier "$ITERATION"; then
            # Success! Verification passed
            print_pass "Verification PASSED on iteration ${ITERATION}"

            if [[ "$do_commit" == "true" ]]; then
                commit_result
            fi

            return 0
        fi

        # Verification failed
        print_warn "Verification FAILED on iteration ${ITERATION}"

        # Check if we've exhausted iterations
        if [[ $ITERATION -ge $MAX_ITERATIONS ]]; then
            print_fail "Maximum iterations (${MAX_ITERATIONS}) exceeded"
            print_info "Last verdict: ${LAST_VERDICT}"
            return 1
        fi

        # Generate divergence report
        local report_file
        report_file=$(generate_divergence_report "$ITERATION")

        # Format feedback for agent
        local feedback
        feedback=$(format_feedback "$report_file")
        CUMULATIVE_DIVERGENCE="${CUMULATIVE_DIVERGENCE}\n\n--- Iteration ${ITERATION} ---\n${feedback}"

        print_info "Divergence feedback prepared"

        # Next iteration with feedback
        ((ITERATION++))
        print_agent "Starting iteration ${ITERATION} with divergence feedback..."

        if ! run_agent "$task_description" "$feedback" "$ITERATION"; then
            print_fail "Agent execution failed on iteration ${ITERATION}"
            return 1
        fi
    done

    # Should not reach here
    print_fail "Unexpected loop termination"
    return 1
}

# Print summary
print_summary() {
    local exit_code="$1"

    echo ""
    echo "=============================================="
    echo "ln_ctrl Swarm Integration Loop - Summary"
    echo "=============================================="
    echo "Iterations:   ${ITERATION}/${MAX_ITERATIONS}"
    echo "Timestamp:    $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    echo "Generated:    ${GENERATED_DIR}"
    echo "Reports:      ${REPORTS_DIR}"
    echo "Logs:         ${LOGS_DIR}"
    echo "----------------------------------------------"

    if [[ $exit_code -eq 0 ]]; then
        echo -e "Result:       ${GREEN}‚úÖ SUCCESS${NC}"
        echo "Verdict:      ${LAST_VERDICT}"
    else
        echo -e "Result:       ${RED}‚ùå FAILURE${NC}"
        echo "Last Verdict: ${LAST_VERDICT}"
        echo ""
        echo "Debug:"
        echo "  - Review logs in ${LOGS_DIR}"
        echo "  - Check reports in ${REPORTS_DIR}"
        echo "  - Verify generated code in ${GENERATED_DIR}"
    fi

    echo "=============================================="
    echo ""
}

# Main execution
main() {
    local task_description=""
    local max_iter="${MAX_ITERATIONS}"
    local timeout="${AGENT_TIMEOUT}"
    local do_commit=true
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --task)
                task_description="$2"
                shift 2
                ;;
            --max-iter)
                max_iter="$2"
                shift 2
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            --no-commit)
                do_commit=false
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 2
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$task_description" ]]; then
        print_fail "Missing required argument: --task"
        echo ""
        usage
        exit 2
    fi

    echo ""
    echo "=============================================="
    echo "ln_ctrl Swarm Integration Loop"
    echo "=============================================="
    echo "Verification-Constrained Coding Agent"
    echo "Formula: Agent ‚Üí Code ‚Üí Verify ‚Üí [Pass: Commit | Fail: Feedback Loop]"
    echo "----------------------------------------------"
    echo ""

    # Check dependencies
    if ! check_dependencies; then
        exit 2
    fi

    # Check verifier
    if ! check_verifier; then
        exit 2
    fi

    # Run swarm loop
    local exit_code=0
    if ! run_swarm_loop "$task_description" "$do_commit"; then
        exit_code=1
    fi

    # Print summary
    print_summary "$exit_code"

    exit $exit_code
}

main "$@"
