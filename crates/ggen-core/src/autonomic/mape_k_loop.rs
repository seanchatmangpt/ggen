//! MAPE-K loop coordinator for autonomic computing
//!
//! Implements the Monitor-Analyze-Plan-Execute-Knowledge (MAPE-K) loop pattern
//! for self-managing, self-healing distributed systems.
//!
//! ## Architecture
//!
//! The MAPE-K loop provides continuous autonomous operation through five phases:
//! - **Monitor**: Observe system state and detect failures
//! - **Analyze**: Diagnose root causes and assess severity
//! - **Plan**: Generate recovery strategies
//! - **Execute**: Apply recovery actions
//! - **Knowledge**: Update knowledge base with learnings
//!
//! ## Example
//!
//! ```rust,no_run
//! use ggen_core::autonomic::mape_k_loop::{MapekLoop, MapekConfig};
//! use std::time::Duration;
//!
//! # async fn example() -> ggen_utils::error::Result<()> {
//! let config = MapekConfig::default()
//!     .with_cycle_interval(Duration::from_secs(5))
//!     .with_max_recovery_time(Duration::from_secs(300));
//!
//! let loop_instance = MapekLoop::new_with_config(config)?;
//!
//! // Run single cycle
//! let result = loop_instance.run_cycle().await?;
//! println!("Cycle completed in {:?}", result.total_time);
//!
//! // Run continuous for 1 hour
//! let results = loop_instance.run_continuous(Duration::from_secs(3600)).await?;
//! println!("Handled {} failures", results.len());
//! # Ok(())
//! # }
//! ```

use std::sync::Arc;
use std::time::{Duration, Instant};
use thiserror::Error;

/// MAPE-K loop error types
#[derive(Debug, Error)]
pub enum MapekError {
    /// Monitor phase failed
    #[error("Monitor phase failed: {0}")]
    MonitorFailed(String),

    /// Analyze phase failed
    #[error("Analyze phase failed: {0}")]
    AnalyzeFailed(String),

    /// Plan phase failed
    #[error("Plan phase failed: {0}")]
    PlanFailed(String),

    /// Execute phase failed
    #[error("Execute phase failed: {0}")]
    ExecuteFailed(String),

    /// Knowledge base update failed
    #[error("Knowledge base update failed: {0}")]
    KnowledgeUpdateFailed(String),

    /// Cycle timeout
    #[error("MAPE-K cycle exceeded timeout: {0:?}")]
    CycleTimeout(Duration),

    /// Invalid configuration
    #[error("Invalid MAPE-K configuration: {0}")]
    InvalidConfig(String),
}

/// Result type for MAPE-K operations
pub type Result<T> = std::result::Result<T, MapekError>;

// ============================================================================
// Stub types for MAPE-K components (to be implemented separately)
// ============================================================================

/// Cluster state snapshot from monitoring
#[derive(Debug, Clone)]
pub struct ClusterState {
    /// Timestamp when state was captured
    pub timestamp: Instant,
    /// Number of healthy nodes
    pub healthy_nodes: usize,
    /// Number of failed nodes
    pub failed_nodes: usize,
    /// Detected failures
    pub failures: Vec<DetectedFailure>,
    /// System metrics
    pub metrics: SystemMetrics,
}

/// Detected failure information
#[derive(Debug, Clone)]
pub struct DetectedFailure {
    /// Failure identifier
    pub id: String,
    /// Failure type
    pub failure_type: FailureType,
    /// Affected component
    pub component: String,
    /// Detection timestamp
    pub detected_at: Instant,
}

/// Types of failures that can be detected
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FailureType {
    /// Node crash or unavailability
    NodeCrash,
    /// Network partition or connectivity loss
    NetworkPartition,
    /// Resource exhaustion (CPU, memory, disk)
    ResourceExhaustion,
    /// Performance degradation
    PerformanceDegradation,
}

/// System performance metrics
#[derive(Debug, Clone)]
pub struct SystemMetrics {
    /// Average response time in milliseconds
    pub avg_response_time_ms: f64,
    /// Current throughput (requests/second)
    pub throughput_rps: f64,
    /// Error rate (0.0 to 1.0)
    pub error_rate: f64,
    /// CPU utilization percentage (0.0 to 100.0)
    pub cpu_utilization: f64,
    /// Memory utilization percentage (0.0 to 100.0)
    pub memory_utilization: f64,
}

/// Analysis result from failure diagnosis
#[derive(Debug, Clone)]
pub struct AnalysisResult {
    /// Root cause analysis
    pub root_cause: String,
    /// Severity level (0.0 = minor, 1.0 = critical)
    pub severity: f64,
    /// Affected failures
    pub failures: Vec<DetectedFailure>,
    /// Recommended actions
    pub recommendations: Vec<String>,
}

/// Recovery plan generated by planner
#[derive(Debug, Clone)]
pub struct RecoveryPlan {
    /// Plan identifier
    pub plan_id: String,
    /// Recovery actions to execute
    pub actions: Vec<RecoveryAction>,
    /// Estimated recovery time
    pub estimated_duration: Duration,
    /// Expected degradation during recovery
    pub expected_degradation_percent: f64,
}

/// Recovery action to execute
#[derive(Debug, Clone)]
pub struct RecoveryAction {
    /// Action identifier
    pub id: String,
    /// Action type
    pub action_type: ActionType,
    /// Target component
    pub target: String,
    /// Action parameters
    pub parameters: Vec<String>,
}

/// Types of recovery actions
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ActionType {
    /// Restart a failed component
    Restart,
    /// Failover to backup
    Failover,
    /// Scale resources
    Scale,
    /// Reconfigure component
    Reconfigure,
}

/// Execution result
#[derive(Debug, Clone)]
pub struct ExecutionResult {
    /// Whether execution succeeded
    pub success: bool,
    /// Actions executed
    pub executed_actions: Vec<String>,
    /// Actual recovery time
    pub recovery_time: Duration,
    /// Maximum degradation observed
    pub max_degradation_percent: f64,
    /// Error message if failed
    pub error_message: Option<String>,
}

/// Resilience monitor (stub - to be implemented)
pub struct ResilienceMonitor;

impl ResilienceMonitor {
    /// Capture current cluster state
    pub async fn capture_state(&self) -> Result<ClusterState> {
        // Stub implementation - returns healthy state
        Ok(ClusterState {
            timestamp: Instant::now(),
            healthy_nodes: 3,
            failed_nodes: 0,
            failures: Vec::new(),
            metrics: SystemMetrics {
                avg_response_time_ms: 50.0,
                throughput_rps: 1000.0,
                error_rate: 0.001,
                cpu_utilization: 45.0,
                memory_utilization: 60.0,
            },
        })
    }
}

/// Resilience analyzer (stub - to be implemented)
pub struct ResilienceAnalyzer;

impl ResilienceAnalyzer {
    /// Analyze cluster state and diagnose failures
    pub async fn analyze(&self, state: &ClusterState) -> Result<AnalysisResult> {
        if state.failures.is_empty() {
            return Ok(AnalysisResult {
                root_cause: "No failures detected".to_string(),
                severity: 0.0,
                failures: Vec::new(),
                recommendations: Vec::new(),
            });
        }

        Ok(AnalysisResult {
            root_cause: "Failure detected".to_string(),
            severity: 0.5,
            failures: state.failures.clone(),
            recommendations: vec!["Investigate failure".to_string()],
        })
    }
}

/// Resilience planner (stub - to be implemented)
pub struct ResiliencePlanner;

impl ResiliencePlanner {
    /// Generate recovery plan from analysis
    pub async fn plan(&self, analysis: &AnalysisResult) -> Result<RecoveryPlan> {
        if analysis.failures.is_empty() {
            return Ok(RecoveryPlan {
                plan_id: "no-op".to_string(),
                actions: Vec::new(),
                estimated_duration: Duration::from_secs(0),
                expected_degradation_percent: 0.0,
            });
        }

        Ok(RecoveryPlan {
            plan_id: format!("plan-{}", uuid::Uuid::new_v4()),
            actions: vec![RecoveryAction {
                id: "action-1".to_string(),
                action_type: ActionType::Restart,
                target: "node-1".to_string(),
                parameters: Vec::new(),
            }],
            estimated_duration: Duration::from_secs(30),
            expected_degradation_percent: 10.0,
        })
    }
}

/// Resilience executor (stub - to be implemented)
pub struct ResilienceExecutor;

impl ResilienceExecutor {
    /// Execute recovery plan
    pub async fn execute(&self, plan: &RecoveryPlan) -> Result<ExecutionResult> {
        let start = Instant::now();

        if plan.actions.is_empty() {
            return Ok(ExecutionResult {
                success: true,
                executed_actions: Vec::new(),
                recovery_time: Duration::from_secs(0),
                max_degradation_percent: 0.0,
                error_message: None,
            });
        }

        // Simulate execution
        let executed: Vec<String> = plan.actions.iter().map(|a| a.id.clone()).collect();

        Ok(ExecutionResult {
            success: true,
            executed_actions: executed,
            recovery_time: start.elapsed(),
            max_degradation_percent: plan.expected_degradation_percent,
            error_message: None,
        })
    }
}

/// Failure knowledge base (stub - to be implemented)
pub struct FailureKnowledgeBase;

impl FailureKnowledgeBase {
    /// Record a MAPE-K cycle result
    pub async fn record_cycle(&self, _result: &MapekCycleResult) -> Result<()> {
        // Stub implementation - no-op
        Ok(())
    }
}

// ============================================================================
// MAPE-K Loop Configuration
// ============================================================================

/// Configuration for MAPE-K loop
#[derive(Debug, Clone)]
pub struct MapekConfig {
    /// Interval between cycles
    pub cycle_interval: Duration,
    /// Maximum time allowed for a single cycle
    pub max_cycle_time: Duration,
    /// Maximum time for recovery operations
    pub max_recovery_time: Duration,
    /// Whether to update knowledge base after each cycle
    pub enable_knowledge_updates: bool,
}

impl Default for MapekConfig {
    fn default() -> Self {
        MapekConfig {
            cycle_interval: Duration::from_secs(10),
            max_cycle_time: Duration::from_secs(60),
            max_recovery_time: Duration::from_secs(300),
            enable_knowledge_updates: true,
        }
    }
}

impl MapekConfig {
    /// Set cycle interval
    pub fn with_cycle_interval(mut self, interval: Duration) -> Self {
        self.cycle_interval = interval;
        self
    }

    /// Set maximum cycle time
    pub fn with_max_cycle_time(mut self, max_time: Duration) -> Self {
        self.max_cycle_time = max_time;
        self
    }

    /// Set maximum recovery time
    pub fn with_max_recovery_time(mut self, max_time: Duration) -> Self {
        self.max_recovery_time = max_time;
        self
    }

    /// Enable or disable knowledge base updates
    pub fn with_knowledge_updates(mut self, enable: bool) -> Self {
        self.enable_knowledge_updates = enable;
        self
    }

    /// Validate configuration
    pub fn validate(&self) -> Result<()> {
        if self.cycle_interval.as_secs() == 0 {
            return Err(MapekError::InvalidConfig(
                "Cycle interval must be > 0".to_string(),
            ));
        }

        if self.max_cycle_time < self.cycle_interval {
            return Err(MapekError::InvalidConfig(
                "Max cycle time must be >= cycle interval".to_string(),
            ));
        }

        Ok(())
    }
}

// ============================================================================
// MAPE-K Loop
// ============================================================================

/// Result of a complete MAPE-K cycle
#[derive(Debug, Clone)]
pub struct MapekCycleResult {
    /// Time spent in monitor phase
    pub detection_time: Duration,
    /// Time spent in analyze phase
    pub analysis_time: Duration,
    /// Time spent in plan phase
    pub planning_time: Duration,
    /// Time spent in execute phase
    pub execution_time: Duration,
    /// Total cycle time
    pub total_time: Duration,
    /// Whether recovery succeeded
    pub recovered_successfully: bool,
    /// Maximum degradation during cycle
    pub max_degradation_percent: f64,
    /// Failures handled in this cycle
    pub failures_handled: Vec<DetectedFailure>,
}

/// MAPE-K loop coordinator
pub struct MapekLoop {
    /// Resilience monitor component
    monitor: Arc<ResilienceMonitor>,
    /// Resilience analyzer component
    analyzer: Arc<ResilienceAnalyzer>,
    /// Resilience planner component
    planner: Arc<ResiliencePlanner>,
    /// Resilience executor component
    executor: Arc<ResilienceExecutor>,
    /// Failure knowledge base
    knowledge_base: Arc<FailureKnowledgeBase>,
    /// Configuration
    config: MapekConfig,
}

impl MapekLoop {
    /// Create a new MAPE-K loop with default configuration
    ///
    /// # Errors
    ///
    /// Returns error if configuration validation fails
    pub fn new() -> Result<Self> {
        Self::new_with_config(MapekConfig::default())
    }

    /// Create a new MAPE-K loop with custom configuration
    ///
    /// # Arguments
    ///
    /// * `config` - MAPE-K loop configuration
    ///
    /// # Errors
    ///
    /// Returns error if configuration validation fails
    pub fn new_with_config(config: MapekConfig) -> Result<Self> {
        config.validate()?;

        Ok(MapekLoop {
            monitor: Arc::new(ResilienceMonitor),
            analyzer: Arc::new(ResilienceAnalyzer),
            planner: Arc::new(ResiliencePlanner),
            executor: Arc::new(ResilienceExecutor),
            knowledge_base: Arc::new(FailureKnowledgeBase),
            config,
        })
    }

    /// Run a single MAPE-K cycle
    ///
    /// # Errors
    ///
    /// Returns error if any phase fails or cycle exceeds timeout
    pub async fn run_cycle(&self) -> Result<MapekCycleResult> {
        let cycle_start = Instant::now();

        // Monitor phase
        let (state, detection_time) = self.monitor_phase().await?;

        // Analyze phase
        let (analysis, analysis_time) = self.analyze_phase(&state).await?;

        // Plan phase
        let (plan, planning_time) = self.plan_phase(&analysis).await?;

        // Execute phase
        let (execution, execution_time) = self.execute_phase(&plan).await?;

        let total_time = cycle_start.elapsed();

        // Check timeout
        if total_time > self.config.max_cycle_time {
            return Err(MapekError::CycleTimeout(total_time));
        }

        let result = MapekCycleResult {
            detection_time,
            analysis_time,
            planning_time,
            execution_time,
            total_time,
            recovered_successfully: execution.success,
            max_degradation_percent: execution.max_degradation_percent,
            failures_handled: state.failures,
        };

        // Update knowledge base
        if self.config.enable_knowledge_updates {
            self.update_knowledge_base(&result).await?;
        }

        Ok(result)
    }

    /// Run continuous MAPE-K cycles for specified duration
    ///
    /// # Arguments
    ///
    /// * `duration` - How long to run continuous cycles
    ///
    /// # Errors
    ///
    /// Returns error if cycle execution fails
    pub async fn run_continuous(&self, duration: Duration) -> Result<Vec<MapekCycleResult>> {
        let start = Instant::now();
        let mut results = Vec::new();

        while start.elapsed() < duration {
            let result = self.run_cycle().await?;
            results.push(result);

            // Sleep until next cycle
            tokio::time::sleep(self.config.cycle_interval).await;
        }

        Ok(results)
    }

    /// Monitor phase: Observe system state
    async fn monitor_phase(&self) -> Result<(ClusterState, Duration)> {
        let start = Instant::now();
        let state = self
            .monitor
            .capture_state()
            .await
            .map_err(|e| MapekError::MonitorFailed(e.to_string()))?;
        Ok((state, start.elapsed()))
    }

    /// Analyze phase: Diagnose failures
    async fn analyze_phase(&self, state: &ClusterState) -> Result<(AnalysisResult, Duration)> {
        let start = Instant::now();
        let analysis = self
            .analyzer
            .analyze(state)
            .await
            .map_err(|e| MapekError::AnalyzeFailed(e.to_string()))?;
        Ok((analysis, start.elapsed()))
    }

    /// Plan phase: Generate recovery strategy
    async fn plan_phase(&self, analysis: &AnalysisResult) -> Result<(RecoveryPlan, Duration)> {
        let start = Instant::now();
        let plan = self
            .planner
            .plan(analysis)
            .await
            .map_err(|e| MapekError::PlanFailed(e.to_string()))?;
        Ok((plan, start.elapsed()))
    }

    /// Execute phase: Apply recovery actions
    async fn execute_phase(&self, plan: &RecoveryPlan) -> Result<(ExecutionResult, Duration)> {
        let start = Instant::now();
        let execution = self
            .executor
            .execute(plan)
            .await
            .map_err(|e| MapekError::ExecuteFailed(e.to_string()))?;
        Ok((execution, start.elapsed()))
    }

    /// Update knowledge base with cycle results
    async fn update_knowledge_base(&self, cycle_result: &MapekCycleResult) -> Result<()> {
        self.knowledge_base
            .record_cycle(cycle_result)
            .await
            .map_err(|e| MapekError::KnowledgeUpdateFailed(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // Chicago TDD Tests - State-based verification with AAA pattern
    // ========================================================================

    #[tokio::test]
    async fn test_mapek_loop_creation_succeeds() {
        // Arrange - no setup needed

        // Act
        let result = MapekLoop::new();

        // Assert
        assert!(result.is_ok(), "MAPE-K loop creation should succeed");
    }

    #[tokio::test]
    async fn test_mapek_config_validation_rejects_zero_interval() {
        // Arrange
        let config = MapekConfig::default().with_cycle_interval(Duration::from_secs(0));

        // Act
        let result = config.validate();

        // Assert
        assert!(result.is_err(), "Should reject zero cycle interval");
        assert!(
            matches!(result.unwrap_err(), MapekError::InvalidConfig(_)),
            "Should return InvalidConfig error"
        );
    }

    #[tokio::test]
    async fn test_mapek_config_validation_rejects_invalid_timeout() {
        // Arrange
        let config = MapekConfig::default()
            .with_cycle_interval(Duration::from_secs(60))
            .with_max_cycle_time(Duration::from_secs(30));

        // Act
        let result = config.validate();

        // Assert
        assert!(
            result.is_err(),
            "Should reject max_cycle_time < cycle_interval"
        );
    }

    #[tokio::test]
    async fn test_single_cycle_completes_successfully() {
        // Arrange
        let mape_k = MapekLoop::new().expect("Failed to create MAPE-K loop");

        // Act
        let result = mape_k.run_cycle().await;

        // Assert
        assert!(result.is_ok(), "Single cycle should complete successfully");
        let cycle_result = result.unwrap();
        assert!(
            cycle_result.total_time > Duration::from_secs(0),
            "Total time should be positive"
        );
        assert!(
            cycle_result.recovered_successfully,
            "Recovery should succeed with no failures"
        );
    }

    #[tokio::test]
    async fn test_cycle_phases_are_timed_correctly() {
        // Arrange
        let mape_k = MapekLoop::new().expect("Failed to create MAPE-K loop");

        // Act
        let result = mape_k.run_cycle().await.expect("Cycle should succeed");

        // Assert
        assert!(
            result.detection_time >= Duration::from_secs(0),
            "Detection time should be non-negative"
        );
        assert!(
            result.analysis_time >= Duration::from_secs(0),
            "Analysis time should be non-negative"
        );
        assert!(
            result.planning_time >= Duration::from_secs(0),
            "Planning time should be non-negative"
        );
        assert!(
            result.execution_time >= Duration::from_secs(0),
            "Execution time should be non-negative"
        );

        let sum = result.detection_time
            + result.analysis_time
            + result.planning_time
            + result.execution_time;
        assert!(
            result.total_time >= sum,
            "Total time should be >= sum of phase times"
        );
    }

    #[tokio::test]
    async fn test_continuous_cycles_run_for_duration() {
        // Arrange
        let config =
            MapekConfig::default().with_cycle_interval(Duration::from_millis(100));
        let mape_k = MapekLoop::new_with_config(config).expect("Failed to create MAPE-K loop");
        let run_duration = Duration::from_millis(350);

        // Act
        let results = mape_k.run_continuous(run_duration).await;

        // Assert
        assert!(results.is_ok(), "Continuous cycles should complete");
        let cycle_results = results.unwrap();
        assert!(
            cycle_results.len() >= 2,
            "Should complete multiple cycles in 350ms with 100ms interval"
        );
    }

    #[tokio::test]
    async fn test_cycle_result_tracks_failures_handled() {
        // Arrange
        let mape_k = MapekLoop::new().expect("Failed to create MAPE-K loop");

        // Act
        let result = mape_k.run_cycle().await.expect("Cycle should succeed");

        // Assert
        assert!(
            result.failures_handled.is_empty(),
            "No failures should be present in healthy state"
        );
        assert_eq!(
            result.max_degradation_percent, 0.0,
            "No degradation expected with no failures"
        );
    }

    #[tokio::test]
    async fn test_knowledge_base_updates_can_be_disabled() {
        // Arrange
        let config = MapekConfig::default().with_knowledge_updates(false);
        let mape_k = MapekLoop::new_with_config(config).expect("Failed to create MAPE-K loop");

        // Act
        let result = mape_k.run_cycle().await;

        // Assert
        assert!(
            result.is_ok(),
            "Cycle should succeed even without knowledge updates"
        );
    }

    #[tokio::test]
    async fn test_config_builder_pattern_works() {
        // Arrange & Act
        let config = MapekConfig::default()
            .with_cycle_interval(Duration::from_secs(5))
            .with_max_cycle_time(Duration::from_secs(30))
            .with_max_recovery_time(Duration::from_secs(120))
            .with_knowledge_updates(true);

        // Assert
        assert_eq!(config.cycle_interval, Duration::from_secs(5));
        assert_eq!(config.max_cycle_time, Duration::from_secs(30));
        assert_eq!(config.max_recovery_time, Duration::from_secs(120));
        assert!(config.enable_knowledge_updates);
    }

    #[tokio::test]
    async fn test_cycle_recovers_successfully_with_no_failures() {
        // Arrange
        let mape_k = MapekLoop::new().expect("Failed to create MAPE-K loop");

        // Act
        let result = mape_k.run_cycle().await.expect("Cycle should succeed");

        // Assert
        assert!(
            result.recovered_successfully,
            "Recovery should succeed when no failures present"
        );
        assert!(
            result.failures_handled.is_empty(),
            "No failures should be handled"
        );
    }
}
