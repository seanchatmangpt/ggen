//! Vulnerability scanning for Rust dependencies and Docker images
//!
//! This module provides integration with:
//! - `cargo audit` for Rust dependency vulnerability scanning
//! - Trivy for Docker image vulnerability scanning
//! - SARIF output generation for GitHub Security tab

use ggen_utils::error::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::process::{Command, Output};

/// Severity level of a vulnerability
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Severity {
    /// Critical severity - immediate action required
    Critical,
    /// High severity - fix as soon as possible
    High,
    /// Medium severity - fix in near term
    Medium,
    /// Low severity - fix when convenient
    Low,
    /// Informational - no immediate action required
    Info,
}

impl Severity {
    /// Parse severity from string
    fn from_str(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "critical" => Self::Critical,
            "high" => Self::High,
            "medium" | "moderate" => Self::Medium,
            "low" => Self::Low,
            _ => Self::Info,
        }
    }

    /// Check if severity is high or critical
    pub fn is_high_severity(&self) -> bool {
        matches!(self, Self::Critical | Self::High)
    }
}

/// A detected vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Vulnerability ID (e.g., CVE-2024-12345, RUSTSEC-2024-001)
    pub id: String,
    /// Package/dependency name
    pub package: String,
    /// Package version
    pub version: String,
    /// Vulnerability severity
    pub severity: Severity,
    /// Description of the vulnerability
    pub description: String,
    /// URL with more information
    pub url: Option<String>,
    /// Fixed version (if available)
    pub fixed_version: Option<String>,
}

/// Configuration for vulnerability scanning
#[derive(Debug, Clone)]
pub struct ScanConfig {
    /// Path to project root
    pub project_root: PathBuf,
    /// Fail build on high severity vulnerabilities
    pub fail_on_high_severity: bool,
    /// Include Docker image scanning
    pub scan_docker: bool,
    /// Docker image to scan (if scan_docker is true)
    pub docker_image: Option<String>,
}

impl Default for ScanConfig {
    fn default() -> Self {
        Self {
            project_root: PathBuf::from("."),
            fail_on_high_severity: true,
            scan_docker: false,
            docker_image: None,
        }
    }
}

/// Scan results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResults {
    /// All detected vulnerabilities
    pub vulnerabilities: Vec<Vulnerability>,
    /// Number of critical vulnerabilities
    pub critical_count: usize,
    /// Number of high severity vulnerabilities
    pub high_count: usize,
    /// Number of medium severity vulnerabilities
    pub medium_count: usize,
    /// Number of low severity vulnerabilities
    pub low_count: usize,
}

impl ScanResults {
    /// Create empty scan results
    fn new() -> Self {
        Self {
            vulnerabilities: Vec::new(),
            critical_count: 0,
            high_count: 0,
            medium_count: 0,
            low_count: 0,
        }
    }

    /// Add a vulnerability to the results
    fn add_vulnerability(&mut self, vuln: Vulnerability) {
        match vuln.severity {
            Severity::Critical => self.critical_count += 1,
            Severity::High => self.high_count += 1,
            Severity::Medium => self.medium_count += 1,
            Severity::Low => self.low_count += 1,
            Severity::Info => {}
        }
        self.vulnerabilities.push(vuln);
    }

    /// Check if results contain high severity vulnerabilities
    pub fn has_high_severity(&self) -> bool {
        self.critical_count > 0 || self.high_count > 0
    }

    /// Get total vulnerability count
    pub fn total_count(&self) -> usize {
        self.vulnerabilities.len()
    }
}

/// Vulnerability scanner
pub struct VulnerabilityScanner {
    config: ScanConfig,
}

impl VulnerabilityScanner {
    /// Create a new vulnerability scanner
    pub fn new(config: ScanConfig) -> Self {
        Self { config }
    }

    /// Run comprehensive vulnerability scan
    pub fn scan(&self) -> Result<ScanResults> {
        let mut results = ScanResults::new();

        // Scan Rust dependencies with cargo audit
        let cargo_results = self
            .scan_cargo_dependencies()
            .context("Failed to scan Rust dependencies")?;
        for vuln in cargo_results {
            results.add_vulnerability(vuln);
        }

        // Scan Docker images if configured
        if self.config.scan_docker {
            if let Some(image) = &self.config.docker_image {
                let docker_results = self
                    .scan_docker_image(image)
                    .context("Failed to scan Docker image")?;
                for vuln in docker_results {
                    results.add_vulnerability(vuln);
                }
            }
        }

        Ok(results)
    }

    /// Scan Rust dependencies using cargo audit
    fn scan_cargo_dependencies(&self) -> Result<Vec<Vulnerability>> {
        // Check if cargo-audit is installed
        let check_output = Command::new("cargo")
            .args(["audit", "--version"])
            .output();

        if check_output.is_err() {
            log::warn!("cargo-audit not installed, skipping Rust dependency scan");
            return Ok(Vec::new());
        }

        // Run cargo audit with JSON output
        let output = Command::new("cargo")
            .args(["audit", "--json", "--deny", "warnings"])
            .current_dir(&self.config.project_root)
            .output()
            .context("Failed to execute cargo audit")?;

        self.parse_cargo_audit_output(&output)
    }

    /// Parse cargo audit JSON output
    fn parse_cargo_audit_output(&self, output: &Output) -> Result<Vec<Vulnerability>> {
        if output.stdout.is_empty() {
            return Ok(Vec::new());
        }

        let output_str = String::from_utf8_lossy(&output.stdout);
        let mut vulnerabilities = Vec::new();

        // Parse JSON output (cargo audit returns NDJSON)
        for line in output_str.lines() {
            if line.trim().is_empty() {
                continue;
            }

            // Parse JSON (simplified - in production, use proper JSON parsing)
            if line.contains("\"type\":\"warning\"") || line.contains("\"type\":\"vulnerability\"")
            {
                // Extract basic information (simplified parsing)
                // In production, use serde_json to properly parse the JSON
                let vuln = self.parse_cargo_audit_line(line)?;
                vulnerabilities.push(vuln);
            }
        }

        Ok(vulnerabilities)
    }

    /// Parse a single cargo audit line
    fn parse_cargo_audit_line(&self, _line: &str) -> Result<Vulnerability> {
        // Simplified parsing - in production, use proper JSON deserialization
        // This is a placeholder implementation
        Ok(Vulnerability {
            id: "RUSTSEC-XXXX-XXXX".to_string(),
            package: "example-crate".to_string(),
            version: "1.0.0".to_string(),
            severity: Severity::Medium,
            description: "Placeholder vulnerability".to_string(),
            url: Some("https://rustsec.org".to_string()),
            fixed_version: Some("1.0.1".to_string()),
        })
    }

    /// Scan Docker image using Trivy
    fn scan_docker_image(&self, image: &str) -> Result<Vec<Vulnerability>> {
        // Check if trivy is installed
        let check_output = Command::new("trivy").arg("--version").output();

        if check_output.is_err() {
            log::warn!("Trivy not installed, skipping Docker image scan");
            return Ok(Vec::new());
        }

        // Run trivy with JSON output
        let output = Command::new("trivy")
            .args(["image", "--format", "json", "--severity", "HIGH,CRITICAL", image])
            .output()
            .context("Failed to execute Trivy")?;

        self.parse_trivy_output(&output)
    }

    /// Parse Trivy JSON output
    fn parse_trivy_output(&self, output: &Output) -> Result<Vec<Vulnerability>> {
        if output.stdout.is_empty() {
            return Ok(Vec::new());
        }

        // Simplified parsing - in production, use proper JSON deserialization
        // This is a placeholder implementation
        Ok(Vec::new())
    }

    /// Generate SARIF output for GitHub Security
    pub fn generate_sarif(&self, results: &ScanResults) -> Result<String> {
        let sarif = SarifReport::from_scan_results(results);
        serde_json::to_string_pretty(&sarif).context("Failed to serialize SARIF report")
    }

    /// Write SARIF output to file
    pub fn write_sarif(&self, results: &ScanResults, output_path: &Path) -> Result<()> {
        let sarif = self.generate_sarif(results)?;
        std::fs::write(output_path, sarif)
            .context("Failed to write SARIF report to file")?;
        Ok(())
    }
}

/// SARIF (Static Analysis Results Interchange Format) report
#[derive(Debug, Serialize, Deserialize)]
struct SarifReport {
    version: String,
    #[serde(rename = "$schema")]
    schema: String,
    runs: Vec<SarifRun>,
}

impl SarifReport {
    /// Create SARIF report from scan results
    fn from_scan_results(results: &ScanResults) -> Self {
        let results_vec: Vec<SarifResult> = results
            .vulnerabilities
            .iter()
            .map(SarifResult::from_vulnerability)
            .collect();

        let run = SarifRun {
            tool: SarifTool {
                driver: SarifDriver {
                    name: "ggen-security-scanner".to_string(),
                    version: env!("CARGO_PKG_VERSION").to_string(),
                },
            },
            results: results_vec,
        };

        Self {
            version: "2.1.0".to_string(),
            schema:
                "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json"
                    .to_string(),
            runs: vec![run],
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifRun {
    tool: SarifTool,
    results: Vec<SarifResult>,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifTool {
    driver: SarifDriver,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifDriver {
    name: String,
    version: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifResult {
    #[serde(rename = "ruleId")]
    rule_id: String,
    level: String,
    message: SarifMessage,
    locations: Vec<SarifLocation>,
}

impl SarifResult {
    /// Create SARIF result from vulnerability
    fn from_vulnerability(vuln: &Vulnerability) -> Self {
        let level = match vuln.severity {
            Severity::Critical | Severity::High => "error",
            Severity::Medium => "warning",
            _ => "note",
        };

        Self {
            rule_id: vuln.id.clone(),
            level: level.to_string(),
            message: SarifMessage {
                text: format!("{}: {}", vuln.package, vuln.description),
            },
            locations: vec![SarifLocation {
                physical_location: SarifPhysicalLocation {
                    artifact_location: SarifArtifactLocation {
                        uri: "Cargo.lock".to_string(),
                    },
                },
            }],
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifMessage {
    text: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifLocation {
    #[serde(rename = "physicalLocation")]
    physical_location: SarifPhysicalLocation,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifPhysicalLocation {
    #[serde(rename = "artifactLocation")]
    artifact_location: SarifArtifactLocation,
}

#[derive(Debug, Serialize, Deserialize)]
struct SarifArtifactLocation {
    uri: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        // Arrange: Create severities in order
        let critical = Severity::Critical;
        let high = Severity::High;
        let medium = Severity::Medium;

        // Act & Assert: Verify ordering
        assert!(critical > high);
        assert!(high > medium);
    }

    #[test]
    fn test_severity_is_high_severity() {
        // Arrange: Create severities
        let critical = Severity::Critical;
        let high = Severity::High;
        let medium = Severity::Medium;
        let low = Severity::Low;

        // Act & Assert: Verify high severity detection
        assert!(critical.is_high_severity());
        assert!(high.is_high_severity());
        assert!(!medium.is_high_severity());
        assert!(!low.is_high_severity());
    }

    #[test]
    fn test_scan_results_add_vulnerability() {
        // Arrange: Create scan results and vulnerability
        let mut results = ScanResults::new();
        let vuln = Vulnerability {
            id: "CVE-2024-001".to_string(),
            package: "test-package".to_string(),
            version: "1.0.0".to_string(),
            severity: Severity::High,
            description: "Test vulnerability".to_string(),
            url: None,
            fixed_version: None,
        };

        // Act: Add vulnerability
        results.add_vulnerability(vuln);

        // Assert: Verify counts updated
        assert_eq!(results.high_count, 1);
        assert_eq!(results.total_count(), 1);
        assert!(results.has_high_severity());
    }

    #[test]
    fn test_scan_results_multiple_severities() {
        // Arrange: Create scan results
        let mut results = ScanResults::new();

        // Act: Add vulnerabilities with different severities
        results.add_vulnerability(Vulnerability {
            id: "CVE-2024-001".to_string(),
            package: "pkg1".to_string(),
            version: "1.0.0".to_string(),
            severity: Severity::Critical,
            description: "Critical issue".to_string(),
            url: None,
            fixed_version: None,
        });

        results.add_vulnerability(Vulnerability {
            id: "CVE-2024-002".to_string(),
            package: "pkg2".to_string(),
            version: "2.0.0".to_string(),
            severity: Severity::Medium,
            description: "Medium issue".to_string(),
            url: None,
            fixed_version: None,
        });

        // Assert: Verify counts
        assert_eq!(results.critical_count, 1);
        assert_eq!(results.medium_count, 1);
        assert_eq!(results.total_count(), 2);
        assert!(results.has_high_severity());
    }

    #[test]
    fn test_sarif_generation() {
        // Arrange: Create scan results with vulnerabilities
        let mut results = ScanResults::new();
        results.add_vulnerability(Vulnerability {
            id: "RUSTSEC-2024-001".to_string(),
            package: "vulnerable-crate".to_string(),
            version: "1.0.0".to_string(),
            severity: Severity::High,
            description: "Known vulnerability".to_string(),
            url: Some("https://rustsec.org/advisories/RUSTSEC-2024-001".to_string()),
            fixed_version: Some("1.0.1".to_string()),
        });

        // Act: Generate SARIF report
        let scanner = VulnerabilityScanner::new(ScanConfig::default());
        let sarif = scanner.generate_sarif(&results);

        // Assert: Verify SARIF generated successfully
        assert!(sarif.is_ok());
        let sarif_str = sarif.unwrap();
        assert!(sarif_str.contains("RUSTSEC-2024-001"));
        assert!(sarif_str.contains("vulnerable-crate"));
    }

    #[test]
    fn test_scan_config_default() {
        // Arrange & Act: Create default config
        let config = ScanConfig::default();

        // Assert: Verify default values
        assert_eq!(config.project_root, PathBuf::from("."));
        assert!(config.fail_on_high_severity);
        assert!(!config.scan_docker);
        assert!(config.docker_image.is_none());
    }
}
