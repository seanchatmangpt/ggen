// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use uuid::Uuid;
use tokio::sync::RwLock;

use crate::agent::{Agent, AgentConfiguration, AgentError, AgentPort, AgentStatus};
use crate::task::{Task, TaskError, TaskFilters, TaskPort, TaskResult, TaskStatus};
use crate::message::{Message, MessageError, MessageFilters, MessagePort, MessageId, MessagePriority};
use crate::port::{A2APort, A2AAdapter, SystemStatus, SystemOverallStatus, A2AError};

// ============================================================================
// HTTP ADAPTER IMPLEMENTATION
// ============================================================================

pub struct HttpAdapter {
    base_url: String,
    client: reqwest::Client,
    auth_token: Option<String>,
}

impl HttpAdapter {
    pub fn new(base_url: String, auth_token: Option<String>) -> Result<Self, A2AError> {
        let client = reqwest::Client::new();
        Ok(Self {
            base_url,
            client,
            auth_token,
        })
    }

    pub fn with_timeout(mut self, timeout: std::time::Duration) -> Result<Self, A2AError> {
        let client = reqwest::Client::builder()
            .timeout(timeout)
            .build()
            .map_err(|e| A2AError::ConfigurationError(e.to_string()))?;

        Self { client, ..self }
    }

    fn get_auth_header(&self) -> Option<reqwest::header::HeaderValue> {
        self.auth_token.as_ref().map(|token| {
            reqwest::header::HeaderValue::from_str(&format!("Bearer {}", token))
                .expect("Invalid auth token")
        })
    }

    async fn make_request<T: serde::Serialize>(
        &self,
        method: reqwest::Method,
        endpoint: &str,
        data: Option<T>,
    ) -> Result<reqwest::Response, A2AError> {
        let url = format!("{}{}", self.base_url, endpoint);
        let mut request = self.client.request(method, &url);

        // Add auth header if present
        if let Some(auth) = self.get_auth_header() {
            request = request.header(reqwest::header::AUTHORIZATION, auth);
        }

        // Add JSON data if present
        if let Some(data) = data {
            request = request.json(&data);
        }

        let response = request.send()
            .await
            .map_err(|e| A2AError::Network(e.to_string()))?;

        Ok(response)
    }
}

#[async_trait]
impl AgentPort for HttpAdapter {
    async fn start_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let endpoint = format!("/agents/{}/start", agent_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, None::<()>)
            .await
            .map_err(|e| AgentError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let status: AgentStatusResponse = response.json()
                .await
                .map_err(|e| AgentError::Serialization(e))?;
            Ok(status.status)
        } else {
            let error = response.json::<ErrorResponse>().await
                .map_err(|_| ErrorResponse::default());
            Err(AgentError::Communication(format!("Failed to start agent: {:?}", error)))
        }
    }

    async fn stop_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let endpoint = format!("/agents/{}/stop", agent_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, None::<()>)
            .await
            .map_err(|e| AgentError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let status: AgentStatusResponse = response.json()
                .await
                .map_err(|e| AgentError::Serialization(e))?;
            Ok(status.status)
        } else {
            Err(AgentError::Communication("Failed to stop agent".to_string()))
        }
    }

    async fn get_agent_status(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let endpoint = format!("/agents/{}/status", agent_id);
        let response = self.make_request(reqwest::Method::GET, &endpoint, None::<()>)
            .await
            .map_err(|e| AgentError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let status: AgentStatusResponse = response.json()
                .await
                .map_err(|e| AgentError::Serialization(e))?;
            Ok(status.status)
        } else {
            Err(AgentError::Communication(format!("Failed to get agent status: {}", agent_id)))
        }
    }

    async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
        let endpoint = "/agents";
        let response = self.make_request(reqwest::Method::GET, endpoint, None::<()>)
            .await
            .map_err(|e| AgentError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let agents: AgentListResponse = response.json()
                .await
                .map_err(|e| AgentError::Serialization(e))?;
            Ok(agents.agents)
        } else {
            Err(AgentError::Communication("Failed to list agents".to_string()))
        }
    }

    async fn update_agent_config(&self, agent_id: &str, config: AgentConfiguration) -> Result<Agent, AgentError> {
        let endpoint = format!("/agents/{}/config", agent_id);
        let response = self.make_request(reqwest::Method::PUT, &endpoint, Some(config))
            .await
            .map_err(|e| AgentError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let agent: AgentResponse = response.json()
                .await
                .map_err(|e| AgentError::Serialization(e))?;
            Ok(agent.agent)
        } else {
            Err(AgentError::Communication("Failed to update agent config".to_string()))
        }
    }
}

#[async_trait]
impl TaskPort for HttpAdapter {
    async fn create_task(&self, task: Task) -> Result<Task, TaskError> {
        let endpoint = "/tasks";
        let response = self.make_request(reqwest::Method::POST, endpoint, Some(task))
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::Communication("Failed to create task".to_string()))
        }
    }

    async fn get_task(&self, task_id: &str) -> Result<Task, TaskError> {
        let endpoint = format!("/tasks/{}", task_id);
        let response = self.make_request(reqwest::Method::GET, &endpoint, None::<()>)
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::NotFound(task_id.to_string()))
        }
    }

    async fn list_tasks(&self, filters: TaskFilters) -> Result<Vec<Task>, TaskError> {
        let endpoint = "/tasks";
        let response = self.make_request(reqwest::Method::GET, endpoint, Some(filters))
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let tasks_response: TaskListResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(tasks_response.tasks)
        } else {
            Err(TaskError::Communication("Failed to list tasks".to_string()))
        }
    }

    async fn update_task_status(&self, task_id: &str, status: TaskStatus) -> Result<Task, TaskError> {
        let endpoint = format!("/tasks/{}/status", task_id);
        let status_update = TaskStatusUpdate { status };
        let response = self.make_request(reqwest::Method::PUT, &endpoint, Some(status_update))
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::Communication("Failed to update task status".to_string()))
        }
    }

    async fn cancel_task(&self, task_id: &str) -> Result<Task, TaskError> {
        let endpoint = format!("/tasks/{}/cancel", task_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, None::<()>)
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::Communication("Failed to cancel task".to_string()))
        }
    }

    async fn assign_task(&self, task_id: &str, agent_id: &str) -> Result<Task, TaskError> {
        let endpoint = format!("/tasks/{}/assign", task_id);
        let assignment = TaskAssignment { agent_id: agent_id.to_string() };
        let response = self.make_request(reqwest::Method::POST, &endpoint, Some(assignment))
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::Communication("Failed to assign task".to_string()))
        }
    }

    async fn complete_task(&self, task_id: &str, result: TaskResult) -> Result<Task, TaskError> {
        let endpoint = format!("/tasks/{}/complete", task_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, Some(result))
            .await
            .map_err(|e| TaskError::Communication(e.to_string()))?;

        if response.status().is_success() {
            let task_response: TaskResponse = response.json()
                .await
                .map_err(|e| TaskError::Serialization(e))?;
            Ok(task_response.task)
        } else {
            Err(TaskError::Communication("Failed to complete task".to_string()))
        }
    }
}

#[async_trait]
impl MessagePort for HttpAdapter {
    async fn send_message(&self, message: Message) -> Result<MessageId, MessageError> {
        let endpoint = "/messages";
        let response = self.make_request(reqwest::Method::POST, endpoint, Some(message))
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            let message_response: MessageResponse = response.json()
                .await
                .map_err(|e| MessageError::Deserialization(e))?;
            Ok(message_response.message_id)
        } else {
            Err(MessageError::Network("Failed to send message".to_string()))
        }
    }

    async fn get_message(&self, message_id: &str) -> Result<Message, MessageError> {
        let endpoint = format!("/messages/{}", message_id);
        let response = self.make_request(reqwest::Method::GET, &endpoint, None::<()>)
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            let message_response: MessageResponse = response.json()
                .await
                .map_err(|e| MessageError::Deserialization(e))?;
            Ok(message_response.message)
        } else {
            Err(MessageError::NotFound(message_id.to_string()))
        }
    }

    async fn list_messages(&self, filters: MessageFilters) -> Result<Vec<Message>, MessageError> {
        let endpoint = "/messages";
        let response = self.make_request(reqwest::Method::GET, endpoint, Some(filters))
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            let messages_response: MessageListResponse = response.json()
                .await
                .map_err(|e| MessageError::Deserialization(e))?;
            Ok(messages_response.messages)
        } else {
            Err(MessageError::Network("Failed to list messages".to_string()))
        }
    }

    async fn reply_to_message(&self, original_id: &str, reply: Message) -> Result<MessageId, MessageError> {
        let endpoint = format!("/messages/{}/reply", original_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, Some(reply))
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            let message_response: MessageResponse = response.json()
                .await
                .map_err(|e| MessageError::Deserialization(e))?;
            Ok(message_response.message_id)
        } else {
            Err(MessageError::Network("Failed to reply to message".to_string()))
        }
    }

    async fn broadcast_message(&self, message: Message, recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
        let endpoint = "/messages/broadcast";
        let broadcast = MessageBroadcast { message, recipients };
        let response = self.make_request(reqwest::Method::POST, endpoint, Some(broadcast))
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            let broadcast_response: MessageBroadcastResponse = response.json()
                .await
                .map_err(|e| MessageError::Deserialization(e))?;
            Ok(broadcast_response.message_ids)
        } else {
            Err(MessageError::Network("Failed to broadcast message".to_string()))
        }
    }

    async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessageError> {
        let endpoint = format!("/messages/{}/acknowledge", message_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, None::<()>)
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(MessageError::Network("Failed to acknowledge message".to_string()))
        }
    }

    async fn reject_message(&self, message_id: &str, reason: String) -> Result<(), MessageError> {
        let endpoint = format!("/messages/{}/reject", message_id);
        let rejection = MessageRejection { reason };
        let response = self.make_request(reqwest::Method::POST, &endpoint, Some(rejection))
            .await
            .map_err(|e| MessageError::Network(e.to_string()))?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(MessageError::Network("Failed to reject message".to_string()))
        }
    }
}

#[async_trait]
impl A2APort for HttpAdapter {
    async fn initialize_system(&self) -> Result<SystemStatus, A2AError> {
        let endpoint = "/system/initialize";
        let response = self.make_request(reqwest::Method::POST, endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            let status_response: SystemStatusResponse = response.json()
                .await
                .map_err(|e| A2AError::Serialization(e))?;
            Ok(status_response.status)
        } else {
            Err(A2AError::SystemError("Failed to initialize system".to_string()))
        }
    }

    async fn shutdown_system(&self) -> Result<(), A2AError> {
        let endpoint = "/system/shutdown";
        let response = self.make_request(reqwest::Method::POST, endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(A2AError::SystemError("Failed to shutdown system".to_string()))
        }
    }

    async fn get_system_status(&self) -> Result<SystemStatus, A2AError> {
        let endpoint = "/system/status";
        let response = self.make_request(reqwest::Method::GET, endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            let status_response: SystemStatusResponse = response.json()
                .await
                .map_err(|e| A2AError::Serialization(e))?;
            Ok(status_response.status)
        } else {
            Err(A2AError::SystemError("Failed to get system status".to_string()))
        }
    }

    async fn health_check(&self) -> Result<crate::port::HealthStatus, A2AError> {
        let endpoint = "/system/health";
        let response = self.make_request(reqwest::Method::GET, endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            let health_response: HealthStatusResponse = response.json()
                .await
                .map_err(|e| A2AError::Serialization(e))?;
            Ok(health_response.health)
        } else {
            Err(A2AError::SystemError("Failed to perform health check".to_string()))
        }
    }

    async fn backup_state(&self) -> Result<crate::port::BackupInfo, A2AError> {
        let endpoint = "/system/backup";
        let response = self.make_request(reqwest::Method::POST, endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            let backup_response: BackupInfoResponse = response.json()
                .await
                .map_err(|e| A2AError::Serialization(e))?;
            Ok(backup_response.backup)
        } else {
            Err(A2AError::SystemError("Failed to create backup".to_string()))
        }
    }

    async fn restore_state(&self, backup_id: &str) -> Result<(), A2AError> {
        let endpoint = format!("/system/restore/{}", backup_id);
        let response = self.make_request(reqwest::Method::POST, &endpoint, None::<()>)
            .await
            .map_err(|e| A2AError::SystemError(e.to_string()))?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(A2AError::SystemError("Failed to restore state".to_string()))
        }
    }
}

// ============================================================================
// RESPONSE TYPES
// ============================================================================

#[derive(Debug, Deserialize)]
struct AgentStatusResponse {
    status: AgentStatus,
}

#[derive(Debug, Deserialize)]
struct AgentListResponse {
    agents: Vec<Agent>,
}

#[derive(Debug, Deserialize)]
struct AgentResponse {
    agent: Agent,
}

#[derive(Debug, Deserialize)]
struct TaskResponse {
    task: Task,
}

#[derive(Debug, Deserialize)]
struct TaskListResponse {
    tasks: Vec<Task>,
}

#[derive(Debug, Serialize)]
struct TaskStatusUpdate {
    status: TaskStatus,
}

#[derive(Debug, Serialize)]
struct TaskAssignment {
    agent_id: String,
}

#[derive(Debug, Deserialize)]
struct MessageResponse {
    message_id: MessageId,
    message: Message,
}

#[derive(Debug, Deserialize)]
struct MessageListResponse {
    messages: Vec<Message>,
}

#[derive(Debug, Serialize)]
struct MessageBroadcast {
    message: Message,
    recipients: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct MessageBroadcastResponse {
    message_ids: Vec<MessageId>,
}

#[derive(Debug, Serialize)]
struct MessageRejection {
    reason: String,
}

#[derive(Debug, Deserialize)]
struct SystemStatusResponse {
    status: SystemStatus,
}

#[derive(Debug, Deserialize)]
struct HealthStatusResponse {
    health: crate::port::HealthStatus,
}

#[derive(Debug, Deserialize)]
struct BackupInfoResponse {
    backup: crate::port::BackupInfo,
}

#[derive(Debug, Default, Deserialize)]
struct ErrorResponse {
    error: String,
    message: String,
}

// ============================================================================
// MEMORY-BASED ADAPTER IMPLEMENTATION
// ============================================================================

pub struct MemoryAdapter {
    agents: RwLock<HashMap<String, Agent>>,
    tasks: RwLock<HashMap<String, Task>>,
    messages: RwLock<HashMap<String, Message>>,
    system_status: RwLock<SystemStatus>,
}

impl MemoryAdapter {
    pub fn new() -> Self {
        Self {
            agents: RwLock::new(HashMap::new()),
            tasks: RwLock::new(HashMap::new()),
            messages: RwLock::new(HashMap::new()),
            system_status: RwLock::new(SystemStatus::default()),
        }
    }

    pub async fn add_agent(&self, agent: Agent) {
        let mut agents = self.agents.write().await;
        agents.insert(agent.id.clone(), agent);
    }

    pub async fn add_task(&self, task: Task) {
        let mut tasks = self.tasks.write().await;
        tasks.insert(task.id.clone(), task);
    }

    pub async fn add_message(&self, message: Message) {
        let mut messages = self.messages.write().await;
        messages.insert(message.id.clone(), message);
    }
}

impl Default for MemoryAdapter {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl AgentPort for MemoryAdapter {
    async fn start_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let mut agents = self.agents.write().await;
        if let Some(agent) = agents.get_mut(agent_id) {
            agent.update_status(AgentStatus::Running);
            Ok(AgentStatus::Running)
        } else {
            Err(AgentError::agent_not_found(agent_id))
        }
    }

    async fn stop_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let mut agents = self.agents.write().await;
        if let Some(agent) = agents.get_mut(agent_id) {
            agent.update_status(AgentStatus::Stopped);
            Ok(AgentStatus::Stopped)
        } else {
            Err(AgentError::agent_not_found(agent_id))
        }
    }

    async fn get_agent_status(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        let agents = self.agents.read().await;
        agents.get(agent_id)
            .map(|agent| agent.status.clone())
            .ok_or_else(|| AgentError::agent_not_found(agent_id))
    }

    async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
        let agents = self.agents.read().await;
        Ok(agents.values().cloned().collect())
    }

    async fn update_agent_config(&self, agent_id: &str, config: AgentConfiguration) -> Result<Agent, AgentError> {
        let mut agents = self.agents.write().await;
        if let Some(agent) = agents.get_mut(agent_id) {
            agent.configuration = config;
            agent.update_status(AgentStatus::Idle);
            Ok(agent.clone())
        } else {
            Err(AgentError::agent_not_found(agent_id))
        }
    }
}

#[async_trait]
impl TaskPort for MemoryAdapter {
    async fn create_task(&self, task: Task) -> Result<Task, TaskError> {
        let mut tasks = self.tasks.write().await;
        tasks.insert(task.id.clone(), task.clone());
        Ok(task)
    }

    async fn get_task(&self, task_id: &str) -> Result<Task, TaskError> {
        let tasks = self.tasks.read().await;
        tasks.get(task_id)
            .cloned()
            .ok_or_else(|| TaskError::task_not_found(task_id))
    }

    async fn list_tasks(&self, _filters: TaskFilters) -> Result<Vec<Task>, TaskError> {
        let tasks = self.tasks.read().await;
        Ok(tasks.values().cloned().collect())
    }

    async fn update_task_status(&self, task_id: &str, status: TaskStatus) -> Result<Task, TaskError> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = status.clone();
            Ok(task.clone())
        } else {
            Err(TaskError::task_not_found(task_id))
        }
    }

    async fn cancel_task(&self, task_id: &str) -> Result<Task, TaskError> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = TaskStatus::Cancelled;
            Ok(task.clone())
        } else {
            Err(TaskError::task_not_found(task_id))
        }
    }

    async fn assign_task(&self, task_id: &str, agent_id: &str) -> Result<Task, TaskError> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.assignee = Some(agent_id.to_string());
            Ok(task.clone())
        } else {
            Err(TaskError::task_not_found(task_id))
        }
    }

    async fn complete_task(&self, task_id: &str, result: TaskResult) -> Result<Task, TaskError> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = TaskStatus::Completed;
            task.result = Some(result);
            Ok(task.clone())
        } else {
            Err(TaskError::task_not_found(task_id))
        }
    }
}

#[async_trait]
impl MessagePort for MemoryAdapter {
    async fn send_message(&self, message: Message) -> Result<MessageId, MessageError> {
        let mut messages = self.messages.write().await;
        messages.insert(message.id.clone(), message);
        Ok(MessageId(message.id))
    }

    async fn get_message(&self, message_id: &str) -> Result<Message, MessageError> {
        let messages = self.messages.read().await;
        messages.get(message_id)
            .cloned()
            .ok_or_else(|| MessageError::message_not_found(message_id))
    }

    async fn list_messages(&self, _filters: MessageFilters) -> Result<Vec<Message>, MessageError> {
        let messages = self.messages.read().await;
        Ok(messages.values().cloned().collect())
    }

    async fn reply_to_message(&self, original_id: &str, reply: Message) -> Result<MessageId, MessageError> {
        let mut messages = self.messages.write().await;
        messages.insert(reply.id.clone(), reply);
        Ok(MessageId(reply.id))
    }

    async fn broadcast_message(&self, message: Message, _recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
        let mut messages = self.messages.write().await;
        messages.insert(message.id.clone(), message);
        Ok(vec![MessageId(message.id)])
    }

    async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessageError> {
        let mut messages = self.messages.write().await;
        if messages.contains_key(message_id) {
            Ok(())
        } else {
            Err(MessageError::message_not_found(message_id))
        }
    }

    async fn reject_message(&self, message_id: &str, _reason: String) -> Result<(), MessageError> {
        let mut messages = self.messages.write().await;
        if messages.contains_key(message_id) {
            Ok(())
        } else {
            Err(MessageError::message_not_found(message_id))
        }
    }
}

#[async_trait]
impl A2APort for MemoryAdapter {
    async fn initialize_system(&self) -> Result<SystemStatus, A2AError> {
        let mut status = self.system_status.write().await;
        status.overall_status = SystemOverallStatus::Healthy;
        Ok(status.clone())
    }

    async fn shutdown_system(&self) -> Result<(), A2AError> {
        let mut status = self.system_status.write().await;
        status.overall_status = SystemOverallStatus::Maintenance;
        Ok(())
    }

    async fn get_system_status(&self) -> Result<SystemStatus, A2AError> {
        let status = self.system_status.read().await;
        Ok(status.clone())
    }

    async fn health_check(&self) -> Result<crate::port::HealthStatus, A2AError> {
        Ok(crate::port::HealthStatus::default())
    }

    async fn backup_state(&self) -> Result<crate::port::BackupInfo, A2AError> {
        let agents = self.agents.read().await;
        let tasks = self.tasks.read().await;
        let messages = self.messages.read().await;

        let backup = BackupInfo {
            agents_count: agents.len(),
            tasks_count: tasks.len(),
            messages_count: messages.len(),
            ..BackupInfo::default()
        };
        Ok(backup)
    }

    async fn restore_state(&self, _backup_id: &str) -> Result<(), A2AError> {
        // In-memory adapter doesn't persist state, so this is a no-op
        Ok(())
    }
}