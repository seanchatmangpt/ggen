// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use uuid::Uuid;

// ============================================================================
// A2A PORT TRAIT IMPLEMENTATIONS
// ============================================================================

use crate::agent::{Agent, AgentError, AgentPort, AgentStatus};
use crate::task::{Task, TaskError, TaskPort, TaskStatus};
use crate::message::{Message, MessageError, MessagePort, MessageId};

// ============================================================================
// COMBINED PORT TRAIT
// ============================================================================

#[async_trait]
pub trait A2APort: AgentPort + TaskPort + MessagePort + Send + Sync {
    // A2A-specific operations that cross-cut multiple domains
    async fn initialize_system(&self) -> Result<SystemStatus, A2AError>;
    async fn shutdown_system(&self) -> Result<(), A2AError>;
    async fn get_system_status(&self) -> Result<SystemStatus, A2AError>;
    async fn health_check(&self) -> Result<HealthStatus, A2AError>;
    async fn backup_state(&self) -> Result<BackupInfo, A2AError>;
    async fn restore_state(&self, backup_id: &str) -> Result<(), A2AError>;
}

// ============================================================================
// A2A ADAPTER
// ============================================================================

pub struct A2AAdapter {
    agent_port: Box<dyn AgentPort + Send + Sync>,
    task_port: Box<dyn TaskPort + Send + Sync>,
    message_port: Box<dyn MessagePort + Send + Sync>,
    system_port: Box<dyn A2APort + Send + Sync>,
}

impl A2AAdapter {
    pub fn new(system_port: Box<dyn A2APort + Send + Sync>) -> Self {
        Self {
            agent_port: system_port.clone(),
            task_port: system_port.clone(),
            message_port: system_port.clone(),
            system_port,
        }
    }

    // Agent operations delegate to agent_port
    pub async fn start_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.agent_port.start_agent(agent_id).await
    }

    pub async fn stop_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.agent_port.stop_agent(agent_id).await
    }

    pub async fn get_agent_status(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.agent_port.get_agent_status(agent_id).await
    }

    pub async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
        self.agent_port.list_agents().await
    }

    pub async fn update_agent_config(&self, agent_id: &str, config: crate::agent::AgentConfiguration) -> Result<Agent, AgentError> {
        self.agent_port.update_agent_config(agent_id, config).await
    }

    // Task operations delegate to task_port
    pub async fn create_task(&self, task: Task) -> Result<Task, TaskError> {
        self.task_port.create_task(task).await
    }

    pub async fn get_task(&self, task_id: &str) -> Result<Task, TaskError> {
        self.task_port.get_task(task_id).await
    }

    pub async fn list_tasks(&self, filters: crate::task::TaskFilters) -> Result<Vec<Task>, TaskError> {
        self.task_port.list_tasks(filters).await
    }

    pub async fn update_task_status(&self, task_id: &str, status: TaskStatus) -> Result<Task, TaskError> {
        self.task_port.update_task_status(task_id, status).await
    }

    pub async fn cancel_task(&self, task_id: &str) -> Result<Task, TaskError> {
        self.task_port.cancel_task(task_id).await
    }

    pub async fn assign_task(&self, task_id: &str, agent_id: &str) -> Result<Task, TaskError> {
        self.task_port.assign_task(task_id, agent_id).await
    }

    pub async fn complete_task(&self, task_id: &str, result: crate::task::TaskResult) -> Result<Task, TaskError> {
        self.task_port.complete_task(task_id, result).await
    }

    // Message operations delegate to message_port
    pub async fn send_message(&self, message: Message) -> Result<MessageId, MessageError> {
        self.message_port.send_message(message).await
    }

    pub async fn get_message(&self, message_id: &str) -> Result<Message, MessageError> {
        self.message_port.get_message(message_id).await
    }

    pub async fn list_messages(&self, filters: crate::message::MessageFilters) -> Result<Vec<Message>, MessageError> {
        self.message_port.list_messages(filters).await
    }

    pub async fn reply_to_message(&self, original_id: &str, reply: Message) -> Result<MessageId, MessageError> {
        self.message_port.reply_to_message(original_id, reply).await
    }

    pub async fn broadcast_message(&self, message: Message, recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
        self.message_port.broadcast_message(message, recipients).await
    }

    pub async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessageError> {
        self.message_port.acknowledge_message(message_id).await
    }

    pub async fn reject_message(&self, message_id: &str, reason: String) -> Result<(), MessageError> {
        self.message_port.reject_message(message_id, reason).await
    }

    // System operations delegate to system_port
    pub async fn initialize_system(&self) -> Result<SystemStatus, A2AError> {
        self.system_port.initialize_system().await
    }

    pub async fn shutdown_system(&self) -> Result<(), A2AError> {
        self.system_port.shutdown_system().await
    }

    pub async fn get_system_status(&self) -> Result<SystemStatus, A2AError> {
        self.system_port.get_system_status().await
    }

    pub async fn health_check(&self) -> Result<HealthStatus, A2AError> {
        self.system_port.health_check().await
    }

    pub async fn backup_state(&self) -> Result<BackupInfo, A2AError> {
        self.system_port.backup_state().await
    }

    pub async fn restore_state(&self, backup_id: &str) -> Result<(), A2AError> {
        self.system_port.restore_state(backup_id).await
    }

    // A2A-specific workflows that coordinate multiple domains
    pub async fn execute_agent_task(&self, agent_id: &str, task: Task) -> Result<Task, A2AError> {
        // Step 1: Start the agent
        let agent_status = self.start_agent(agent_id).await
            .map_err(|e| A2AError::AgentError(e.to_string()))?;

        if agent_status != AgentStatus::Idle {
            return Err(A2AError::AgentNotReady(format!("Agent {} is not idle", agent_id)));
        }

        // Step 2: Assign task to agent
        let assigned_task = self.assign_task(task.id.as_str(), agent_id).await
            .map_err(|e| A2AError::TaskError(e.to_string()))?;

        // Step 3: Start task execution
        let started_task = self.update_task_status(assigned_task.id.as_str(), TaskStatus::Running).await
            .map_err(|e| A2AError::TaskError(e.to_string()))?;

        // Step 4: Monitor task completion
        let completed_task = self.monitor_task_completion(&started_task).await?;

        Ok(completed_task)
    }

    pub async fn send_agent_message(&self, agent_id: &str, message: Message) -> Result<MessageId, A2AError> {
        // Check if agent is available
        let agent_status = self.get_agent_status(agent_id).await
            .map_err(|e| A2AError::AgentError(e.to_string()))?;

        if agent_status == AgentStatus::Stopped {
            return Err(A2AError::AgentNotReady(format!("Agent {} is stopped", agent_id)));
        }

        // Send message to agent
        self.send_message(message).await
            .map_err(|e| A2AError::MessageError(e.to_string()))
    }

    async fn monitor_task_completion(&self, task: &Task) -> Result<Task, A2AError> {
        let mut current_task = task.clone();

        loop {
            // Update task status
            current_task = self.get_task(current_task.id.as_str()).await
                .map_err(|e| A2AError::TaskError(e.to_string()))?;

            match current_task.status {
                TaskStatus::Completed => return Ok(current_task),
                TaskStatus::Failed(error) => return Err(A2AError::TaskFailed(error)),
                TaskStatus::Cancelled => return Err(A2AError::TaskCancelled),
                _ => {
                    // Wait a bit before checking again
                    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                }
            }
        }
    }
}

// ============================================================================
// SYSTEM STATUS TYPES
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemStatus {
    pub overall_status: SystemOverallStatus,
    pub agents: Vec<AgentStatusSummary>,
    pub tasks: Vec<TaskStatusSummary>,
    pub messages: MessageStatusSummary,
    pub uptime: chrono::Duration,
    pub version: String,
    pub features: Vec<String>,
    pub metrics: SystemMetrics,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SystemOverallStatus {
    Healthy,
    Degraded,
    Unhealthy,
    Maintenance,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentStatusSummary {
    pub agent_id: String,
    pub name: String,
    pub status: AgentStatus,
    pub capabilities: Vec<String>,
    pub last_activity: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskStatusSummary {
    pub task_id: String,
    pub name: String,
    pub status: TaskStatus,
    pub priority: crate::task::TaskPriority,
    pub assignee: Option<String>,
    pub progress: f64,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageStatusSummary {
    pub total_sent: u64,
    pub total_received: u64,
    pub pending: u64,
    pub failed: u64,
    pub avg_latency_ms: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemMetrics {
    pub cpu_usage_percent: f64,
    pub memory_usage_percent: f64,
    pub disk_usage_percent: f64,
    pub network_io_bytes: u64,
    pub active_connections: u32,
    pub tasks_per_second: f64,
    pub messages_per_second: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthStatus {
    pub status: HealthCheckStatus,
    pub checks: Vec<HealthCheck>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub next_check: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum HealthCheckStatus {
    Healthy,
    Warning,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub name: String,
    pub status: HealthCheckStatus,
    pub message: String,
    pub details: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackupInfo {
    pub backup_id: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub size_bytes: u64,
    pub agents_count: usize,
    pub tasks_count: usize,
    pub messages_count: usize,
    pub checksum: String,
}

// ============================================================================
// A2A ERROR TYPES
// ============================================================================

#[derive(Debug, thiserror::Error)]
pub enum A2AError {
    #[error("Agent error: {0}")]
    AgentError(String),

    #[error("Task error: {0}")]
    TaskError(String),

    #[error("Message error: {0}")]
    MessageError(String),

    #[error("Agent not ready: {0}")]
    AgentNotReady(String),

    #[error("Task failed: {0}")]
    TaskFailed(String),

    #[error("Task cancelled")]
    TaskCancelled,

    #[error("System error: {0}")]
    SystemError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),

    #[error("Configuration error: {0}")]
    ConfigurationError(String),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("UUID generation error: {0}")]
    Uuid(#[from] uuid::Error),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Timeout error: {0}")]
    Timeout(String),
}

impl A2AError {
    pub fn system_error(message: String) -> Self {
        A2AError::SystemError(message)
    }

    pub fn communication_error(message: String) -> Self {
        A2AError::CommunicationError(message)
    }

    pub fn configuration_error(message: String) -> Self {
        A2AError::ConfigurationError(message)
    }
}

// ============================================================================
// DEFAULT IMPLEMENTATIONS
// ============================================================================

impl Default for SystemOverallStatus {
    fn default() -> Self {
        SystemOverallStatus::Healthy
    }
}

impl Default for HealthCheckStatus {
    fn default() -> Self {
        HealthCheckStatus::Healthy
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_a2a_adapter_creation() {
        // Mock implementations for testing
        struct MockAgentPort;
        #[async_trait]
        impl AgentPort for MockAgentPort {
            async fn start_agent(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Idle)
            }
            async fn stop_agent(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Stopped)
            }
            async fn get_agent_status(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Idle)
            }
            async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
                Ok(Vec::new())
            }
            async fn update_agent_config(&self, _agent_id: &str, _config: crate::agent::AgentConfiguration) -> Result<Agent, AgentError> {
                Ok(Agent::default())
            }
        }

        struct MockTaskPort;
        #[async_trait]
        impl TaskPort for MockTaskPort {
            async fn create_task(&self, _task: Task) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn get_task(&self, _task_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn list_tasks(&self, _filters: crate::task::TaskFilters) -> Result<Vec<Task>, TaskError> {
                Ok(Vec::new())
            }
            async fn update_task_status(&self, _task_id: &str, _status: TaskStatus) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn cancel_task(&self, _task_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn assign_task(&self, _task_id: &str, _agent_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn complete_task(&self, _task_id: &str, _result: crate::task::TaskResult) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
        }

        struct MockMessagePort;
        #[async_trait]
        impl MessagePort for MockMessagePort {
            async fn send_message(&self, _message: Message) -> Result<MessageId, MessageError> {
                Ok(MessageId(Uuid::new_v4().to_string()))
            }
            async fn get_message(&self, _message_id: &str) -> Result<Message, MessageError> {
                Ok(Message::default())
            }
            async fn list_messages(&self, _filters: crate::message::MessageFilters) -> Result<Vec<Message>, MessageError> {
                Ok(Vec::new())
            }
            async fn reply_to_message(&self, _original_id: &str, _reply: Message) -> Result<MessageId, MessageError> {
                Ok(MessageId(Uuid::new_v4().to_string()))
            }
            async fn broadcast_message(&self, _message: Message, _recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
                Ok(Vec::new())
            }
            async fn acknowledge_message(&self, _message_id: &str) -> Result<(), MessageError> {
                Ok(())
            }
            async fn reject_message(&self, _message_id: &str, _reason: String) -> Result<(), MessageError> {
                Ok(())
            }
        }

        struct MockA2APort;
        #[async_trait]
        impl A2APort for MockA2APort {
            async fn initialize_system(&self) -> Result<SystemStatus, A2AError> {
                Ok(SystemStatus::default())
            }
            async fn shutdown_system(&self) -> Result<(), A2AError> {
                Ok(())
            }
            async fn get_system_status(&self) -> Result<SystemStatus, A2AError> {
                Ok(SystemStatus::default())
            }
            async fn health_check(&self) -> Result<HealthStatus, A2AError> {
                Ok(HealthStatus::default())
            }
            async fn backup_state(&self) -> Result<BackupInfo, A2AError> {
                Ok(BackupInfo::default())
            }
            async fn restore_state(&self, _backup_id: &str) -> Result<(), A2AError> {
                Ok(())
            }
        }

        #[async_trait]
        impl AgentPort for MockA2APort {
            async fn start_agent(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Idle)
            }
            async fn stop_agent(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Stopped)
            }
            async fn get_agent_status(&self, _agent_id: &str) -> Result<AgentStatus, AgentError> {
                Ok(AgentStatus::Idle)
            }
            async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
                Ok(Vec::new())
            }
            async fn update_agent_config(&self, _agent_id: &str, _config: crate::agent::AgentConfiguration) -> Result<Agent, AgentError> {
                Ok(Agent::default())
            }
        }

        #[async_trait]
        impl TaskPort for MockA2APort {
            async fn create_task(&self, _task: Task) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn get_task(&self, _task_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn list_tasks(&self, _filters: crate::task::TaskFilters) -> Result<Vec<Task>, TaskError> {
                Ok(Vec::new())
            }
            async fn update_task_status(&self, _task_id: &str, _status: TaskStatus) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn cancel_task(&self, _task_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn assign_task(&self, _task_id: &str, _agent_id: &str) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
            async fn complete_task(&self, _task_id: &str, _result: crate::task::TaskResult) -> Result<Task, TaskError> {
                Ok(Task::default())
            }
        }

        #[async_trait]
        impl MessagePort for MockA2APort {
            async fn send_message(&self, _message: Message) -> Result<MessageId, MessageError> {
                Ok(MessageId(Uuid::new_v4().to_string()))
            }
            async fn get_message(&self, _message_id: &str) -> Result<Message, MessageError> {
                Ok(Message::default())
            }
            async fn list_messages(&self, _filters: crate::message::MessageFilters) -> Result<Vec<Message>, MessageError> {
                Ok(Vec::new())
            }
            async fn reply_to_message(&self, _original_id: &str, _reply: Message) -> Result<MessageId, MessageError> {
                Ok(MessageId(Uuid::new_v4().to_string()))
            }
            async fn broadcast_message(&self, _message: Message, _recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
                Ok(Vec::new())
            }
            async fn acknowledge_message(&self, _message_id: &str) -> Result<(), MessageError> {
                Ok(())
            }
            async fn reject_message(&self, _message_id: &str, _reason: String) -> Result<(), MessageError> {
                Ok(())
            }
        }

        let adapter = A2AAdapter::new(Box::new(MockA2APort));
        let status = adapter.get_system_status().await;
        assert!(status.is_ok());
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageId(String);

impl MessageId {
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl Default for SystemStatus {
    fn default() -> Self {
        Self {
            overall_status: SystemOverallStatus::Healthy,
            agents: Vec::new(),
            tasks: Vec::new(),
            messages: MessageStatusSummary::default(),
            uptime: chrono::Duration::zero(),
            version: "1.0.0".to_string(),
            features: vec!["agents".to_string(), "tasks".to_string(), "messages".to_string()],
            metrics: SystemMetrics::default(),
        }
    }
}

impl Default for MessageStatusSummary {
    fn default() -> Self {
        Self {
            total_sent: 0,
            total_received: 0,
            pending: 0,
            failed: 0,
            avg_latency_ms: 0.0,
        }
    }
}

impl Default for SystemMetrics {
    fn default() -> Self {
        Self {
            cpu_usage_percent: 0.0,
            memory_usage_percent: 0.0,
            disk_usage_percent: 0.0,
            network_io_bytes: 0,
            active_connections: 0,
            tasks_per_second: 0.0,
            messages_per_second: 0.0,
        }
    }
}

impl Default for HealthStatus {
    fn default() -> Self {
        Self {
            status: HealthCheckStatus::Healthy,
            checks: Vec::new(),
            timestamp: chrono::Utc::now(),
            next_check: chrono::Utc::now() + chrono::Duration::minutes(5),
        }
    }
}

impl Default for BackupInfo {
    fn default() -> Self {
        Self {
            backup_id: Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now(),
            size_bytes: 0,
            agents_count: 0,
            tasks_count: 0,
            messages_count: 0,
            checksum: String::new(),
        }
    }
}