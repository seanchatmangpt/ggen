// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use uuid::Uuid;

// ============================================================================
// TASK DOMAIN TYPES
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    pub id: String,
    pub name: String,
    pub description: String,
    pub task_type: TaskType,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub assignee: Option<String>,  // Agent ID
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub scheduled_at: Option<chrono::DateTime<chrono::Utc>>,
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deadline: Option<chrono::DateTime<chrono::Utc>>,
    pub dependencies: Vec<String>,  // Task IDs
    pub payload: TaskPayload,
    pub result: Option<TaskResult>,
    pub progress: f64, // 0.0 to 1.0
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TaskType {
    PlainText,
    CodeGeneration,
    DataAnalysis,
    Workflow,
    Custom(String),
}

impl Default for TaskType {
    fn default() -> Self {
        TaskType::PlainText
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TaskPriority {
    Low,
    Normal,
    High,
    Critical,
}

impl Default for TaskPriority {
    fn default() -> Self {
        TaskPriority::Normal
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TaskStatus {
    Pending,
    Scheduled,
    Running,
    Completed,
    Failed(String),
    Cancelled,
    Timeout,
}

impl Default for TaskStatus {
    fn default() -> Self {
        TaskStatus::Pending
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskPayload {
    pub content: String,
    pub format: PayloadFormat,
    pub attachments: Vec<Attachment>,
    pub context: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PayloadFormat {
    Text,
    Json,
    Xml,
    Yaml,
    Markdown,
    Custom(String),
}

impl Default for PayloadFormat {
    fn default() -> Self {
        PayloadFormat::Text
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attachment {
    pub id: String,
    pub name: String,
    pub content_type: String,
    pub size: u64,
    pub content: Vec<u8>,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskResult {
    pub id: String,
    pub task_id: String,
    pub status: TaskStatus,
    pub output: ResultOutput,
    pub metrics: TaskMetrics,
    pub artifacts: Vec<Artifact>,
    pub completed_at: chrono::DateTime<chrono::Utc>,
    pub error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResultOutput {
    Text(String),
    Json(serde_json::Value),
    Binary(Vec<u8>),
    None,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskMetrics {
    pub execution_time_ms: u64,
    pub cpu_time_ms: u64,
    pub memory_usage_bytes: u64,
    pub output_size_bytes: u64,
    pub retry_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Artifact {
    pub id: String,
    pub name: String,
    pub artifact_type: String,
    pub content: Vec<u8>,
    pub metadata: HashMap<String, serde_json::Value>,
}

// ============================================================================
// TASK PORT TRAIT
// ============================================================================

#[async_trait]
pub trait TaskPort {
    fn create_task(&self, task: Task) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
    fn get_task(&self, task_id: &str) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
    fn list_tasks(&self, filters: TaskFilters) -> impl std::future::Future<Output = Result<Vec<Task>, TaskError>> + Send;
    fn update_task_status(&self, task_id: &str, status: TaskStatus) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
    fn cancel_task(&self, task_id: &str) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
    fn assign_task(&self, task_id: &str, agent_id: &str) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
    fn complete_task(&self, task_id: &str, result: TaskResult) -> impl std::future::Future<Output = Result<Task, TaskError>> + Send;
}

// ============================================================================
// TASK ADAPTER
// ============================================================================

pub struct TaskAdapter {
    tasks: HashMap<String, Task>,
    port: Box<dyn TaskPort + Send + Sync>,
}

impl TaskAdapter {
    pub fn new(port: Box<dyn TaskPort + Send + Sync>) -> Self {
        Self {
            tasks: HashMap::new(),
            port,
        }
    }

    pub async fn initialize(&mut self) -> Result<(), TaskError> {
        let tasks = self.port.list_tasks(TaskFilters::default()).await?;
        for task in tasks {
            self.tasks.insert(task.id.clone(), task);
        }
        Ok(())
    }

    pub async fn create_task(&mut self, task: Task) -> Result<Task, TaskError> {
        let created_task = self.port.create_task(task).await?;
        self.tasks.insert(created_task.id.clone(), created_task.clone());
        Ok(created_task)
    }

    pub async fn get_task(&self, task_id: &str) -> Result<Task, TaskError> {
        self.port.get_task(task_id).await
    }

    pub async fn list_tasks(&self, filters: TaskFilters) -> Result<Vec<Task>, TaskError> {
        let tasks = self.port.list_tasks(filters).await?;
        Ok(tasks)
    }

    pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> Result<Task, TaskError> {
        let updated_task = self.port.update_task_status(task_id, status).await?;
        self.tasks.insert(task_id.to_string(), updated_task.clone());
        Ok(updated_task)
    }

    pub async fn cancel_task(&mut self, task_id: &str) -> Result<Task, TaskError> {
        let cancelled_task = self.port.cancel_task(task_id).await?;
        self.tasks.insert(task_id.to_string(), cancelled_task.clone());
        Ok(cancelled_task)
    }

    pub async fn assign_task(&mut self, task_id: &str, agent_id: &str) -> Result<Task, TaskError> {
        let assigned_task = self.port.assign_task(task_id, agent_id).await?;
        self.tasks.insert(task_id.to_string(), assigned_task.clone());
        Ok(assigned_task)
    }

    pub async fn complete_task(&mut self, task_id: &str, result: TaskResult) -> Result<Task, TaskError> {
        let completed_task = self.port.complete_task(task_id, result).await?;
        self.tasks.insert(task_id.to_string(), completed_task.clone());
        Ok(completed_task)
    }

    pub fn get_task(&self, task_id: &str) -> Option<&Task> {
        self.tasks.get(task_id)
    }
}

// ============================================================================
// TASK FILTERS
// ============================================================================

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TaskFilters {
    pub status: Option<Vec<TaskStatus>>,
    pub priority: Option<Vec<TaskPriority>>,
    pub assignee: Option<Vec<String>>,
    pub task_type: Option<Vec<TaskType>>,
    pub created_after: Option<chrono::DateTime<chrono::Utc>>,
    pub created_before: Option<chrono::DateTime<chrono::Utc>>,
    pub assignee: Option<Vec<String>>,  // Agent IDs
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}

// ============================================================================
// ERROR TYPES
// ============================================================================

#[derive(Debug, thiserror::Error)]
pub enum TaskError {
    #[error("Task not found: {0}")]
    NotFound(String),

    #[error("Task already exists: {0}")]
    AlreadyExists(String),

    #[error("Task is not running: {0}")]
    NotRunning(String),

    #[error("Task is completed: {0}")]
    Completed(String),

    #[error("Invalid task status transition: {0}")]
    InvalidStatusTransition(String),

    #[error("Invalid task dependencies: {0}")]
    InvalidDependencies(String),

    #[error("Task deadline exceeded: {0}")]
    DeadlineExceeded(String),

    #[error("Task assignment failed: {0}")]
    AssignmentFailed(String),

    #[error("Configuration error: {0}")]
    Configuration(String),

    #[error("Communication error: {0}")]
    Communication(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("UUID generation error: {0}")]
    Uuid(#[from] uuid::Error),
}

impl TaskError {
    pub fn task_not_found(task_id: &str) -> Self {
        TaskError::NotFound(task_id.to_string())
    }

    pub fn task_already_exists(task_id: &str) -> Self {
        TaskError::AlreadyExists(task_id.to_string())
    }

    pub fn task_not_running(task_id: &str) -> Self {
        TaskError::NotRunning(task_id.to_string())
    }

    pub fn task_completed(task_id: &str) -> Self {
        TaskError::Completed(task_id.to_string())
    }
}

// ============================================================================
// IMPLEMENTATIONS
// ============================================================================

impl Task {
    pub fn new(name: &str, description: &str, task_type: TaskType, payload: TaskPayload) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name: name.to_string(),
            description: description.to_string(),
            task_type,
            priority: TaskPriority::Normal,
            status: TaskStatus::Pending,
            assignee: None,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            scheduled_at: None,
            started_at: None,
            completed_at: None,
            deadline: None,
            dependencies: Vec::new(),
            payload,
            result: None,
            progress: 0.0,
            metadata: HashMap::new(),
        }
    }

    pub fn with_priority(mut self, priority: TaskPriority) -> Self {
        self.priority = priority;
        self
    }

    pub fn with_deadline(mut self, deadline: chrono::DateTime<chrono::Utc>) -> Self {
        self.deadline = Some(deadline);
        self
    }

    pub fn with_dependencies(mut self, dependencies: Vec<String>) -> Self {
        self.dependencies = dependencies;
        self
    }

    pub fn add_dependency(&mut self, dependency_id: &str) {
        self.dependencies.push(dependency_id.to_string());
    }

    pub fn start(&mut self) {
        self.status = TaskStatus::Running;
        self.started_at = Some(chrono::Utc::now());
        self.updated_at = chrono::Utc::now();
    }

    pub fn complete(&mut self, result: TaskResult) {
        self.status = TaskStatus::Completed;
        self.result = Some(result);
        self.completed_at = Some(chrono::Utc::now());
        self.updated_at = chrono::Utc::now();
        self.progress = 1.0;
    }

    pub fn fail(&mut self, error: String) {
        self.status = TaskStatus::Failed(error);
        self.completed_at = Some(chrono::Utc::now());
        self.updated_at = chrono::Utc::now();
        self.progress = 0.0;
    }

    pub fn cancel(&mut self) {
        self.status = TaskStatus::Cancelled;
        self.completed_at = Some(chrono::Utc::now());
        self.updated_at = chrono::Utc::now();
    }

    pub fn update_progress(&mut self, progress: f64) {
        self.progress = progress.clamp(0.0, 1.0);
        self.updated_at = chrono::Utc::now();
    }

    pub fn is_ready_to_run(&self) -> bool {
        self.status == TaskStatus::Pending && self.dependencies.is_empty()
    }

    pub fn is_overdue(&self) -> bool {
        match self.deadline {
            Some(deadline) => deadline < chrono::Utc::now() && self.status != TaskStatus::Completed,
            None => false,
        }
    }
}

impl TaskResult {
    pub fn new(task_id: &str, output: ResultOutput, metrics: TaskMetrics) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            task_id: task_id.to_string(),
            status: TaskStatus::Completed,
            output,
            metrics,
            artifacts: Vec::new(),
            completed_at: chrono::Utc::now(),
            error_message: None,
        }
    }

    pub fn with_artifacts(mut self, artifacts: Vec<Artifact>) -> Self {
        self.artifacts = artifacts;
        self
    }

    pub fn with_error(mut self, error: String) -> Self {
        self.status = TaskStatus::Failed(error.clone());
        self.error_message = Some(error);
        self
    }
}

// Default implementations
impl Default for Task {
    fn default() -> Self {
        Self::new("default-task", "Default task", TaskType::PlainText, TaskPayload::default())
    }
}

impl Default for TaskPayload {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            format: PayloadFormat::Text,
            attachments: Vec::new(),
            context: HashMap::new(),
        }
    }
}

impl Default for TaskResult {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            task_id: "".to_string(),
            status: TaskStatus::Completed,
            output: ResultOutput::None,
            metrics: TaskMetrics::default(),
            artifacts: Vec::new(),
            completed_at: chrono::Utc::now(),
            error_message: None,
        }
    }
}

impl Default for TaskMetrics {
    fn default() -> Self {
        Self {
            execution_time_ms: 0,
            cpu_time_ms: 0,
            memory_usage_bytes: 0,
            output_size_bytes: 0,
            retry_count: 0,
        }
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_task_creation() {
        let payload = TaskPayload::default();
        let task = Task::new("test-task", "Test task", TaskType::PlainText, payload);
        assert_eq!(task.name, "test-task");
        assert_eq!(task.status, TaskStatus::Pending);
        assert_eq!(task.progress, 0.0);
    }

    #[test]
    fn test_task_status_transitions() {
        let mut task = Task::default();

        task.start();
        assert_eq!(task.status, TaskStatus::Running);
        assert!(task.started_at.is_some());

        let result = TaskResult::new(&task.id, ResultOutput::Text("Done".to_string()), TaskMetrics::default());
        task.complete(result);
        assert_eq!(task.status, TaskStatus::Completed);
        assert!(task.completed_at.is_some());
        assert_eq!(task.progress, 1.0);
    }

    #[test]
    fn test_task_dependencies() {
        let mut task = Task::default();
        task.add_dependency("task-1");
        task.add_dependency("task-2");

        assert_eq!(task.dependencies.len(), 2);
        assert!(!task.is_ready_to_run());
    }

    #[test]
    fn test_task_deadline() {
        let mut task = Task::default();
        let deadline = chrono::Utc::now() + chrono::Duration::hours(1);

        assert!(!task.is_overdue());

        let past_deadline = chrono::Utc::now() - chrono::Duration::hours(1);
        let mut overdue_task = Task::default();
        overdue_task.deadline = Some(past_deadline);

        assert!(overdue_task.is_overdue());
    }
}