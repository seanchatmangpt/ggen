// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use uuid::Uuid;

// ============================================================================
// AGENT DOMAIN TYPES
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Agent {
    pub id: String,
    pub name: String,
    pub description: String,
    pub capabilities: Vec<AgentCapability>,
    pub behaviors: Vec<AgentBehavior>,
    pub configuration: AgentConfiguration,
    pub status: AgentStatus,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AgentStatus {
    Idle,
    Busy,
    Error(String),
    Stopped,
    Starting,
    Stopping,
}

impl Default for AgentStatus {
    fn default() -> Self {
        AgentStatus::Idle
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentCapability {
    pub id: String,
    pub name: String,
    pub description: String,
    pub version: String,
    pub required_resources: Vec<Resource>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentBehavior {
    pub id: String,
    pub name: String,
    pub description: String,
    pub configuration: HashMap<String, serde_json::Value>,
    pub enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfiguration {
    pub max_concurrent_tasks: usize,
    pub timeout_seconds: u64,
    pub retry_attempts: u32,
    pub logging_level: String,
    pub metrics_enabled: bool,
    pub custom_settings: HashMap<String, serde_json::Value>,
}

impl Default for AgentConfiguration {
    fn default() -> Self {
        AgentConfiguration {
            max_concurrent_tasks: 10,
            timeout_seconds: 300,
            retry_attempts: 3,
            logging_level: "info".to_string(),
            metrics_enabled: true,
            custom_settings: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub name: String,
    pub resource_type: ResourceType,
    pub amount: u64,
    pub unit: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResourceType {
    Cpu,
    Memory,
    Storage,
    Network,
    Custom(String),
}

// ============================================================================
// AGENT PORT TRAIT
// ============================================================================

#[async_trait]
pub trait AgentPort {
    fn start_agent(&self, agent_id: &str) -> impl std::future::Future<Output = Result<AgentStatus, AgentError>> + Send;
    fn stop_agent(&self, agent_id: &str) -> impl std::future::Future<Output = Result<AgentStatus, AgentError>> + Send;
    fn get_agent_status(&self, agent_id: &str) -> impl std::future::Future<Output = Result<AgentStatus, AgentError>> + Send;
    fn list_agents(&self) -> impl std::future::Future<Output = Result<Vec<Agent>, AgentError>> + Send;
    fn update_agent_config(&self, agent_id: &str, config: AgentConfiguration) -> impl std::future::Future<Output = Result<Agent, AgentError>> + Send;
}

// ============================================================================
// AGENT ADAPTER
// ============================================================================

pub struct AgentAdapter {
    agents: HashMap<String, Agent>,
    port: Box<dyn AgentPort + Send + Sync>,
}

impl AgentAdapter {
    pub fn new(port: Box<dyn AgentPort + Send + Sync>) -> Self {
        Self {
            agents: HashMap::new(),
            port,
        }
    }

    pub async fn initialize(&mut self) -> Result<(), AgentError> {
        let agents = self.port.list_agents().await?;
        for agent in agents {
            self.agents.insert(agent.id.clone(), agent);
        }
        Ok(())
    }

    pub async fn start_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.port.start_agent(agent_id).await
    }

    pub async fn stop_agent(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.port.stop_agent(agent_id).await
    }

    pub async fn get_agent_status(&self, agent_id: &str) -> Result<AgentStatus, AgentError> {
        self.port.get_agent_status(agent_id).await
    }

    pub async fn list_agents(&self) -> Result<Vec<Agent>, AgentError> {
        self.port.list_agents().await
    }

    pub async fn update_agent_config(&self, agent_id: &str, config: AgentConfiguration) -> Result<Agent, AgentError> {
        let updated_agent = self.port.update_agent_config(agent_id, config).await?;
        self.agents.insert(agent_id.to_string(), updated_agent.clone());
        Ok(updated_agent)
    }

    pub fn get_agent(&self, agent_id: &str) -> Option<&Agent> {
        self.agents.get(agent_id)
    }
}

// ============================================================================
// ERROR TYPES
// ============================================================================

#[derive(Debug, thiserror::Error)]
pub enum AgentError {
    #[error("Agent not found: {0}")]
    NotFound(String),

    #[error("Agent already exists: {0}")]
    AlreadyExists(String),

    #[error("Agent is not running: {0}")]
    NotRunning(String),

    #[error("Agent is busy: {0}")]
    Busy(String),

    #[error("Configuration error: {0}")]
    Configuration(String),

    #[error("Communication error: {0}")]
    Communication(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("UUID generation error: {0}")]
    Uuid(#[from] uuid::Error),
}

impl AgentError {
    pub fn agent_not_found(agent_id: &str) -> Self {
        AgentError::NotFound(agent_id.to_string())
    }

    pub fn agent_already_exists(agent_id: &str) -> Self {
        AgentError::AlreadyExists(agent_id.to_string())
    }

    pub fn agent_not_running(agent_id: &str) -> Self {
        AgentError::NotRunning(agent_id.to_string())
    }

    pub fn agent_busy(agent_id: &str) -> Self {
        AgentError::Busy(agent_id.to_string())
    }
}

// ============================================================================
// IMPLEMENTATIONS
// ============================================================================

impl Agent {
    pub fn new(name: &str, description: &str) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name: name.to_string(),
            description: description.to_string(),
            capabilities: Vec::new(),
            behaviors: Vec::new(),
            configuration: AgentConfiguration::default(),
            status: AgentStatus::Idle,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        }
    }

    pub fn add_capability(&mut self, capability: AgentCapability) {
        self.capabilities.push(capability);
    }

    pub fn add_behavior(&mut self, behavior: AgentBehavior) {
        self.behaviors.push(behavior);
    }

    pub fn update_status(&mut self, status: AgentStatus) {
        self.status = status;
        self.updated_at = chrono::Utc::now();
    }
}

// Default implementations
impl Default for Agent {
    fn default() -> Self {
        Self::new("default-agent", "Default agent")
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_agent_creation() {
        let agent = Agent::new("test-agent", "Test agent");
        assert_eq!(agent.name, "test-agent");
        assert_eq!(agent.description, "Test agent");
        assert_eq!(agent.status, AgentStatus::Idle);
    }

    #[test]
    fn test_agent_status_update() {
        let mut agent = Agent::default();
        let new_status = AgentStatus::Busy;
        agent.update_status(new_status.clone());
        assert_eq!(agent.status, new_status);
    }

    #[test]
    fn test_agent_add_capability() {
        let mut agent = Agent::default();
        let capability = AgentCapability {
            id: "cap-1".to_string(),
            name: "test-capability".to_string(),
            description: "Test capability".to_string(),
            version: "1.0.0".to_string(),
            required_resources: Vec::new(),
        };

        agent.add_capability(capability);
        assert_eq!(agent.capabilities.len(), 1);
    }
}