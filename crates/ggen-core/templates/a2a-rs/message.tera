// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use uuid::Uuid;

// ============================================================================
// MESSAGE DOMAIN TYPES
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub id: String,
    pub message_type: MessageType,
    pub role: MessageRole,
    pub content: MessageContent,
    pub header: MessageHeader,
    pub signature: Option<MessageSignature>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MessageType {
    Text,
    Task,
    Result,
    Status,
    Error,
    Workflow,
    Heartbeat,
    Custom(String),
}

impl Default for MessageType {
    fn default() -> Self {
        MessageType::Text
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MessageRole {
    User,
    Assistant,
    System,
    Agent,
    Workflow,
}

impl Default for MessageRole {
    fn default() -> Self {
        MessageRole::User
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContent {
    pub text: Option<String>,
    pub json: Option<serde_json::Value>,
    pub binary: Option<Vec<u8>>,
    pub format: ContentFormat,
    pub attachments: Vec<Attachment>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ContentFormat {
    Text,
    Json,
    Xml,
    Yaml,
    Binary,
    Custom(String),
}

impl Default for ContentFormat {
    fn default() -> Self {
        ContentFormat::Text
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageHeader {
    pub version: String,
    pub correlation_id: Option<String>,
    pub conversation_id: Option<String>,
    pub parent_message_id: Option<String>,
    pub sequence: u64,
    pub session_id: Option<String>,
    pub priority: MessagePriority,
    pub ttl: Option<chrono::Duration>,
    pub compression: CompressionType,
    pub encryption: EncryptionType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessagePriority {
    Low,
    Normal,
    High,
    Critical,
}

impl Default for MessagePriority {
    fn default() -> Self {
        MessagePriority::Normal
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CompressionType {
    None,
    Gzip,
    Brotli,
    Zstd,
}

impl Default for CompressionType {
    fn default() -> Self {
        CompressionType::None
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EncryptionType {
    None,
    Aes256,
    Rsa2048,
    Ecdsa256,
}

impl Default for EncryptionType {
    fn default() -> Self {
        EncryptionType::None
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSignature {
    pub algorithm: String,
    pub signature: Vec<u8>,
    pub public_key: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attachment {
    pub id: String,
    pub name: String,
    pub content_type: String,
    pub size: u64,
    pub content: Vec<u8>,
    pub metadata: HashMap<String, serde_json::Value>,
}

// ============================================================================
// MESSAGE PORT TRAIT
// ============================================================================

#[async_trait]
pub trait MessagePort {
    async fn send_message(&self, message: Message) -> Result<MessageId, MessageError>;
    async fn get_message(&self, message_id: &str) -> Result<Message, MessageError>;
    async fn list_messages(&self, filters: MessageFilters) -> Result<Vec<Message>, MessageError>;
    async fn reply_to_message(&self, original_id: &str, reply: Message) -> Result<MessageId, MessageError>;
    async fn broadcast_message(&self, message: Message, recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError>;
    async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessageError>;
    async fn reject_message(&self, message_id: &str, reason: String) -> Result<(), MessageError>;
}

// ============================================================================
// MESSAGE ADAPTER
// ============================================================================

pub struct MessageAdapter {
    messages: HashMap<String, Message>,
    port: Box<dyn MessagePort + Send + Sync>,
}

impl MessageAdapter {
    pub fn new(port: Box<dyn MessagePort + Send + Sync>) -> Self {
        Self {
            messages: HashMap::new(),
            port,
        }
    }

    pub async fn initialize(&mut self) -> Result<(), MessageError> {
        let messages = self.port.list_messages(MessageFilters::default()).await?;
        for message in messages {
            self.messages.insert(message.id.clone(), message);
        }
        Ok(())
    }

    pub async fn send_message(&mut self, message: Message) -> Result<MessageId, MessageError> {
        let message_id = self.port.send_message(message.clone()).await?;
        self.messages.insert(message.id.clone(), message);
        Ok(message_id)
    }

    pub async fn get_message(&self, message_id: &str) -> Result<Message, MessageError> {
        self.port.get_message(message_id).await
    }

    pub async fn list_messages(&self, filters: MessageFilters) -> Result<Vec<Message>, MessageError> {
        self.port.list_messages(filters).await
    }

    pub async fn reply_to_message(&mut self, original_id: &str, reply: Message) -> Result<MessageId, MessageError> {
        let reply_id = self.port.reply_to_message(original_id, reply.clone()).await?;
        self.messages.insert(reply.id.clone(), reply);
        Ok(reply_id)
    }

    pub async fn broadcast_message(&mut self, message: Message, recipients: Vec<String>) -> Result<Vec<MessageId>, MessageError> {
        let message_ids = self.port.broadcast_message(message.clone(), recipients.clone()).await?;
        self.messages.insert(message.id.clone(), message);
        Ok(message_ids)
    }

    pub async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessageError> {
        self.port.acknowledge_message(message_id).await
    }

    pub async fn reject_message(&self, message_id: &str, reason: String) -> Result<(), MessageError> {
        self.port.reject_message(message_id, reason).await
    }

    pub fn get_message(&self, message_id: &str) -> Option<&Message> {
        self.messages.get(message_id)
    }
}

// ============================================================================
// MESSAGE FILTERS
// ============================================================================

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageFilters {
    pub message_type: Option<Vec<MessageType>>,
    pub role: Option<Vec<MessageRole>>,
    pub conversation_id: Option<String>,
    pub session_id: Option<String>,
    pub created_after: Option<chrono::DateTime<chrono::Utc>>,
    pub created_before: Option<chrono::DateTime<chrono::Utc>>,
    pub sender: Option<Vec<String>>,
    pub recipient: Option<Vec<String>>,
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}

// ============================================================================
// MESSAGE BUILDER
// ============================================================================

pub struct MessageBuilder {
    message: Message,
}

impl MessageBuilder {
    pub fn new() -> Self {
        Self {
            message: Message {
                id: Uuid::new_v4().to_string(),
                message_type: MessageType::Text,
                role: MessageRole::User,
                content: MessageContent::default(),
                header: MessageHeader::default(),
                signature: None,
                created_at: chrono::Utc::now(),
                metadata: HashMap::new(),
            },
        }
    }

    pub fn with_id(mut self, id: String) -> Self {
        self.message.id = id;
        self
    }

    pub fn with_message_type(mut self, message_type: MessageType) -> Self {
        self.message.message_type = message_type;
        self
    }

    pub fn with_role(mut self, role: MessageRole) -> Self {
        self.message.role = role;
        self
    }

    pub fn with_text_content(mut self, text: String) -> Self {
        self.message.content.text = Some(text);
        self.message.content.format = ContentFormat::Text;
        self
    }

    pub fn with_json_content(mut self, json: serde_json::Value) -> Self {
        self.message.content.json = Some(json);
        self.message.content.format = ContentFormat::Json;
        self
    }

    pub fn with_binary_content(mut self, binary: Vec<u8>) -> Self {
        self.message.content.binary = Some(binary);
        self.message.content.format = ContentFormat::Binary;
        self
    }

    pub fn with_correlation_id(mut self, correlation_id: String) -> Self {
        self.message.header.correlation_id = Some(correlation_id);
        self
    }

    pub fn with_conversation_id(mut self, conversation_id: String) -> Self {
        self.message.header.conversation_id = Some(conversation_id);
        self
    }

    pub fn with_priority(mut self, priority: MessagePriority) -> Self {
        self.message.header.priority = priority;
        self
    }

    pub fn with_ttl(mut self, ttl: chrono::Duration) -> Self {
        self.message.header.ttl = Some(ttl);
        self
    }

    pub fn with_metadata(mut self, key: String, value: serde_json::Value) -> Self {
        self.message.metadata.insert(key, value);
        self
    }

    pub fn build(self) -> Message {
        self.message
    }
}

impl Default for MessageBuilder {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// ERROR TYPES
// ============================================================================

#[derive(Debug, thiserror::Error)]
pub enum MessageError {
    #[error("Message not found: {0}")]
    NotFound(String),

    #[error("Message already exists: {0}")]
    AlreadyExists(String),

    #[error("Invalid message format: {0}")]
    InvalidFormat(String),

    #[error("Message timeout: {0}")]
    Timeout(String),

    #[error("Message authentication failed: {0}")]
    Authentication(String),

    #[error("Message authorization failed: {0}")]
    Authorization(String),

    #[error("Message serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("Message deserialization error: {0}")]
    Deserialization(#[from] serde_json::Error),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("UUID generation error: {0}")]
    Uuid(#[from] uuid::Error),

    #[error("Network error: {0}")]
    Network(String),
}

impl MessageError {
    pub fn message_not_found(message_id: &str) -> Self {
        MessageError::NotFound(message_id.to_string())
    }

    pub fn message_already_exists(message_id: &str) -> Self {
        MessageError::AlreadyExists(message_id.to_string())
    }

    pub fn invalid_message_format(format: &str) -> Self {
        MessageError::InvalidFormat(format.to_string())
    }
}

// ============================================================================
// CONVENIENCE FUNCTIONS
// ============================================================================

pub fn user_text(text: String, correlation_id: Option<String>) -> Message {
    MessageBuilder::new()
        .with_role(MessageRole::User)
        .with_message_type(MessageType::Text)
        .with_text_content(text)
        .with_correlation_id(correlation_id.unwrap_or_else(|| Uuid::new_v4().to_string()))
        .build()
}

pub fn assistant_text(text: String, correlation_id: Option<String>) -> Message {
    MessageBuilder::new()
        .with_role(MessageRole::Assistant)
        .with_message_type(MessageType::Text)
        .with_text_content(text)
        .with_correlation_id(correlation_id.unwrap_or_else(|| Uuid::new_v4().to_string()))
        .build()
}

pub fn system_text(text: String, correlation_id: Option<String>) -> Message {
    MessageBuilder::new()
        .with_role(MessageRole::System)
        .with_message_type(MessageType::Text)
        .with_text_content(text)
        .with_correlation_id(correlation_id.unwrap_or_else(|| Uuid::new_v4().to_string()))
        .build()
}

pub fn task_message(task_id: String, description: String, correlation_id: Option<String>) -> Message {
    let mut payload = HashMap::new();
    payload.insert("task_id".to_string(), serde_json::Value::String(task_id));
    payload.insert("description".to_string(), serde_json::Value::String(description));

    MessageBuilder::new()
        .with_role(MessageRole::User)
        .with_message_type(MessageType::Task)
        .with_json_content(serde_json::Value::Object(payload))
        .with_correlation_id(correlation_id.unwrap_or_else(|| Uuid::new_v4().to_string()))
        .build()
}

// ============================================================================
// DEFAULT IMPLEMENTATIONS
// ============================================================================

impl Default for Message {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            message_type: MessageType::Text,
            role: MessageRole::User,
            content: MessageContent::default(),
            header: MessageHeader::default(),
            signature: None,
            created_at: chrono::Utc::now(),
            metadata: HashMap::new(),
        }
    }
}

impl Default for MessageContent {
    fn default() -> Self {
        Self {
            text: None,
            json: None,
            binary: None,
            format: ContentFormat::Text,
            attachments: Vec::new(),
        }
    }
}

impl Default for MessageHeader {
    fn default() -> Self {
        Self {
            version: "1.0.0".to_string(),
            correlation_id: None,
            conversation_id: None,
            parent_message_id: None,
            sequence: 0,
            session_id: None,
            priority: MessagePriority::Normal,
            ttl: None,
            compression: CompressionType::None,
            encryption: EncryptionType::None,
        }
    }
}

impl Default for Attachment {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name: "unnamed".to_string(),
            content_type: "application/octet-stream".to_string(),
            size: 0,
            content: Vec::new(),
            metadata: HashMap::new(),
        }
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_builder() {
        let message = MessageBuilder::new()
            .with_text_content("Hello, world!".to_string())
            .with_role(MessageRole::User)
            .build();

        assert_eq!(message.content.text, Some("Hello, world!".to_string()));
        assert_eq!(message.role, MessageRole::User);
    }

    #[test]
    fn test_message_convenience_functions() {
        let user_msg = user_text("Hello".to_string(), None);
        assert_eq!(user_msg.role, MessageRole::User);
        assert_eq!(user_msg.message_type, MessageType::Text);

        let assistant_msg = assistant_text("Hi there!".to_string(), None);
        assert_eq!(assistant_msg.role, MessageRole::Assistant);

        let system_msg = system_text("System message".to_string(), None);
        assert_eq!(system_msg.role, MessageRole::System);
    }

    #[test]
    fn test_task_message() {
        let task_msg = task_message("task-123".to_string(), "Test task".to_string(), None);
        assert_eq!(task_msg.message_type, MessageType::Task);
        assert!(task_msg.content.json.is_some());
    }

    #[test]
    fn test_message_header() {
        let header = MessageHeader::default();
        assert_eq!(header.version, "1.0.0");
        assert_eq!(header.priority, MessagePriority::Normal);
        assert_eq!(header.sequence, 0);
    }

    #[test]
    fn test_attachment() {
        let attachment = Attachment::default();
        assert!(!attachment.id.is_empty());
        assert_eq!(attachment.name, "unnamed");
        assert_eq!(attachment.content_type, "application/octet-stream");
    }
}