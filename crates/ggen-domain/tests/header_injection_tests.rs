//! Integration tests for warning header injection functionality
//!
//! Tests the `[generation].poka_yoke.warning_headers` configuration
//! to inject "DO NOT EDIT" headers in generated files.

use ggen_domain::generation::headers::{
    format_header_for_extension, inject_warning_header, HeaderInjectionConfig,
};
use std::fs;
use std::path::Path;
use tempfile::TempDir;

/// Test: Header injection for Rust files
#[test]
fn test_header_injection_rust_file() {
    let content = "fn main() {\n    println!(\"Hello\");\n}";
    let output_path = Path::new("test.rs");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    // Check that header is present
    assert!(
        result.contains("DO NOT EDIT"),
        "Header should contain 'DO NOT EDIT'"
    );
    assert!(result.contains("// "), "Rust comments should use //");

    // Check that original content is preserved
    assert!(
        result.contains("fn main()"),
        "Original content should be preserved"
    );
    assert!(
        result.contains("println!"),
        "Original content should be preserved"
    );

    // Check that header comes first
    assert!(
        result.find("DO NOT EDIT").unwrap_or(999) < result.find("fn main()").unwrap_or(999),
        "Header should come before original content"
    );
}

/// Test: Header injection for Python files
#[test]
fn test_header_injection_python_file() {
    let content = "def hello():\n    print('Hello')\n";
    let output_path = Path::new("test.py");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    // Check that header uses Python comments
    assert!(result.contains("# "), "Python comments should use #");
    assert!(
        result.contains("DO NOT EDIT"),
        "Header should contain 'DO NOT EDIT'"
    );

    // Check that original content is preserved
    assert!(
        result.contains("def hello()"),
        "Original content should be preserved"
    );
}

/// Test: Header injection for TypeScript files
#[test]
fn test_header_injection_typescript_file() {
    let content = "export interface User {\n  id: string;\n}\n";
    let output_path = Path::new("test.ts");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    assert!(result.contains("// "), "TypeScript comments should use //");
    assert!(
        result.contains("DO NOT EDIT"),
        "Header should contain 'DO NOT EDIT'"
    );
    assert!(
        result.contains("export interface User"),
        "Original content should be preserved"
    );
}

/// Test: Header injection for Go files
#[test]
fn test_header_injection_go_file() {
    let content = "package main\n\nfunc Hello() string {\n    return \"Hello\"\n}\n";
    let output_path = Path::new("test.go");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    assert!(result.contains("// "), "Go comments should use //");
    assert!(
        result.contains("DO NOT EDIT"),
        "Header should contain 'DO NOT EDIT'"
    );
    assert!(
        result.contains("package main"),
        "Original content should be preserved"
    );
}

/// Test: Shebang preservation in shell scripts
#[test]
fn test_header_injection_preserves_shebang() {
    let content = "#!/bin/bash\necho 'Hello'\n";
    let output_path = Path::new("test.sh");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    // Shebang should be first line
    assert!(
        result.starts_with("#!/bin/bash"),
        "Shebang should be preserved as first line"
    );

    // Header should come after shebang
    assert!(
        result.contains("# DO NOT EDIT"),
        "Header should use shell comments"
    );
}

/// Test: Regeneration command in header
#[test]
fn test_regeneration_command_in_header() {
    let content = "fn main() {}";
    let output_path = Path::new("test.rs");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    assert!(
        result.contains("Generated by ggen"),
        "Header should mention ggen generation"
    );
}

/// Test: Header formatting per language
#[test]
fn test_format_header_per_extension() {
    let header_text = "DO NOT EDIT";
    let extensions = vec![
        ("rs", "// "),
        ("ts", "// "),
        ("js", "// "),
        ("go", "// "),
        ("py", "# "),
        ("sh", "# "),
    ];

    for (ext, expected_comment) in extensions {
        let header = format_header_for_extension(header_text, ext);
        assert!(
            header.contains(expected_comment),
            "Extension {} should use comment style {}",
            ext,
            expected_comment
        );
    }
}

/// Test: Header with real filesystem operations
#[test]
fn test_header_injection_real_filesystem() -> std::io::Result<()> {
    let temp_dir = TempDir::new()?;
    let file_path = temp_dir.path().join("generated.rs");

    // Write original content
    let original = "pub fn greet() {\n    println!(\"Hello, World!\");\n}";
    fs::write(&file_path, original)?;

    // Read, inject header, write back
    let content = fs::read_to_string(&file_path)?;
    let config = HeaderInjectionConfig::default_config();
    let with_header = inject_warning_header(&content, &file_path, &config);
    fs::write(&file_path, &with_header)?;

    // Verify file contains header
    let result = fs::read_to_string(&file_path)?;
    assert!(result.contains("DO NOT EDIT"), "File should contain header");
    assert!(
        result.contains("pub fn greet()"),
        "File should contain original content"
    );

    Ok(())
}

/// Test: Header injected is idempotent (disabled header with config)
#[test]
fn test_header_injection_disabled_config() {
    let original = "fn main() {}";
    let output_path = Path::new("test.rs");
    let disabled_config = HeaderInjectionConfig::disabled();
    let result = inject_warning_header(original, output_path, &disabled_config);

    // With disabled config, content should be unchanged
    assert_eq!(result, original, "Disabled config should not inject header");
}

/// Test: Header format for unknown extensions defaults to safe option
#[test]
fn test_header_format_unknown_extension() {
    let header_text = "DO NOT EDIT";
    // Unknown extension should default safely
    let header = format_header_for_extension(header_text, "unknown");
    assert!(
        header.contains("// "),
        "Unknown extension should default to // comments"
    );
}

/// Test: Large files with header injection
#[test]
fn test_header_injection_large_file() {
    let mut large_content = String::new();
    for i in 0..1000 {
        large_content.push_str(&format!("fn func_{}() {{}}\n", i));
    }

    let output_path = Path::new("test.rs");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(&large_content, output_path, &config);

    // Check header is at beginning
    assert!(
        result.starts_with("//"),
        "Header should be at the beginning"
    );

    // Check all original content is preserved
    assert!(
        result.contains("fn func_0()"),
        "All content should be preserved"
    );
    assert!(
        result.contains("fn func_999()"),
        "All content should be preserved"
    );

    // Header should not be too large
    let header_lines = result.lines().take_while(|l| l.starts_with("//")).count();
    assert!(
        header_lines < 20,
        "Header should be concise, got {} lines",
        header_lines
    );
}

/// Test: Header with special characters in content
#[test]
fn test_header_injection_special_characters() {
    let content = "// Comment with \"quotes\" and 'apostrophes'\nfn test() {}";
    let output_path = Path::new("test.rs");
    let config = HeaderInjectionConfig::default_config();
    let result = inject_warning_header(content, output_path, &config);

    assert!(result.contains("DO NOT EDIT"), "Header should be injected");
    assert!(
        result.contains("\"quotes\""),
        "Special characters should be preserved"
    );
    assert!(
        result.contains("'apostrophes'"),
        "Special characters should be preserved"
    );
}
