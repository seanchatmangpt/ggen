// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

//! A2A-RS Integration Code
//!
//! This module contains the A2A (Agent-to-Agent) protocol integration code generated
//! from the RDF ontology by ggen. It provides type-safe interfaces for agent communication,
//! task management, and message handling.

pub mod adapter;
pub mod agent;
pub mod converged;
pub mod handlers;
pub mod message;
pub mod port;
pub mod task;

// Re-export commonly used types
pub use adapter::{
    Adapter, AdapterCapabilities, AdapterError, BaseAdapter, JsonAdapter, XmlAdapter,
};
pub use agent::{Agent, AgentBehavior, AgentFactory};
pub use message::{
    Message, MessageError, MessageHandler, MessagePriority, MessageResponse, MessageStatus,
    MessageType,
};
pub use port::{BasicPort, Port, PortData, PortError, PortStats, PortStatus, PortType};
pub use task::{Task, TaskError, TaskExecutor, TaskPriority, TaskResult, TaskStatus};

// Re-export unified converged interfaces
pub use converged::{
    AgentCapabilities, AgentCommunication, AgentError, AgentExecution, AgentHealth, AgentIdentity,
    AgentLifecycle, AgentMetrics, AgentProtocol, AgentSecurity, AgentState, Capability,
    ComparisonOperator, DataFormat, ExecutionMode, ExecutionStrategy, HealthStatus,
    LatencyRequirements, QoSLevel, ReliabilityLevel, ResourceConstraints, ThroughputRequirements,
    UnifiedAgent, UnifiedAgentBuilder, ValidationAction, ValidationRule, ValidationSeverity,
};

// Re-export message types and handlers
pub use message::{
    ConvergedMessage, ConvergedMessageType, ConvergedPayload, HandlerAction, HandlerPriority,
    HandlerStatus, LatencyRequirements, MessageEnvelope, MessageHandler, MessageHandlerError,
    MessageHandlerFactory, MessageHandlerResult, MessageLifecycle, MessageRouter, MessageRouting,
    MessageState, ProcessingMetrics, ReliabilityLevel, ResourceUsageMetrics,
    ThroughputRequirements, UnifiedContent,
};

// Re-export security types
pub use agent::{
    AuditConfig, AuditEvent, AuthenticationConfig, AuthenticationMethod, AuthenticationProvider,
    AuthorizationConfig, AuthorizationModel, AuthorizationRole, ComplianceConfig,
    ComplianceControl, ComplianceFramework, ComplianceRequirement, ComplianceStandard,
    DestinationType, EncryptionAlgorithm, EncryptionConfig, EncryptionKey, EncryptionMode,
    EncryptionRequirements, Permission, PermissionScope, PermissionType, PolicyEffect,
    PolicyPriority, PolicyType, ProviderType, RequirementType, RetentionPolicy,
    SecurityClassification, SecurityPolicies, SecurityPolicy, SecurityRule,
};

// Prelude for easier imports
pub mod prelude {
    pub use super::{
        Adapter,
        AdapterCapabilities,
        AdapterError,
        Agent,
        AgentBehavior,
        AgentCapabilities,
        AgentCommunication,
        AgentError,
        AgentExecution,
        AgentFactory,
        AgentHealth,
        AgentIdentity,
        AgentLifecycle,
        AgentMetrics,
        AgentProtocol,
        AgentSecurity,
        AgentState,
        AuditConfig,
        // Security types
        AuthenticationConfig,
        AuthenticationMethod,
        AuthorizationConfig,
        AuthorizationModel,
        BaseAdapter,
        BasicPort,
        Capability,
        // Message types
        ConvergedMessage,
        ConvergedMessageType,
        ConvergedPayload,
        DataFormat,
        EncryptionAlgorithm,
        EncryptionConfig,
        ExecutionMode,
        HandlerAction,
        HandlerPriority,
        HandlerStatus,
        HealthStatus,
        JsonAdapter,
        LatencyRequirements,
        Message,
        MessageEnvelope,
        MessageError,
        MessageHandler,
        // Message handlers
        MessageHandler,
        MessageHandlerError,
        MessageHandlerResult,
        MessageLifecycle,
        MessagePriority,
        MessageResponse,
        MessageRouter,
        MessageRouting,
        MessageState,
        MessageStatus,
        MessageType,
        Port,
        PortData,
        PortError,
        PortStats,
        PortStatus,
        PortType,
        QoSLevel,
        ReliabilityLevel,
        ResourceConstraints,
        SecurityPolicy,
        Task,
        TaskError,
        TaskExecutor,
        TaskPriority,
        TaskResult,
        TaskStatus,
        ThroughputRequirements,
        // Unified converged interfaces
        UnifiedAgent,
        UnifiedAgentBuilder,
        UnifiedContent,
        XmlAdapter,
    };
}

// Version information
pub const VERSION: &str = "0.1.0";
pub const ONTOLOGY_VERSION: &str = "1.0.0";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version() {
        assert!(!VERSION.is_empty());
        assert!(!ONTOLOGY_VERSION.is_empty());
    }

    #[tokio::test]
    async fn test_agent_creation() {
        let agent = AgentFactory::create_agent("test", "123", "Test Agent");
        assert_eq!(agent.id, "123");
        assert_eq!(agent.name, "Test Agent");
        assert_eq!(agent.agent_type, "test");
    }

    #[tokio::test]
    async fn test_task_creation() {
        let task = Task::new(
            "task-123".to_string(),
            "Test Task".to_string(),
            "test".to_string(),
            serde_json::json!({"input": "test"}),
        );
        assert_eq!(task.id, "task-123");
        assert_eq!(task.name, "Test Task");
        assert_eq!(task.task_type, "test");
        assert_eq!(task.priority, TaskPriority::Normal);
        assert_eq!(task.status, TaskStatus::Pending);
    }

    #[tokio::test]
    async fn test_message_creation() {
        let message = Message::new(
            "msg-123".to_string(),
            MessageType::TaskRequest,
            "agent-1".to_string(),
            Some("agent-2".to_string()),
            serde_json::json!({"task": "test"}),
        );
        assert_eq!(message.id, "msg-123");
        assert_eq!(message.source, "agent-1");
        assert_eq!(message.target, Some("agent-2".to_string()));
        assert_eq!(message.message_type, MessageType::TaskRequest);
    }

    #[tokio::test]
    async fn test_port_creation() {
        let port = BasicPort::new(
            "port-123".to_string(),
            "Test Port".to_string(),
            PortType::Output,
        );
        assert_eq!(port.id(), "port-123");
        assert_eq!(port.name(), "Test Port");
        assert_eq!(port.port_type(), PortType::Output);
    }

    #[tokio::test]
    async fn test_adapter_creation() {
        let mut json_adapter = JsonAdapter::new();
        json_adapter
            .initialize(serde_json::json!({}))
            .await
            .unwrap();

        assert_eq!(json_adapter.name(), "json");
        assert_eq!(json_adapter.version(), "1.0.0");

        let test_json = serde_json::json!({"test": "message"});
        let converted = json_adapter.to_a2a(&test_json).await.unwrap();
        assert_eq!(converted, test_json);
    }
}

// Benchmark suite
#[cfg(feature = "all-adapters")]
pub mod benchmarks {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    pub fn benchmark_agent_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("agent_operations");

        group.bench_function("agent_creation", |b| {
            b.iter(|| {
                black_box(AgentFactory::create_agent("test", "123", "Test Agent"));
            })
        });

        group.bench_function("agent_behavior", |b| {
            let agent = AgentFactory::create_agent("test", "123", "Test Agent");
            let mut behavior = DefaultAgent::new(agent);
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(behavior.initialize(&serde_json::json!({})));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_task_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("task_operations");

        group.bench_function("task_creation", |b| {
            b.iter(|| {
                black_box(Task::new(
                    "task-123".to_string(),
                    "Test Task".to_string(),
                    "test".to_string(),
                    serde_json::json!({"input": "test"}),
                ));
            })
        });

        group.bench_function("task_execution", |b| {
            let task = Task::new(
                "task-123".to_string(),
                "Test Task".to_string(),
                "test".to_string(),
                serde_json::json!({"input": "test"}),
            );
            let executor = DefaultTaskExecutor { max_parallel: 4 };
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(executor.execute(&task));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_message_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("message_operations");

        group.bench_function("message_creation", |b| {
            b.iter(|| {
                black_box(Message::new(
                    "msg-123".to_string(),
                    MessageType::TaskRequest,
                    "agent-1".to_string(),
                    None,
                    serde_json::json!({"task": "test"}),
                ));
            })
        });

        group.bench_function("message_serialization", |b| {
            let message = Message::new(
                "msg-123".to_string(),
                MessageType::TaskRequest,
                "agent-1".to_string(),
                None,
                serde_json::json!({"task": "test"}),
            );
            b.iter(|| {
                black_box(serde_json::to_string(&message).unwrap());
            })
        });

        group.finish();
    }

    pub fn benchmark_port_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("port_operations");

        group.bench_function("port_creation", |b| {
            b.iter(|| {
                black_box(BasicPort::new(
                    "port-123".to_string(),
                    "Test Port".to_string(),
                    PortType::Output,
                ));
            })
        });

        group.bench_function("port_send_receive", |b| {
            let mut port = BasicPort::new(
                "port-123".to_string(),
                "Test Port".to_string(),
                PortType::Bidirectional,
            );
            port.initialize(PortConfig::new()).await.unwrap();
            let test_message = serde_json::json!({"test": "message"});
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(port.send(&test_message));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_adapter_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("adapter_operations");

        group.bench_function("json_conversion", |b| {
            let adapter = JsonAdapter::new();
            let test_json = serde_json::json!({"test": "message"});
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(adapter.to_a2a(&test_json));
                }));
            })
        });

        group.bench_function("xml_conversion", |b| {
            let adapter = XmlAdapter::new();
            let test_xml = serde_json::json!("<test>message</test>");
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(adapter.to_a2a(&test_xml));
                }));
            })
        });

        group.finish();
    }
}

#[cfg(feature = "all-adapters")]
criterion_group!(
    benches,
    benchmark_agent_operations,
    benchmark_task_operations,
    benchmark_message_operations,
    benchmark_port_operations,
    benchmark_adapter_operations
);
#[cfg(feature = "all-adapters")]
criterion_main!(benches);
