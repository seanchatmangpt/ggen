// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

//! A2A-RS Integration Code
//!
//! This module contains the A2A (Agent-to-Agent) protocol integration code generated
//! from the RDF ontology by ggen. It provides type-safe interfaces for agent communication,
//! task management, and message handling.

pub mod agent;
pub mod task;
pub mod message;
pub mod port;
pub mod adapter;
pub mod converged;
pub mod handlers;

// Re-export commonly used types
pub use agent::{Agent, AgentBehavior, AgentFactory};
pub use task::{Task, TaskPriority, TaskStatus, TaskExecutor, TaskResult, TaskError};
pub use message::{Message, MessageType, MessagePriority, MessageStatus, MessageHandler, MessageResponse, MessageError};
pub use port::{Port, PortType, PortStatus, PortError, PortStats, PortData, BasicPort};
pub use adapter::{Adapter, AdapterCapabilities, AdapterError, BaseAdapter, JsonAdapter, XmlAdapter};

// Re-export unified converged interfaces
pub use converged::{
    UnifiedAgent, AgentIdentity, AgentCapabilities, AgentLifecycle, AgentCommunication,
    AgentExecution, AgentSecurity, Capability, AgentProtocol, DataFormat, QoSLevel,
    ResourceConstraints, AgentState, AgentHealth, HealthStatus, AgentMetrics,
    ExecutionMode, ExecutionStrategy, ReliabilityLevel, LatencyRequirements, ThroughputRequirements,
    ValidationRule, ValidationAction, ValidationSeverity, ComparisonOperator,
    AgentError, UnifiedAgentBuilder,
};

// Re-export message types and handlers
pub use message::{
    ConvergedMessage, ConvergedMessageType, ConvergedPayload, UnifiedContent,
    MessageEnvelope, MessageRouting, MessageLifecycle, MessageState,
    ReliabilityLevel, LatencyRequirements, ThroughputRequirements,
    MessageHandler, MessageHandlerResult, MessageHandlerError,
    MessageRouter, MessageHandlerFactory, HandlerPriority, HandlerStatus,
    HandlerAction, ProcessingMetrics, ResourceUsageMetrics,
};

// Re-export security types
pub use agent::{
    AuthenticationConfig, AuthorizationConfig, EncryptionConfig, AuditConfig,
    ComplianceConfig, SecurityPolicies, AuthenticationMethod, AuthorizationModel,
    EncryptionAlgorithm, EncryptionKey, EncryptionMode, AuditEvent,
    RetentionPolicy, ComplianceFramework, ComplianceStandard, ComplianceRequirement,
    Permission, PermissionType, PermissionScope, SecurityClassification,
    EncryptionRequirements, SecurityRule, PolicyType, PolicyEffect, PolicyPriority,
    SecurityPolicy, AuthorizationRole, AuthenticationProvider, ProviderType,
    DestinationType, ComplianceControl, RequirementType,
};

// Prelude for easier imports
pub mod prelude {
    pub use super::{
        Agent, AgentBehavior, AgentFactory,
        Task, TaskPriority, TaskStatus, TaskExecutor, TaskResult, TaskError,
        Message, MessageType, MessagePriority, MessageStatus, MessageHandler, MessageResponse, MessageError,
        Port, PortType, PortStatus, PortError, PortStats, PortData, BasicPort,
        Adapter, AdapterCapabilities, AdapterError, BaseAdapter, JsonAdapter, XmlAdapter,
        // Unified converged interfaces
        UnifiedAgent, UnifiedAgentBuilder, AgentIdentity, AgentCapabilities,
        AgentLifecycle, AgentCommunication, AgentExecution, AgentSecurity,
        Capability, AgentProtocol, DataFormat, QoSLevel, ResourceConstraints,
        AgentState, AgentHealth, HealthStatus, AgentMetrics, ExecutionMode,
        ReliabilityLevel, LatencyRequirements, ThroughputRequirements, AgentError,
        // Message types
        ConvergedMessage, ConvergedMessageType, UnifiedContent, ConvergedPayload,
        MessageEnvelope, MessageRouting, MessageLifecycle, MessageState,
        // Message handlers
        MessageHandler, MessageHandlerResult, MessageHandlerError,
        MessageRouter, HandlerPriority, HandlerStatus, HandlerAction,
        // Security types
        AuthenticationConfig, AuthorizationConfig, EncryptionConfig, AuditConfig,
        AuthenticationMethod, AuthorizationModel, EncryptionAlgorithm, SecurityPolicy,
    };
}

// Version information
pub const VERSION: &str = "0.1.0";
pub const ONTOLOGY_VERSION: &str = "1.0.0";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version() {
        assert!(!VERSION.is_empty());
        assert!(!ONTOLOGY_VERSION.is_empty());
    }

    #[tokio::test]
    async fn test_agent_creation() {
        let agent = AgentFactory::create_agent("test", "123", "Test Agent");
        assert_eq!(agent.id, "123");
        assert_eq!(agent.name, "Test Agent");
        assert_eq!(agent.agent_type, "test");
    }

    #[tokio::test]
    async fn test_task_creation() {
        let task = Task::new(
            "task-123".to_string(),
            "Test Task".to_string(),
            "test".to_string(),
            serde_json::json!({"input": "test"}),
        );
        assert_eq!(task.id, "task-123");
        assert_eq!(task.name, "Test Task");
        assert_eq!(task.task_type, "test");
        assert_eq!(task.priority, TaskPriority::Normal);
        assert_eq!(task.status, TaskStatus::Pending);
    }

    #[tokio::test]
    async fn test_message_creation() {
        let message = Message::new(
            "msg-123".to_string(),
            MessageType::TaskRequest,
            "agent-1".to_string(),
            Some("agent-2".to_string()),
            serde_json::json!({"task": "test"}),
        );
        assert_eq!(message.id, "msg-123");
        assert_eq!(message.source, "agent-1");
        assert_eq!(message.target, Some("agent-2".to_string()));
        assert_eq!(message.message_type, MessageType::TaskRequest);
    }

    #[tokio::test]
    async fn test_port_creation() {
        let port = BasicPort::new("port-123".to_string(), "Test Port".to_string(), PortType::Output);
        assert_eq!(port.id(), "port-123");
        assert_eq!(port.name(), "Test Port");
        assert_eq!(port.port_type(), PortType::Output);
    }

    #[tokio::test]
    async fn test_adapter_creation() {
        let mut json_adapter = JsonAdapter::new();
        json_adapter.initialize(serde_json::json!({})).await.unwrap();

        assert_eq!(json_adapter.name(), "json");
        assert_eq!(json_adapter.version(), "1.0.0");

        let test_json = serde_json::json!({"test": "message"});
        let converted = json_adapter.to_a2a(&test_json).await.unwrap();
        assert_eq!(converted, test_json);
    }
}

// Benchmark suite
#[cfg(feature = "all-adapters")]
pub mod benchmarks {
    use criterion::{black_box, criterion_group, criterion_main, Criterion};
    use super::*;

    pub fn benchmark_agent_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("agent_operations");

        group.bench_function("agent_creation", |b| {
            b.iter(|| {
                black_box(AgentFactory::create_agent("test", "123", "Test Agent"));
            })
        });

        group.bench_function("agent_behavior", |b| {
            let agent = AgentFactory::create_agent("test", "123", "Test Agent");
            let mut behavior = DefaultAgent::new(agent);
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(behavior.initialize(&serde_json::json!({})));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_task_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("task_operations");

        group.bench_function("task_creation", |b| {
            b.iter(|| {
                black_box(Task::new(
                    "task-123".to_string(),
                    "Test Task".to_string(),
                    "test".to_string(),
                    serde_json::json!({"input": "test"}),
                ));
            })
        });

        group.bench_function("task_execution", |b| {
            let task = Task::new(
                "task-123".to_string(),
                "Test Task".to_string(),
                "test".to_string(),
                serde_json::json!({"input": "test"}),
            );
            let executor = DefaultTaskExecutor { max_parallel: 4 };
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(executor.execute(&task));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_message_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("message_operations");

        group.bench_function("message_creation", |b| {
            b.iter(|| {
                black_box(Message::new(
                    "msg-123".to_string(),
                    MessageType::TaskRequest,
                    "agent-1".to_string(),
                    None,
                    serde_json::json!({"task": "test"}),
                ));
            })
        });

        group.bench_function("message_serialization", |b| {
            let message = Message::new(
                "msg-123".to_string(),
                MessageType::TaskRequest,
                "agent-1".to_string(),
                None,
                serde_json::json!({"task": "test"}),
            );
            b.iter(|| {
                black_box(serde_json::to_string(&message).unwrap());
            })
        });

        group.finish();
    }

    pub fn benchmark_port_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("port_operations");

        group.bench_function("port_creation", |b| {
            b.iter(|| {
                black_box(BasicPort::new("port-123".to_string(), "Test Port".to_string(), PortType::Output));
            })
        });

        group.bench_function("port_send_receive", |b| {
            let mut port = BasicPort::new("port-123".to_string(), "Test Port".to_string(), PortType::Bidirectional);
            port.initialize(PortConfig::new()).await.unwrap();
            let test_message = serde_json::json!({"test": "message"});
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(port.send(&test_message));
                }));
            })
        });

        group.finish();
    }

    pub fn benchmark_adapter_operations(c: &mut Criterion) {
        let mut group = c.benchmark_group("adapter_operations");

        group.bench_function("json_conversion", |b| {
            let adapter = JsonAdapter::new();
            let test_json = serde_json::json!({"test": "message"});
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(adapter.to_a2a(&test_json));
                }));
            })
        });

        group.bench_function("xml_conversion", |b| {
            let adapter = XmlAdapter::new();
            let test_xml = serde_json::json!("<test>message</test>");
            b.iter(|| {
                black_box(tokio::task::block_in_place(|| {
                    black_box(adapter.to_a2a(&test_xml));
                }));
            })
        });

        group.finish();
    }
}

#[cfg(feature = "all-adapters")]
criterion_group!(
    benches,
    benchmark_agent_operations,
    benchmark_task_operations,
    benchmark_message_operations,
    benchmark_port_operations,
    benchmark_adapter_operations
);
#[cfg(feature = "all-adapters")]
criterion_main!(benches);