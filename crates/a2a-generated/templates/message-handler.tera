// Message Handler Interface Template
// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Message handler trait for unified agent interface
#[async_trait]
pub trait MessageHandler: Send + Sync {
    /// Handle an incoming message
    async fn handle(&self, message: &ConvergedMessage) -> Result<MessageHandlerResult, MessageHandlerError>;

    /// Check if this handler can process the given message type
    fn can_handle(&self, message_type: &ConvergedMessageType) -> bool;

    /// Get handler priority
    fn priority(&self) -> HandlerPriority;

    /// Get handler name
    fn name(&self) -> &str;
}

/// Message handler result
#[derive(Debug, Clone, PartialEq)]
pub struct MessageHandlerResult {
    /// Response message (optional)
    pub response: Option<ConvergedMessage>,

    /// Processing status
    pub status: HandlerStatus,

    /// Processing metrics
    pub metrics: Option<ProcessingMetrics>,

    /// Next actions to take
    pub actions: Vec<HandlerAction>,

    /// Handler metadata
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

/// Handler status
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HandlerStatus {
    Success,
    PartialSuccess,
    Failed,
    Retry,
    Skip,
}

/// Handler actions
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HandlerAction {
    SendMessage(ConvergedMessage),
    ScheduleTask(String),
    CreateEvent(String),
    LogMessage(String),
    Retry(usize),
    Skip,
    Custom(String),
}

/// Processing metrics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProcessingMetrics {
    /// Processing time
    pub duration: std::time::Duration,

    /// Message size
    pub message_size: usize,

    /// Resource usage
    pub resource_usage: ResourceUsageMetrics,

    /// Processing errors
    pub errors: Vec<String>,

    /// Warnings
    pub warnings: Vec<String>,
}

/// Resource usage metrics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceUsageMetrics {
    /// CPU usage percentage
    pub cpu: f64,

    /// Memory usage percentage
    pub memory: f64,

    /// Network bytes sent
    pub network_sent: u64,

    /// Network bytes received
    pub network_received: u64,
}

/// Message handler error
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MessageHandlerError {
    InvalidMessage(String),
    HandlerNotFound(String),
    ProcessingError(String),
    TimeoutError,
    SecurityError(String),
    NetworkError(String),
}

impl std::fmt::Display for MessageHandlerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MessageHandlerError::InvalidMessage(msg) => write!(f, "Invalid message: {}", msg),
            MessageHandlerError::HandlerNotFound(msg) => write!(f, "Handler not found: {}", msg),
            MessageHandlerError::ProcessingError(msg) => write!(f, "Processing error: {}", msg),
            MessageHandlerError::TimeoutError => write!(f, "Timeout error"),
            MessageHandlerError::SecurityError(msg) => write!(f, "Security error: {}", msg),
            MessageHandlerError::NetworkError(msg) => write!(f, "Network error: {}", msg),
        }
    }
}

impl std::error::Error for MessageHandlerError {}

/// Message router for handling message routing
pub struct MessageRouter {
    /// Registered handlers
    handlers: Vec<Box<dyn MessageHandler>>,

    /// Message routing rules
    routing_rules: Vec<RoutingRule>,

    /// Handler registry
    handler_registry: HandlerRegistry,
}

impl MessageRouter {
    pub fn new() -> Self {
        Self {
            handlers: Vec::new(),
            routing_rules: Vec::new(),
            handler_registry: HandlerRegistry::new(),
        }
    }

    /// Register a message handler
    pub fn register_handler<H>(&mut self, handler: H)
    where
        H: MessageHandler + 'static,
    {
        let handler_name = handler.name().to_string();
        self.handler_registry.register(handler_name, Box::new(handler));

        // Also add to handlers list for priority-based selection
        if let Some(handler) = self.handler_registry.get_handler(&handler_name) {
            self.handlers.push(handler);
        }
    }

    /// Add a routing rule
    pub fn add_routing_rule(&mut self, rule: RoutingRule) {
        self.routing_rules.push(rule);
    }

    /// Route a message to appropriate handler
    pub async fn route(&self, message: &ConvergedMessage) -> Result<MessageHandlerResult, MessageHandlerError> {
        // Find appropriate handler based on message type and routing rules
        let handler = self.find_handler(message).await?;

        // Handle the message
        handler.handle(message).await
    }

    /// Find the best handler for a message
    async fn find_handler(&self, message: &ConvergedMessage) -> Result<&Box<dyn MessageHandler>, MessageHandlerError> {
        // Filter handlers that can handle this message type
        let capable_handlers: Vec<_> = self.handlers.iter()
            .filter(|h| h.can_handle(&message.envelope.message_type))
            .collect();

        if capable_handlers.is_empty() {
            return Err(MessageHandlerError::HandlerNotFound(
                format!("No handler found for message type: {:?}", message.envelope.message_type)
            ));
        }

        // Select handler based on priority
        let best_handler = capable_handlers.iter()
            .max_by_key(|h| h.priority())
            .unwrap();

        Ok(best_handler)
    }

    /// Get all registered handlers
    pub fn get_handlers(&self) -> &[Box<dyn MessageHandler>] {
        &self.handlers
    }

    /// Get handler by name
    pub fn get_handler(&self, name: &str) -> Option<&Box<dyn MessageHandler>> {
        self.handler_registry.get_handler(name)
    }
}

/// Handler registry for managing handlers by name
pub struct HandlerRegistry {
    handlers: HashMap<String, Box<dyn MessageHandler>>,
}

impl HandlerRegistry {
    pub fn new() -> Self {
        Self {
            handlers: HashMap::new(),
        }
    }

    pub fn register(&mut self, name: String, handler: Box<dyn MessageHandler>) {
        self.handlers.insert(name, handler);
    }

    pub fn get_handler(&self, name: &str) -> Option<&Box<dyn MessageHandler>> {
        self.handlers.get(name)
    }

    pub fn get_handler_mut(&mut self, name: &str) -> Option<&mut Box<dyn MessageHandler>> {
        self.handlers.get_mut(name)
    }

    pub fn list_handlers(&self) -> Vec<String> {
        self.handlers.keys().cloned().collect()
    }
}

/// Routing rule for message routing
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RoutingRule {
    /// Rule name
    pub name: String,

    /// Condition for rule matching
    pub condition: RoutingCondition,

    /// Target handler name
    pub target: String,

    /// Rule priority
    pub priority: u32,

    /// Rule metadata
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

/// Routing condition
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RoutingCondition {
    MessageType(ConvergedMessageType),
    MessageSource(String),
    MessageTarget(String),
    HeaderMatch(String, String),
    Custom(String),
}

/// Message handler factory
pub struct MessageHandlerFactory {
    handler_types: HashMap<String, Box<dyn HandlerFactory>>,
}

impl MessageHandlerFactory {
    pub fn new() -> Self {
        Self {
            handler_types: HashMap::new(),
        }
    }

    pub fn register_handler_type<H>(&mut self, name: String, factory: H)
    where
        H: HandlerFactory + 'static,
    {
        self.handler_types.insert(name, Box::new(factory));
    }

    pub fn create_handler(&self, name: &str, config: serde_json::Value) -> Result<Box<dyn MessageHandler>, MessageHandlerError> {
        if let Some(factory) = self.handler_types.get(name) {
            factory.create_handler(config)
                .map_err(|e| MessageHandlerError::ProcessingError(e.to_string()))
        } else {
            Err(MessageHandlerError::HandlerNotFound(format!("Unknown handler type: {}", name)))
        }
    }
}

/// Handler factory trait
#[async_trait]
pub trait HandlerFactory: Send + Sync {
    type Handler: MessageHandler;

    /// Create a new handler instance
    async fn create_handler(&self, config: serde_json::Value) -> Result<Self::Handler, String>;

    /// Get handler type name
    fn type_name(&self) -> &str;

    /// Get default configuration
    fn default_config(&self) -> serde_json::Value;
}

/// Built-in message handlers

/// Text message handler
pub struct TextMessageHandler {
    name: String,
    priority: HandlerPriority,
}

impl TextMessageHandler {
    pub fn new(name: String) -> Self {
        Self {
            name,
            priority: HandlerPriority::Normal,
        }
    }
}

#[async_trait]
impl MessageHandler for TextMessageHandler {
    async fn handle(&self, message: &ConvergedMessage) -> Result<MessageHandlerResult, MessageHandlerError> {
        match &message.payload.content {
            UnifiedContent::Text { content, metadata } => {
                // Process text content
                let response = Self::create_response(message, content, metadata)?;

                Ok(MessageHandlerResult {
                    response: Some(response),
                    status: HandlerStatus::Success,
                    metrics: Some(ProcessingMetrics {
                        duration: std::time::Duration::from_millis(10),
                        message_size: content.len(),
                        resource_usage: ResourceUsageMetrics {
                            cpu: 0.1,
                            memory: 1.0,
                            network_sent: 0,
                            network_received: 0,
                        },
                        errors: Vec::new(),
                        warnings: Vec::new(),
                    }),
                    actions: Vec::new(),
                    metadata: None,
                })
            }
            _ => Err(MessageHandlerError::InvalidMessage("Expected text content".to_string())),
        }
    }

    fn can_handle(&self, message_type: &ConvergedMessageType) -> bool {
        matches!(message_type, ConvergedMessageType::Direct | ConvergedMessageType::Task)
    }

    fn priority(&self) -> HandlerPriority {
        self.priority
    }

    fn name(&self) -> &str {
        &self.name
    }
}

impl TextMessageHandler {
    fn create_response(original: &ConvergedMessage, content: &str, metadata: &Option<HashMap<String, serde_json::Value>>) -> Result<ConvergedMessage, MessageHandlerError> {
        let response_content = format!("Processed: {}", content);

        Ok(ConvergedMessage::text(
            format!("{}-response", original.message_id),
            original.source.clone(),
            response_content,
        ))
    }
}

/// Task message handler
pub struct TaskMessageHandler {
    name: String,
    priority: HandlerPriority,
    executor: TaskExecutor,
}

impl TaskMessageHandler {
    pub fn new(name: String) -> Self {
        Self {
            name,
            priority: HandlerPriority::High,
            executor: TaskExecutor::new(),
        }
    }
}

#[async_trait]
impl MessageHandler for TaskMessageHandler {
    async fn handle(&self, message: &ConvergedMessage) -> Result<MessageHandlerResult, MessageHandlerError> {
        // Extract task information from message
        let task = self.extract_task(message)?;

        // Execute the task
        let result = self.executor.execute(&task).await?;

        // Create response
        let response = Self::create_response(&task, result)?;

        Ok(MessageHandlerResult {
            response: Some(response),
            status: HandlerStatus::Success,
            metrics: Some(ProcessingMetrics {
                duration: task.estimated_time.unwrap_or_else(|| std::time::Duration::from_secs(1)),
                message_size: serde_json::to_string(&task).unwrap().len(),
                resource_usage: ResourceUsageMetrics {
                    cpu: 0.2,
                    memory: 2.0,
                    network_sent: 0,
                    network_received: 0,
                },
                errors: Vec::new(),
                warnings: Vec::new(),
            }),
            actions: vec![
                HandlerAction::CreateEvent("task_completed".to_string()),
                HandlerAction::LogMessage("Task completed successfully".to_string()),
            ],
            metadata: None,
        })
    }

    fn can_handle(&self, message_type: &ConvergedMessageType) -> bool {
        matches!(message_type, ConvergedMessageType::Task)
    }

    fn priority(&self) -> HandlerPriority {
        self.priority
    }

    fn name(&self) -> &str {
        &self.name
    }
}

impl TaskMessageHandler {
    fn extract_task(&self, message: &ConvergedMessage) -> Result<Task, MessageHandlerError> {
        // Extract task from message payload
        // This would involve parsing the message content
        // For now, create a dummy task
        Ok(Task::new(
            format!("task-{}", message.message_id),
            "Extracted Task".to_string(),
            "extracted".to_string(),
            serde_json::json!({"input": message.clone()}),
        ))
    }

    fn create_response(&self, task: &Task, result: TaskResult) -> Result<ConvergedMessage, MessageHandlerError> {
        let response_content = serde_json::to_string(&result)
            .map_err(|e| MessageHandlerError::ProcessingError(e.to_string()))?;

        Ok(ConvergedMessage::text(
            format!("{}-result", task.id),
            task.executor.clone(),
            response_content,
        ))
    }
}

/// Task executor for handling task execution
pub struct TaskExecutor {
    max_concurrent: usize,
}

impl TaskExecutor {
    pub fn new() -> Self {
        Self { max_concurrent: 4 }
    }

    pub async fn execute(&self, task: &Task) -> Result<TaskResult, String> {
        // Simulate task execution
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;

        Ok(TaskResult {
            task_id: task.id.clone(),
            status: TaskStatus::Completed,
            result: serde_json::json!({"output": "Task completed"}),
            errors: Vec::new(),
            metadata: None,
        })
    }
}

/// Default message handler factory
pub struct DefaultMessageHandlerFactory;

impl DefaultMessageHandlerFactory {
    pub fn new() -> Box<Self> {
        Box::new(Self)
    }

    pub fn create_handlers() -> Vec<Box<dyn MessageHandler>> {
        vec![
            Box::new(TextMessageHandler::new("text_handler".to_string())),
            Box::new(TaskMessageHandler::new("task_handler".to_string())),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_text_message_handler() {
        let handler = TextMessageHandler::new("test_text".to_string());

        let message = ConvergedMessage::text(
            "msg-123".to_string(),
            "agent-1".to_string(),
            "Hello, world!".to_string(),
        );

        let result = handler.handle(&message).await.unwrap();
        assert!(result.response.is_some());
        assert_eq!(result.status, HandlerStatus::Success);
    }

    #[tokio::test]
    async fn test_message_router() {
        let mut router = MessageRouter::new();
        router.register_handler(TextMessageHandler::new("test_text".to_string()));

        let message = ConvergedMessage::text(
            "msg-456".to_string(),
            "agent-1".to_string(),
            "Hello, router!".to_string(),
        );

        let result = router.route(&message).await.unwrap();
        assert!(result.response.is_some());
        assert_eq!(result.status, HandlerStatus::Success);
    }

    #[tokio::test]
    async fn test_handler_factory() {
        let mut factory = MessageHandlerFactory::new();
        factory.register_handler_type("text".to_string(), DefaultMessageHandlerFactory::new());

        let config = serde_json::json!({});
        let handler = factory.create_handler("text", config).unwrap();

        assert!(handler.can_handle(&ConvergedMessageType::Direct));
    }
}