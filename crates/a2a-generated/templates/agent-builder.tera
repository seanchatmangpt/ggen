// Unified Agent Builder Template
// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

// Unified agent builder
pub struct UnifiedAgentBuilder {
    identity: AgentIdentity,
    capabilities: AgentCapabilities,
    lifecycle: AgentLifecycle,
    communication: AgentCommunication,
    execution: AgentExecution,
    security: AgentSecurity,
    extensions: Option<HashMap<String, serde_json::Value>>,
}

impl UnifiedAgentBuilder {
    pub fn new(id: String, name: String, agent_type: String, namespace: String) -> Self {
        Self {
            identity: AgentIdentity {
                id,
                name,
                agent_type,
                version: "{{ default_version }}".to_string(),
                namespace,
                tags: None,
            },
            capabilities: AgentCapabilities {
                primary: Vec::new(),
                secondary: None,
                protocols: vec![{% for protocol in default_protocols %}AgentProtocol::{{ protocol | upper }}, {% endfor %}],
                formats: vec![{% for format in default_formats %}DataFormat::{{ format.name | upper }}, {% endfor %}],
                message_types: vec![{% for msg_type in default_message_types %}ConvergedMessageType::{{ msg_type | upper }}, {% endfor %}],
                qos_levels: vec![{% for qos in default_qos_levels %}QoSLevel::{{ qos.name | upper }}, {% endfor %}],
                constraints: None,
            },
            lifecycle: AgentLifecycle {
                state: AgentState::Created,
                state_history: Vec::new(),
                health: AgentHealth {
                    status: HealthStatus::Healthy,
                    last_check: Utc::now(),
                    check_interval: std::time::Duration::from_secs(30),
                    metrics: None,
                    warnings: None,
                    errors: None,
                },
                metrics: None,
                configuration: AgentConfiguration {
                    parameters: HashMap::new(),
                    version: "{{ default_version }}".to_string(),
                    timestamp: Utc::now(),
                    source: None,
                    validation: None,
                },
                dependencies: None,
                timeouts: None,
            },
            communication: AgentCommunication {
                endpoints: Vec::new(),
                protocols: vec![{% for protocol in default_protocols %}AgentProtocol::{{ protocol | upper }}, {% endfor %}],
                handlers: None,
                security: None,
                qos: CommunicationQoS {
                    reliability: ReliabilityLevel::AtLeastOnce,
                    latency: None,
                    throughput: None,
                    ordering: None,
                    flow_control: None,
                },
            },
            execution: AgentExecution {
                mode: ExecutionMode::Synchronous,
                parameters: HashMap::new(),
                context: None,
                strategy: None,
                monitoring: None,
                policies: None,
            },
            security: AgentSecurity {
                authentication: AuthenticationConfig {
                    methods: vec![{% for auth_method in default_auth_methods %}AuthenticationMethod::{{ auth_method | upper }}, {% endfor %}],
                    providers: None,
                    metadata: None,
                },
                authorization: AuthorizationConfig {
                    model: AuthorizationModel::Rbac,
                    policies: Vec::new(),
                    roles: None,
                    metadata: None,
                },
                encryption: EncryptionConfig {
                    algorithms: vec![{% for algorithm in default_algorithms %}EncryptionAlgorithm::{{ algorithm | upper }}, {% endfor %}],
                    keys: Vec::new(),
                    modes: vec![{% for mode in default_encryption_modes %}EncryptionMode::{{ mode | upper }}, {% endfor %}],
                    metadata: None,
                },
                audit: AuditConfig {
                    events: vec![{% for audit_event in default_audit_events %}AuditEvent::{{ audit_event | upper }}, {% endfor %}],
                    destinations: Vec::new(),
                    retention: AuditRetention {
                        period: std::time::Duration::from_secs(365 * 24 * 60 * 60),
                        policy: RetentionPolicy::TimeBased,
                        metadata: None,
                    },
                    metadata: None,
                },
                compliance: None,
                policies: None,
            },
            extensions: None,
        }
    }

    pub fn with_capability(mut self, capability: Capability) -> Self {
        self.capabilities.primary.push(capability);
        self
    }

    pub fn with_protocol(mut self, protocol: AgentProtocol) -> Self {
        self.capabilities.protocols.push(protocol);
        self
    }

    pub fn with_message_type(mut self, message_type: ConvergedMessageType) -> Self {
        self.capabilities.message_types.push(message_type);
        self
    }

    pub fn with_endpoint(mut self, endpoint: CommunicationEndpoint) -> Self {
        self.communication.endpoints.push(endpoint);
        self
    }

    pub fn with_policy(mut self, policy: SecurityPolicy) -> Self {
        if let Some(policies) = &mut self.security.policies {
            policies.access_control.push(policy);
        } else {
            self.security.policies = Some(SecurityPolicies {
                access_control: vec![policy],
                data_protection: Vec::new(),
                network_security: Vec::new(),
                system_security: Vec::new(),
                custom: None,
            });
        }
        self
    }

    pub fn with_extension(mut self, key: String, value: serde_json::Value) -> Self {
        if let Some(extensions) = &mut self.extensions {
            extensions.insert(key, value);
        } else {
            let mut extensions = HashMap::new();
            extensions.insert(key, value);
            self.extensions = Some(extensions);
        }
        self
    }

    pub fn with_auth_method(mut self, method: AuthenticationMethod) -> Self {
        self.security.authentication.methods.push(method);
        self
    }

    pub fn with_role(mut self, role: AuthorizationRole) -> Self {
        if let Some(roles) = &mut self.security.authorization.roles {
            roles.push(role);
        } else {
            self.security.authorization.roles = Some(vec![role]);
        }
        self
    }

    pub fn with_resource_constraint(mut self, constraint: ResourceConstraints) -> Self {
        self.capabilities.constraints = Some(constraint);
        self
    }

    pub fn with_health_check(mut self, interval: std::time::Duration) -> Self {
        self.lifecycle.health.check_interval = interval;
        self
    }

    pub fn with_timeout(mut self, timeout: AgentTimeouts) -> Self {
        self.lifecycle.timeouts = Some(timeout);
        self
    }

    pub fn build(self) -> UnifiedAgent {
        UnifiedAgent {
            identity: self.identity,
            capabilities: self.capabilities,
            lifecycle: self.lifecycle,
            communication: self.communication,
            execution: self.execution,
            security: self.security,
            extensions: self.extensions,
        }
    }
}

// Helper implementations for common patterns
impl UnifiedAgent {
    /// Create a basic agent
    pub fn basic(id: String, name: String, agent_type: String) -> Self {
        UnifiedAgentBuilder::new(id, name, agent_type, "default".to_string()).build()
    }

    /// Create an agent with specific capabilities
    pub fn with_capabilities(id: String, name: String, agent_type: String, capabilities: Vec<Capability>) -> Self {
        let mut builder = UnifiedAgentBuilder::new(id, name, agent_type, "default".to_string());
        for capability in capabilities {
            builder = builder.with_capability(capability);
        }
        builder.build()
    }

    /// Create an agent with authentication
    pub fn with_auth(id: String, name: String, agent_type: String, methods: Vec<AuthenticationMethod>) -> Self {
        let mut builder = UnifiedAgentBuilder::new(id, name, agent_type, "default".to_string());
        for method in methods {
            builder = builder.with_auth_method(method);
        }
        builder.build()
    }

    /// Add a message type to the agent
    pub fn with_message_type(mut self, message_type: ConvergedMessageType) -> Self {
        self.capabilities.message_types.push(message_type);
        self
    }

    /// Add a protocol to the agent
    pub fn with_protocol(mut self, protocol: AgentProtocol) -> Self {
        self.capabilities.protocols.push(protocol);
        self
    }

    /// Add an endpoint to the agent
    pub fn with_endpoint(mut self, endpoint: CommunicationEndpoint) -> Self {
        self.communication.endpoints.push(endpoint);
        self
    }

    /// Add a security policy to the agent
    pub fn with_policy(mut self, policy: SecurityPolicy) -> Self {
        if let Some(policies) = &mut self.security.policies {
            policies.access_control.push(policy);
        } else {
            self.security.policies = Some(SecurityPolicies {
                access_control: vec![policy],
                data_protection: Vec::new(),
                network_security: Vec::new(),
                system_security: Vec::new(),
                custom: None,
            });
        }
        self
    }

    /// Initialize the agent
    pub async fn initialize(&mut self) -> Result<(), AgentError> {
        // Set initial state
        self.lifecycle.state = AgentState::Initializing;

        // Validate configuration
        self.validate()?;

        // Initialize security
        self.initialize_security().await?;

        // Initialize communication
        self.initialize_communication().await?;

        // Set to ready state
        self.lifecycle.state = AgentState::Ready;
        self.lifecycle.state_history.push(AgentStateTransition {
            from: AgentState::Initializing,
            to: AgentState::Ready,
            timestamp: Utc::now(),
            reason: Some("Initialization completed".to_string()),
            details: None,
        });

        Ok(())
    }

    /// Start the agent
    pub async fn start(&mut self) -> Result<(), AgentError> {
        if self.lifecycle.state != AgentState::Ready {
            return Err(AgentError::InvalidState(format!("Cannot start agent in state: {:?}", self.lifecycle.state)));
        }

        self.lifecycle.state = AgentState::Busy;
        self.lifecycle.state_history.push(AgentStateTransition {
            from: AgentState::Ready,
            to: AgentState::Busy,
            timestamp: Utc::now(),
            reason: Some("Agent started".to_string()),
            details: None,
        });

        // Start execution components
        self.start_execution().await?;

        Ok(())
    }

    /// Stop the agent
    pub async fn stop(&mut self) -> Result<(), AgentError> {
        if self.lifecycle.state == AgentState::Terminated {
            return Err(AgentError::InvalidState("Agent already terminated".to_string()));
        }

        // Stop execution
        self.stop_execution().await?;

        self.lifecycle.state = AgentState::Terminated;
        self.lifecycle.state_history.push(AgentStateTransition {
            from: AgentState::Busy,
            to: AgentState::Terminated,
            timestamp: Utc::now(),
            reason: Some("Agent stopped".to_string()),
            details: None,
        });

        Ok(())
    }

    /// Restart the agent
    pub async fn restart(&mut self) -> Result<(), AgentError> {
        self.stop().await?;
        self.initialize().await?;
        self.start().await
    }

    /// Get agent status
    pub fn get_status(&self) -> AgentState {
        self.lifecycle.state
    }

    /// Get agent health
    pub fn get_health(&self) -> &AgentHealth {
        &self.lifecycle.health
    }

    /// Validate the agent configuration
    pub fn validate(&self) -> Result<(), AgentError> {
        if self.identity.id.is_empty() {
            return Err(AgentError::InvalidConfiguration("Agent ID cannot be empty".to_string()));
        }

        if self.identity.name.is_empty() {
            return Err(AgentError::InvalidConfiguration("Agent name cannot be empty".to_string()));
        }

        if self.capabilities.primary.is_empty() {
            return Err(AgentError::InvalidConfiguration("Agent must have at least one primary capability".to_string()));
        }

        if self.capabilities.protocols.is_empty() {
            return Err(AgentError::InvalidConfiguration("Agent must support at least one protocol".to_string()));
        }

        Ok(())
    }

    /// Initialize security components
    async fn initialize_security(&mut self) -> Result<(), AgentError> {
        // Initialize authentication
        for method in &self.security.authentication.methods {
            // Implementation depends on authentication method
            match method {
                AuthenticationMethod::Token => {
                    // Initialize token-based authentication
                }
                AuthenticationMethod::Password => {
                    // Initialize password-based authentication
                }
                // Other methods...
            }
        }

        // Initialize authorization
        // Implementation for role-based access control

        // Initialize encryption
        for algorithm in &self.security.encryption.algorithms {
            // Initialize encryption keys and algorithms
        }

        Ok(())
    }

    /// Initialize communication components
    async fn initialize_communication(&mut self) -> Result<(), AgentError> {
        // Initialize communication endpoints
        for endpoint in &self.communication.endpoints {
            // Setup communication channels
            match endpoint.endpoint_type {
                EndpointType::Rest => {
                    // Initialize REST endpoint
                }
                EndpointType::WebSocket => {
                    // Initialize WebSocket connection
                }
                EndpointType::Grpc => {
                    // Initialize gRPC endpoint
                }
                // Other types...
            }
        }

        // Setup message handlers
        if let Some(handlers) = &mut self.communication.handlers {
            // Initialize message handlers
        }

        Ok(())
    }

    /// Start execution components
    async fn start_execution(&mut self) -> Result<(), AgentError> {
        // Start execution monitoring
        if let Some(monitoring) = &mut self.execution.monitoring {
            // Start monitoring threads/tasks
        }

        // Start execution policies
        if let Some(policies) = &self.execution.policies {
            // Start policy enforcement
        }

        Ok(())
    }

    /// Stop execution components
    async fn stop_execution(&mut self) -> Result<(), AgentError> {
        // Stop monitoring
        self.execution.monitoring = None;

        // Stop policy enforcement
        // Cleanup execution resources

        Ok(())
    }
}

/// Agent error types
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AgentError {
    InvalidConfiguration(String),
    InvalidState(String),
    SecurityError(String),
    CommunicationError(String),
    ExecutionError(String),
    TimeoutError(String),
}

impl std::fmt::Display for AgentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AgentError::InvalidConfiguration(msg) => write!(f, "Invalid configuration: {}", msg),
            AgentError::InvalidState(msg) => write!(f, "Invalid state: {}", msg),
            AgentError::SecurityError(msg) => write!(f, "Security error: {}", msg),
            AgentError::CommunicationError(msg) => write!(f, "Communication error: {}", msg),
            AgentError::ExecutionError(msg) => write!(f, "Execution error: {}", msg),
            AgentError::TimeoutError(msg) => write!(f, "Timeout error: {}", msg),
        }
    }
}

impl std::error::Error for AgentError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unified_agent_creation() {
        let agent = UnifiedAgent::basic(
            "agent-123".to_string(),
            "Test Agent".to_string(),
            "test".to_string(),
        );

        assert_eq!(agent.identity.id, "agent-123");
        assert_eq!(agent.identity.name, "Test Agent");
        assert_eq!(agent.identity.agent_type, "test");
        assert_eq!(agent.identity.namespace, "default");
        assert_eq!(agent.capabilities.protocols.len(), 1); // Default protocol
    }

    #[test]
    fn test_agent_with_capabilities() {
        let capability = Capability {
            name: "text-processing".to_string(),
            version: "1.0.0".to_string(),
            description: Some("Process text content".to_string()),
            requirements: None,
            metadata: None,
        };

        let agent = UnifiedAgent::with_capabilities(
            "agent-456".to_string(),
            "Smart Agent".to_string(),
            "smart".to_string(),
            vec![capability],
        );

        assert_eq!(agent.capabilities.primary.len(), 1);
        assert_eq!(agent.capabilities.primary[0].name, "text-processing");
    }

    #[tokio::test]
    async fn test_agent_lifecycle() {
        let mut agent = UnifiedAgent::basic(
            "lifecycle-agent".to_string(),
            "Lifecycle Agent".to_string(),
            "lifecycle".to_string(),
        );

        // Test initialization
        assert!(agent.initialize().await.is_ok());
        assert_eq!(agent.get_status(), AgentState::Ready);

        // Test start
        assert!(agent.start().await.is_ok());
        assert_eq!(agent.get_status(), AgentState::Busy);

        // Test stop
        assert!(agent.stop().await.is_ok());
        assert_eq!(agent.get_status(), AgentState::Terminated);
    }

    #[test]
    fn test_agent_validation() {
        let valid_agent = UnifiedAgent::basic(
            "valid-agent".to_string(),
            "Valid Agent".to_string(),
            "test".to_string(),
        );

        assert!(valid_agent.validate().is_ok());

        let mut invalid_agent = valid_agent;
        invalid_agent.identity.id = "".to_string();
        assert!(invalid_agent.validate().is_err());
    }
}