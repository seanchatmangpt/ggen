// Unified Agent Interface Template
// Generated by ggen from A2A ontology
// Do not edit - regenerate with: ggen sync

use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Unified convergent agent interface eliminating {{ redundancy_percent }}% redundancy
///
/// This interface consolidates basic and rich agent patterns into a single,
/// extensible format that maintains backward compatibility while dramatically
/// reducing code duplication and semantic overlap.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UnifiedAgent {
    /// Core agent identity (immutable)
    pub identity: AgentIdentity,

    /// Unified agent capabilities eliminating redundancy
    pub capabilities: AgentCapabilities,

    /// Agent lifecycle and state management
    pub lifecycle: AgentLifecycle,

    /// Agent communication and messaging
    pub communication: AgentCommunication,

    /// Agent execution and processing
    pub execution: AgentExecution,

    /// Agent security and access control
    pub security: AgentSecurity,

    /// Extensible agent metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extensions: Option<HashMap<String, serde_json::Value>>,
}

/// Core agent identity
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct AgentIdentity {
    /// Unique agent identifier
    pub id: String,

    /// Human-readable agent name
    pub name: String,

    /// Agent type classification
    #[serde(rename = "agentType")]
    pub agent_type: String,

    /// Agent version
    pub version: String,

    /// Agent namespace
    pub namespace: String,

    /// Agent tags for classification
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// Unified agent capabilities eliminating redundancy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentCapabilities {
    /// Primary agent capabilities
    pub primary: Vec<Capability>,

    /// Secondary agent capabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary: Option<Vec<Capability>>,

    /// Agent protocols supported
    pub protocols: Vec<AgentProtocol>,

    /// Data formats supported
    pub formats: Vec<DataFormat>,

    /// Message types handled
    pub message_types: Vec<ConvergedMessageType>,

    /// Quality of service levels
    #[serde(rename = "qosLevels")]
    pub qos_levels: Vec<QoSLevel>,

    /// Resource constraints
    #[serde(skip_serializing_if = "Option::is_none")]
    pub constraints: Option<ResourceConstraints>,
}

/// Agent capability definition
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Capability {
    /// Capability name
    pub name: String,

    /// Capability version
    pub version: String,

    /// Capability description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Capability requirements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirements: Option<HashMap<String, serde_json::Value>>,

    /// Capability metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

{% for protocol in protocols %}
/// Agent protocols supported
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AgentProtocol {
    {% for p in protocol.enum_values %}
    {{ p | upper }},
    {% endfor %}
}
{% endfor %}

/// Data formats supported
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DataFormat {
    {% for format in data_formats %}
    {{ format.name | upper }},
    {% endfor %}
}

/// Quality of service levels
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum QoSLevel {
    {% for qos in qos_levels %}
    {{ qos.name | upper }},
    {% endfor %}
}

/// Resource constraints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceConstraints {
    /// Memory constraints
    pub memory: Option<ResourceLimit>,

    /// CPU constraints
    pub cpu: Option<ResourceLimit>,

    /// Storage constraints
    pub storage: Option<ResourceLimit>,

    /// Network constraints
    pub network: Option<ResourceLimit>,

    /// Concurrent operations
    #[serde(rename = "concurrentOps")]
    pub concurrent_ops: Option<ResourceLimit>,
}

/// Resource limit definition
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceLimit {
    /// Minimum resource requirement
    pub min: Option<u64>,

    /// Maximum resource limit
    pub max: Option<u64>,

    /// Default resource allocation
    pub default: Option<u64>,

    /// Resource unit
    pub unit: ResourceUnit,
}

/// Resource units
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ResourceUnit {
    {% for unit in resource_units %}
    {{ unit.name | upper }},
    {% endfor %}
}

/// Agent lifecycle state
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentLifecycle {
    /// Current lifecycle state
    pub state: AgentState,

    /// Lifecycle state history
    #[serde(rename = "stateHistory")]
    pub state_history: Vec<AgentStateTransition>,

    /// Health status
    pub health: AgentHealth,

    /// Performance metrics
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metrics: Option<AgentMetrics>,

    /// Configuration and settings
    pub configuration: AgentConfiguration,

    /// Dependencies and requirements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<AgentDependencies>,

    /// Lifecycle timeout information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeouts: Option<AgentTimeouts>,
}

/// Agent states
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AgentState {
    {% for state in agent_states %}
    {{ state.name | upper }},
    {% endfor %}
}

/// Agent health status
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct AgentHealth {
    /// Overall health status
    pub status: HealthStatus,

    /// Health check timestamp
    #[serde(rename = "lastCheck")]
    pub last_check: DateTime<Utc>,

    /// Health check intervals
    #[serde(rename = "checkInterval")]
    pub check_interval: std::time::Duration,

    /// Health metrics
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metrics: Option<HealthMetrics>,

    /// Health warnings
    #[serde(skip_serializing_if = "Option::is_none")]
    pub warnings: Option<Vec<HealthWarning>>,

    /// Health errors
    #[serde(skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<HealthError>>,
}

/// Health status
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum HealthStatus {
    {% for status in health_statuses %}
    {{ status.name | upper }},
    {% endfor %}
}

/// Agent security interface
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentSecurity {
    /// Authentication configuration
    pub authentication: AuthenticationConfig,

    /// Authorization configuration
    pub authorization: AuthorizationConfig,

    /// Encryption configuration
    pub encryption: EncryptionConfig,

    /// Audit configuration
    pub audit: AuditConfig,

    /// Compliance configuration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compliance: Option<ComplianceConfig>,

    /// Security policies
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<SecurityPolicies>,
}