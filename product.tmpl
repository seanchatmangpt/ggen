Frontmatter { to: None, from: None, force: false, unless_exists: false, inject: false, before: None, after: None, prepend: false, append: false, at_line: None, eof_last: false, skip_if: None, sh_before: None, sh_after: None, base: None, prefixes: {}, rdf_inline: [], rdf: [], sparql: {}, vars: {}, backup: None, idempotent: false, shape: [], determinism: None }
---
---
to: "src/models/product.rs"
vars:
  - name: "product_id"
    type: "string"
    description: "Unique identifier for the product"
  - name: "product_name"
    type: "string"
    description: "Name of the product"
  - name: "product_price"
    type: "number"
    description: "Price of the product"
rdf:
  - "rdf/product_schema.ttl"
sparql:
  product_query: "SELECT ?product ?id ?name ?price WHERE { ?product <http://schema.org/id> ?id . ?product <http://schema.org/name> ?name . ?product <http://schema.org/price> ?price }"
  validation_query: "SELECT ?product WHERE { ?product <http://schema.org/id> ?id . FILTER(BOUND(?id)) }"
---
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub struct Product {
    pub id: String,
    pub name: String,
    pub price: f64,
}

impl Product {
    /// Creates a new Product instance
    pub fn new(id: String, name: String, price: f64) -> Self {
        Product { id, name, price }
    }

    /// Validates that the product has a valid ID
    pub fn validate_id(&self) -> bool {
        !self.id.is_empty()
    }

    /// Validates that the product has a valid price
    pub fn validate_price(&self) -> bool {
        self.price >= 0.0
    }

    /// Validates that the product has a valid name
    pub fn validate_name(&self) -> bool {
        !self.name.is_empty()
    }

    /// Performs complete validation of the product
    pub fn is_valid(&self) -> bool {
        self.validate_id() && self.validate_price() && self.validate_name()
    }
}

impl fmt::Display for Product {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Product {{ id: {}, name: {}, price: {} }}", self.id, self.name, self.price)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_product_creation() {
        let product = Product::new(
            "123".to_string(),
            "Test Product".to_string(),
            29.99
        );
        assert_eq!(product.id, "123");
        assert_eq!(product.name, "Test Product");
        assert_eq!(product.price, 29.99);
    }

    #[test]
    fn test_product_validation() {
        let valid_product = Product::new(
            "123".to_string(),
            "Test Product".to_string(),
            29.99
        );
        assert!(valid_product.is_valid());

        let invalid_product = Product::new(
            "".to_string(),
            "Test Product".to_string(),
            29.99
        );
        assert!(!invalid_product.is_valid());
    }
}