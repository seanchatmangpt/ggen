@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix pl: <https://ggen.dev/pattern-language#> .
@prefix sync: <https://ggen.dev/sync-patterns#> .
@prefix agi: <https://ggen.dev/agi#> .

# =============================================================================
# PATTERN LANGUAGE ONTOLOGY SCHEMA
# =============================================================================

# Core Classes
pl:Pattern a rdfs:Class ;
    rdfs:label "Pattern" ;
    rdfs:comment "A recurring solution to a recurring problem in code synchronization" .

pl:PatternCategory a rdfs:Class ;
    rdfs:label "Pattern Category" ;
    rdfs:comment "A grouping of related patterns" .

pl:Force a rdfs:Class ;
    rdfs:label "Force" ;
    rdfs:comment "A tension or pressure that creates a problem" .

pl:Connection a rdfs:Class ;
    rdfs:label "Connection" ;
    rdfs:comment "A relationship between two patterns" .

pl:Example a rdfs:Class ;
    rdfs:label "Example" ;
    rdfs:comment "A concrete example of pattern application" .

pl:AntiPattern a rdfs:Class ;
    rdfs:label "Anti-Pattern" ;
    rdfs:comment "A common mistake to avoid" .

pl:Term a rdfs:Class ;
    rdfs:label "Term" ;
    rdfs:comment "A glossary term" .

# Properties
pl:hasNumber a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:integer ;
    rdfs:comment "Pattern number for ordering" .

pl:hasConfidence a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:integer ;
    rdfs:comment "Confidence level: 1=emerging, 2=established, 3=fundamental" .

pl:hasCategory a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range pl:PatternCategory .

pl:hasContext a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "The situation where this pattern applies" .

pl:hasProblem a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "The core problem statement" .

pl:hasSolution a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "The Therefore statement" .

pl:hasForce a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range pl:Force .

pl:hasConnection a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range pl:Connection .

pl:hasExample a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range pl:Example .

pl:hasImplementation a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "How ggen sync implements this pattern" .

pl:hasFlag a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "CLI flag that invokes this pattern" .

pl:hasManifestSection a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range xsd:string ;
    rdfs:comment "Manifest section that configures this pattern" .

pl:connectsTo a rdf:Property ;
    rdfs:domain pl:Connection ;
    rdfs:range pl:Pattern .

pl:connectionType a rdf:Property ;
    rdfs:domain pl:Connection ;
    rdfs:range xsd:string ;
    rdfs:comment "Type: supports, enables, modifies, requires" .

pl:connectionReason a rdf:Property ;
    rdfs:domain pl:Connection ;
    rdfs:range xsd:string .

pl:hasCodeRef a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range pl:CodeReference ;
    rdfs:comment "Reference to implementation source code" .

pl:CodeReference a rdfs:Class ;
    rdfs:label "Code Reference" ;
    rdfs:comment "A reference to source code that implements a pattern" .

pl:refFile a rdf:Property ;
    rdfs:domain pl:CodeReference ;
    rdfs:range xsd:string ;
    rdfs:comment "File path relative to project root" .

pl:refLine a rdf:Property ;
    rdfs:domain pl:CodeReference ;
    rdfs:range xsd:integer ;
    rdfs:comment "Line number in the file" .

pl:refDescription a rdf:Property ;
    rdfs:domain pl:CodeReference ;
    rdfs:range xsd:string ;
    rdfs:comment "Description of what this code does" .

pl:refLayer a rdf:Property ;
    rdfs:domain pl:CodeReference ;
    rdfs:range xsd:string ;
    rdfs:comment "Architectural layer: cli, integration, domain" .

# =============================================================================
# PATTERN CATEGORIES
# =============================================================================

sync:FoundationCategory a pl:PatternCategory ;
    rdfs:label "Foundation Patterns" ;
    pl:categoryOrder 1 ;
    pl:categoryDescription "These patterns establish the fundamental structure and philosophy of code synchronization. They are the largest-scale patterns, setting the context for everything that follows." ;
    pl:categorySlug "foundation" .

sync:KnowledgeCategory a pl:PatternCategory ;
    rdfs:label "Knowledge Patterns" ;
    pl:categoryOrder 2 ;
    pl:categoryDescription "These patterns govern how domain knowledge flows through the system and becomes code. They form the heart of the generation pipeline." ;
    pl:categorySlug "knowledge" .

sync:SafetyCategory a pl:PatternCategory ;
    rdfs:label "Safety Patterns" ;
    pl:categoryOrder 3 ;
    pl:categoryDescription "These patterns protect the system, developers, and outputs from harm. They provide safeguards, previews, and escape hatches." ;
    pl:categorySlug "safety" .

sync:IntegrityCategory a pl:PatternCategory ;
    rdfs:label "Integrity Patterns" ;
    pl:categoryOrder 4 ;
    pl:categoryDescription "These patterns ensure trust, reproducibility, and auditability in generated outputs." ;
    pl:categorySlug "integrity" .

sync:SelectiveCategory a pl:PatternCategory ;
    rdfs:label "Selective Patterns" ;
    pl:categoryOrder 5 ;
    pl:categoryDescription "These patterns allow focused, intentional synchronization for specific needs." ;
    pl:categorySlug "selective" .

# =============================================================================
# FOUNDATION PATTERNS (1-3)
# =============================================================================

sync:SingleCommand a pl:Pattern ;
    rdfs:label "THE SINGLE COMMAND" ;
    pl:hasNumber 1 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:FoundationCategory ;
    pl:hasSlug "single-command" ;
    pl:hasEvocativeImage "A narrow gate that opens into a wide garden." ;
    pl:hasContext """You are building a code generation system. Over time, the system has accumulated many commands: generate, validate, template, init, update, check, build. Each command has its own flags, its own behavior, its own mental model. Users must learn which command to use when, how commands interact, and what order to run them in. The cognitive load grows. The documentation grows. The confusion grows.""" ;
    pl:hasProblem "A code generation system with many commands forces users to become experts in the tool rather than experts in their domain." ;
    pl:hasSolution """Provide exactly one command that does everything. Let the system figure out what \"everything\" means based on the manifest and the flags provided.

The command should:
- Be simple to type and remember
- Accept optional flags that modify behavior
- Derive all other decisions from the manifest
- Execute the complete pipeline atomically""" ;
    pl:hasImplementation """In ggen v5, the single command is:

```bash
ggen sync
```

That's it. There are no other commands. Everything happens through `sync`.

The command accepts flags that modify its behavior without changing its nature:
- `--manifest PATH` — Point to a different manifest file
- `--dry-run` — Preview without writing
- `--validate-only` — Check without generating
- `--force` — Overwrite protected files
- `--audit` — Record what happened
- `--rule NAME` — Run only one rule
- `--verbose` — Show detailed output
- `--format json` — Output as JSON
- `--timeout MS` — Set execution limit""" ;
    pl:hasFlag "--manifest" ;
    pl:hasFlag "--dry-run" ;
    pl:hasFlag "--force" ;
    pl:hasFlag "--audit" ;
    pl:hasFlag "--rule" ;
    pl:hasDeepPattern """THE SINGLE COMMAND is not just about reducing commands. It is about shifting cognitive load.

In a multi-command system, the user must hold the system's structure in their head: \"First I validate, then I generate, unless I need to update, in which case...\"

In a single-command system, the user holds only their intent: \"I want my code synchronized with my knowledge.\"

The system handles the structure. The user handles the domain.

This is the liberation that THE SINGLE COMMAND provides: freedom from the tool to focus on the work.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 148 ;
        pl:refDescription "sync() verb function - single unified command entry point" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 115 ;
        pl:refDescription "SyncExecutor::execute() - orchestrates entire pipeline" ;
        pl:refLayer "integration"
    ] .

sync:ManifestAsTruth a pl:Pattern ;
    rdfs:label "MANIFEST AS TRUTH" ;
    pl:hasNumber 2 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:FoundationCategory ;
    pl:hasSlug "manifest-as-truth" ;
    pl:hasEvocativeImage "A map is only useful if it reflects the territory." ;
    pl:hasContext """You have embraced THE SINGLE COMMAND. Now the question arises: how does the command know what to do? Commands with many flags can express configuration, but they become unwieldy. Environment variables scatter configuration across the system. Code-based configuration requires modifying and recompiling.""" ;
    pl:hasProblem "When configuration is scattered or implicit, the system becomes unpredictable. When configuration is centralized and explicit, the system becomes trustworthy." ;
    pl:hasSolution """Place all synchronization configuration in a single manifest file, located at the root of the project. Make this file the exclusive source of truth for what gets generated.

The manifest should:
- Declare the ontology sources
- Define inference rules
- Specify generation rules
- Set validation requirements
- Configure output paths

The command-line may override some behaviors (like --dry-run), but it never specifies what gets generated—only how the generation proceeds.""" ;
    pl:hasManifestSection "[project]" ;
    pl:hasManifestSection "[ontology]" ;
    pl:hasManifestSection "[inference]" ;
    pl:hasManifestSection "[generation]" ;
    pl:hasManifestSection "[validation]" ;
    pl:hasImplementation """In ggen, the manifest is `ggen.toml`:

```toml
[project]
name = \"my-service\"
version = \"1.0.0\"

[ontology]
source = \"ontology/domain.ttl\"
imports = [\"ontology/common.ttl\"]

[ontology.prefixes]
domain = \"https://example.org/domain#\"

[[inference.rules]]
name = \"infer-required-fields\"
order = 1
construct = \"\"\"
PREFIX domain: <https://example.org/domain#>
CONSTRUCT { ?field domain:isRequired true }
WHERE { ?field domain:minCardinality ?min . FILTER(?min > 0) }
\"\"\"

[[generation.rules]]
name = \"structs\"
query = { file = \"queries/structs.sparql\" }
template = { file = \"templates/struct.tera\" }
output_file = \"{{ name | snake_case }}.rs\"
mode = \"Overwrite\"

[generation]
output_dir = \"src/generated\"
```""" ;
    pl:hasDeepPattern """MANIFEST AS TRUTH is about declarative configuration.

Imperative configuration says: \"Do this, then this, then this.\"
Declarative configuration says: \"This is what I want. Make it so.\"

The manifest declares intent. The system figures out execution. This separation is what makes the system trustworthy.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/types.rs" ;
        pl:refLine 27 ;
        pl:refDescription "GgenManifest struct - root manifest structure parsed from ggen.toml" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/validation.rs" ;
        pl:refLine 33 ;
        pl:refDescription "ManifestValidator::validate() - ensures manifest correctness" ;
        pl:refLayer "domain"
    ] .

sync:ThreeLayerArchitecture a pl:Pattern ;
    rdfs:label "THREE-LAYER ARCHITECTURE" ;
    pl:hasNumber 3 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:FoundationCategory ;
    pl:hasSlug "three-layer-architecture" ;
    pl:hasEvocativeImage "A building has structure, and the structure has layers." ;
    pl:hasContext """You are implementing THE SINGLE COMMAND. The command must parse arguments and validate input, execute complex domain logic, handle errors gracefully, and format output appropriately. Putting all this in one place creates a monolith—hard to test, hard to change, hard to understand.""" ;
    pl:hasProblem "When concerns are mixed, changes ripple unpredictably. When concerns are layered, changes stay contained." ;
    pl:hasSolution """Structure the implementation in three layers: CLI (input/output), Integration (orchestration), and Domain (pure logic). Each layer depends only on the layer below it.

```
┌─────────────────────────────────┐
│  Layer 3: CLI                   │  ← Input parsing, output formatting
│  (thin, stateless)              │
├─────────────────────────────────┤
│  Layer 2: Integration           │  ← Orchestration, async execution
│  (SyncExecutor)                 │
├─────────────────────────────────┤
│  Layer 1: Domain                │  ← Pure generation logic
│  (GenerationPipeline)           │
└─────────────────────────────────┘
```""" ;
    pl:hasImplementation """Layer 3 (CLI) lives in `crates/ggen-cli/src/cmds/sync.rs`
Layer 2 (Integration) lives in `crates/ggen-core/src/codegen/executor.rs`
Layer 1 (Domain) lives in `crates/ggen-core/src/codegen/pipeline.rs`""" ;
    pl:hasDeepPattern """THREE-LAYER ARCHITECTURE is about separation of concerns at the architectural level. Each layer has its own language, its own testing strategy, its own rate of change. When you change the output format, only Layer 3 changes. When you add a new pipeline stage, only Layer 1 changes.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 147 ;
        pl:refDescription "Layer 3 (CLI) - thin stateless verb function" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 98 ;
        pl:refDescription "Layer 2 (Integration) - SyncExecutor struct" ;
        pl:refLayer "integration"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 112 ;
        pl:refDescription "Layer 1 (Domain) - GenerationPipeline struct" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 484 ;
        pl:refDescription "GenerationPipeline::run() - pure domain logic execution" ;
        pl:refLayer "domain"
    ] .

# =============================================================================
# KNOWLEDGE PATTERNS (4-7)
# =============================================================================

sync:OntologyLoading a pl:Pattern ;
    rdfs:label "ONTOLOGY LOADING" ;
    pl:hasNumber 4 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:KnowledgeCategory ;
    pl:hasSlug "ontology-loading" ;
    pl:hasEvocativeImage "Before you can speak, you must have words. Before you can generate, you must have knowledge." ;
    pl:hasContext """You have a MANIFEST AS TRUTH that declares what should be generated. But the manifest only points to knowledge—it does not contain it. The actual domain knowledge lives in ontologies: RDF graphs that describe entities, relationships, and constraints.""" ;
    pl:hasProblem "Without loaded knowledge, the pipeline is empty. With improperly loaded knowledge, the pipeline produces garbage." ;
    pl:hasSolution """Load all ontology sources into a unified graph before any other pipeline operation. Validate the graph is complete and well-formed. Make loading explicit, observable, and fail-fast.

The loading should:
- Start from the primary source declared in the manifest
- Follow all import declarations
- Parse each file with strict validation
- Merge all sources into a single queryable graph
- Fail immediately if any source cannot be loaded""" ;
    pl:hasManifestSection "[ontology]" ;
    pl:hasImplementation """The `[ontology]` section declares what to load:

```toml
[ontology]
source = \"ontology/domain.ttl\"
imports = [\"ontology/common.ttl\", \"ontology/validation.ttl\"]
base_iri = \"https://example.org/my-service#\"

[ontology.prefixes]
schema = \"https://schema.org/\"
domain = \"https://example.org/domain#\"
```""" ;
    pl:hasDeepPattern """ONTOLOGY LOADING is about establishing the ground of possibility. Before loading, the system has no knowledge. After loading, the system has all knowledge. This is a phase transition—from empty to full, from potential to actual.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/graph/core.rs" ;
        pl:refLine 110 ;
        pl:refDescription "Graph::new() - creates empty RDF graph" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/graph/core.rs" ;
        pl:refLine 215 ;
        pl:refDescription "Graph::insert_turtle() - parses and inserts Turtle RDF" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 180 ;
        pl:refDescription "GenerationPipeline::load_ontology() - orchestrates ontology loading" ;
        pl:refLayer "domain"
    ] .

sync:InferenceEnrichment a pl:Pattern ;
    rdfs:label "INFERENCE ENRICHMENT" ;
    pl:hasNumber 5 ;
    pl:hasConfidence 1 ;
    pl:hasCategory sync:KnowledgeCategory ;
    pl:hasSlug "inference-enrichment" ;
    pl:hasEvocativeImage "What is implicit must be made explicit before it can be used." ;
    pl:hasContext """You have loaded your ontology. The graph contains facts that were explicitly stated. But often, there are facts that should exist—facts that can be derived from what is stated.""" ;
    pl:hasProblem "When derived knowledge is implicit, generation logic must re-derive it everywhere. When derived knowledge is explicit, generation logic simply uses it." ;
    pl:hasSolution """Execute CONSTRUCT queries that derive new facts and materialize them into the graph before any generation rules run. Order the inference rules explicitly. Make the enrichment observable in the audit trail.""" ;
    pl:hasManifestSection "[inference]" ;
    pl:hasImplementation """```toml
[[inference.rules]]
name = \"infer-required-fields\"
order = 1
construct = \"\"\"
PREFIX domain: <https://example.org/domain#>
CONSTRUCT { ?field domain:isRequired true }
WHERE { ?field domain:minCardinality ?min . FILTER(?min > 0) }
\"\"\"
```""" ;
    pl:hasDeepPattern """INFERENCE ENRICHMENT is about making implicit knowledge explicit. Domain experts think in terms of rules. These rules are implicit in the domain model. INFERENCE ENRICHMENT makes them explicit in the graph.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 212 ;
        pl:refDescription "execute_inference_rules() - runs all CONSTRUCT queries in order" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 229 ;
        pl:refDescription "execute_inference_rule() - runs single CONSTRUCT query" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/graph/construct.rs" ;
        pl:refLine 90 ;
        pl:refDescription "execute_and_materialize() - runs CONSTRUCT and adds triples to graph" ;
        pl:refLayer "domain"
    ] .

sync:GenerationRules a pl:Pattern ;
    rdfs:label "GENERATION RULES" ;
    pl:hasNumber 6 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:KnowledgeCategory ;
    pl:hasSlug "generation-rules" ;
    pl:hasEvocativeImage "From knowledge, code. From queries, templates. From rules, files." ;
    pl:hasContext """You have a graph loaded and enriched. The graph contains facts about your domain: entities, fields, relationships, constraints. Now you must transform this knowledge into code.""" ;
    pl:hasProblem "When transformation logic is scattered in code, it is hard to understand, test, and maintain. When transformation is declared as rules, it becomes visible, verifiable, and changeable." ;
    pl:hasSolution """Express each code generation as a rule with three parts: a SPARQL SELECT query to extract data, a Tera template to shape the output, and an output pattern to name the file. Each rule is independent; together they produce the complete codebase.""" ;
    pl:hasManifestSection "[generation]" ;
    pl:hasManifestSection "[[generation.rules]]" ;
    pl:hasImplementation """```toml
[[generation.rules]]
name = \"structs\"
query = { file = \"queries/structs.sparql\" }
template = { file = \"templates/struct.tera\" }
output_file = \"{{ name | snake_case }}.rs\"
mode = \"Overwrite\"
skip_empty = true
```""" ;
    pl:hasDeepPattern """GENERATION RULES embody the separation of concerns:
- What to extract → SPARQL query
- How to shape it → Tera template
- Where to put it → Output pattern

Each concern is expressed in its own language, optimized for that concern.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 257 ;
        pl:refDescription "execute_generation_rules() - processes all generation rules" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 466 ;
        pl:refDescription "execute_generation_rule() - SELECT query → template → file" ;
        pl:refLayer "domain"
    ] .

sync:TemplateRendering a pl:Pattern ;
    rdfs:label "TEMPLATE RENDERING" ;
    pl:hasNumber 7 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:KnowledgeCategory ;
    pl:hasSlug "template-rendering" ;
    pl:hasEvocativeImage "A template is a shape waiting to be filled." ;
    pl:hasContext """GENERATION RULES extract data from the graph. But data is not code. You need a way to transform variable bindings into actual source files—with proper syntax, formatting, and structure.""" ;
    pl:hasProblem "When code generation is embedded in the tool, the tool controls the output. When code generation is in templates, the user controls the output." ;
    pl:hasSolution """Use a template language (Tera) that supports control flow, filters, and composition. Store templates as separate files. Make templates the authority on output format.""" ;
    pl:hasImplementation """ggen uses Tera with Jinja2-style syntax:

```jinja2
/// {{ description }}
#[derive(Debug, Clone)]
pub struct {{ name | pascal_case }} {
{% for field in fields %}
    {% if field.required %}
    pub {{ field.name | snake_case }}: {{ field.type }},
    {% else %}
    pub {{ field.name | snake_case }}: Option<{{ field.type }}>,
    {% endif %}
{% endfor %}
}
```""" ;
    pl:hasDeepPattern """TEMPLATE RENDERING is about separating content from presentation. The SPARQL query defines what data exists. The template defines how that data appears as code.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 346 ;
        pl:refDescription "Tera template engine initialization" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 388 ;
        pl:refDescription "tera.render() - renders template with context" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 399 ;
        pl:refDescription "tera.render_str() - expands output path template" ;
        pl:refLayer "domain"
    ] .

# =============================================================================
# SAFETY PATTERNS (8-12)
# =============================================================================

sync:DryRun a pl:Pattern ;
    rdfs:label "DRY RUN" ;
    pl:hasNumber 8 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:SafetyCategory ;
    pl:hasSlug "dry-run" ;
    pl:hasEvocativeImage "Look before you leap. Ask before you change." ;
    pl:hasContext """You are about to run THE SINGLE COMMAND. The pipeline will load ontologies, execute inference, generate code, and write files. Once written, files are changed.""" ;
    pl:hasProblem "Irreversible actions should be previewable. The cost of looking should be zero." ;
    pl:hasSolution """Provide a dry-run mode that executes the complete pipeline without writing files. Show what would be generated, what would change, and what would remain unchanged.""" ;
    pl:hasFlag "--dry-run" ;
    pl:hasImplementation """```bash
ggen sync --dry-run
```

Output:
```
ggen sync v5.0.0 (dry-run mode)

Would sync 5 files:
  [CREATE]  src/generated/user.rs (1,247 bytes)
  [UPDATE]  src/generated/product.rs (1,456 bytes)
  [SKIP]    src/generated/mod.rs (unchanged)

No files were modified (dry-run).
```""" ;
    pl:hasDeepPattern """DRY RUN is about separating decision from action. The decision—what files to generate, with what content—is computed by the pipeline. The action—writing to disk—is a separate concern. By separating them, we enable safe exploration.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 250 ;
        pl:refDescription "execute_dry_run() - runs pipeline without file writes" ;
        pl:refLayer "integration"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 196 ;
        pl:refDescription "options.dry_run = dry_run.unwrap_or(false)" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 158 ;
        pl:refDescription "dry_run mode dispatch in execute()" ;
        pl:refLayer "integration"
    ] .

sync:ValidationGate a pl:Pattern ;
    rdfs:label "VALIDATION GATE" ;
    pl:hasNumber 9 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:SafetyCategory ;
    pl:hasSlug "validation-gate" ;
    pl:hasEvocativeImage "Check the map before starting the journey." ;
    pl:hasContext """You have written a ggen.toml manifest. The manifest references ontology files, query files, and template files. Any of these could have errors.""" ;
    pl:hasProblem "Errors discovered late are expensive. Errors discovered early are cheap." ;
    pl:hasSolution """Provide a validation-only mode that checks all configuration without executing generation. Validate file existence, syntax, and semantic correctness. Fail fast with clear error messages.""" ;
    pl:hasFlag "--validate-only" ;
    pl:hasImplementation """```bash
ggen sync --validate-only
```""" ;
    pl:hasDeepPattern """VALIDATION GATE is about fail-fast. The later an error is discovered, the more work has been wasted. Validation inverts this: check everything that can be checked statically, before any dynamic work begins.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 166 ;
        pl:refDescription "execute_validate_only() - validates without generating" ;
        pl:refLayer "integration"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 201 ;
        pl:refDescription "options.validate_only = validate_only.unwrap_or(false)" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/validation.rs" ;
        pl:refLine 33 ;
        pl:refDescription "ManifestValidator::validate() - validates manifest structure" ;
        pl:refLayer "domain"
    ] .

sync:ForceOverwrite a pl:Pattern ;
    rdfs:label "FORCE OVERWRITE" ;
    pl:hasNumber 10 ;
    pl:hasConfidence 1 ;
    pl:hasCategory sync:SafetyCategory ;
    pl:hasSlug "force-overwrite" ;
    pl:hasEvocativeImage "Sometimes you must break the rules you set for yourself." ;
    pl:hasContext """GENERATION RULES support a mode field that controls file behavior: Create (only if absent), Overwrite (always), Merge (preserve sections). But sometimes, you know better and need to override protections.""" ;
    pl:hasProblem "Safety mechanisms must be overridable, or they become prisons." ;
    pl:hasSolution """Provide a force flag that overrides all file protections. When force is active, treat all rules as Overwrite mode. Make force explicit and observable.""" ;
    pl:hasFlag "--force" ;
    pl:hasImplementation """```bash
ggen sync --force
```""" ;
    pl:hasDeepPattern """FORCE OVERWRITE is about explicit override. Good systems have protections. Great systems let you bypass those protections when you know what you're doing. The key is explicitness.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 197 ;
        pl:refDescription "options.force = force.unwrap_or(false)" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 408 ;
        pl:refDescription "should_write match on GenerationMode" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 410 ;
        pl:refDescription "GenerationMode::Overwrite => true" ;
        pl:refLayer "domain"
    ] .

sync:TimeoutProtection a pl:Pattern ;
    rdfs:label "TIMEOUT PROTECTION" ;
    pl:hasNumber 11 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:SafetyCategory ;
    pl:hasSlug "timeout-protection" ;
    pl:hasEvocativeImage "No task should run forever. Every process deserves an ending." ;
    pl:hasContext """The generation pipeline executes SPARQL queries against RDF graphs. Some queries are complex. And some are accidentally infinite—they never complete.""" ;
    pl:hasProblem "Unbounded operations are a reliability risk. Time limits transform risks into failures—and failures can be handled." ;
    pl:hasSolution """Impose time limits on all pipeline operations. Provide configurable timeouts at both the manifest level and the command line. When a timeout is exceeded, fail with a clear error.""" ;
    pl:hasFlag "--timeout" ;
    pl:hasManifestSection "inference.max_reasoning_timeout_ms" ;
    pl:hasManifestSection "generation.max_sparql_timeout_ms" ;
    pl:hasImplementation """```toml
[inference]
max_reasoning_timeout_ms = 5000

[generation]
max_sparql_timeout_ms = 5000
```

Or via CLI:
```bash
ggen sync --timeout 30000
```""" ;
    pl:hasDeepPattern """TIMEOUT PROTECTION is about bounded execution. Every operation should have a known upper bound on its execution time. The timeout transforms unknown-duration operations into bounded operations.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/mod.rs" ;
        pl:refLine 117 ;
        pl:refDescription "SyncOptions::timeout_ms field" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/mod.rs" ;
        pl:refLine 133 ;
        pl:refDescription "timeout_ms: 30000 - 30 second default" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 214 ;
        pl:refDescription "CLI --timeout flag handling" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/types.rs" ;
        pl:refLine 11 ;
        pl:refDescription "Default SPARQL/reasoning timeout constants (5000ms)" ;
        pl:refLayer "domain"
    ] .

sync:ErrorSignals a pl:Pattern ;
    rdfs:label "ERROR SIGNALS" ;
    pl:hasNumber 12 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:SafetyCategory ;
    pl:hasSlug "error-signals" ;
    pl:hasEvocativeImage "A tool that fails silently is worse than one that fails loudly." ;
    pl:hasContext """The generation pipeline has many stages. Each stage can fail in different ways. When something goes wrong, the user needs to know what, where, why, and how to fix it.""" ;
    pl:hasProblem "Error messages are the user interface for failures. Good error messages are actionable; bad ones are bewildering." ;
    pl:hasSolution """Define a clear error taxonomy with distinct exit codes for each failure category. Format errors with context, explanation, and suggestions. Make errors parseable in both text and JSON formats.""" ;
    pl:hasImplementation """Exit codes:
- 0: Success
- 1: Manifest validation error
- 2: Ontology load error
- 3: SPARQL query error
- 4: Template rendering error
- 5: File I/O error
- 6: Timeout exceeded""" ;
    pl:hasDeepPattern """ERROR SIGNALS is about actionable failure. An error is only useful if it leads to resolution. Every error message should answer: What happened? Where? Why? How can it be fixed?""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/error.rs" ;
        pl:refLine 19 ;
        pl:refDescription "GgenError enum - semantic error types" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/error.rs" ;
        pl:refLine 55 ;
        pl:refDescription "exit_code() - maps errors to exit codes 1-5" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 119 ;
        pl:refDescription "error[E0001]: Manifest not found signal" ;
        pl:refLayer "integration"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 328 ;
        pl:refDescription "error[E0003]: Pipeline execution failed signal" ;
        pl:refLayer "integration"
    ] .

# =============================================================================
# INTEGRITY PATTERNS (13-15)
# =============================================================================

sync:DeterministicOutput a pl:Pattern ;
    rdfs:label "DETERMINISTIC OUTPUT" ;
    pl:hasNumber 13 ;
    pl:hasConfidence 3 ;
    pl:hasCategory sync:IntegrityCategory ;
    pl:hasSlug "deterministic-output" ;
    pl:hasEvocativeImage "Given the same inputs, produce the same outputs. Always. Without exception." ;
    pl:hasContext """You run ggen sync today. It generates code. You run it tomorrow, with the same manifest, ontology, and templates. Does it produce the same code?""" ;
    pl:hasProblem "Non-determinism in code generation is a defect. Every source of randomness must be eliminated or controlled." ;
    pl:hasSolution """Eliminate all sources of non-determinism from the generation pipeline. Use ordered data structures. Require explicit ordering in queries. Avoid timestamps and random values. Make reproducibility a hard requirement, not an aspiration.

Determinism requires:
- BTreeMap instead of HashMap
- ORDER BY in all SPARQL queries
- Fixed iteration order in templates
- No timestamps or random values in output
- Consistent file write ordering""" ;
    pl:hasImplementation """ggen uses BTreeMap throughout. The manifest validator warns about queries lacking ORDER BY. Templates use ordered source data.""" ;
    pl:hasDeepPattern """DETERMINISTIC OUTPUT is about reproducibility as a first-class requirement.

The Determinism Equation:
```
Output = f(Manifest, Ontology, Templates)
```

The function f must be pure. Same inputs → same outputs. This is not optional; it is fundamental.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/types.rs" ;
        pl:refLine 4 ;
        pl:refDescription "Comment: All collections use BTreeMap for deterministic serialization" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/manifest/types.rs" ;
        pl:refLine 76 ;
        pl:refDescription "prefixes: BTreeMap<String, String> - ordered prefixes" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/audit.rs" ;
        pl:refLine 45 ;
        pl:refDescription "ontology_hashes: BTreeMap - deterministic hash ordering" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 308 ;
        pl:refDescription "let mut row = BTreeMap::new() - deterministic row context" ;
        pl:refLayer "domain"
    ] .

sync:AuditTrail a pl:Pattern ;
    rdfs:label "AUDIT TRAIL" ;
    pl:hasNumber 14 ;
    pl:hasConfidence 2 ;
    pl:hasCategory sync:IntegrityCategory ;
    pl:hasSlug "audit-trail" ;
    pl:hasEvocativeImage "What happened, when, and why—recorded for posterity." ;
    pl:hasContext """You run ggen sync. Files are generated. But which rules produced which files? How long did each stage take? Can you prove the output matches the input?""" ;
    pl:hasProblem "Trust requires evidence. Evidence requires records. Records require an audit trail." ;
    pl:hasSolution """Record all significant events during pipeline execution into an audit trail. Include rule names, durations, input hashes, output hashes, and any decisions made. Store the trail alongside generated output.""" ;
    pl:hasFlag "--audit" ;
    pl:hasManifestSection "generation.require_audit_trail" ;
    pl:hasImplementation """```bash
ggen sync --audit
```

Generates `audit.json`:
```json
{
  \"pipeline\": { \"duration_ms\": 55 },
  \"inference_rules\": [...],
  \"generation_rules\": [...],
  \"generated_files\": [
    { \"path\": \"user.rs\", \"content_hash\": \"sha256:...\" }
  ]
}
```""" ;
    pl:hasDeepPattern """AUDIT TRAIL is about provenance. Where did this come from? How was it made? Can it be reproduced? The audit trail captures all three, making the generation process transparent and verifiable.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/audit.rs" ;
        pl:refLine 15 ;
        pl:refDescription "AuditTrail struct - complete execution record" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/audit.rs" ;
        pl:refLine 95 ;
        pl:refDescription "AuditTrailBuilder - fluent builder for audit construction" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/audit.rs" ;
        pl:refLine 231 ;
        pl:refDescription "write_to() - serializes audit trail to JSON file" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 198 ;
        pl:refDescription "options.audit = audit.unwrap_or(false)" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 377 ;
        pl:refDescription "Audit path resolution and file generation" ;
        pl:refLayer "integration"
    ] .

sync:PipelineState a pl:Pattern ;
    rdfs:label "PIPELINE STATE" ;
    pl:hasNumber 15 ;
    pl:hasConfidence 1 ;
    pl:hasCategory sync:IntegrityCategory ;
    pl:hasSlug "pipeline-state" ;
    pl:hasEvocativeImage "The pipeline is not just a sequence—it is a growing state." ;
    pl:hasContext """The generation pipeline executes in stages. Each stage produces results. Later stages need earlier results. This is not a stateless transformation—it is a stateful process.""" ;
    pl:hasProblem "Stateful processes require explicit state management. Implicit state leads to confusion and bugs." ;
    pl:hasSolution """Model the pipeline as a progression through explicit states. Each stage receives the previous state and produces the next state. The final state contains all accumulated results. Make state observable and queryable.""" ;
    pl:hasImplementation """PipelineState tracks:
- manifest: GgenManifest
- ontology_graph: Graph
- executed_rules: Vec<ExecutedRule>
- generated_files: Vec<GeneratedFile>
- validation_results: Vec<ValidationResult>
- started_at: Instant""" ;
    pl:hasDeepPattern """PIPELINE STATE is about making the process observable. A pipeline is not just a function: it is a journey through states. Each step transforms the state. The final state contains the history of that journey.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 19 ;
        pl:refDescription "PipelineState struct - accumulated pipeline state" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 20 ;
        pl:refDescription "manifest, ontology_graph, executed_rules, generated_files fields" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 43 ;
        pl:refDescription "ExecutedRule struct - records rule execution" ;
        pl:refLayer "domain"
    ] .

# =============================================================================
# SELECTIVE PATTERNS (16)
# =============================================================================

sync:RuleSelection a pl:Pattern ;
    rdfs:label "RULE SELECTION" ;
    pl:hasNumber 16 ;
    pl:hasConfidence 1 ;
    pl:hasCategory sync:SelectiveCategory ;
    pl:hasSlug "rule-selection" ;
    pl:hasEvocativeImage "Sometimes you need a scalpel, not a sledgehammer." ;
    pl:hasContext """THE SINGLE COMMAND runs the entire pipeline. This is usually what you want. But sometimes you're iterating on a single template, or debugging why one rule fails, or measuring one rule's performance.""" ;
    pl:hasProblem "Precision beats thoroughness when you know what you need." ;
    pl:hasSolution """Allow selecting specific rules by name. When a rule is selected, run only that rule (still executing necessary prerequisites like ontology loading). Make selection work with all other flags.""" ;
    pl:hasFlag "--rule" ;
    pl:hasImplementation """```bash
ggen sync --rule structs
ggen sync --rule enums --dry-run
ggen sync --rule structs --force --verbose
```""" ;
    pl:hasDeepPattern """RULE SELECTION is about precision. THE SINGLE COMMAND provides unity—one command for everything. RULE SELECTION provides focus—one rule when that's what you need. These are not contradictions.""" ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-cli/src/cmds/sync.rs" ;
        pl:refLine 204 ;
        pl:refDescription "options.selected_rules = Some(vec![r]) - CLI flag handling" ;
        pl:refLayer "cli"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/mod.rs" ;
        pl:refLine 102 ;
        pl:refDescription "selected_rules: Option<Vec<String>> - SyncOptions field" ;
        pl:refLayer "domain"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/executor.rs" ;
        pl:refLine 262 ;
        pl:refDescription "Filter generation rules by selected_rules" ;
        pl:refLayer "integration"
    ] ;
    pl:hasCodeRef [
        pl:refFile "crates/ggen-core/src/codegen/pipeline.rs" ;
        pl:refLine 466 ;
        pl:refDescription "execute_generation_rule() - runs single rule" ;
        pl:refLayer "domain"
    ] .

# =============================================================================
# PATTERN CONNECTIONS
# =============================================================================

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:ManifestAsTruth ;
    pl:connectionType "requires" ;
    pl:connectionReason "THE SINGLE COMMAND reads configuration from MANIFEST AS TRUTH"
] .

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:ThreeLayerArchitecture ;
    pl:connectionType "implemented-by" ;
    pl:connectionReason "THREE-LAYER ARCHITECTURE structures how THE SINGLE COMMAND is built"
] .

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:DryRun ;
    pl:connectionType "modified-by" ;
    pl:connectionReason "DRY RUN modifies THE SINGLE COMMAND via --dry-run flag"
] .

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:ValidationGate ;
    pl:connectionType "modified-by" ;
    pl:connectionReason "VALIDATION GATE modifies THE SINGLE COMMAND via --validate-only flag"
] .

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:ForceOverwrite ;
    pl:connectionType "modified-by" ;
    pl:connectionReason "FORCE OVERWRITE modifies THE SINGLE COMMAND via --force flag"
] .

sync:SingleCommand pl:hasConnection [
    pl:connectsTo sync:RuleSelection ;
    pl:connectionType "modified-by" ;
    pl:connectionReason "RULE SELECTION modifies THE SINGLE COMMAND via --rule flag"
] .

sync:ManifestAsTruth pl:hasConnection [
    pl:connectsTo sync:OntologyLoading ;
    pl:connectionType "configures" ;
    pl:connectionReason "The [ontology] section configures ONTOLOGY LOADING"
] .

sync:ManifestAsTruth pl:hasConnection [
    pl:connectsTo sync:InferenceEnrichment ;
    pl:connectionType "configures" ;
    pl:connectionReason "The [inference] section configures INFERENCE ENRICHMENT"
] .

sync:ManifestAsTruth pl:hasConnection [
    pl:connectsTo sync:GenerationRules ;
    pl:connectionType "configures" ;
    pl:connectionReason "The [generation] section configures GENERATION RULES"
] .

sync:OntologyLoading pl:hasConnection [
    pl:connectsTo sync:InferenceEnrichment ;
    pl:connectionType "enables" ;
    pl:connectionReason "INFERENCE ENRICHMENT operates on the graph created by ONTOLOGY LOADING"
] .

sync:InferenceEnrichment pl:hasConnection [
    pl:connectsTo sync:GenerationRules ;
    pl:connectionType "enables" ;
    pl:connectionReason "GENERATION RULES query the enriched graph"
] .

sync:GenerationRules pl:hasConnection [
    pl:connectsTo sync:TemplateRendering ;
    pl:connectionType "invokes" ;
    pl:connectionReason "GENERATION RULES invoke TEMPLATE RENDERING for each result row"
] .

sync:DeterministicOutput pl:hasConnection [
    pl:connectsTo sync:ManifestAsTruth ;
    pl:connectionType "constrains" ;
    pl:connectionReason "MANIFEST AS TRUTH uses BTreeMap for determinism"
] .

sync:DeterministicOutput pl:hasConnection [
    pl:connectsTo sync:InferenceEnrichment ;
    pl:connectionType "constrains" ;
    pl:connectionReason "INFERENCE ENRICHMENT requires ordered rule execution"
] .

sync:DeterministicOutput pl:hasConnection [
    pl:connectsTo sync:GenerationRules ;
    pl:connectionType "constrains" ;
    pl:connectionReason "GENERATION RULES requires ORDER BY in queries"
] .

sync:AuditTrail pl:hasConnection [
    pl:connectsTo sync:DeterministicOutput ;
    pl:connectionType "verifies" ;
    pl:connectionReason "AUDIT TRAIL verifies DETERMINISTIC OUTPUT via hashes"
] .

sync:AuditTrail pl:hasConnection [
    pl:connectsTo sync:PipelineState ;
    pl:connectionType "serializes" ;
    pl:connectionReason "AUDIT TRAIL serializes PIPELINE STATE for records"
] .

sync:ErrorSignals pl:hasConnection [
    pl:connectsTo sync:ValidationGate ;
    pl:connectionType "reports" ;
    pl:connectionReason "ERROR SIGNALS reports VALIDATION GATE failures"
] .

sync:ErrorSignals pl:hasConnection [
    pl:connectsTo sync:TimeoutProtection ;
    pl:connectionType "reports" ;
    pl:connectionReason "ERROR SIGNALS reports TIMEOUT PROTECTION violations"
] .

# =============================================================================
# GLOSSARY TERMS
# =============================================================================

sync:TermGgenSync a pl:Term ;
    rdfs:label "ggen sync" ;
    pl:termDefinition "The single command in ggen v5 that performs knowledge-driven code generation. It synchronizes domain knowledge (ontologies) with code (generated files)." ;
    pl:termCategory "core" .

sync:TermManifest a pl:Term ;
    rdfs:label "Manifest" ;
    pl:termDefinition "The ggen.toml file that declares all configuration for a generation run. It is the MANIFEST AS TRUTH." ;
    pl:termCategory "core" .

sync:TermOntology a pl:Term ;
    rdfs:label "Ontology" ;
    pl:termDefinition "An RDF graph expressed in Turtle (.ttl) format that describes domain knowledge: entities, properties, relationships, and constraints." ;
    pl:termCategory "knowledge" .

sync:TermPipeline a pl:Term ;
    rdfs:label "Pipeline" ;
    pl:termDefinition "The sequence of stages that transforms ontology → inference → generation → files." ;
    pl:termCategory "core" .

sync:TermTriple a pl:Term ;
    rdfs:label "Triple" ;
    pl:termDefinition "The fundamental unit of RDF: subject-predicate-object." ;
    pl:termCategory "knowledge" .

sync:TermGraph a pl:Term ;
    rdfs:label "Graph" ;
    pl:termDefinition "A collection of triples that can be queried." ;
    pl:termCategory "knowledge" .

sync:TermSPARQL a pl:Term ;
    rdfs:label "SPARQL" ;
    pl:termDefinition "The query language for RDF graphs. ggen uses CONSTRUCT for inference and SELECT for generation." ;
    pl:termCategory "knowledge" .

sync:TermTera a pl:Term ;
    rdfs:label "Tera" ;
    pl:termDefinition "The template engine used by ggen. It uses Jinja2-style syntax." ;
    pl:termCategory "knowledge" .

sync:TermDryRun a pl:Term ;
    rdfs:label "Dry Run" ;
    pl:termDefinition "Executing the pipeline without writing files. Invoked via --dry-run." ;
    pl:termCategory "safety" .

sync:TermDeterminism a pl:Term ;
    rdfs:label "Determinism" ;
    pl:termDefinition "The property of producing identical outputs from identical inputs." ;
    pl:termCategory "integrity" .

sync:TermAuditTrail a pl:Term ;
    rdfs:label "Audit Trail" ;
    pl:termDefinition "A JSON file (audit.json) recording all execution details." ;
    pl:termCategory "integrity" .

sync:TermExitCode a pl:Term ;
    rdfs:label "Exit Code" ;
    pl:termDefinition "The numeric status returned by ggen sync. 0 = success, 1-6 = specific failure categories." ;
    pl:termCategory "safety" .

# =============================================================================
# AGI CAPABILITY ONTOLOGY - SCHEMA DEFINITIONS
# =============================================================================
# This ontology extends the pattern language to describe Artificial General
# Intelligence capabilities. It models how sync patterns enable AGI through
# knowledge representation, reasoning, learning, and meta-cognition.
# =============================================================================

# -----------------------------------------------------------------------------
# AGI CORE CLASSES
# -----------------------------------------------------------------------------

agi:Capability a rdfs:Class ;
    rdfs:label "AGI Capability" ;
    rdfs:comment "An abstract base class for any capability that contributes to AGI functionality." .

agi:ReasoningMode a rdfs:Class ;
    rdfs:label "Reasoning Mode" ;
    rdfs:subClassOf agi:Capability ;
    rdfs:comment "A distinct mode or strategy for reasoning (deductive, inductive, abductive, analogical)." .

agi:LearningStrategy a rdfs:Class ;
    rdfs:label "Learning Strategy" ;
    rdfs:subClassOf agi:Capability ;
    rdfs:comment "An approach for acquiring knowledge (supervised, unsupervised, reinforcement, meta)." .

agi:KnowledgeType a rdfs:Class ;
    rdfs:label "Knowledge Type" ;
    rdfs:comment "A category of knowledge (declarative, procedural, episodic, semantic)." .

agi:GoalStructure a rdfs:Class ;
    rdfs:label "Goal Structure" ;
    rdfs:subClassOf agi:Capability ;
    rdfs:comment "A way of organizing goals to enable hierarchical goal-directed behavior." .

agi:MetaCognition a rdfs:Class ;
    rdfs:label "Meta-Cognition" ;
    rdfs:subClassOf agi:Capability ;
    rdfs:comment "The ability to reflect on and reason about cognitive processes." .

# -----------------------------------------------------------------------------
# AGI PROPERTIES: Capability-Pattern Relationships
# -----------------------------------------------------------------------------

agi:enablesCapability a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range agi:Capability ;
    rdfs:label "enables capability" ;
    rdfs:comment "A pattern enables (provides infrastructure for) an AGI capability." .

agi:requiresPattern a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range pl:Pattern ;
    rdfs:label "requires pattern" ;
    rdfs:comment "An AGI capability requires (depends on) a sync pattern." ;
    owl:inverseOf agi:enablesCapability .

agi:enhances a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range agi:Capability ;
    rdfs:label "enhances" ;
    rdfs:comment "One capability enhances or amplifies another capability." .

agi:implementsReasoning a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range agi:ReasoningMode ;
    rdfs:label "implements reasoning" ;
    rdfs:comment "A pattern implements a specific reasoning mode." .

agi:supportsLearning a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range agi:LearningStrategy ;
    rdfs:label "supports learning" ;
    rdfs:comment "A pattern supports a particular learning strategy." .

agi:representsKnowledge a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range agi:KnowledgeType ;
    rdfs:label "represents knowledge" ;
    rdfs:comment "A pattern provides mechanisms for representing a particular type of knowledge." .

agi:enablesMetaCognition a rdf:Property ;
    rdfs:domain pl:Pattern ;
    rdfs:range agi:MetaCognition ;
    rdfs:label "enables meta-cognition" ;
    rdfs:comment "A pattern enables reflection on cognitive processes." .

# -----------------------------------------------------------------------------
# AGI CAPABILITY PROPERTIES
# -----------------------------------------------------------------------------

agi:capabilityId a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range xsd:string ;
    rdfs:comment "Unique identifier for the capability." .

agi:cognitiveLevel a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range xsd:string ;
    rdfs:comment "Cognitive level: perception, reasoning, learning, planning, autonomy." .

agi:maturityLevel a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range xsd:integer ;
    rdfs:comment "Maturity: 1=emerging, 2=established, 3=fundamental." .

agi:prerequisiteCapability a rdf:Property ;
    rdfs:domain agi:Capability ;
    rdfs:range agi:Capability ;
    rdfs:comment "A capability that must be established first." .

# -----------------------------------------------------------------------------
# KNOWLEDGE TYPE INSTANCES
# -----------------------------------------------------------------------------

agi:DeclarativeKnowledge a agi:KnowledgeType ;
    rdfs:label "Declarative Knowledge" ;
    rdfs:comment "Knowledge about facts and their relationships (RDF triples, ontologies)." .

agi:ProceduralKnowledge a agi:KnowledgeType ;
    rdfs:label "Procedural Knowledge" ;
    rdfs:comment "Knowledge about how to do things (templates, rules, pipelines)." .

agi:EpisodicKnowledge a agi:KnowledgeType ;
    rdfs:label "Episodic Knowledge" ;
    rdfs:comment "Knowledge about specific events and experiences (audit trails, logs)." .

agi:SemanticKnowledge a agi:KnowledgeType ;
    rdfs:label "Semantic Knowledge" ;
    rdfs:comment "Knowledge about meaning and concepts (ontology schemas)." .

# -----------------------------------------------------------------------------
# REASONING MODE INSTANCES
# -----------------------------------------------------------------------------

agi:DeductiveReasoning a agi:ReasoningMode ;
    rdfs:label "Deductive Reasoning" ;
    agi:capabilityId "deductive" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 3 ;
    rdfs:comment "Deriving specific conclusions from general premises (CONSTRUCT queries, type inference)." .

agi:InductiveReasoning a agi:ReasoningMode ;
    rdfs:label "Inductive Reasoning" ;
    agi:capabilityId "inductive" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 2 ;
    rdfs:comment "Identifying patterns from specific examples (pattern detection, generalization)." .

agi:AbductiveReasoning a agi:ReasoningMode ;
    rdfs:label "Abductive Reasoning" ;
    agi:capabilityId "abductive" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 1 ;
    rdfs:comment "Forming hypotheses to explain observations (error diagnosis, root cause analysis)." .

agi:AnalogicalReasoning a agi:ReasoningMode ;
    rdfs:label "Analogical Reasoning" ;
    agi:capabilityId "analogical" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 1 ;
    rdfs:comment "Mapping solutions across domains by structural similarity (template reuse)." .

# -----------------------------------------------------------------------------
# LEARNING STRATEGY INSTANCES
# -----------------------------------------------------------------------------

agi:SupervisedLearning a agi:LearningStrategy ;
    rdfs:label "Supervised Learning" ;
    agi:capabilityId "supervised" ;
    agi:cognitiveLevel "learning" ;
    agi:maturityLevel 2 ;
    rdfs:comment "Learning guided by explicit rules and manifests." .

agi:UnsupervisedLearning a agi:LearningStrategy ;
    rdfs:label "Unsupervised Learning" ;
    agi:capabilityId "unsupervised" ;
    agi:cognitiveLevel "learning" ;
    agi:maturityLevel 1 ;
    rdfs:comment "Discovering structure in raw knowledge without guidance." .

agi:ReinforcementLearning a agi:LearningStrategy ;
    rdfs:label "Reinforcement Learning" ;
    agi:capabilityId "reinforcement" ;
    agi:cognitiveLevel "learning" ;
    agi:maturityLevel 1 ;
    rdfs:comment "Learning from outcomes and feedback (error signals, dry runs)." .

agi:MetaLearning a agi:LearningStrategy ;
    rdfs:label "Meta-Learning" ;
    agi:capabilityId "meta-learning" ;
    agi:cognitiveLevel "learning" ;
    agi:maturityLevel 1 ;
    rdfs:comment "Learning how to learn (system structure, layered architecture)." .

# -----------------------------------------------------------------------------
# SPECIFIC AGI CAPABILITIES
# -----------------------------------------------------------------------------

agi:KnowledgeRepresentation a agi:Capability ;
    rdfs:label "Knowledge Representation" ;
    agi:capabilityId "knowledge-representation" ;
    agi:cognitiveLevel "perception" ;
    agi:maturityLevel 3 ;
    agi:requiresPattern sync:OntologyLoading ;
    rdfs:comment "The capability to represent and structure knowledge in queryable form." .

agi:KnowledgeEnrichment a agi:Capability ;
    rdfs:label "Knowledge Enrichment" ;
    agi:capabilityId "knowledge-enrichment" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:InferenceEnrichment ;
    agi:prerequisiteCapability agi:KnowledgeRepresentation ;
    rdfs:comment "Deriving new facts from existing knowledge through inference." .

agi:GoalDirectedGeneration a agi:Capability ;
    rdfs:label "Goal-Directed Generation" ;
    agi:capabilityId "goal-directed-generation" ;
    agi:cognitiveLevel "planning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:GenerationRules ;
    agi:prerequisiteCapability agi:KnowledgeEnrichment ;
    rdfs:comment "Generating outputs directed by explicit goals and rules." .

agi:ExecutionReflection a agi:Capability ;
    rdfs:label "Execution Reflection" ;
    agi:capabilityId "execution-reflection" ;
    agi:cognitiveLevel "autonomy" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:AuditTrail ;
    rdfs:comment "The ability to reflect on and analyze what has been executed." .

agi:HypotheticalReasoning a agi:Capability ;
    rdfs:label "Hypothetical Reasoning" ;
    agi:capabilityId "hypothetical-reasoning" ;
    agi:cognitiveLevel "planning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:DryRun ;
    rdfs:comment "Reasoning about outcomes without commitment to action." .

agi:BoundedRationality a agi:Capability ;
    rdfs:label "Bounded Rationality" ;
    agi:capabilityId "bounded-rationality" ;
    agi:cognitiveLevel "planning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:TimeoutProtection ;
    rdfs:comment "Resource-limited reasoning with explicit bounds." .

agi:RobustReasoning a agi:Capability ;
    rdfs:label "Robust Reasoning Under Uncertainty" ;
    agi:capabilityId "robust-reasoning" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:ErrorSignals ;
    rdfs:comment "Maintaining correctness even when errors occur." .

agi:DeterministicBehavior a agi:Capability ;
    rdfs:label "Deterministic Behavior" ;
    agi:capabilityId "deterministic-behavior" ;
    agi:cognitiveLevel "autonomy" ;
    agi:maturityLevel 3 ;
    agi:requiresPattern sync:DeterministicOutput ;
    rdfs:comment "Reproducible, predictable reasoning behavior." .

agi:CognitiveAbstraction a agi:Capability ;
    rdfs:label "Cognitive Abstraction" ;
    agi:capabilityId "cognitive-abstraction" ;
    agi:cognitiveLevel "perception" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:SingleCommand ;
    rdfs:comment "Reducing cognitive load through unified interfaces." .

agi:HierarchicalReasoning a agi:Capability ;
    rdfs:label "Hierarchical Reasoning" ;
    agi:capabilityId "hierarchical-reasoning" ;
    agi:cognitiveLevel "reasoning" ;
    agi:maturityLevel 2 ;
    agi:requiresPattern sync:ThreeLayerArchitecture ;
    rdfs:comment "Reasoning organized in modular, layered structures." .

# -----------------------------------------------------------------------------
# PATTERN-TO-CAPABILITY MAPPINGS
# -----------------------------------------------------------------------------

sync:SingleCommand agi:enablesCapability agi:CognitiveAbstraction ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:MetaLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:ManifestAsTruth agi:enablesCapability agi:KnowledgeRepresentation ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:DeclarativeKnowledge .

sync:ThreeLayerArchitecture agi:enablesCapability agi:HierarchicalReasoning ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:MetaLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:OntologyLoading agi:enablesCapability agi:KnowledgeRepresentation ;
    agi:implementsReasoning agi:InductiveReasoning ;
    agi:supportsLearning agi:UnsupervisedLearning ;
    agi:representsKnowledge agi:DeclarativeKnowledge ;
    agi:representsKnowledge agi:SemanticKnowledge .

sync:InferenceEnrichment agi:enablesCapability agi:KnowledgeEnrichment ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:UnsupervisedLearning ;
    agi:representsKnowledge agi:SemanticKnowledge .

sync:GenerationRules agi:enablesCapability agi:GoalDirectedGeneration ;
    agi:implementsReasoning agi:AbductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:TemplateRendering agi:enablesCapability agi:GoalDirectedGeneration ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:DryRun agi:enablesCapability agi:HypotheticalReasoning ;
    agi:implementsReasoning agi:AbductiveReasoning ;
    agi:supportsLearning agi:ReinforcementLearning ;
    agi:representsKnowledge agi:EpisodicKnowledge .

sync:ValidationGate agi:enablesCapability agi:RobustReasoning ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:DeclarativeKnowledge .

sync:ForceOverwrite agi:enablesCapability agi:BoundedRationality ;
    agi:implementsReasoning agi:AnalogicalReasoning ;
    agi:supportsLearning agi:MetaLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:TimeoutProtection agi:enablesCapability agi:BoundedRationality ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:MetaLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:ErrorSignals agi:enablesCapability agi:RobustReasoning ;
    agi:implementsReasoning agi:AbductiveReasoning ;
    agi:supportsLearning agi:ReinforcementLearning ;
    agi:representsKnowledge agi:EpisodicKnowledge .

sync:DeterministicOutput agi:enablesCapability agi:DeterministicBehavior ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

sync:AuditTrail agi:enablesCapability agi:ExecutionReflection ;
    agi:enablesMetaCognition agi:ExecutionReflection ;
    agi:implementsReasoning agi:AnalogicalReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:EpisodicKnowledge .

sync:PipelineState agi:enablesCapability agi:ExecutionReflection ;
    agi:implementsReasoning agi:DeductiveReasoning ;
    agi:supportsLearning agi:SupervisedLearning ;
    agi:representsKnowledge agi:EpisodicKnowledge .

sync:RuleSelection agi:enablesCapability agi:GoalDirectedGeneration ;
    agi:implementsReasoning agi:AnalogicalReasoning ;
    agi:supportsLearning agi:ReinforcementLearning ;
    agi:representsKnowledge agi:ProceduralKnowledge .

# -----------------------------------------------------------------------------
# CAPABILITY ENHANCEMENT RELATIONSHIPS
# -----------------------------------------------------------------------------

agi:KnowledgeRepresentation agi:enhances agi:KnowledgeEnrichment .
agi:KnowledgeEnrichment agi:enhances agi:GoalDirectedGeneration .
agi:DeterministicBehavior agi:enhances agi:GoalDirectedGeneration .
agi:ExecutionReflection agi:enhances agi:RobustReasoning .
agi:HypotheticalReasoning agi:enhances agi:RobustReasoning .
agi:BoundedRationality agi:enhances agi:DeterministicBehavior .
agi:HierarchicalReasoning agi:enhances agi:CognitiveAbstraction .

# -----------------------------------------------------------------------------
# AGI GLOSSARY TERMS
# -----------------------------------------------------------------------------

agi:TermAGI a pl:Term ;
    rdfs:label "AGI (Artificial General Intelligence)" ;
    pl:termDefinition "A system that can perform any intellectual task that a human can. ggen patterns provide foundational capabilities toward AGI through knowledge representation, reasoning, and meta-cognition." ;
    pl:termCategory "agi" .

agi:TermCapability a pl:Term ;
    rdfs:label "Capability" ;
    pl:termDefinition "A concrete, measurable AGI ability that emerges from one or more sync patterns." ;
    pl:termCategory "agi" .

agi:TermReasoningMode a pl:Term ;
    rdfs:label "Reasoning Mode" ;
    pl:termDefinition "A specific way of deriving conclusions: deductive (general→specific), inductive (examples→general), abductive (best explanation), analogical (cross-domain)." ;
    pl:termCategory "agi" .

agi:TermMetaCognition a pl:Term ;
    rdfs:label "Meta-Cognition" ;
    pl:termDefinition "The capability to reason about reasoning itself: reflecting on what was done, why, and how to improve." ;
    pl:termCategory "agi" .

agi:TermKnowledgeGraph a pl:Term ;
    rdfs:label "Knowledge Graph" ;
    pl:termDefinition "A graph-structured knowledge representation using RDF triples. The foundation for AGI knowledge representation in ggen." ;
    pl:termCategory "agi" .

agi:TermGoalDirected a pl:Term ;
    rdfs:label "Goal-Directed Behavior" ;
    pl:termDefinition "Behavior organized around explicit goals, where actions are selected based on their contribution to goal achievement." ;
    pl:termCategory "agi" .
