# 13. DETERMINISTIC OUTPUT ***

*Given the same inputs, produce the same outputs. Always. Without exception.*

---

## Context

You run `ggen sync` today. It generates code. You run it tomorrow, with the same manifest, the same ontology, the same templates. Does it produce the same code?

If it doesn't—if timestamps, random values, or ordering variations creep in—you have a problem:

- Version control shows changes when nothing changed
- Build artifacts are never identical
- Reproducibility is impossible
- Trust in the system erodes

---

❖ ❖ ❖

**Non-determinism in code generation is a defect. Every source of randomness must be eliminated or controlled.**

The forces:
- Many operations have inherent non-determinism (hash map iteration order)
- Some outputs want timestamps ("generated at...")
- SPARQL results may vary in order
- File system operations may return different orderings

Non-determinism leads to:
- Spurious diffs in version control
- Unreproducible bugs
- Build cache invalidation
- CI/CD flakiness

**Therefore:**

**Eliminate all sources of non-determinism from the generation pipeline. Use ordered data structures. Require explicit ordering in queries. Avoid timestamps and random values. Make reproducibility a hard requirement, not an aspiration.**

Determinism requires:
- BTreeMap instead of HashMap
- ORDER BY in all SPARQL queries
- Fixed iteration order in templates
- No timestamps or random values in output
- Consistent file write ordering

---

❖ ❖ ❖

## Connections

This pattern is fundamental—it affects nearly all other patterns.

- **[MANIFEST AS TRUTH](02-manifest-as-truth.md)** uses BTreeMap for prefixes
- **[INFERENCE ENRICHMENT](05-inference-enrichment.md)** requires ordered rule execution
- **[GENERATION RULES](06-generation-rules.md)** requires ORDER BY in queries
- **[AUDIT TRAIL](14-audit-trail.md)** verifies determinism via hashes

---

## Implementation

### Ordered Data Structures

```rust
// ❌ Non-deterministic: HashMap iteration order varies
use std::collections::HashMap;
let prefixes: HashMap<String, String> = ...;

// ✅ Deterministic: BTreeMap has consistent ordering
use std::collections::BTreeMap;
let prefixes: BTreeMap<String, String> = ...;
```

ggen uses `BTreeMap` throughout for:
- Prefix mappings in manifest
- SPARQL variable bindings
- Template contexts

### Ordered Query Results

```sparql
-- ❌ Non-deterministic: result order not guaranteed
SELECT ?name ?type
WHERE {
  ?entity a domain:Entity ;
          rdfs:label ?name ;
          domain:type ?type .
}

-- ✅ Deterministic: explicit ordering
SELECT ?name ?type
WHERE {
  ?entity a domain:Entity ;
          rdfs:label ?name ;
          domain:type ?type .
}
ORDER BY ?name
```

The manifest validator warns about queries lacking ORDER BY:

```
warning: Inference rule 'derive-fields' lacks ORDER BY
         Results may be non-deterministic
         Add ORDER BY to ensure consistent output
```

### Ordered Rule Execution

Inference rules execute in explicit order:

```toml
[[inference.rules]]
name = "first"
order = 1  # Explicit ordering

[[inference.rules]]
name = "second"
order = 2

[[inference.rules]]
name = "third"
order = 3
```

Generation rules execute in manifest order (array order is preserved).

### No Timestamps

```jinja2
{# ❌ Non-deterministic: timestamp changes on every run #}
// Generated at {{ now() }}

{# ✅ Deterministic: no timestamp #}
// Generated by ggen sync

{# ✅ Deterministic: version from manifest #}
// Generated from {{ project_version }}
```

### Hash Verification

The audit trail includes content hashes:

```json
{
  "files": [
    {
      "path": "src/generated/user.rs",
      "content_hash": "sha256:a1b2c3d4e5f6..."
    }
  ]
}
```

Identical inputs should produce identical hashes. If they don't, something is non-deterministic.

---

## Testing Determinism

### The Double-Run Test

```bash
# Generate once
ggen sync

# Capture state
sha256sum src/generated/*.rs > checksums1.txt

# Generate again (same inputs)
ggen sync

# Capture state again
sha256sum src/generated/*.rs > checksums2.txt

# Compare
diff checksums1.txt checksums2.txt
# Should produce no output (files identical)
```

### CI/CD Verification

```yaml
- name: Verify deterministic output
  run: |
    ggen sync
    sha256sum src/generated/*.rs > first.txt

    ggen sync
    sha256sum src/generated/*.rs > second.txt

    if ! diff first.txt second.txt; then
      echo "ERROR: Non-deterministic output detected!"
      exit 1
    fi
```

---

## Sources of Non-Determinism

| Source | Risk | Mitigation |
|--------|------|------------|
| HashMap iteration | High | Use BTreeMap |
| SPARQL result order | High | Require ORDER BY |
| Template loop order | Medium | Ordered source data |
| File system readdir | Medium | Sort file lists |
| Timestamps | High | Avoid entirely |
| Random values | High | Avoid entirely |
| Floating point | Low | Use integer math |

---

## The Determinism Equation

```
Output = f(Manifest, Ontology, Templates)
```

The function `f` must be pure:
- Same Manifest → same intermediate structures
- Same Ontology → same graph
- Same Templates → same renderings
- Same graph + same renderings → same files

If any step introduces variation, the equation breaks.

---

## Determinism Salt

For cases requiring unique identifiers, ggen supports a determinism salt:

```toml
[generation]
determinism_salt = "my-project-2024"
```

This salt, combined with entity data, produces deterministic but unique identifiers:

```rust
fn generate_id(entity: &str, salt: &str) -> String {
    let input = format!("{}{}", salt, entity);
    format!("{:x}", sha256(input.as_bytes()))[..8].to_string()
}
```

The ID is deterministic (same inputs → same ID) but unique across different salts.

---

## The Deeper Pattern

DETERMINISTIC OUTPUT is about **reproducibility as a first-class requirement**.

Reproducibility means:
- Any developer can regenerate the same output
- Any build system produces identical artifacts
- Any time in the future, the same inputs yield the same outputs

This is not just a nice-to-have. It is fundamental to:
- **Trust**: You can verify that generation is correct
- **Debugging**: You can reproduce problems
- **Caching**: You can skip regeneration if inputs haven't changed
- **Auditing**: You can prove what was generated from what

Non-determinism undermines all of these.

---

## When Determinism Seems Impossible

Some scenarios seem to require non-determinism:

**"I need a timestamp"** → Use the git commit hash or version number instead

**"I need random IDs"** → Use deterministic hashes of entity data

**"I need the current date"** → Make it a manifest variable, not computed

**"Query order doesn't matter"** → It matters for diffs and caching; add ORDER BY anyway

**"It's just formatting"** → Formatting differences cause diffs; standardize

---

## The Three-Star Pattern

DETERMINISTIC OUTPUT is marked `***`—a fundamental pattern.

This means:
- It is essential to the language
- Without it, other patterns lose coherence
- It should be the default, not an option

Every other pattern must support determinism:
- Inference uses ordered rule execution
- Generation uses ordered queries
- Templates use ordered iteration
- Audit uses content hashes

Determinism is not a pattern you apply. It is a property the entire system must maintain.
