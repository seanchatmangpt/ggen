@startuml template-rdf-system
!theme blueprint

title Template-to-File-Tree Generation with RDF Integration

' Components
package "User Interface" {
    [CLI Commands] as CLI
}

package "Orchestration Layer" {
    [Template Resolver] as Resolver
    [Lifecycle Manager] as Lifecycle
    [Generator Pipeline] as Pipeline
}

package "Cache & Storage" {
    database "Package Cache" as PackageCache
    database "Lockfile" as Lockfile
    database "Query Cache" as QueryCache
}

package "Processing Layer" {
    component "Template Parser" as Parser
    component "Frontmatter Renderer" as FrontRenderer
    component "RDF Graph Store" as Graph
    component "SPARQL Engine" as SPARQL
    component "Tera Template Engine" as Tera
    component "File Tree Generator" as FileGen
}

package "Validation Layer" {
    [Path Security] as PathSec
    [Checksum Verifier] as Checksum
    [SHACL Validator] as SHACL
}

package "Output" {
    folder "File System" as FS
}

' Relationships
CLI --> Resolver : template generate
CLI --> Lifecycle : lifecycle run

Resolver --> Lockfile : read versions
Resolver --> PackageCache : load packages
Resolver --> Pipeline : provide template

Lifecycle --> Pipeline : execute phases

Pipeline --> Parser : parse template
Parser --> FrontRenderer : YAML + body
FrontRenderer --> Graph : load RDF
Graph --> SPARQL : execute queries
SPARQL --> Tera : query results
Tera --> FileGen : rendered content

FileGen --> PathSec : validate paths
FileGen --> Checksum : verify integrity
FileGen --> SHACL : validate RDF
FileGen --> FS : write files

Graph --> QueryCache : cache results
SPARQL --> QueryCache : read cached

note right of Graph
  Thread-safe RDF store
  - Oxigraph backend
  - Epoch-based invalidation
  - LRU caching (100 plans, 1000 results)
end note

note right of FileGen
  Generates:
  - Directory structures
  - Multiple files
  - File injections
  - Checksums
end note

note right of PathSec
  Security:
  - Prevent path traversal (..)
  - Canonical path validation
  - Output root boundary checks
end note

@enduml

@startuml template-processing-sequence
!theme blueprint

title Template Processing Sequence Diagram

actor User
participant "CLI" as CLI
participant "TemplateResolver" as Resolver
participant "CacheManager" as Cache
participant "Template" as Tmpl
participant "Graph" as RDF
participant "Tera" as Tera
participant "FileTreeGenerator" as FileGen
participant "FileSystem" as FS

User -> CLI: ggen template generate\npack:template.tmpl
CLI -> Resolver: resolve("pack:template.tmpl")
Resolver -> Cache: load_cached("pack", "1.0.0")
Cache --> Resolver: TemplateSource

Resolver -> Tmpl: parse(content)
Tmpl --> Resolver: Template { frontmatter, body }

CLI -> Tmpl: render_frontmatter(vars)
Tmpl -> Tera: render_str(yaml, vars)
Tera --> Tmpl: rendered YAML
Tmpl --> CLI: Frontmatter populated

CLI -> Tmpl: process_graph(graph, vars)
loop for each RDF source
    Tmpl -> RDF: insert_turtle(ttl)
end
loop for each SPARQL query
    Tmpl -> RDF: query_cached(sparql)
    RDF --> Tmpl: CachedResult
    note right: Store in\nsparql_results
end
Tmpl --> CLI: Graph processed

CLI -> Tmpl: render(tera, vars)
Tmpl -> Tera: render_str(body, context)
note right: Context includes\nvars + sparql_results
Tera --> Tmpl: rendered content
Tmpl --> CLI: String

CLI -> FileGen: generate_file(path, content)
FileGen -> FileGen: validate_path()
FileGen -> FS: create_dir_all()
FileGen -> FS: write(path, content)
FileGen -> FileGen: calculate_sha256()
FileGen --> CLI: GeneratedFile

CLI --> User: ✓ Generated src/main.rs

@enduml

@startuml rdf-integration-flow
!theme blueprint

title RDF Integration Data Flow

start

:User defines template;
note right
  ---
  prefixes: { ex: "..." }
  base: "http://..."
  rdf_inline: ["..."]
  rdf: ["data.ttl"]
  sparql:
    people: "SELECT ..."
  ---
end note

:Parse frontmatter;

:Render variables in YAML;

partition "RDF Graph Construction" {
    :Build PREFIX/BASE prolog;

    fork
        :Process rdf_inline[];
        :Parse Turtle;
        :Insert triples;
    fork again
        :Load rdf[] files;
        :Read TTL/RDF/JSONLD;
        :Insert triples;
    end fork

    :Graph populated;
}

partition "SPARQL Execution" {
    :For each named query;

    :Prepend prolog;

    :Check query cache;

    if (Cached?) then (yes)
        :Return cached result;
    else (no)
        :Execute SPARQL;
        :Store in cache;
    endif

    :Convert to JSON;

    :Store in sparql_results;
}

:Create Tera context;
note right
  {
    vars: {...},
    sparql_results: {
      people: [...],
      ...
    }
  }
end note

:Render template body;

:Access SPARQL results;
note right
  {{ sparql_results.people | length }}
  {{ sparql_first(results=..., column="name") }}
end note

:Generate output file;

stop

@enduml

@startuml component-architecture
!theme blueprint

title Component Architecture Diagram

package "ggen-core" {

    package "template" {
        class Template {
            + raw_frontmatter: Value
            + front: Frontmatter
            + body: String
            --
            + parse(input: &str) → Result<Self>
            + render_frontmatter(tera, vars)
            + process_graph(graph, tera, vars)
            + render(tera, vars) → String
        }

        class Frontmatter {
            + to: Option<String>
            + from: Option<String>
            + inject: bool
            + rdf_inline: Vec<String>
            + rdf: Vec<String>
            + sparql: BTreeMap<String, String>
            + vars: BTreeMap<String, Value>
            + sparql_results: BTreeMap<String, JsonValue>
        }
    }

    package "graph" {
        class Graph {
            - inner: Store
            - epoch: Arc<AtomicU64>
            - plan_cache: LruCache
            - result_cache: LruCache
            --
            + insert_turtle(ttl: &str)
            + load_path(path: Path)
            + query(sparql: &str) → Results
            + query_cached(sparql) → CachedResult
        }

        enum CachedResult {
            Boolean(bool)
            Solutions(Vec<BTreeMap>)
            Graph(Vec<String>)
        }
    }

    package "generator" {
        class Generator {
            + pipeline: Pipeline
            + ctx: GenContext
            --
            + generate() → PathBuf
        }

        class GenContext {
            + template_path: PathBuf
            + output_root: PathBuf
            + vars: BTreeMap<String, String>
            + global_prefixes: BTreeMap
            + dry_run: bool
        }
    }

    package "resolver" {
        class TemplateResolver {
            - cache_manager: CacheManager
            - lockfile_manager: LockfileManager
            --
            + resolve(ref: &str) → TemplateSource
            + search_templates(query) → Vec<Result>
            + get_pack_templates(id) → Vec<String>
        }

        class TemplateSource {
            + pack_id: String
            + template_path: PathBuf
            + pack: CachedPack
            + manifest: Option<GpackManifest>
        }
    }

    package "gpack" {
        class GpackManifest {
            + metadata: GpackMetadata
            + dependencies: BTreeMap
            + templates: TemplatesConfig
            + rdf: RdfConfig
            + queries: QueriesConfig
            --
            + discover_templates(base) → Vec<Path>
            + discover_rdf_files(base) → Vec<Path>
        }
    }
}

' Relationships
Template *-- Frontmatter
Template ..> Graph : uses
Generator *-- GenContext
Generator ..> Template : creates
TemplateResolver ..> TemplateSource : creates
TemplateResolver ..> GpackManifest : reads
Graph *-- CachedResult

@enduml

@startuml file-tree-generation
!theme blueprint

title File Tree Generation Flow

start

:Receive TemplateSource[];

:Build dependency DAG;

:Topological sort;

if (Cyclic dependencies?) then (yes)
    :Error: Cyclic dependency;
    stop
endif

:Merge variables\n(CLI > Template > Package);

partition "Process Each Template" {
    :Load template content;

    :Parse frontmatter & body;

    :Render frontmatter with vars;

    :Load RDF data;

    :Execute SPARQL queries;

    :Render template body;

    :Determine output path;
    note right
      from frontmatter.to
      validate path security
    end note

    :Add to FileTree;
}

:Group by directory;

:Create directory structure;

partition "Write Files" {
    fork
        :Write file 1;
        :Calculate checksum;
    fork again
        :Write file 2;
        :Calculate checksum;
    fork again
        :Write file N;
        :Calculate checksum;
    end fork
}

:Execute post hooks;

:Generate snapshot;

:Return GeneratedFiles[];

stop

@enduml

@startuml security-architecture
!theme blueprint

title Security Architecture Layers

rectangle "Input Validation" {
    (Template Reference\nSyntax Check) as RefCheck
    (Variable Type\nValidation) as VarCheck
    (YAML Schema\nValidation) as YAMLCheck
}

rectangle "Path Security" {
    (Reject .. Components) as RejectDots
    (Canonical Path\nResolution) as Canonical
    (Boundary Checking) as Boundary
}

rectangle "Content Verification" {
    (PQC SHA-256\nChecksums) as Checksum
    (Package Signature\nVerification) as Signature
    (Lockfile Integrity) as Lockfile
}

rectangle "RDF Validation" {
    (SHACL Shapes\nValidation) as SHACL
    (Graph Consistency\nChecks) as Consistency
    (SPARQL Injection\nPrevention) as Injection
}

rectangle "Output Protection" {
    (File Permission\nControls) as Permissions
    (Atomic File\nWrites) as Atomic
    (Backup Creation) as Backup
    (Rollback on Error) as Rollback
}

RefCheck -down-> RejectDots
VarCheck -down-> Canonical
YAMLCheck -down-> Boundary

RejectDots -down-> Checksum
Canonical -down-> Signature
Boundary -down-> Lockfile

Checksum -down-> SHACL
Signature -down-> Consistency
Lockfile -down-> Injection

SHACL -down-> Permissions
Consistency -down-> Atomic
Injection -down-> Backup

Permissions -down-> Rollback

@enduml
