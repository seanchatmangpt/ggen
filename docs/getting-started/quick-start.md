# Quick Start Tutorial

**Goal**: Generate JavaScript code with Zod schemas from an RDF ontology in 10 minutes.

**You'll learn**:
- How to install ggen
- How to load RDF data into the graph
- How to extract schema from ontologies
- How to generate JavaScript + Zod validation schemas

**Time**: 10 minutes

---

## Step 1: Install ggen (1 minute)

Choose your installation method:

**Homebrew** (macOS/Linux):
```bash
brew install seanchatmangpt/ggen/ggen
```

**Cargo** (any platform):
```bash
cargo install ggen-cli-lib
```

**Verify installation**:
```bash
ggen --version
# Should output: ggen 3.4.1 (or newer)
```

---

## Step 2: Create Your First Ontology (2 minutes)

Create a simple e-commerce product ontology:

```bash
# Create a new directory for your project
mkdir ggen-quickstart
cd ggen-quickstart

# Create an RDF ontology file
cat > product-ontology.ttl << 'EOF'
@prefix ex: <http://example.org/ecommerce/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# Define Product class
ex:Product a rdfs:Class ;
    rdfs:label "Product" ;
    rdfs:comment "A product in the e-commerce catalog" .

# Define properties
ex:id a rdf:Property ;
    rdfs:domain ex:Product ;
    rdfs:range xsd:string ;
    rdfs:label "id" ;
    rdfs:comment "Unique product identifier" .

ex:name a rdf:Property ;
    rdfs:domain ex:Product ;
    rdfs:range xsd:string ;
    rdfs:label "name" ;
    rdfs:comment "Product name" .

ex:price a rdf:Property ;
    rdfs:domain ex:Product ;
    rdfs:range xsd:decimal ;
    rdfs:label "price" ;
    rdfs:comment "Product price in USD" .

ex:inStock a rdf:Property ;
    rdfs:domain ex:Product ;
    rdfs:range xsd:boolean ;
    rdfs:label "inStock" ;
    rdfs:comment "Whether product is currently in stock" .

# Sample product instance
ex:product001 a ex:Product ;
    ex:id "PROD-001" ;
    ex:name "Wireless Mouse" ;
    ex:price "29.99"^^xsd:decimal ;
    ex:inStock true .
EOF
```

**What you created**: An RDF ontology defining a `Product` class with 4 properties (id, name, price, inStock) and one example product instance.

---

## Step 3: Load RDF into Graph (1 minute)

Load your ontology into ggen's RDF graph:

```bash
ggen graph load --file product-ontology.ttl
```

**Expected output**:
```
âœ“ Loaded 13 triples from product-ontology.ttl
```

**Verify data loaded**:
```bash
ggen graph query --sparql_query "SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 5"
```

You should see your RDF triples printed as JSON.

---

## Step 4: Extract Schema (2 minutes)

Extract the ontology schema into a JSON format:

```bash
ggen ontology extract --ontology_file product-ontology.ttl --output product-schema.json
```

**View the extracted schema**:
```bash
cat product-schema.json
```

**What you'll see**: A JSON representation of your ontology's classes and properties, ready for code generation.

---

## Step 5: Create JavaScript + Zod Template (3 minutes)

Create a custom template for JavaScript with Zod schemas:

```bash
cat > javascript-zod.tmpl << 'EOF'
---
name: "JavaScript + Zod Schema Generator"
description: "Generate JavaScript modules with Zod validation schemas from RDF ontology"
version: "1.0.0"
variables:
  - name: "schema_file"
    description: "Path to extracted schema JSON"
    required: true
---
/**
 * @fileoverview Generated from RDF ontology
 * Auto-generated by ggen - DO NOT EDIT MANUALLY
 */

import { z } from 'zod';

{% for class in classes %}
/**
 * {{ class.comment | default(value="") }}
 * @typedef {Object} {{ class.name }}
{% for prop in class.properties %}
 * @property {{ "{" }}{{ prop.type }}{{ "}" }} {{ prop.name }} - {{ prop.comment | default(value="") }}
{% endfor %}
 */

/**
 * Zod schema for {{ class.name }}
 */
export const {{ class.name }}Schema = z.object({
{% for prop in class.properties %}
  {{ prop.name }}: z.{{ prop.type | lower }}(){% if prop.required %}.min(1){% endif %},
{% endfor %}
});

/**
 * Validate {{ class.name }} data
 * @param {unknown} data - Data to validate
 * @returns {{ "{" }}{{ class.name }}{{ "}" }} Validated {{ class.name }} object
 * @throws {z.ZodError} If validation fails
 */
export function validate{{ class.name }}(data) {
  return {{ class.name }}Schema.parse(data);
}

/**
 * Safely validate {{ class.name }} data
 * @param {unknown} data - Data to validate
 * @returns {{ "{" }}success: boolean, data?: {{ class.name }}, error?: z.ZodError{{ "}" }}
 */
export function safeValidate{{ class.name }}(data) {
  const result = {{ class.name }}Schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  } else {
    return { success: false, error: result.error };
  }
}

{% endfor %}
EOF
```

**Note**: This is a simplified template. For production use, you'll want to add proper type mapping from XSD to Zod types.

---

## Step 6: Generate JavaScript Code (1 minute)

Generate your JavaScript module with Zod schemas:

```bash
# Using project gen command with the template
ggen project gen --template_ref javascript-zod.tmpl \
  --vars schema_file=product-schema.json \
  --output src/models/product.js
```

**View generated code**:
```bash
cat src/models/product.js
```

**What you got**:
- âœ… JSDoc type annotations for IDE autocomplete
- âœ… Zod schemas for runtime validation
- âœ… Validation helper functions
- âœ… Type-safe JavaScript without TypeScript

---

## Step 7: Use Your Generated Code

Create a test file to use your generated schemas:

```bash
cat > test-product.js << 'EOF'
import { ProductSchema, validateProduct, safeValidateProduct } from './src/models/product.js';

// Valid product
const validProduct = {
  id: "PROD-002",
  name: "Keyboard",
  price: 79.99,
  inStock: true
};

try {
  const validated = validateProduct(validProduct);
  console.log("âœ“ Valid product:", validated);
} catch (error) {
  console.error("âœ— Validation failed:", error.errors);
}

// Invalid product (missing required fields)
const invalidProduct = {
  name: "Incomplete Product"
};

const result = safeValidateProduct(invalidProduct);
if (result.success) {
  console.log("âœ“ Valid:", result.data);
} else {
  console.error("âœ— Invalid:", result.error.errors);
}
EOF
```

---

## ðŸŽ‰ Congratulations!

You just:
1. âœ… Installed ggen
2. âœ… Created an RDF ontology
3. âœ… Loaded data into the graph
4. âœ… Extracted schema to JSON
5. âœ… Generated JavaScript with Zod schemas
6. âœ… Created runtime validation code

**What you learned**:
- RDF ontologies define your domain model once
- ggen extracts schemas and generates code
- JavaScript + Zod gives you type safety without TypeScript
- JSDoc provides IDE autocomplete

---

## Next Steps

**Want to learn more?**

1. **[Query your data with SPARQL](../how-to/generation/query-rdf-sparql.md)** - Extract specific data from ontologies
2. **[Generate from Schema.org](../how-to/generation/generate-javascript-zod.md)** - Use standard vocabularies
3. **[Create custom templates](../tutorials/core/03-custom-template-creation.md)** - Build your own generators
4. **[Build a CLI tool](../how-to/generation/create-cli-tool.md)** - Generate entire applications

**Explore built-in templates**:
```bash
ggen template list
```

**Join the community**:
- [GitHub Discussions](https://github.com/seanchatmangpt/ggen/discussions)
- [Examples Repository](https://github.com/seanchatmangpt/ggen/tree/master/examples)
