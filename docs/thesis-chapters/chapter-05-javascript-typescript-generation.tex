\chapter{JavaScript/TypeScript Code Generation}
\label{ch:javascript-typescript-generation}

\section{Introduction}

The generation of JavaScript and TypeScript artifacts from RDF ontologies represents a critical bridge between semantic web technologies and modern web development practices. While previous chapters explored the theoretical foundations and RDF-based modeling approaches, this chapter addresses the practical challenge of translating ontological specifications into type-safe, idiomatic JavaScript code that integrates seamlessly with contemporary web application architectures.

The core tension in this domain lies between JavaScript's dynamic nature and the desire for type safety derived from formal ontological specifications. Rather than adopting TypeScript's compile-time type system exclusively, our approach leverages a hybrid strategy combining JSDoc type annotations, runtime validation through Zod schemas, and type guards for defensive programming. This design decision reflects the reality that many Node.js applications require runtime type checking, particularly when interfacing with external APIs or processing user input.

This chapter examines the complete pipeline from RDF property definitions to executable JavaScript modules, demonstrating how ontology-driven generation produces deterministic, maintainable, and type-safe code artifacts. We explore the architectural decisions underlying the module system, the rationale for choosing JSDoc over pure TypeScript, and the patterns that enable seamless integration with both frontend and backend JavaScript ecosystems.

\section{Generated Code Artifacts}
\label{sec:generated-artifacts}

The code generation system produces multiple complementary artifact types, each serving distinct roles in the runtime and development-time type system. These artifacts form a cohesive type safety layer that spans from static analysis to runtime validation.

\subsection{JSDoc Type Definitions}

JSDoc annotations provide static type information for JavaScript code without requiring compilation. The generator produces comprehensive type definitions extracted directly from RDF property constraints, as illustrated in Listing~\ref{lst:jsdoc-entity}.

\begin{lstlisting}[
  language=JavaScript,
  caption={Generated JSDoc type definition for entity from RDF ontology},
  label=lst:jsdoc-entity,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @fileoverview Generated type definitions from RDF ontology
 * DO NOT EDIT - auto-generated by ggen sync
 * @module generated/types
 */

/**
 * User - Blog user account
 * @typedef {Object} User
 * @property {string} id - Unique user identifier
 * @property {string} username - Username
 * @property {string} email - Email address
 * @property {string} ?bio - Optional user biography
 * @property {Post[]} ?posts - Posts authored by user
 */
\end{lstlisting}

The JSDoc generator implements a sophisticated mapping from RDF property ranges to JavaScript types. The Tera template processes SPARQL query results to determine optionality, array cardinality, and reference types. Property optionality is indicated through the \texttt{?} prefix, following JSDoc conventions for optional properties. This notation enables IDE autocomplete and type checking while maintaining runtime flexibility.

\subsection{Request and Response Type Definitions}

API contract types separate creation, update, and response schemas through discriminated type definitions. The generator produces operation-specific types that encode CRUD semantics directly in the type system, as shown in Listing~\ref{lst:request-types}.

\begin{lstlisting}[
  language=JavaScript,
  caption={Generated request type definitions for API operations},
  label=lst:request-types,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * CreateUserRequest
 * @typedef {Object} CreateUserRequest
 * @property {string} username - Username
 * @property {string} email - Email address
 * @property {string} ?bio - Optional user biography
 */

/**
 * UpdateUserRequest
 * @typedef {Object} UpdateUserRequest
 * @property {string} ?username - Username
 * @property {string} ?email - Email address
 * @property {string} ?bio - Optional user biography
 */
\end{lstlisting}

This separation ensures type safety across operation boundaries. Create requests omit system-generated fields (ID, timestamps), while update requests make all fields optional to support partial updates. The discriminated union pattern prevents accidental misuse of request types across different operations.

\subsection{Entity Type Definitions}

Entity types represent the complete domain model with full property sets. The generator traverses RDF class definitions and aggregates all properties within the class hierarchy, respecting inheritance relationships defined through \texttt{rdfs:subClassOf} predicates. Array properties are detected through cardinality constraints (\texttt{owl:minCardinality}, \texttt{owl:maxCardinality}) or explicit array annotations in the ontology.

Reference types, indicated by \texttt{api:type "reference"} in the RDF specification, generate typed array references to related entities. This approach maintains referential integrity in the type system while permitting lazy loading patterns common in modern web applications.

\subsection{Barrel Exports}

Module composition follows the barrel export pattern, centralizing type exports through index modules. The generated index file re-exports all entity and request types, simplifying import statements throughout the codebase (Listing~\ref{lst:barrel-export}).

\begin{lstlisting}[
  language=JavaScript,
  caption={Barrel export pattern for module composition},
  label=lst:barrel-export,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @fileoverview Barrel export for types
 * DO NOT EDIT - auto-generated by ggen sync
 * @module generated/types
 */

export * from './entities.mjs';
export * from './requests.mjs';
\end{lstlisting}

This pattern reduces coupling between consumer code and the internal organization of generated modules. Consumers import from the barrel module, insulating them from structural changes in the generation templates.

\section{JavaScript Module System}
\label{sec:module-system}

The adoption of ES modules (\texttt{.mjs} extension) rather than CommonJS reflects strategic alignment with modern JavaScript standards and tooling ecosystems. This decision carries implications for module resolution, bundling, and runtime behavior.

\subsection{ES Modules Architecture}

ES modules provide static analysis capabilities essential for tree-shaking and compile-time optimization in bundlers like Webpack, Rollup, and esbuild. The \texttt{.mjs} extension explicitly signals ES module syntax, avoiding ambiguity in environments that support both module systems. The generated code uses explicit \texttt{export} declarations, enabling named imports that facilitate refactoring and improve IDE support.

The module resolution strategy follows Node.js ES module conventions, requiring explicit file extensions in import specifiers. This explicitness prevents resolution ambiguities and aligns with browser-native module loading.

\subsection{Export Patterns}

The generator employs named exports exclusively, avoiding default exports to improve discoverability and refactoring safety. Named exports enable IDEs to provide accurate autocomplete suggestions and support automatic import insertion. They also prevent the naming inconsistencies that plague default exports in large codebases.

For schema exports, the generator uses a consistent naming convention: entity types use PascalCase (\texttt{User}), while Zod schema exports append \texttt{Schema} (\texttt{userSchema}). This convention clearly distinguishes between type-level constructs and runtime validators.

\subsection{Import Resolution}

Generated modules use relative imports for internal dependencies and bare specifiers for external packages (e.g., \texttt{import \{ z \} from "zod"}). This approach ensures portability across different module bundlers and runtime environments. The Tera templates generate import statements with explicit \texttt{.mjs} extensions, satisfying strict ES module resolution requirements.

\subsection{Module Composition}

Modules are organized hierarchically: \texttt{lib/types/}, \texttt{lib/schemas/}, and \texttt{lib/guards/} directories contain domain-specific artifacts. Each directory includes an \texttt{index.mjs} barrel export. This structure enables both fine-grained and coarse-grained imports:

\begin{lstlisting}[
  language=JavaScript,
  basicstyle=\small\ttfamily,
  frame=single
]
// Fine-grained import
import { User } from './lib/types/entities.mjs';

// Coarse-grained import
import { User, CreateUserRequest } from './lib/types/index.mjs';
\end{lstlisting}

\section{JSDoc vs TypeScript}
\label{sec:jsdoc-vs-typescript}

The decision to generate JSDoc-annotated JavaScript rather than TypeScript source code reflects pragmatic engineering considerations around runtime validation, build complexity, and ecosystem compatibility.

\subsection{JSDoc Type Annotations}

JSDoc provides type information consumable by TypeScript's type checker without requiring compilation. Modern IDEs (VS Code, WebStorm, IntelliJ) parse JSDoc comments to provide autocomplete, type checking, and refactoring support equivalent to TypeScript. This approach delivers static type safety without introducing a build step for JavaScript-only projects.

The JSDoc syntax supports sophisticated type expressions including union types, generic types, and conditional types:

\begin{lstlisting}[
  language=JavaScript,
  caption={Advanced JSDoc type expressions},
  label=lst:jsdoc-advanced,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * Generic repository interface
 * @template T
 * @typedef {Object} Repository
 * @property {(id: string) => Promise<T | null>} findById
 * @property {(entity: T) => Promise<T>} save
 * @property {(id: string) => Promise<boolean>} delete
 */

/**
 * Union type for API responses
 * @typedef {SuccessResponse | ErrorResponse} ApiResponse
 */
\end{lstlisting}

\subsection{Rationale for JSDoc in Ontology-Driven Generation}

Several factors motivate the JSDoc-first approach:

\begin{enumerate}
\item \textbf{Runtime Validation Primacy}: Ontological constraints must be enforced at runtime, not merely checked statically. Zod schemas provide runtime validation, while JSDoc provides development-time type checking. TypeScript compilation would duplicate type information without adding runtime safety.

\item \textbf{Build Simplicity}: JavaScript projects avoid the complexity of TypeScript compilation, source maps, and declaration file generation. Generated code is directly executable in Node.js and modern browsers.

\item \textbf{Template Simplicity}: Generating JSDoc comments is simpler than generating TypeScript syntax trees. JSDoc templates produce valid JavaScript with embedded type metadata, while TypeScript generation requires careful handling of type syntax, generic constraints, and type-level computation.

\item \textbf{Interoperability}: JSDoc-annotated JavaScript files can be consumed by TypeScript projects through implicit type acquisition, while the inverse requires declaration file generation.

\item \textbf{Debuggability}: Stack traces and debugger experiences are cleaner when debugging source code directly rather than compiled output. JSDoc preserves source fidelity.
\end{enumerate}

\subsection{Type Inference Capabilities}

TypeScript's control flow analysis operates on JSDoc annotations identically to TypeScript type annotations. The type checker understands narrowing, type guards, and discriminated unions in JSDoc-annotated code:

\begin{lstlisting}[
  language=JavaScript,
  caption={Type narrowing with JSDoc annotations},
  label=lst:type-narrowing,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @param {User | null} user
 * @returns {string}
 */
function getUserDisplay(user) {
  if (user === null) {
    return 'Anonymous';
  }
  // TypeScript infers user is User here, not User | null
  return user.username;
}
\end{lstlisting}

\subsection{IDE Support}

VS Code, WebStorm, and IntelliJ provide comprehensive JSDoc support:

\begin{itemize}
\item \textbf{Autocomplete}: Property access, method signatures, and parameter hints work identically to TypeScript.
\item \textbf{Type Checking}: Errors for type mismatches appear inline during editing.
\item \textbf{Refactoring}: Rename symbol, extract method, and move file operations respect JSDoc types.
\item \textbf{Documentation}: Hover tooltips display JSDoc comments with rich formatting.
\end{itemize}

This support ensures developers receive immediate feedback on type errors without configuring complex build pipelines.

\section{Type Definition Generation}
\label{sec:type-generation}

Type definitions are synthesized from RDF property specifications through a multi-stage pipeline involving SPARQL queries, template rendering, and deterministic code emission.

\subsection{Entity Types from RDF Properties}

The TypeScript generator in Rust (Listing~\ref{lst:rust-ts-generator}) demonstrates the core transformation logic:

\begin{lstlisting}[
  language=Rust,
  caption={Rust implementation of TypeScript interface generation},
  label=lst:rust-ts-generator,
  basicstyle=\small\ttfamily,
  frame=single
]
pub fn generate_interfaces(schema: &OntologySchema)
    -> Result<String, String> {
    let mut output = String::new();

    for ont_class in &schema.classes {
        writeln!(output, "export interface {} {{\n",
                 ont_class.name)?;

        let class_props = schema.properties_for_class(
            &ont_class.uri);
        for prop in class_props {
            let ts_type = prop.range.to_typescript_type();
            let optional = matches!(prop.cardinality,
                Cardinality::ZeroOrOne | Cardinality::Many);

            writeln!(output, "  {}{}: {};",
                prop.name,
                if optional { "?" } else { "" },
                ts_type)?;
        }
        writeln!(output, "}}\n")?;
    }
    Ok(output)
}
\end{lstlisting}

The \texttt{PropertyRange} enum encodes the mapping from RDF datatypes to JavaScript types:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{RDF Range} & \textbf{JavaScript Type} & \textbf{Notes} \\
\hline
\texttt{xsd:string} & \texttt{string} & Primitive string \\
\texttt{xsd:integer} & \texttt{number} & Integer validation via Zod \\
\texttt{xsd:decimal} & \texttt{number} & Floating-point \\
\texttt{xsd:boolean} & \texttt{boolean} & Primitive boolean \\
\texttt{xsd:dateTime} & \texttt{string} & ISO 8601 format \\
\texttt{xsd:date} & \texttt{string} & Date string \\
Reference & \texttt{EntityName} & Typed object reference \\
\hline
\end{tabular}
\caption{RDF datatype to JavaScript type mapping}
\label{tab:type-mapping}
\end{table}

\subsection{Property Optionality}

Optionality is determined by examining \texttt{api:required} predicates in the RDF specification and OWL cardinality restrictions. A property is optional if:

\begin{enumerate}
\item Its \texttt{api:required} value is \texttt{false}, or
\item Its \texttt{owl:minCardinality} is 0, or
\item Its cardinality is \texttt{ZeroOrOne} or \texttt{Many}
\end{enumerate}

This logic ensures consistency between ontological constraints and generated type definitions.

\subsection{Array and Reference Types}

Array types are generated when:
\begin{itemize}
\item The property has \texttt{api:isArray true} in the RDF specification, or
\item The cardinality is \texttt{Many}, \texttt{OneOrMore}, or \texttt{Range\{min, max\}}
\end{itemize}

Reference types use lazy evaluation in Zod schemas to handle circular dependencies:

\begin{lstlisting}[
  language=JavaScript,
  caption={Zod lazy reference for circular dependencies},
  label=lst:zod-lazy,
  basicstyle=\small\ttfamily,
  frame=single
]
export const userSchema = z.object({
  id: z.string(),
  username: z.string(),
  posts: z.lazy(() => z.array(postSchema))
    .default([]).optional().nullable(),
});

export const postSchema = z.object({
  id: z.string(),
  title: z.string(),
  author: z.lazy(() => userSchema).optional().nullable(),
});
\end{lstlisting}

The \texttt{z.lazy()} combinator defers schema evaluation until runtime, breaking circular dependencies while maintaining type safety.

\subsection{Type Inheritance and Composition}

When an RDF class extends another through \texttt{rdfs:subClassOf}, the generator produces TypeScript intersection types:

\begin{lstlisting}[
  language=JavaScript,
  caption={Type inheritance through intersection types},
  label=lst:type-inheritance,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * Base entity with common fields
 * @typedef {Object} BaseEntity
 * @property {string} id
 * @property {string} createdAt
 * @property {string} updatedAt
 */

/**
 * User extends BaseEntity
 * @typedef {BaseEntity & {
 *   username: string;
 *   email: string;
 * }} User
 */
\end{lstlisting}

This pattern preserves the inheritance hierarchy while remaining compatible with JavaScript's structural type system.

\section{Request Type Definitions}
\label{sec:request-types}

API request types encode CRUD semantics through systematic type transformations applied to entity schemas. These transformations eliminate boilerplate and ensure consistency across API endpoints.

\subsection{Request/Response Separation}

The generator produces distinct types for inputs and outputs:

\begin{itemize}
\item \textbf{Entity Type}: Complete domain model with all properties
\item \textbf{Create Request}: Omits system-generated fields (ID, timestamps)
\item \textbf{Update Request}: All fields optional (partial update support)
\item \textbf{Response Type}: Entity type plus metadata (timestamps, status)
\end{itemize}

This separation prevents clients from supplying system-managed fields and clarifies API contracts.

\subsection{Operation-Specific Types}

The Rust generator produces utility types for each entity (Listing~\ref{lst:utility-types}):

\begin{lstlisting}[
  language=Rust,
  caption={Utility type generation in Rust},
  label=lst:utility-types,
  basicstyle=\small\ttfamily,
  frame=single
]
pub fn generate_utility_types(schema: &OntologySchema)
    -> Result<String, String> {
    let mut output = String::new();

    for ont_class in &schema.classes {
        // Create type (omit system fields)
        writeln!(output,
            "export type {}Create = Omit<{}, \
             'id' | 'createdAt' | 'updatedAt'>;\n",
            ont_class.name, ont_class.name)?;

        // Update type (all optional)
        writeln!(output,
            "export type {}Update = Partial<{}Create>;\n",
            ont_class.name, ont_class.name)?;

        // Response type (add metadata)
        writeln!(output,
            "export type {}Response = {} & {{\
             id: string; createdAt: Date; \
             updatedAt: Date }};\n",
            ont_class.name, ont_class.name)?;
    }
    Ok(output)
}
\end{lstlisting}

\subsection{Partial vs Full Schemas}

Create operations require full schemas with mandatory fields, while update operations use partial schemas. This distinction is enforced through TypeScript's \texttt{Partial<T>} utility type and Zod's \texttt{.partial()} method:

\begin{lstlisting}[
  language=JavaScript,
  caption={Full vs partial schema validation},
  label=lst:partial-schemas,
  basicstyle=\small\ttfamily,
  frame=single
]
// Create schema: all required fields enforced
export const createUserSchema = z.object({
  username: z.string().min(1).max(255),
  email: z.string().email(),
  bio: z.string().max(500).optional().nullable(),
});

// Update schema: all fields optional
export const updateUserSchema = createUserSchema.partial();
\end{lstlisting}

\subsection{Discriminated Unions for Operations}

When endpoints support multiple request types, the generator produces discriminated unions with a \texttt{type} discriminator field:

\begin{lstlisting}[
  language=JavaScript,
  caption={Discriminated union for polymorphic requests},
  label=lst:discriminated-union,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @typedef {{
 *   type: 'create';
 *   username: string;
 *   email: string;
 * }} CreateUserAction
 */

/**
 * @typedef {{
 *   type: 'update';
 *   id: string;
 *   username?: string;
 *   email?: string;
 * }} UpdateUserAction
 */

/**
 * @typedef {CreateUserAction | UpdateUserAction} UserAction
 */
\end{lstlisting}

TypeScript's control flow analysis narrows union types based on the discriminator, enabling exhaustive case analysis.

\section{Code Quality and Standards}
\label{sec:code-quality}

Generated code adheres to industry-standard conventions and integrates with standard JavaScript tooling ecosystems.

\subsection{Naming Conventions}

The generator enforces consistent naming:

\begin{itemize}
\item \textbf{Types}: PascalCase (\texttt{User}, \texttt{CreateUserRequest})
\item \textbf{Properties}: camelCase (\texttt{username}, \texttt{createdAt})
\item \textbf{Schema Constants}: camelCase with \texttt{Schema} suffix (\texttt{userSchema})
\item \textbf{Type Guards}: \texttt{is} prefix (\texttt{isUser})
\item \textbf{Modules}: kebab-case filenames (\texttt{user-repository.mjs})
\end{itemize}

These conventions align with the Airbnb JavaScript Style Guide and TypeScript conventions.

\subsection{Module Organization}

Generated artifacts are organized by concern:

\begin{verbatim}
lib/
├── types/
│   ├── entities.mjs      # Domain entity types
│   ├── requests.mjs      # API request types
│   └── index.mjs         # Barrel export
├── schemas/
│   ├── entities.mjs      # Zod validation schemas
│   └── index.mjs
└── guards/
    ├── entities.mjs      # Runtime type guards
    └── index.mjs
\end{verbatim}

This structure separates concerns while enabling cohesive imports.

\subsection{Documentation Generation}

All generated code includes comprehensive JSDoc comments extracted from RDF \texttt{rdfs:comment} predicates. The generator produces documentation in a format compatible with JSDoc, TypeDoc, and documentation.js tooling:

\begin{lstlisting}[
  language=JavaScript,
  caption={Generated documentation with metadata},
  label=lst:generated-docs,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @fileoverview Generated type definitions from RDF ontology
 * DO NOT EDIT - auto-generated by ggen sync
 * @module generated/types
 */

/**
 * User - Blog user account
 * @typedef {Object} User
 * @property {string} id - Unique user identifier
 * @property {string} username - Username
 * @property {string} email - Email address
 * @property {string} ?bio - Optional user biography
 */
\end{lstlisting}

The \texttt{@fileoverview}, \texttt{@module}, and property comments enable automatic documentation generation with full type information.

\subsection{Compatibility with Package Management}

Generated modules include \texttt{package.json} metadata specifying ES module format:

\begin{lstlisting}[
  language=JSON,
  caption={Package.json configuration for ES modules},
  label=lst:package-json,
  basicstyle=\small\ttfamily,
  frame=single
]
{
  "name": "@ggen/generated-types",
  "version": "1.0.0",
  "type": "module",
  "exports": {
    "./types": "./lib/types/index.mjs",
    "./schemas": "./lib/schemas/index.mjs",
    "./guards": "./lib/guards/index.mjs"
  }
}
\end{lstlisting}

The \texttt{"type": "module"} field signals ES module semantics. The \texttt{exports} field defines entry points, enabling consumers to import specific submodules without exposing internal structure.

\section{Integration Patterns}
\label{sec:integration-patterns}

Generated types and schemas integrate with frontend frameworks, API clients, and backend validation layers through well-defined patterns.

\subsection{Using Generated Types in Frontend Code}

React, Vue, and Svelte components can import and use generated types directly:

\begin{lstlisting}[
  language=JavaScript,
  caption={React component using generated types},
  label=lst:react-integration,
  basicstyle=\small\ttfamily,
  frame=single
]
import { User, CreateUserRequest } from '@ggen/generated-types/types';
import { createUserSchema } from '@ggen/generated-types/schemas';

/**
 * User profile component
 * @param {{ user: User }} props
 */
export function UserProfile({ user }) {
  return (
    <div>
      <h1>{user.username}</h1>
      <p>{user.email}</p>
      {user.bio && <p>{user.bio}</p>}
    </div>
  );
}

/**
 * User creation form with validation
 * @param {{ onSubmit: (user: CreateUserRequest) => void }} props
 */
export function UserForm({ onSubmit }) {
  const handleSubmit = (data) => {
    const result = createUserSchema.safeParse(data);
    if (result.success) {
      onSubmit(result.data);
    } else {
      console.error(result.error.issues);
    }
  };
  // Form implementation...
}
\end{lstlisting}

The integration provides type safety during development and runtime validation before API calls.

\subsection{Server-Side Validation Integration}

Express.js middleware leverages Zod schemas for request validation:

\begin{lstlisting}[
  language=JavaScript,
  caption={Express middleware with Zod validation},
  label=lst:express-validation,
  basicstyle=\small\ttfamily,
  frame=single
]
import { createUserSchema, updateUserSchema }
  from '@ggen/generated-types/schemas';

/**
 * Validation middleware factory
 * @template T
 * @param {import('zod').ZodSchema<T>} schema
 * @returns {import('express').RequestHandler}
 */
function validate(schema) {
  return (req, res, next) => {
    const result = schema.safeParse(req.body);
    if (result.success) {
      req.validatedBody = result.data;
      next();
    } else {
      res.status(400).json({
        error: 'Validation failed',
        issues: result.error.issues
      });
    }
  };
}

app.post('/users',
  validate(createUserSchema),
  async (req, res) => {
    const user = await userRepository.create(
      req.validatedBody);
    res.json(user);
  }
);
\end{lstlisting}

This pattern ensures all requests are validated against the ontology-derived schema before reaching business logic.

\subsection{Database Schema Alignment}

Type definitions guide database schema generation. ORM tools like Prisma or TypeORM can consume generated types to ensure database schemas remain synchronized with API contracts:

\begin{lstlisting}[
  language=JavaScript,
  caption={Prisma schema aligned with generated types},
  label=lst:prisma-integration,
  basicstyle=\small\ttfamily,
  frame=single
]
// Prisma schema generated from RDF ontology
model User {
  id        String   @id @default(uuid())
  username  String   @unique
  email     String   @unique
  bio       String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
\end{lstlisting}

This alignment prevents schema drift between API types, database models, and frontend interfaces.

\subsection{API Client Generation}

Type-safe API clients can be generated from the same RDF specifications:

\begin{lstlisting}[
  language=JavaScript,
  caption={Type-safe API client},
  label=lst:api-client,
  basicstyle=\small\ttfamily,
  frame=single
]
import {
  User, CreateUserRequest, UpdateUserRequest
} from '@ggen/generated-types/types';

export class UserClient {
  /**
   * @param {string} baseUrl
   */
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }

  /**
   * @returns {Promise<User[]>}
   */
  async list() {
    const response = await fetch(
      `${this.baseUrl}/users`);
    return response.json();
  }

  /**
   * @param {CreateUserRequest} data
   * @returns {Promise<User>}
   */
  async create(data) {
    const response = await fetch(
      `${this.baseUrl}/users`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      }
    );
    return response.json();
  }

  /**
   * @param {string} id
   * @param {UpdateUserRequest} data
   * @returns {Promise<User>}
   */
  async update(id, data) {
    const response = await fetch(
      `${this.baseUrl}/users/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      }
    );
    return response.json();
  }
}
\end{lstlisting}

The client provides type-safe methods with parameter validation and return type inference.

\section{Validation Schemas with Zod}
\label{sec:zod-validation}

Zod schemas provide runtime type validation that complements JSDoc's static type checking. The generator produces comprehensive validation logic including constraints, transformations, and error messages.

\subsection{Schema Generation from RDF Constraints}

RDF property definitions include validation constraints that map directly to Zod validators:

\begin{lstlisting}[
  language=JavaScript,
  caption={Zod schema with RDF-derived constraints},
  label=lst:zod-constraints,
  basicstyle=\small\ttfamily,
  frame=single
]
import { z } from "zod";

/**
 * User schema - Blog user account
 */
export const userSchema = z.object({
  id: z.string().min(1),
  username: z.string().min(1).max(255),
  email: z.string().email("Must be a valid email address"),
  bio: z.string().max(500).optional().nullable(),
  posts: z.lazy(() => z.array(postSchema))
    .default([]).optional().nullable(),
});

/**
 * @typedef {z.infer<typeof userSchema>} User
 */
\end{lstlisting}

The Rust generator (Listing~\ref{lst:rust-zod-generator}) implements the constraint mapping:

\begin{lstlisting}[
  language=Rust,
  caption={Rust implementation of Zod schema generation},
  label=lst:rust-zod-generator,
  basicstyle=\small\ttfamily,
  frame=single
]
fn property_to_zod(range: &PropertyRange,
                   cardinality: &Cardinality) -> String {
    let base = match range {
        PropertyRange::String => "z.string()",
        PropertyRange::Integer => "z.number().int()",
        PropertyRange::Float => "z.number()",
        PropertyRange::Boolean => "z.boolean()",
        PropertyRange::DateTime => "z.date()",
        PropertyRange::Reference(class_uri) => {
            let class_name = extract_class_name(class_uri);
            return format!(
              "z.lazy(() => {}Schema)", class_name);
        }
        PropertyRange::Enum(values) => {
            let enum_values = values.iter()
                .map(|v| format!("'{}'", v))
                .collect::<Vec<_>>().join(", ");
            return format!("z.enum([{}])", enum_values);
        }
        _ => "z.any()",
    };

    match cardinality {
        Cardinality::One => base.to_string(),
        Cardinality::ZeroOrOne =>
            format!("{}.optional()", base),
        Cardinality::Many =>
            format!("z.array({})", base),
        Cardinality::OneOrMore =>
            format!("z.array({}).nonempty()", base),
    }
}
\end{lstlisting}

\subsection{Refinements and Custom Validators}

Complex constraints not expressible in RDF can be added through Zod refinements:

\begin{lstlisting}[
  language=JavaScript,
  caption={Zod refinements for complex validation},
  label=lst:zod-refinements,
  basicstyle=\small\ttfamily,
  frame=single
]
export const passwordSchema = z.string()
  .min(8, "Password must be at least 8 characters")
  .refine(
    (password) => /[A-Z]/.test(password),
    "Password must contain an uppercase letter"
  )
  .refine(
    (password) => /[0-9]/.test(password),
    "Password must contain a digit"
  );
\end{lstlisting}

\subsection{Error Messages and Localization}

Zod validation errors include structured issue arrays with field paths and constraint violations. These can be transformed into user-friendly messages:

\begin{lstlisting}[
  language=JavaScript,
  caption={Zod error formatting},
  label=lst:zod-errors,
  basicstyle=\small\ttfamily,
  frame=single
]
const result = userSchema.safeParse(data);
if (!result.success) {
  const errors = result.error.issues.map(issue => ({
    field: issue.path.join('.'),
    message: issue.message,
  }));
  // errors = [
  //   { field: 'email',
  //     message: 'Must be a valid email address' },
  //   { field: 'username',
  //     message: 'String must contain at least 1 character(s)' }
  // ]
}
\end{lstlisting}

\section{Type Guards and Runtime Type Checking}
\label{sec:type-guards}

Type guards provide runtime type checking for defensive programming and gradual typing in legacy codebases.

\subsection{Generated Type Guard Functions}

The generator produces type guard functions that check object shapes at runtime:

\begin{lstlisting}[
  language=JavaScript,
  caption={Generated type guard for runtime type checking},
  label=lst:type-guard,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * Type guard for User
 * @param {unknown} value - Value to check
 * @returns {value is User} True if value matches User structure
 */
export function isUser(value) {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'username' in value &&
    'email' in value
  );
}
\end{lstlisting}

TypeScript recognizes the \texttt{value is User} return type as a type predicate, enabling type narrowing:

\begin{lstlisting}[
  language=JavaScript,
  caption={Type narrowing with type guards},
  label=lst:type-guard-usage,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @param {unknown} data
 */
function processData(data) {
  if (isUser(data)) {
    // TypeScript knows data is User here
    console.log(data.username);
  } else {
    console.error('Invalid user data');
  }
}
\end{lstlisting}

\subsection{Deep Type Guards}

For nested structures, the generator produces recursive type guards:

\begin{lstlisting}[
  language=JavaScript,
  caption={Recursive type guard for nested structures},
  label=lst:recursive-guard,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * @param {unknown} value
 * @returns {value is Post}
 */
export function isPost(value) {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'title' in value &&
    ('author' in value ? isUser(value.author) : true)
  );
}
\end{lstlisting}

\section{Comparison with TypeScript Interfaces}
\label{sec:typescript-comparison}

While TypeScript interfaces provide compile-time type safety, the JSDoc + Zod approach offers distinct advantages for ontology-driven generation.

\subsection{TypeScript Interface Generation}

For comparison, a TypeScript interface generator would produce:

\begin{lstlisting}[
  language=TypeScript,
  caption={Equivalent TypeScript interfaces},
  label=lst:typescript-interfaces,
  basicstyle=\small\ttfamily,
  frame=single
]
/**
 * Blog user account
 */
export interface User {
  /** Unique user identifier */
  id: string;
  /** Username */
  username: string;
  /** Email address */
  email: string;
  /** Optional user biography */
  bio?: string;
  /** Posts authored by user */
  posts?: Post[];
}

export type CreateUserRequest = Omit<User,
  'id' | 'posts'>;
export type UpdateUserRequest = Partial<CreateUserRequest>;
\end{lstlisting}

\subsection{Trade-offs Analysis}

\begin{table}[h]
\centering
\begin{tabular}{|p{4cm}|p{4.5cm}|p{4.5cm}|}
\hline
\textbf{Aspect} & \textbf{JSDoc + Zod} & \textbf{TypeScript} \\
\hline
Runtime validation & Native through Zod & Requires separate library \\
Build step & None (direct execution) & TypeScript compilation required \\
Type safety & Development + Runtime & Development only \\
Template complexity & Moderate (JSDoc + Zod) & Higher (TypeScript syntax trees) \\
Interoperability & Works in JS projects & Requires TypeScript project \\
Debugging & Source code directly & Requires source maps \\
Adoption & Lower barrier & Higher initial setup \\
\hline
\end{tabular}
\caption{JSDoc + Zod vs TypeScript comparison}
\label{tab:jsdoc-vs-typescript}
\end{table}

\subsection{Hybrid Approach}

TypeScript projects can consume JSDoc-annotated code directly, enabling a hybrid approach where generated code uses JSDoc while application code uses TypeScript:

\begin{lstlisting}[
  language=TypeScript,
  caption={TypeScript consuming JSDoc-annotated code},
  label=lst:hybrid-approach,
  basicstyle=\small\ttfamily,
  frame=single
]
// application.ts (TypeScript)
import { User, CreateUserRequest } from '@ggen/types';
import { userSchema } from '@ggen/schemas';

class UserService {
  async createUser(
    data: CreateUserRequest
  ): Promise<User> {
    // Runtime validation
    const validated = userSchema.parse(data);
    // TypeScript type checking + runtime safety
    return this.repository.save(validated);
  }
}
\end{lstlisting}

This approach combines TypeScript's static analysis with Zod's runtime validation, leveraging strengths of both systems.

\section{Conclusion}

This chapter demonstrated how RDF ontologies can drive comprehensive JavaScript/TypeScript code generation, producing type-safe artifacts that integrate seamlessly with modern web development workflows. The multi-layered approach—JSDoc for static types, Zod for runtime validation, and type guards for defensive programming—provides defense in depth against type errors while maintaining JavaScript's dynamic flexibility.

The decision to generate JSDoc-annotated JavaScript rather than TypeScript reflects pragmatic engineering considerations: runtime validation is essential for API boundaries, build simplicity reduces friction, and JavaScript compatibility broadens adoption. TypeScript projects can consume generated code transparently, enabling gradual migration paths.

The deterministic generation pipeline ensures that changes to RDF specifications propagate consistently to all consuming systems—frontend components, API clients, server-side validators, and database schemas. This consistency eliminates entire categories of integration bugs while accelerating development through reliable code generation.

Future work might explore enhanced constraint mapping from SHACL shapes to Zod refinements, automatic generation of GraphQL resolvers from RDF schemas, and optimization of generated code size through tree-shaking and dead code elimination. The foundation established here—deterministic, ontology-driven generation of idiomatic JavaScript—provides a robust basis for these extensions.
