---
name: "Quick Start API Generator (Marketplace-First)"
description: "Generate a complete REST API using marketplace patterns and production readiness tracking"
variables:
  - name: api_name
    description: "Name of the API"
    type: string
    default: "MyAPI"
  - name: resource_name
    description: "Name of the primary resource"
    type: string
    default: "User"
  - name: database_url
    description: "Database connection URL"
    type: string
    default: "postgres://localhost:5432/myapp"
  - name: framework
    description: "Web framework to use"
    type: string
    default: "axum"
    options: ["axum", "actix-web", "warp", "rocket"]
lifecycle:
  init:
    description: "Initialize API project structure"
    commands:
      - "ggen lifecycle run init"
      - "ggen market add rust-{{framework}}-service"
      - "ggen market add postgresql-database"
  generate:
    description: "Generate API components"
    commands:
      - "ggen template generate rust-{{framework}}-service:api-service.tmpl"
      - "ggen template generate postgresql-database:schema.tmpl"
  validate:
    description: "Validate production readiness"
    commands:
      - "ggen lifecycle readiness"
      - "ggen lifecycle validate --env development"
  test:
    description: "Run comprehensive tests"
    commands:
      - "ggen lifecycle run test"
  deploy:
    description: "Deploy to environment"
    commands:
      - "ggen lifecycle run deploy --env development"
query: |
  PREFIX : <http://example.org/>
  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

  SELECT ?className ?propName ?propType ?isRequired
  WHERE {
    ?class a rdfs:Class ;
           rdfs:label ?className .
    ?prop rdfs:domain ?class ;
          rdfs:label ?propName ;
          rdfs:range ?propType .
    OPTIONAL { ?prop :required ?isRequired . }
  }
  ORDER BY ?className ?propName
---

// ðŸš§ PLACEHOLDER: Quick Start API Generator (Marketplace-First)
// This recipe demonstrates the marketplace-first approach:
// 1. Search marketplace for proven patterns
// 2. Install required packages
// 3. Generate using marketplace templates
// 4. Validate production readiness
// 5. Deploy with confidence

// ============================================================================
// DATA MODELS
// ============================================================================

{{#each results}}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{pascalCase className}} {
    pub id: Option<i32>,
    pub {{snake_case propName}}: {{propType}},
}

impl {{pascalCase className}} {
    pub fn new({{snake_case propName}}: {{propType}}) -> Self {
        Self {
            id: None,
            {{snake_case propName}},
        }
    }
}

{{/each}}

// ============================================================================
// DATABASE MODELS
// ============================================================================

use diesel::prelude::*;
use diesel::pg::PgConnection;

pub fn establish_connection() -> PgConnection {
    let database_url = "{{database_url}}";
    PgConnection::establish(database_url)
        .expect(&format!("Error connecting to {}", database_url))
}

// ============================================================================
// REST HANDLERS
// ============================================================================

use actix_web::{web, HttpResponse, Result};

pub async fn create_{{snake_case resource_name}}(
    data: web::Json<{{pascalCase resource_name}}>
) -> Result<HttpResponse> {
    // TODO: Implement database insert
    Ok(HttpResponse::Ok().json(data.0))
}

pub async fn get_{{snake_case resource_name}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database select
    Ok(HttpResponse::Ok().json({{pascalCase resource_name}}::new("placeholder".to_string())))
}

pub async fn update_{{snake_case resource_name}}(
    id: web::Path<i32>,
    data: web::Json<{{pascalCase resource_name}}>
) -> Result<HttpResponse> {
    // TODO: Implement database update
    Ok(HttpResponse::Ok().json(data.0))
}

pub async fn delete_{{snake_case resource_name}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database delete
    Ok(HttpResponse::NoContent().finish())
}

// ============================================================================
// ROUTES
// ============================================================================

pub fn configure_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api/v1")
            .route("/{{kebab-case resource_name}}s", web::post().to(create_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::get().to(get_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::put().to(update_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::delete().to(delete_{{snake_case resource_name}}))
    );
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::test;
    
    #[actix_rt::test]
    async fn test_create_{{snake_case resource_name}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::post()
            .uri("/api/v1/{{kebab-case resource_name}}s")
            .set_json(&{{pascalCase resource_name}}::new("test".to_string()))
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
    
    #[actix_rt::test]
    async fn test_get_{{snake_case resource_name}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::get()
            .uri("/api/v1/{{kebab-case resource_name}}s/1")
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
}

// ============================================================================
// USAGE INSTRUCTIONS
// ============================================================================

// 1. Add dependencies to Cargo.toml:
//    [dependencies]
//    actix-web = "4.0"
//    diesel = { version = "2.0", features = ["postgres"] }
//    serde = { version = "1.0", features = ["derive"] }
//    serde_json = "1.0"
//
// 2. Set up database:
//    createdb myapp
//    diesel setup
//    diesel migration generate create_{{snake_case resource_name}}s
//
// 3. Run the application:
//    cargo run
//
// 4. Test the API:
//    curl -X POST http://localhost:8080/api/v1/{{kebab-case resource_name}}s \
//         -H "Content-Type: application/json" \
//         -d '{"{{snake_case resource_name}}": "test"}'
