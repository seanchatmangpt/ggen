---
name: "Quick Start API Generator"
description: "Generate a complete REST API with models, handlers, and tests"
variables:
  - name: api_name
    description: "Name of the API"
    type: string
    default: "MyAPI"
  - name: resource_name
    description: "Name of the primary resource"
    type: string
    default: "User"
  - name: database_url
    description: "Database connection URL"
    type: string
    default: "postgres://localhost:5432/myapp"
hooks:
  pre:
    - name: "validate-input"
      command: "ggen validate input"
  post:
    - name: "format-code"
      command: "rustfmt"
    - name: "lint-code"
      command: "clippy"
    - name: "test-code"
      command: "cargo test"
query: |
  PREFIX : <http://example.org/>
  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  
  SELECT ?className ?propName ?propType
  WHERE {
    ?class a rdfs:Class ;
           rdfs:label ?className .
    ?prop rdfs:domain ?class ;
          rdfs:label ?propName ;
          rdfs:range ?propType .
  }
  ORDER BY ?className ?propName
---

// Quick Start API Generator
// This recipe generates a complete REST API with:
// - Data models from semantic knowledge graph
// - REST handlers with CRUD operations
// - Database integration
// - Comprehensive tests
// - Documentation

// ============================================================================
// DATA MODELS
// ============================================================================

{{#each results}}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{pascalCase className}} {
    pub id: Option<i32>,
    pub {{snake_case propName}}: {{propType}},
}

impl {{pascalCase className}} {
    pub fn new({{snake_case propName}}: {{propType}}) -> Self {
        Self {
            id: None,
            {{snake_case propName}},
        }
    }
}

{{/each}}

// ============================================================================
// DATABASE MODELS
// ============================================================================

use diesel::prelude::*;
use diesel::pg::PgConnection;

pub fn establish_connection() -> PgConnection {
    let database_url = "{{database_url}}";
    PgConnection::establish(database_url)
        .expect(&format!("Error connecting to {}", database_url))
}

// ============================================================================
// REST HANDLERS
// ============================================================================

use actix_web::{web, HttpResponse, Result};

pub async fn create_{{snake_case resource_name}}(
    data: web::Json<{{pascalCase resource_name}}>
) -> Result<HttpResponse> {
    // TODO: Implement database insert
    Ok(HttpResponse::Ok().json(data.0))
}

pub async fn get_{{snake_case resource_name}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database select
    Ok(HttpResponse::Ok().json({{pascalCase resource_name}}::new("placeholder".to_string())))
}

pub async fn update_{{snake_case resource_name}}(
    id: web::Path<i32>,
    data: web::Json<{{pascalCase resource_name}}>
) -> Result<HttpResponse> {
    // TODO: Implement database update
    Ok(HttpResponse::Ok().json(data.0))
}

pub async fn delete_{{snake_case resource_name}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database delete
    Ok(HttpResponse::NoContent().finish())
}

// ============================================================================
// ROUTES
// ============================================================================

pub fn configure_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api/v1")
            .route("/{{kebab-case resource_name}}s", web::post().to(create_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::get().to(get_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::put().to(update_{{snake_case resource_name}}))
            .route("/{{kebab-case resource_name}}s/{id}", web::delete().to(delete_{{snake_case resource_name}}))
    );
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::test;
    
    #[actix_rt::test]
    async fn test_create_{{snake_case resource_name}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::post()
            .uri("/api/v1/{{kebab-case resource_name}}s")
            .set_json(&{{pascalCase resource_name}}::new("test".to_string()))
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
    
    #[actix_rt::test]
    async fn test_get_{{snake_case resource_name}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::get()
            .uri("/api/v1/{{kebab-case resource_name}}s/1")
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
}

// ============================================================================
// USAGE INSTRUCTIONS
// ============================================================================

// 1. Add dependencies to Cargo.toml:
//    [dependencies]
//    actix-web = "4.0"
//    diesel = { version = "2.0", features = ["postgres"] }
//    serde = { version = "1.0", features = ["derive"] }
//    serde_json = "1.0"
//
// 2. Set up database:
//    createdb myapp
//    diesel setup
//    diesel migration generate create_{{snake_case resource_name}}s
//
// 3. Run the application:
//    cargo run
//
// 4. Test the API:
//    curl -X POST http://localhost:8080/api/v1/{{kebab-case resource_name}}s \
//         -H "Content-Type: application/json" \
//         -d '{"{{snake_case resource_name}}": "test"}'
