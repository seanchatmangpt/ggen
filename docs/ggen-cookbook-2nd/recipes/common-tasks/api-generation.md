<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [API Generation Recipe](#api-generation-recipe)
  - [Overview](#overview)
  - [Prerequisites](#prerequisites)
  - [Step 1: Define the Domain Model](#step-1-define-the-domain-model)
  - [Step 2: Create the API Template](#step-2-create-the-api-template)
  - [Step 3: Generate the API](#step-3-generate-the-api)
  - [Step 4: Set Up Dependencies](#step-4-set-up-dependencies)
  - [Step 5: Set Up Database](#step-5-set-up-database)
  - [Step 6: Test the API](#step-6-test-the-api)
  - [Step 7: Test API Endpoints](#step-7-test-api-endpoints)
  - [Step 8: Add Documentation](#step-8-add-documentation)
  - [Step 9: Docker Configuration](#step-9-docker-configuration)
  - [Step 10: Deploy](#step-10-deploy)
  - [Benefits of This Approach](#benefits-of-this-approach)
  - [Next Steps](#next-steps)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# API Generation Recipe

This recipe shows how to generate a complete REST API with models, handlers, tests, and documentation using GGen's pattern language approach.

## Overview

We'll generate:
- Data models from semantic knowledge graphs
- REST API handlers with CRUD operations
- Database integration
- Comprehensive tests
- API documentation
- Docker configuration

## Prerequisites

- GGen installed
- Rust 1.70+
- PostgreSQL (or Docker)
- Basic knowledge of REST APIs

## Step 1: Define the Domain Model

Create a semantic model of your API:

```bash
cat > domain-model.ttl << 'EOF'
@prefix : <http://example.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

:User a rdfs:Class ;
    rdfs:label "User" ;
    rdfs:comment "A system user with authentication" .

:name a rdf:Property ;
    rdfs:domain :User ;
    rdfs:range xsd:string ;
    rdfs:label "name" .

:email a rdf:Property ;
    rdfs:domain :User ;
    rdfs:range xsd:string ;
    rdfs:label "email" .

:created_at a rdf:Property ;
    rdfs:domain :User ;
    rdfs:range xsd:dateTime ;
    rdfs:label "created_at" .

:Post a rdfs:Class ;
    rdfs:label "Post" ;
    rdfs:comment "A blog post or article" .

:title a rdf:Property ;
    rdfs:domain :Post ;
    rdfs:range xsd:string ;
    rdfs:label "title" .

:content a rdf:Property ;
    rdfs:domain :Post ;
    rdfs:range xsd:string ;
    rdfs:label "content" .

:author a rdf:Property ;
    rdfs:domain :Post ;
    rdfs:range :User ;
    rdfs:label "author" .
EOF
```

## Step 2: Create the API Template

Create a comprehensive API template:

```bash
cat > rest-api.tmpl << 'EOF'
---
name: "REST API Generator"
description: "Generate a complete REST API with models, handlers, and tests"
variables:
  - name: api_name
    description: "Name of the API"
    type: string
    default: "MyAPI"
  - name: database_url
    description: "Database connection URL"
    type: string
    default: "postgres://localhost:5432/myapp"
  - name: port
    description: "Server port"
    type: number
    default: 8080
query: |
  PREFIX : <http://example.org/>
  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
  
  SELECT ?className ?propName ?propType
  WHERE {
    ?class a rdfs:Class ;
           rdfs:label ?className .
    ?prop rdfs:domain ?class ;
          rdfs:label ?propName ;
          rdfs:range ?propType .
  }
  ORDER BY ?className ?propName
---

// {{api_name}} REST API
// Generated by GGen using Pattern 001: Knowledge-First Projection
// 
// This API demonstrates:
// - Semantic data models from RDF knowledge graphs
// - RESTful CRUD operations
// - Database integration
// - Comprehensive testing
// - API documentation

use actix_web::{web, App, HttpServer, Result, HttpResponse};
use serde::{Deserialize, Serialize};
use diesel::prelude::*;
use diesel::pg::PgConnection;
use std::env;

// ============================================================================
// DATA MODELS
// ============================================================================

{{#each results}}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{pascalCase className}} {
    pub id: Option<i32>,
    pub {{snake_case propName}}: {{propType}},
}

impl {{pascalCase className}} {
    pub fn new({{snake_case propName}}: {{propType}}) -> Self {
        Self {
            id: None,
            {{snake_case propName}},
        }
    }
}

{{/each}}

// ============================================================================
// DATABASE CONNECTION
// ============================================================================

pub fn establish_connection() -> PgConnection {
    let database_url = "{{database_url}}";
    PgConnection::establish(database_url)
        .expect(&format!("Error connecting to {}", database_url))
}

// ============================================================================
// REST HANDLERS
// ============================================================================

{{#each results}}
// {{className}} Handlers

pub async fn create_{{snake_case className}}(
    data: web::Json<{{pascalCase className}}>
) -> Result<HttpResponse> {
    // TODO: Implement database insert
    let mut item = data.into_inner();
    item.id = Some(1); // Mock ID
    Ok(HttpResponse::Created().json(item))
}

pub async fn get_{{snake_case className}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database select
    let item = {{pascalCase className}}::new("placeholder".to_string());
    Ok(HttpResponse::Ok().json(item))
}

pub async fn list_{{snake_case className}}s() -> Result<HttpResponse> {
    // TODO: Implement database select all
    let items = vec![{{pascalCase className}}::new("placeholder".to_string())];
    Ok(HttpResponse::Ok().json(items))
}

pub async fn update_{{snake_case className}}(
    id: web::Path<i32>,
    data: web::Json<{{pascalCase className}}>
) -> Result<HttpResponse> {
    // TODO: Implement database update
    let mut item = data.into_inner();
    item.id = Some(*id);
    Ok(HttpResponse::Ok().json(item))
}

pub async fn delete_{{snake_case className}}(
    id: web::Path<i32>
) -> Result<HttpResponse> {
    // TODO: Implement database delete
    Ok(HttpResponse::NoContent().finish())
}

{{/each}}

// ============================================================================
// ROUTES
// ============================================================================

pub fn configure_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/api/v1")
            {{#each results}}
            .service(
                web::scope("/{{kebab-case className}}s")
                    .route("", web::post().to(create_{{snake_case className}}))
                    .route("", web::get().to(list_{{snake_case className}}s))
                    .route("/{id}", web::get().to(get_{{snake_case className}}))
                    .route("/{id}", web::put().to(update_{{snake_case className}}))
                    .route("/{id}", web::delete().to(delete_{{snake_case className}}))
            )
            {{/each}}
    );
}

// ============================================================================
// MAIN APPLICATION
// ============================================================================

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let port = {{port}};
    
    println!("Starting {{api_name}} server on port {}", port);
    
    HttpServer::new(|| {
        App::new()
            .configure(configure_routes)
    })
    .bind(format!("127.0.0.1:{}", port))?
    .run()
    .await
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use actix_web::test;
    
    {{#each results}}
    #[actix_rt::test]
    async fn test_create_{{snake_case className}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::post()
            .uri("/api/v1/{{kebab-case className}}s")
            .set_json(&{{pascalCase className}}::new("test".to_string()))
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
    
    #[actix_rt::test]
    async fn test_get_{{snake_case className}}() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::get()
            .uri("/api/v1/{{kebab-case className}}s/1")
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
    
    #[actix_rt::test]
    async fn test_list_{{snake_case className}}s() {
        let app = test::init_service(
            App::new().configure(configure_routes)
        ).await;
        
        let req = test::TestRequest::get()
            .uri("/api/v1/{{kebab-case className}}s")
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());
    }
    
    {{/each}}
}
EOF
```

## Step 3: Generate the API

Load the domain model and generate the API:

```bash
# Load the domain model
ggen graph load domain-model.ttl

# Generate the API
ggen template apply rest-api.tmpl \
  --set api_name="BlogAPI" \
  --set database_url="postgres://localhost:5432/blog" \
  --set port=3000 \
  --output src/main.rs
```

## Step 4: Set Up Dependencies

Create `Cargo.toml`:

```bash
cat > Cargo.toml << 'EOF'
[package]
name = "blog-api"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.0"
diesel = { version = "2.0", features = ["postgres"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
dotenv = "0.15"

[dev-dependencies]
actix-rt = "2.0"
EOF
```

## Step 5: Set Up Database

```bash
# Create database
createdb blog

# Set up Diesel
diesel setup

# Create migration
diesel migration generate create_users
```

Edit the migration file:

```rust
// migrations/xxx_create_users/up.sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    email VARCHAR NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR NOT NULL,
    content TEXT NOT NULL,
    author_id INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW()
);
```

Run migration:

```bash
diesel migration run
```

## Step 6: Test the API

```bash
# Build the project
cargo build

# Run tests
cargo test

# Start the server
cargo run
```

## Step 7: Test API Endpoints

```bash
# Create a user
curl -X POST http://localhost:3000/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'

# Get all users
curl http://localhost:3000/api/v1/users

# Get a specific user
curl http://localhost:3000/api/v1/users/1

# Create a post
curl -X POST http://localhost:3000/api/v1/posts \
  -H "Content-Type: application/json" \
  -d '{"title": "Hello World", "content": "This is my first post", "author_id": 1}'
```

## Step 8: Add Documentation

Generate API documentation:

```bash
cat > api-docs.tmpl << 'EOF'
---
name: "API Documentation"
description: "Generate OpenAPI documentation for the REST API"
variables:
  - name: api_name
    description: "Name of the API"
    type: string
    default: "MyAPI"
  - name: version
    description: "API version"
    type: string
    default: "1.0.0"
query: |
  PREFIX : <http://example.org/>
  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  
  SELECT ?className ?propName ?propType
  WHERE {
    ?class a rdfs:Class ;
           rdfs:label ?className .
    ?prop rdfs:domain ?class ;
          rdfs:label ?propName ;
          rdfs:range ?propType .
  }
  ORDER BY ?className ?propName
---

openapi: 3.0.0
info:
  title: {{api_name}}
  version: {{version}}
  description: Generated by GGen using Pattern 001: Knowledge-First Projection

paths:
{{#each results}}
  /api/v1/{{kebab-case className}}s:
    get:
      summary: List {{className}}s
      responses:
        '200':
          description: List of {{className}}s
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/{{pascalCase className}}'
    post:
      summary: Create {{className}}
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/{{pascalCase className}}'
      responses:
        '201':
          description: {{className}} created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{pascalCase className}}'
  
  /api/v1/{{kebab-case className}}s/{id}:
    get:
      summary: Get {{className}} by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: {{className}} found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{pascalCase className}}'
    put:
      summary: Update {{className}}
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/{{pascalCase className}}'
      responses:
        '200':
          description: {{className}} updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{pascalCase className}}'
    delete:
      summary: Delete {{className}}
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '204':
          description: {{className}} deleted

{{/each}}

components:
  schemas:
{{#each results}}
    {{pascalCase className}}:
      type: object
      properties:
        id:
          type: integer
          description: Unique identifier
        {{snake_case propName}}:
          type: string
          description: {{propName}}
      required:
        - {{snake_case propName}}

{{/each}}
EOF
```

Generate documentation:

```bash
ggen template apply api-docs.tmpl \
  --set api_name="BlogAPI" \
  --set version="1.0.0" \
  --output api-docs.yaml
```

## Step 9: Docker Configuration

Create `Dockerfile`:

```bash
cat > Dockerfile << 'EOF'
FROM rust:1.70-slim as builder

WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bullseye-slim
RUN apt-get update && apt-get install -y \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/blog-api /usr/local/bin/blog-api
EXPOSE 3000
CMD ["blog-api"]
EOF
```

Create `docker-compose.yml`:

```bash
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: blog
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgres://postgres:password@db:5432/blog
    depends_on:
      - db

volumes:
  postgres_data:
EOF
```

## Step 10: Deploy

```bash
# Build and run with Docker Compose
docker-compose up --build

# Test the deployed API
curl http://localhost:3000/api/v1/users
```

## Benefits of This Approach

1. **Semantic Consistency**: All generated code reflects the same domain model
2. **Traceability**: Generated code can be traced back to specific RDF triples
3. **Multi-Target Generation**: Same model can generate code for multiple languages
4. **Evolution**: When the model changes, all code can be updated automatically
5. **Validation**: Model can be validated independently of generated code

## Next Steps

- Explore [Advanced Patterns](../patterns/advanced.md)
- Learn about [Testing Strategies](../testing/strategies.md)
- Try [CI/CD Integration](../integration/cicd.md)
- Join the [Community](../community/)
