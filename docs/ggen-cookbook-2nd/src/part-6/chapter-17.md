<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Chapter 17 - Extending GGen](#chapter-17---extending-ggen)
  - [17.1 Custom Processors](#171-custom-processors)
    - [Basic Processor Implementation](#basic-processor-implementation)
    - [Processor Configuration](#processor-configuration)
  - [17.2 Plugin Architecture](#172-plugin-architecture)
    - [Plugin Interface](#plugin-interface)
    - [Plugin Registration](#plugin-registration)
  - [17.3 Foreign Function Interface](#173-foreign-function-interface)
    - [C Interface](#c-interface)
    - [Python Bindings](#python-bindings)
  - [17.4 Contributing to Core](#174-contributing-to-core)
    - [Development Setup](#development-setup)
    - [Code Organization](#code-organization)
    - [Adding New Template Types](#adding-new-template-types)
    - [Testing Contributions](#testing-contributions)
  - [17.5 Advanced Extension Patterns](#175-advanced-extension-patterns)
    - [Template Inheritance Extension](#template-inheritance-extension)
    - [Custom Variable Resolution](#custom-variable-resolution)
  - [17.6 Performance Extensions](#176-performance-extensions)
    - [Custom Cache Implementations](#custom-cache-implementations)
    - [Parallel Processing Extensions](#parallel-processing-extensions)
  - [17.7 Integration with External Systems](#177-integration-with-external-systems)
    - [Database Integration](#database-integration)
    - [Git-Based Template Storage](#git-based-template-storage)
  - [17.8 Custom Output Formats](#178-custom-output-formats)
    - [Binary Generation](#binary-generation)
    - [Documentation Generation](#documentation-generation)
  - [17.9 Community Extensions](#179-community-extensions)
    - [Extension Registry](#extension-registry)
    - [Extension Development Kit](#extension-development-kit)
  - [Summary](#summary)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Chapter 17 - Extending GGen

GGen's architecture is designed for extensibility, allowing developers to customize and enhance its capabilities for specialized use cases. This chapter covers the various ways to extend GGen, from simple custom processors to building entirely new code generation paradigms.

## 17.1 Custom Processors

Custom processors allow you to modify or enhance generated code during the generation pipeline.

### Basic Processor Implementation

```rust
use ggen_core::processor::{Processor, ProcessorContext, ProcessorResult};
use ggen_core::template::Template;
use ggen_core::graph::Graph;

pub struct CustomProcessor {
    config: ProcessorConfig,
}

impl Processor for CustomProcessor {
    fn name(&self) -> &str {
        "custom-processor"
    }

    fn process(&self, ctx: &mut ProcessorContext) -> ProcessorResult {
        // Access template information
        let template = &ctx.template;
        let variables = &ctx.variables;

        // Modify the generated content
        let mut content = ctx.content.clone();

        // Apply custom transformations
        content = self.transform_content(content, template, variables)?;

        ctx.content = content;
        Ok(())
    }
}

impl CustomProcessor {
    fn transform_content(
        &self,
        mut content: String,
        _template: &Template,
        _variables: &HashMap<String, String>,
    ) -> ProcessorResult<String> {
        // Example: Add custom headers to all generated files
        if content.contains("fn main") {
            content = format!(
                "// Generated by GGen with custom processor\n{}\n{}",
                self.config.header_text,
                content
            );
        }

        Ok(content)
    }
}
```

### Processor Configuration

```toml
# .ggen.toml
[processors.custom]
enabled = true
header_text = "// Custom header added by processor"
priority = 100  # Higher numbers run later
```

## 17.2 Plugin Architecture

Plugins provide a more comprehensive way to extend GGen's functionality.

### Plugin Interface

```rust
use ggen_core::plugin::{Plugin, PluginMetadata, PluginContext, PluginResult};

pub struct CustomPlugin {
    metadata: PluginMetadata,
}

impl Plugin for CustomPlugin {
    fn metadata(&self) -> &PluginMetadata {
        &self.metadata
    }

    fn initialize(&mut self, ctx: &PluginContext) -> PluginResult<()> {
        // Plugin initialization logic
        println!("Initializing custom plugin");
        Ok(())
    }

    fn execute(&self, ctx: &PluginContext) -> PluginResult<()> {
        // Plugin execution logic
        Ok(())
    }

    fn cleanup(&mut self, ctx: &PluginContext) -> PluginResult<()> {
        // Plugin cleanup logic
        Ok(())
    }
}

impl CustomPlugin {
    pub fn new() -> Self {
        Self {
            metadata: PluginMetadata {
                name: "custom-plugin".to_string(),
                version: "1.0.0".to_string(),
                description: "Custom plugin for enhanced functionality".to_string(),
                author: "Your Name".to_string(),
            },
        }
    }
}
```

### Plugin Registration

```bash
# Register plugin with GGen
ggen plugin register ./target/debug/libcustom_plugin.so

# List registered plugins
ggen plugin list

# Enable/disable plugin
ggen plugin enable custom-plugin
ggen plugin disable custom-plugin
```

## 17.3 Foreign Function Interface

Integrate GGen with other languages and systems through FFI.

### C Interface

```c
// ggen-ffi.h
#ifndef GGEN_FFI_H
#define GGEN_FFI_H

#ifdef __cplusplus
extern "C" {
#endif

// Generate code from template
const char* ggen_generate(
    const char* template_path,
    const char* variables_json,
    const char** error_message
);

// Free generated string
void ggen_free_string(const char* str);

// Initialize GGen context
void* ggen_create_context(const char* config_path);

// Destroy GGen context
void ggen_destroy_context(void* context);

#ifdef __cplusplus
}
#endif

#endif
```

### Python Bindings

```python
# ggen.pyi
from typing import Dict, Optional, Tuple

class GGenContext:
    def __init__(self, config_path: str) -> None: ...
    def generate(self, template_path: str, variables: Dict[str, str]) -> str: ...
    def validate(self, template_path: str) -> Tuple[bool, str]: ...
    def close(self) -> None: ...

def generate_code(template_path: str, variables: Dict[str, str]) -> str: ...
def validate_template(template_path: str) -> Tuple[bool, str]: ...
```

## 17.4 Contributing to Core

For developers who want to contribute significant enhancements back to GGen core.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/seanchatmangpt/ggen.git
cd ggen

# Set up development environment
cargo make setup-dev

# Run tests
cargo make test

# Run benchmarks
cargo make bench
```

### Code Organization

Understanding GGen's architecture for contributions:

```
src/
├── bin/           # CLI entry points
├── lib.rs         # Main library exports
├── core/          # Core generation engine
├── cli/           # CLI command implementations
└── utils/         # Utilities and helpers
```

### Adding New Template Types

```rust
// In ggen-core/src/template/types.rs
#[derive(Debug, Clone)]
pub enum TemplateType {
    Standard,
    AiGenerated,
    Custom(String),
}

// In ggen-core/src/template/mod.rs
impl Template {
    pub fn new_custom(template_type: TemplateType, content: String) -> Self {
        Self {
            template_type,
            content,
            frontmatter: Frontmatter::default(),
            metadata: TemplateMetadata::default(),
        }
    }
}
```

### Testing Contributions

```rust
// In tests/integration_tests.rs
#[test]
fn test_custom_template_generation() {
    let template = Template::new_custom(
        TemplateType::Custom("my-template".to_string()),
        "Hello {{name}}!".to_string(),
    );

    let result = generate_template(
        &template,
        &HashMap::from([("name".to_string(), "World".to_string())]),
    );

    assert_eq!(result, "Hello World!");
}
```

## 17.5 Advanced Extension Patterns

### Template Inheritance Extension

Create more sophisticated template inheritance:

```rust
use ggen_core::template::{Template, TemplateInheritance};

pub struct AdvancedInheritance;

impl TemplateInheritance for AdvancedInheritance {
    fn resolve_inheritance(&self, templates: Vec<Template>) -> Result<Template, Error> {
        // Custom inheritance logic
        let mut base_template = templates.first().unwrap().clone();

        for template in templates.iter().skip(1) {
            base_template = self.merge_templates(base_template, template.clone())?;
        }

        Ok(base_template)
    }
}
```

### Custom Variable Resolution

Implement domain-specific variable resolution:

```rust
use ggen_core::variables::{VariableResolver, VariableContext};

pub struct DomainVariableResolver {
    domain_config: DomainConfig,
}

impl VariableResolver for DomainVariableResolver {
    fn resolve(&self, variable: &str, ctx: &VariableContext) -> Option<String> {
        match variable {
            "current_user" => Some(self.domain_config.current_user.clone()),
            "tenant_id" => Some(ctx.get("tenant").unwrap_or("default")),
            "environment" => Some(self.domain_config.environment.clone()),
            _ => None,
        }
    }
}
```

## 17.6 Performance Extensions

### Custom Cache Implementations

```rust
use ggen_core::cache::{Cache, CacheEntry};

pub struct RedisCache {
    client: RedisClient,
}

impl Cache for RedisCache {
    fn get(&self, key: &str) -> Option<CacheEntry> {
        self.client.get(format!("ggen:{}", key)).ok()
    }

    fn set(&self, key: &str, entry: CacheEntry) -> Result<(), Error> {
        self.client.set_ex(
            format!("ggen:{}", key),
            entry,
            entry.ttl_seconds,
        )?;
        Ok(())
    }

    fn invalidate(&self, pattern: &str) -> Result<(), Error> {
        let keys = self.client.keys(format!("ggen:{}*", pattern))?;
        if !keys.is_empty() {
            self.client.del(keys)?;
        }
        Ok(())
    }
}
```

### Parallel Processing Extensions

```rust
use ggen_core::pipeline::{PipelineStage, ParallelProcessor};

pub struct CustomParallelProcessor {
    thread_pool: ThreadPool,
}

impl ParallelProcessor for CustomParallelProcessor {
    fn process_parallel(&self, templates: Vec<Template>) -> Vec<TemplateResult> {
        templates
            .into_par_iter()
            .map(|template| self.process_single(template))
            .collect()
    }
}
```

## 17.7 Integration with External Systems

### Database Integration

```rust
pub struct DatabaseTemplateSource {
    db_pool: DatabasePool,
}

impl TemplateSource for DatabaseTemplateSource {
    fn load_template(&self, name: &str) -> Result<Template, Error> {
        let row = self.db_pool
            .query_one(
                "SELECT content, metadata FROM templates WHERE name = $1",
                &[&name],
            )?;

        Ok(Template::from_database_row(row)?)
    }

    fn list_templates(&self) -> Result<Vec<String>, Error> {
        let rows = self.db_pool
            .query("SELECT name FROM templates ORDER BY name", &[])?;

        Ok(rows.iter().map(|row| row.get("name")).collect())
    }
}
```

### Git-Based Template Storage

```rust
pub struct GitTemplateSource {
    repo_url: String,
    branch: String,
}

impl TemplateSource for GitTemplateSource {
    fn load_template(&self, name: &str) -> Result<Template, Error> {
        let repo = Repository::clone(&self.repo_url, "/tmp/ggen-templates")?;
        let tree = repo.find_branch(&self.branch)?.get().peel_to_tree()?;

        let entry = tree.get_path(Path::new(&format!("templates/{}", name)))?;
        let blob = entry.to_object(&repo)?.peel_to_blob()?;

        let content = String::from_utf8(blob.content().to_vec())?;
        Ok(Template::from_string(content)?)
    }
}
```

## 17.8 Custom Output Formats

### Binary Generation

```rust
use ggen_core::output::{OutputFormat, BinaryGenerator};

pub struct WasmGenerator;

impl OutputFormat for WasmGenerator {
    fn generate(&self, template: &Template, variables: &HashMap<String, String>) -> Result<Vec<u8>, Error> {
        // Generate WebAssembly binary from template
        let source = template.render(variables)?;

        // Compile to WASM
        let binary = wasm_compiler::compile(&source)?;
        Ok(binary)
    }
}
```

### Documentation Generation

```rust
pub struct MarkdownGenerator;

impl OutputFormat for MarkdownGenerator {
    fn generate(&self, template: &Template, variables: &HashMap<String, String>) -> Result<Vec<u8>, Error> {
        let content = template.render(variables)?;

        // Transform code to markdown documentation
        let markdown = self.code_to_docs(&content)?;
        Ok(markdown.into_bytes())
    }
}
```

## 17.9 Community Extensions

### Extension Registry

The GGen ecosystem supports a registry of community extensions:

```bash
# Browse available extensions
ggen extension search processor

# Install extension
ggen extension install ggen-custom-processor

# Update extensions
ggen extension update

# Remove extension
ggen extension remove ggen-custom-processor
```

### Extension Development Kit

```rust
// ggen-extension-kit/src/lib.rs
pub use ggen_core::{Processor, Plugin, TemplateSource, OutputFormat};

pub mod prelude {
    pub use crate::{Processor, Plugin, TemplateSource, OutputFormat};
    pub use ggen_core::error::Result;
    pub use serde::{Serialize, Deserialize};
}

// Example extension
pub struct ExampleProcessor;

impl Processor for ExampleProcessor {
    // Implementation
}
```

## Summary

Extending GGen opens up limitless possibilities for customization and integration. Whether you're building simple processors for specific use cases or developing comprehensive plugins that transform how GGen works, the architecture provides the flexibility to adapt to any development workflow. The key is understanding your specific needs and leveraging the appropriate extension points while maintaining compatibility with the broader GGen ecosystem.
