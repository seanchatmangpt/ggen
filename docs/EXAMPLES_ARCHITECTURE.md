# ggen Examples Architecture

**Version**: 1.0.0
**Date**: 2025-10-11
**Status**: Design Specification

## Executive Summary

This document defines a comprehensive, progressive example architecture for ggen that covers all major use cases from basic template generation to advanced AI-powered multi-template projects. Each example is designed to be self-contained, runnable, and educational.

**Design Principles**:
- **Progressive Complexity**: Start simple, build gradually
- **Self-Contained**: Each example runs independently
- **Educational Value**: Teach 1-2 core concepts per example
- **Real-World Patterns**: Production-ready workflows
- **Composability**: Examples build on each other

**Coverage**:
- âœ… All AI commands (generate, sparql, graph, frontmatter, from-source, project)
- âœ… MCP integration patterns
- âœ… RDF/SPARQL workflows
- âœ… Marketplace usage
- âœ… Ultrathink task orchestration
- âœ… Multi-template projects

---

## Example Progression Map

```
Level 1: Fundamentals
â”œâ”€ Example 1: Basic Template Generation (frontmatter + rendering)
â””â”€ Example 2: RDF/SPARQL Integration (semantic metadata)

Level 2: AI-Powered Generation
â”œâ”€ Example 3: AI Template Creation (ai generate, ai validate)
â””â”€ Example 4: Source Code Analysis (ai from-source)

Level 3: Complete Workflows
â”œâ”€ Example 5: Full Project Generation (ai project, multi-file)
â””â”€ Example 6: MCP Integration (ggen-mcp tools usage)

Level 4: Advanced Patterns
â””â”€ Example 7: Multi-Template Project (combining all patterns)
```

**Learning Path**:
1. **Beginner** â†’ Examples 1-2 (understand templates and RDF)
2. **Intermediate** â†’ Examples 3-4 (leverage AI generation)
3. **Advanced** â†’ Examples 5-6 (complete projects and integration)
4. **Expert** â†’ Example 7 (production-ready multi-pattern projects)

---

## Example 1: Basic Template Generation

### Goals
- Understand ggen template structure (YAML frontmatter + body)
- Learn variable substitution and rendering
- Master file output and injection modes
- **Teaching Points**: Template anatomy, Tera templating, frontmatter variables

### Use Case
Generate a simple Rust module with configurable name and author.

### File Structure
```
examples/01-basic-template/
â”œâ”€â”€ README.md                      # Tutorial walkthrough
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ rust-module.tmpl          # Basic module template
â”‚   â””â”€â”€ rust-struct.tmpl          # Struct with fields template
â”œâ”€â”€ outputs/                       # Generated code examples
â”‚   â”œâ”€â”€ my_module.rs
â”‚   â””â”€â”€ user_struct.rs
â”œâ”€â”€ run.sh                         # Automation script
â””â”€â”€ tests/
    â””â”€â”€ validate_output.sh        # Validation tests
```

### Template Example (`rust-module.tmpl`)
```yaml
---
to: "src/{{name}}.rs"
vars:
  name: "example"
  author: "ggen"
  description: "A generated module"
---
//! {{description}}
//! Generated by {{author}}

pub struct {{name | capitalize}} {
    // Module implementation
}

impl {{name | capitalize}} {
    pub fn new() -> Self {
        Self {}
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_{{name}}_creation() {
        let instance = {{name | capitalize}}::new();
        // Add assertions
    }
}
```

### Commands Demonstrated
```bash
# Basic generation
ggen gen templates/rust-module.tmpl --vars name=my_module author="Your Name"

# With output path
ggen gen templates/rust-module.tmpl \
  --vars name=user author="Your Name" \
  --output src/user.rs

# Multiple variables
ggen gen templates/rust-struct.tmpl \
  --vars name=User \
  --vars fields="id,name,email" \
  --vars derive="Debug,Clone,Serialize"
```

### Success Criteria
- [ ] Template renders successfully
- [ ] Variables are substituted correctly
- [ ] Output file is created in correct location
- [ ] Generated code compiles (for Rust examples)
- [ ] User understands frontmatter variables
- [ ] User can modify template for their needs

### Prerequisites
- ggen installed
- Basic understanding of YAML
- Text editor

### Estimated Time
**15-30 minutes**

---

## Example 2: RDF/SPARQL Integration

### Goals
- Embed semantic metadata in templates
- Query RDF graphs with SPARQL
- Use query results in template rendering
- **Teaching Points**: RDF triples, SPARQL syntax, semantic generation

### Use Case
Generate a user management system with RDF ontology and SPARQL-driven templates.

### File Structure
```
examples/02-rdf-sparql/
â”œâ”€â”€ README.md                      # Tutorial walkthrough
â”œâ”€â”€ ontology/
â”‚   â”œâ”€â”€ user-ontology.ttl         # User domain model (RDF)
â”‚   â””â”€â”€ project-schema.ttl        # Project metadata
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ user-model.tmpl           # Template with RDF inline
â”‚   â””â”€â”€ sparql-queries.tmpl       # Template using SPARQL
â”œâ”€â”€ outputs/
â”‚   â”œâ”€â”€ user.rs
â”‚   â””â”€â”€ queries.sql
â”œâ”€â”€ run.sh
â””â”€â”€ tests/
    â””â”€â”€ validate_rdf.sh           # RDF validation script
```

### RDF Ontology Example (`user-ontology.ttl`)
```turtle
@prefix ex: <http://example.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .

ex:User a owl:Class ;
    rdfs:label "User" ;
    rdfs:comment "A user in the system" .

ex:hasEmail a owl:DatatypeProperty ;
    rdfs:domain ex:User ;
    rdfs:range xsd:string .

ex:hasRole a owl:ObjectProperty ;
    rdfs:domain ex:User ;
    rdfs:range ex:Role .

ex:Admin a ex:Role ;
    rdfs:label "Administrator" .
```

### Template with SPARQL (`user-model.tmpl`)
```yaml
---
to: "src/models/{{entity}}.rs"
vars:
  entity: "User"
prefixes:
  ex: "http://example.org/"
  rdfs: "http://www.w3.org/2000/01/rdf-schema#"
rdf_inline:
  - "@prefix ex: <http://example.org/> ."
  - "ex:{{entity}} a ex:Model ."
sparql:
  get_properties: |
    SELECT ?property ?label WHERE {
      ex:{{entity}} a owl:Class .
      ?property rdfs:domain ex:{{entity}} .
      ?property rdfs:label ?label .
    }
---
// Generated from RDF ontology
pub struct {{entity}} {
    {% for prop in sparql(query="get_properties") %}
    pub {{prop.label | lower}}: String,
    {% endfor %}
}
```

### Commands Demonstrated
```bash
# Load RDF graph
ggen graph load ontology/user-ontology.ttl

# Query graph
ggen graph query --query "SELECT ?class WHERE { ?class a owl:Class } LIMIT 10"

# Generate from graph
ggen gen templates/user-model.tmpl \
  --graph ontology/user-ontology.ttl \
  --vars entity=User

# Validate RDF
ggen graph validate ontology/user-ontology.ttl
```

### Success Criteria
- [ ] RDF ontology loads successfully
- [ ] SPARQL queries execute and return results
- [ ] Template uses query results in rendering
- [ ] Generated code reflects ontology structure
- [ ] User understands RDF/SPARQL integration
- [ ] User can create custom ontologies

### Prerequisites
- Completed Example 1
- Basic RDF/Turtle syntax knowledge
- Basic SPARQL understanding

### Estimated Time
**30-45 minutes**

---

## Example 3: AI Template Creation

### Goals
- Generate templates using AI (`ai generate`)
- Validate and improve templates iteratively (`ai validate`)
- Understand AI configuration (providers, models)
- **Teaching Points**: AI-powered generation, prompt engineering, validation loops

### Use Case
Use AI to create a REST API template from natural language description.

### File Structure
```
examples/03-ai-template-creation/
â”œâ”€â”€ README.md
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ basic-api.txt             # Simple API description
â”‚   â”œâ”€â”€ advanced-api.txt          # Complex API with auth
â”‚   â””â”€â”€ prompt-guide.md           # Prompt engineering tips
â”œâ”€â”€ templates/                     # AI-generated templates
â”‚   â”œâ”€â”€ api-controller.tmpl
â”‚   â”œâ”€â”€ api-routes.tmpl
â”‚   â””â”€â”€ api-tests.tmpl
â”œâ”€â”€ outputs/
â”‚   â”œâ”€â”€ user_controller.rs
â”‚   â””â”€â”€ user_routes.rs
â”œâ”€â”€ config/
â”‚   â””â”€â”€ ai-config.toml            # AI provider configuration
â”œâ”€â”€ run.sh
â””â”€â”€ tests/
    â””â”€â”€ validate_ai_output.sh
```

### AI Configuration (`config/ai-config.toml`)
```toml
[ai]
provider = "ollama"              # Options: ollama, openai, anthropic
model = "qwen3-coder:30b"        # Model to use
temperature = 0.1                # Lower for deterministic code
max_tokens = 4096
top_p = 0.9

[validation]
enabled = true
max_iterations = 3
strict_mode = false
```

### Prompt Example (`prompts/advanced-api.txt`)
```
Create a REST API template for user management with the following features:
- CRUD operations (Create, Read, Update, Delete)
- JWT authentication middleware
- Input validation using validator crate
- Error handling with proper HTTP status codes
- Actix-web framework
- Include unit tests

The template should support variables:
- entity_name: Name of the entity (e.g., User, Product)
- fields: List of fields with types
- auth_required: Boolean for authentication requirement
```

### Commands Demonstrated
```bash
# Generate template with AI
ggen ai generate \
  --description "REST API controller for user management" \
  --examples "Include CRUD operations" \
  --examples "Add JWT authentication" \
  --output templates/api-controller.tmpl

# Generate with validation
ggen ai generate \
  --description "$(cat prompts/advanced-api.txt)" \
  --validate \
  --max-iterations 3 \
  --output templates/validated-api.tmpl

# Check AI configuration
ggen ai config --show

# List available models
ggen ai models

# Use different provider
ggen ai generate \
  --description "User service layer" \
  --model "gpt-4o" \
  --provider openai \
  --output templates/user-service.tmpl

# Demo AI capabilities
ggen ai demo
```

### Success Criteria
- [ ] AI generates valid ggen template
- [ ] Template includes proper frontmatter
- [ ] Validation improves template quality
- [ ] Generated template is reusable
- [ ] User understands AI configuration
- [ ] User can write effective prompts

### Prerequisites
- Completed Examples 1-2
- Ollama installed OR API keys for OpenAI/Anthropic
- Understanding of prompt engineering basics

### Estimated Time
**30-45 minutes**

---

## Example 4: Source Code Analysis

### Goals
- Analyze existing code with AI (`ai from-source`)
- Extract patterns and generate templates
- Reverse-engineer templates from codebases
- **Teaching Points**: Code analysis, pattern extraction, template synthesis

### Use Case
Analyze an existing Rust project and generate reusable templates from its patterns.

### File Structure
```
examples/04-source-analysis/
â”œâ”€â”€ README.md
â”œâ”€â”€ source-code/
â”‚   â”œâ”€â”€ existing-api/             # Example codebase to analyze
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user_controller.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product_controller.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product.rs
â”‚   â”‚   â”‚   â””â”€â”€ lib.rs
â”‚   â”‚   â””â”€â”€ Cargo.toml
â”‚   â””â”€â”€ legacy-python/            # Python code to convert
â”‚       â”œâ”€â”€ api.py
â”‚       â””â”€â”€ models.py
â”œâ”€â”€ generated-templates/          # Extracted templates
â”‚   â”œâ”€â”€ controller-pattern.tmpl
â”‚   â”œâ”€â”€ model-pattern.tmpl
â”‚   â””â”€â”€ conversion-rust-to-python.tmpl
â”œâ”€â”€ outputs/
â”‚   â”œâ”€â”€ new_controller.rs
â”‚   â””â”€â”€ new_model.rs
â”œâ”€â”€ analysis-reports/
â”‚   â”œâ”€â”€ patterns-detected.md
â”‚   â””â”€â”€ recommendations.md
â”œâ”€â”€ run.sh
â””â”€â”€ tests/
    â””â”€â”€ validate_extraction.sh
```

### Source Code Example (`source-code/existing-api/src/controllers/user_controller.rs`)
```rust
use actix_web::{web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}

pub async fn get_user(path: web::Path<i32>) -> impl Responder {
    let user_id = path.into_inner();
    // Fetch user logic
    HttpResponse::Ok().json(User {
        id: user_id,
        name: "Example".to_string(),
        email: "example@example.com".to_string(),
    })
}

pub async fn create_user(user: web::Json<User>) -> impl Responder {
    // Create user logic
    HttpResponse::Created().json(user.into_inner())
}
```

### Commands Demonstrated
```bash
# Analyze single file
ggen ai from-source \
  --file source-code/existing-api/src/controllers/user_controller.rs \
  --output generated-templates/controller-pattern.tmpl

# Analyze entire directory
ggen ai from-source \
  --directory source-code/existing-api/src \
  --pattern "**/*.rs" \
  --output-dir generated-templates/

# Analyze with specific focus
ggen ai from-source \
  --file source-code/legacy-python/api.py \
  --description "Extract REST API patterns and convert to Rust Actix-web" \
  --output generated-templates/python-to-rust-api.tmpl

# Generate analysis report
ggen ai from-source \
  --directory source-code/existing-api \
  --analyze-only \
  --output analysis-reports/patterns-detected.md

# Extract and validate
ggen ai from-source \
  --file source-code/existing-api/src/models/user.rs \
  --validate \
  --output generated-templates/validated-model.tmpl
```

### Success Criteria
- [ ] AI analyzes source code successfully
- [ ] Patterns are correctly extracted
- [ ] Generated template is reusable
- [ ] Template variables are properly parameterized
- [ ] Analysis report identifies key patterns
- [ ] User can extract templates from any codebase

### Prerequisites
- Completed Examples 1-3
- Source code to analyze (provided in example)
- Understanding of code patterns

### Estimated Time
**30-45 minutes**

---

## Example 5: Full Project Generation

### Goals
- Generate complete project structures (`ai project`)
- Configure multi-file generation
- Understand project templates and scaffolding
- **Teaching Points**: Project architecture, multi-template coordination, build systems

### Use Case
Generate a complete web service project with API, models, tests, and configuration.

### File Structure
```
examples/05-full-project/
â”œâ”€â”€ README.md
â”œâ”€â”€ project-specs/
â”‚   â”œâ”€â”€ web-service.yaml          # Project specification
â”‚   â”œâ”€â”€ microservice.yaml         # Microservice spec
â”‚   â””â”€â”€ full-stack-app.yaml       # Full-stack spec
â”œâ”€â”€ generated-projects/           # Output directory
â”‚   â”œâ”€â”€ web-service/
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ docs/
â”‚   â”‚   â”œâ”€â”€ .github/
â”‚   â”‚   â”‚   â””â”€â”€ workflows/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ microservice/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ templates/                     # Custom project templates
â”‚   â”œâ”€â”€ rust-web-service/
â”‚   â””â”€â”€ python-flask-api/
â”œâ”€â”€ run.sh
â””â”€â”€ tests/
    â””â”€â”€ validate_project_structure.sh
```

### Project Specification (`project-specs/web-service.yaml`)
```yaml
name: "user-management-api"
description: "REST API for user management with authentication"
language: "rust"
framework: "actix-web"

architecture:
  style: "layered"
  layers:
    - name: "api"
      description: "HTTP controllers and routes"
    - name: "service"
      description: "Business logic layer"
    - name: "repository"
      description: "Data access layer"
    - name: "models"
      description: "Data models and DTOs"

features:
  - authentication: true
  - authorization: "rbac"
  - database: "postgresql"
  - caching: "redis"
  - logging: "tracing"
  - metrics: "prometheus"
  - api_docs: "openapi"

entities:
  - name: "User"
    fields:
      - { name: "id", type: "i32", primary: true }
      - { name: "email", type: "String", unique: true }
      - { name: "name", type: "String" }
      - { name: "role", type: "Role", relation: "many-to-one" }
  - name: "Role"
    fields:
      - { name: "id", type: "i32", primary: true }
      - { name: "name", type: "String" }

testing:
  unit_tests: true
  integration_tests: true
  e2e_tests: true
  coverage_threshold: 80

deployment:
  containerized: true
  ci_cd: "github-actions"
  environments: ["dev", "staging", "prod"]
```

### Commands Demonstrated
```bash
# Generate basic project
ggen ai project \
  --description "Web service with REST API" \
  --name "my-web-service" \
  --rust

# Generate from specification
ggen ai project \
  --spec project-specs/web-service.yaml \
  --output generated-projects/web-service

# Generate with custom template
ggen ai project \
  --spec project-specs/microservice.yaml \
  --template templates/rust-web-service \
  --output generated-projects/microservice

# Interactive project generation
ggen ai project --interactive

# Generate and initialize
ggen ai project \
  --spec project-specs/web-service.yaml \
  --output generated-projects/initialized-service \
  --init-git \
  --install-deps

# Full-stack project
ggen ai project \
  --spec project-specs/full-stack-app.yaml \
  --frontend react \
  --backend rust \
  --database postgresql \
  --output generated-projects/full-stack
```

### Success Criteria
- [ ] Complete project structure is generated
- [ ] All files are in correct locations
- [ ] Build system configuration works (Cargo.toml, etc.)
- [ ] Project compiles successfully
- [ ] Tests run and pass
- [ ] Documentation is generated
- [ ] CI/CD configuration is valid
- [ ] User can customize project generation

### Prerequisites
- Completed Examples 1-4
- Understanding of project architecture
- Familiarity with build systems (Cargo, npm, etc.)

### Estimated Time
**45-60 minutes**

---

## Example 6: MCP Integration

### Goals
- Use ggen via Model Context Protocol (MCP)
- Integrate with Claude Desktop / Cline VSCode
- Understand MCP tools and capabilities
- **Teaching Points**: MCP protocol, AI assistant integration, tool usage

### Use Case
Integrate ggen with Claude Desktop to generate code through conversational interface.

### File Structure
```
examples/06-mcp-integration/
â”œâ”€â”€ README.md
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ claude-desktop/
â”‚   â”‚   â”œâ”€â”€ config.json           # Claude Desktop MCP config
â”‚   â”‚   â””â”€â”€ example-conversations.md
â”‚   â”œâ”€â”€ cline-vscode/
â”‚   â”‚   â”œâ”€â”€ settings.json         # VSCode settings
â”‚   â”‚   â””â”€â”€ keybindings.json
â”‚   â””â”€â”€ mcp-server-config.toml    # ggen MCP server config
â”œâ”€â”€ clients/
â”‚   â”œâ”€â”€ rust-client/              # Rust MCP client example
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/main.rs
â”‚   â”œâ”€â”€ python-client/            # Python MCP client example
â”‚   â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”‚   â””â”€â”€ client.py
â”‚   â””â”€â”€ http-curl/                # HTTP/curl examples
â”‚       â”œâ”€â”€ list-tools.sh
â”‚       â”œâ”€â”€ generate-code.sh
â”‚       â””â”€â”€ batch-operations.sh
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ code-generation-flow.md   # Example workflows
â”‚   â”œâ”€â”€ ontology-query-flow.md
â”‚   â””â”€â”€ template-search-flow.md
â”œâ”€â”€ outputs/
â”‚   â””â”€â”€ generated-via-mcp/
â”œâ”€â”€ run-mcp-server.sh
â””â”€â”€ tests/
    â””â”€â”€ validate_mcp_tools.sh
```

### Claude Desktop Configuration (`config/claude-desktop/config.json`)
```json
{
  "mcpServers": {
    "ggen": {
      "command": "ggen",
      "args": ["mcp", "start"],
      "type": "stdio",
      "env": {
        "GGEN_HOME": "${HOME}/.ggen/templates",
        "RUST_LOG": "ggen=info"
      }
    }
  }
}
```

### MCP Client Example (`clients/rust-client/src/main.rs`)
```rust
use rmcp::{Client, StdioTransport};
use serde_json::json;
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    // Connect to ggen MCP server
    let transport = StdioTransport::new("ggen", vec!["mcp", "start"]);
    let mut client = Client::new(transport).await?;

    println!("ğŸ”— Connected to ggen MCP server");

    // List available tools
    let tools = client.list_tools().await?;
    println!("ğŸ“‹ Available tools: {}", tools.len());

    // Example 1: Generate template with AI
    let result = client.call_tool(
        "ggen_ai_generate",
        json!({
            "description": "REST API endpoint for user creation",
            "examples": ["Include validation", "Add error handling"],
            "output": "outputs/user_endpoint.rs"
        })
    ).await?;
    println!("âœ… Generated: {:?}", result);

    // Example 2: Search marketplace
    let templates = client.call_tool(
        "ggen_market_search",
        json!({
            "query": "rust web api",
            "limit": 5
        })
    ).await?;
    println!("ğŸ” Found templates: {:?}", templates);

    // Example 3: Query RDF graph
    client.call_tool(
        "ggen_graph_load",
        json!({ "file": "ontology.ttl" })
    ).await?;

    let query_result = client.call_tool(
        "ggen_graph_query",
        json!({
            "query": "SELECT ?entity WHERE { ?entity a owl:Class } LIMIT 10"
        })
    ).await?;
    println!("ğŸ” SPARQL results: {:?}", query_result);

    Ok(())
}
```

### Example Conversation with Claude Desktop
```
User: "I need to create a REST API for user management in Rust"

Claude: I'll help you generate that using ggen. Let me search for relevant templates.

[Uses: ggen_market_search { query: "rust user api" }]
Found template: io.ggen.rust.actix-api

Now I'll generate a custom template for your needs:

[Uses: ggen_ai_generate {
  description: "REST API for user management with CRUD operations",
  examples: ["Include authentication", "Add validation"]
}]

Generated template! Now let me create the code:

[Uses: ggen_gen_with_vars {
  template: "generated-template.tmpl",
  vars: { entity: "User", operations: ["create", "read", "update", "delete"] },
  output: "src/api/users.rs"
}]

âœ… Created: src/api/users.rs
Your user API is ready with CRUD operations and authentication!
```

### Commands Demonstrated
```bash
# Start MCP server
ggen mcp start

# Start with HTTP transport
ggen mcp start --transport http --port 8080

# List available MCP tools
ggen mcp list-tools

# Test MCP server
curl -X POST http://localhost:8080/tools/call \
  -H "Content-Type: application/json" \
  -d '{
    "name": "ggen_ai_generate",
    "arguments": {
      "description": "User authentication module"
    }
  }'

# Run example clients
cd clients/rust-client && cargo run
cd clients/python-client && python client.py
```

### Available MCP Tools
```
ggen_template_list             - List available templates
ggen_gen                       - Generate from template
ggen_gen_with_vars            - Generate with variables
ggen_gen_batch                - Batch generation
ggen_market_search            - Search marketplace
ggen_market_add               - Add marketplace template
ggen_graph_load               - Load RDF graph
ggen_graph_query              - Query with SPARQL
ggen_graph_add_triple         - Add RDF triple
ggen_graph_validate           - Validate RDF
ggen_ai_generate              - AI template generation
ggen_ai_sparql                - AI SPARQL generation
ggen_ai_graph                 - AI ontology generation
ggen_ai_from_source           - Analyze source code
ggen_ai_project               - Generate project
```

### Success Criteria
- [ ] MCP server starts successfully
- [ ] Claude Desktop/Cline connects to server
- [ ] MCP tools are discoverable
- [ ] Code generation works via conversation
- [ ] User understands MCP integration patterns
- [ ] User can create custom MCP workflows

### Prerequisites
- Completed Examples 1-5
- Claude Desktop or Cline VSCode extension installed
- Understanding of MCP protocol basics

### Estimated Time
**45-60 minutes**

---

## Example 7: Multi-Template Project (Advanced)

### Goals
- Combine all patterns (AI, RDF, MCP, templates)
- Generate complex multi-module projects
- Orchestrate with Ultrathink tasks
- **Teaching Points**: Advanced composition, production patterns, orchestration

### Use Case
Build a complete e-commerce platform with microservices, shared ontology, and automated deployment.

### File Structure
```
examples/07-multi-template-project/
â”œâ”€â”€ README.md
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ system-design.md          # Architecture documentation
â”‚   â”œâ”€â”€ service-map.yaml          # Microservices map
â”‚   â””â”€â”€ data-flow.md              # Data flow diagrams
â”œâ”€â”€ ontology/
â”‚   â”œâ”€â”€ ecommerce-ontology.ttl    # Shared domain model
â”‚   â”œâ”€â”€ product-schema.ttl
â”‚   â”œâ”€â”€ order-schema.ttl
â”‚   â””â”€â”€ user-schema.ttl
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ microservice/             # Service templates
â”‚   â”‚   â”œâ”€â”€ api-gateway.tmpl
â”‚   â”‚   â”œâ”€â”€ product-service.tmpl
â”‚   â”‚   â”œâ”€â”€ order-service.tmpl
â”‚   â”‚   â””â”€â”€ user-service.tmpl
â”‚   â”œâ”€â”€ shared/                   # Shared components
â”‚   â”‚   â”œâ”€â”€ rpc-client.tmpl
â”‚   â”‚   â”œâ”€â”€ database-models.tmpl
â”‚   â”‚   â””â”€â”€ event-bus.tmpl
â”‚   â””â”€â”€ infrastructure/           # DevOps templates
â”‚       â”œâ”€â”€ kubernetes.tmpl
â”‚       â”œâ”€â”€ docker-compose.tmpl
â”‚       â””â”€â”€ github-actions.tmpl
â”œâ”€â”€ generation-plan.yaml          # Orchestration plan
â”œâ”€â”€ generated-project/            # Complete output
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ api-gateway/
â”‚   â”‚   â”œâ”€â”€ product-service/
â”‚   â”‚   â”œâ”€â”€ order-service/
â”‚   â”‚   â””â”€â”€ user-service/
â”‚   â”œâ”€â”€ shared/
â”‚   â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â””â”€â”€ models/
â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”œâ”€â”€ k8s/
â”‚   â”‚   â””â”€â”€ docker/
â”‚   â”œâ”€â”€ docs/
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ ultrathink/
â”‚   â”œâ”€â”€ tasks/                    # Ultrathink task definitions
â”‚   â”‚   â”œâ”€â”€ generate-services.yaml
â”‚   â”‚   â”œâ”€â”€ generate-infra.yaml
â”‚   â”‚   â””â”€â”€ validate-system.yaml
â”‚   â””â”€â”€ workflows/                # Task orchestration
â”‚       â””â”€â”€ full-generation.yaml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ generate-all.sh           # Full generation script
â”‚   â”œâ”€â”€ validate-system.sh        # System validation
â”‚   â””â”€â”€ deploy-dev.sh             # Development deployment
â””â”€â”€ tests/
    â”œâ”€â”€ integration/
    â”‚   â”œâ”€â”€ test_service_communication.rs
    â”‚   â””â”€â”€ test_data_flow.rs
    â””â”€â”€ validate_generation.sh
```

### E-commerce Ontology (`ontology/ecommerce-ontology.ttl`)
```turtle
@prefix ec: <http://ecommerce.example.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .

# Core entities
ec:Product a owl:Class ;
    rdfs:label "Product" ;
    rdfs:comment "A product in the catalog" .

ec:Order a owl:Class ;
    rdfs:label "Order" ;
    rdfs:comment "A customer order" .

ec:User a owl:Class ;
    rdfs:label "User" ;
    rdfs:comment "A system user" .

ec:Payment a owl:Class ;
    rdfs:label "Payment" ;
    rdfs:comment "Payment transaction" .

# Relationships
ec:hasProduct a owl:ObjectProperty ;
    rdfs:domain ec:Order ;
    rdfs:range ec:Product .

ec:placedBy a owl:ObjectProperty ;
    rdfs:domain ec:Order ;
    rdfs:range ec:User .

# Properties
ec:price a owl:DatatypeProperty ;
    rdfs:domain ec:Product ;
    rdfs:range xsd:decimal .

ec:quantity a owl:DatatypeProperty ;
    rdfs:domain ec:Product ;
    rdfs:range xsd:integer .
```

### Generation Plan (`generation-plan.yaml`)
```yaml
name: "ecommerce-platform"
description: "Complete e-commerce microservices platform"

phases:
  - name: "ontology"
    description: "Generate shared domain models from RDF"
    steps:
      - load_graph:
          file: "ontology/ecommerce-ontology.ttl"
      - query_entities:
          sparql: "SELECT ?entity WHERE { ?entity a owl:Class }"
      - generate_models:
          template: "templates/shared/database-models.tmpl"
          output_dir: "generated-project/shared/models"

  - name: "microservices"
    description: "Generate microservices from templates"
    parallel: true
    steps:
      - generate_service:
          name: "product-service"
          template: "templates/microservice/product-service.tmpl"
          vars:
            entity: "Product"
            port: 8081
          output: "generated-project/services/product-service"
      - generate_service:
          name: "order-service"
          template: "templates/microservice/order-service.tmpl"
          vars:
            entity: "Order"
            port: 8082
          output: "generated-project/services/order-service"
      - generate_service:
          name: "user-service"
          template: "templates/microservice/user-service.tmpl"
          vars:
            entity: "User"
            port: 8083
          output: "generated-project/services/user-service"

  - name: "api-gateway"
    description: "Generate API gateway"
    depends_on: ["microservices"]
    steps:
      - ai_generate:
          description: "API gateway routing to microservices"
          examples:
            - "Include service discovery"
            - "Add rate limiting"
            - "Include JWT authentication"
          template: "templates/microservice/api-gateway.tmpl"
          output: "generated-project/services/api-gateway"

  - name: "infrastructure"
    description: "Generate deployment infrastructure"
    steps:
      - generate_kubernetes:
          template: "templates/infrastructure/kubernetes.tmpl"
          services: ["product-service", "order-service", "user-service", "api-gateway"]
          output: "generated-project/infrastructure/k8s"
      - generate_cicd:
          template: "templates/infrastructure/github-actions.tmpl"
          output: "generated-project/.github/workflows"

  - name: "tests"
    description: "Generate test suites"
    steps:
      - generate_integration_tests:
          template: "templates/shared/integration-test.tmpl"
          services: ["product-service", "order-service"]
          output: "generated-project/tests/integration"

validation:
  - check_compilation: true
  - run_tests: true
  - validate_schema: true
  - check_docker_builds: true
```

### Ultrathink Task Definition (`ultrathink/tasks/generate-services.yaml`)
```yaml
task:
  type: "code-generation"
  priority: "high"
  description: "Generate all microservices for e-commerce platform"

dependencies:
  - "load_ontology"
  - "validate_templates"

steps:
  - name: "Load RDF ontology"
    command: "ggen graph load ontology/ecommerce-ontology.ttl"

  - name: "Extract entities"
    command: "ggen graph query --query 'SELECT ?entity WHERE { ?entity a owl:Class }'"
    output: "entities.json"

  - name: "Generate services"
    parallel: true
    tasks:
      - command: "ggen ai project --spec services/product-service.yaml"
      - command: "ggen ai project --spec services/order-service.yaml"
      - command: "ggen ai project --spec services/user-service.yaml"

  - name: "Generate API gateway"
    command: "ggen ai generate --description 'API gateway for microservices' --output api-gateway.tmpl"

validation:
  - "All services compile successfully"
  - "Integration tests pass"
  - "API gateway routes correctly"
```

### Commands Demonstrated
```bash
# Load complete ontology
ggen graph load ontology/ecommerce-ontology.ttl

# Generate from plan
ggen project generate-from-plan generation-plan.yaml

# Use Ultrathink for orchestration
ggen ultrathink start
ggen ultrathink task \
  --description "Generate complete e-commerce platform" \
  --task-type code-generation \
  --priority high

# Generate individual services with AI
ggen ai project \
  --spec architecture/service-map.yaml \
  --service product-service \
  --output generated-project/services/product-service

# Generate with MCP (through Claude)
ggen mcp start
# Then use Claude Desktop:
# "Generate complete e-commerce platform from generation-plan.yaml"

# Batch generate all templates
ggen gen batch templates/microservice/*.tmpl \
  --vars-file generation-plan.yaml \
  --parallel \
  --max-workers 4

# Validate entire system
scripts/validate-system.sh

# Deploy to development
scripts/deploy-dev.sh
```

### Advanced Features Demonstrated
1. **Multi-Phase Generation**: Services â†’ Infrastructure â†’ Tests
2. **Parallel Processing**: Multiple services generated concurrently
3. **Dependency Management**: API gateway depends on services
4. **Shared Ontology**: All services use same domain model
5. **AI-Assisted Generation**: Complex templates generated with AI
6. **Ultrathink Orchestration**: Task-based workflow management
7. **MCP Integration**: Conversational project generation
8. **Validation Pipeline**: Automated testing and validation

### Success Criteria
- [ ] Complete microservices platform generated
- [ ] All services compile and run
- [ ] RDF ontology drives model generation
- [ ] Services communicate correctly
- [ ] Infrastructure configuration is valid
- [ ] Tests pass (unit, integration, e2e)
- [ ] CI/CD pipeline works
- [ ] Documentation is complete
- [ ] User understands advanced composition patterns
- [ ] System can be deployed to production

### Prerequisites
- Completed Examples 1-6
- Understanding of microservices architecture
- Kubernetes/Docker knowledge
- Advanced ggen usage

### Estimated Time
**90-120 minutes**

---

## Cross-Cutting Concerns

### Testing Strategy
Each example includes:
1. **Validation Scripts**: Verify generated output
2. **Compilation Tests**: Check code compiles (for Rust)
3. **Integration Tests**: Test workflows end-to-end
4. **Output Comparison**: Compare against expected outputs

### Documentation Standards
Every example must have:
1. **README.md**: Tutorial walkthrough
2. **run.sh**: Automated execution script
3. **Expected Outputs**: Example results
4. **Troubleshooting**: Common issues and solutions
5. **Next Steps**: Links to related examples

### File Organization
```
examples/
â”œâ”€â”€ README.md                     # Main examples index
â”œâ”€â”€ 01-basic-template/
â”œâ”€â”€ 02-rdf-sparql/
â”œâ”€â”€ 03-ai-template-creation/
â”œâ”€â”€ 04-source-analysis/
â”œâ”€â”€ 05-full-project/
â”œâ”€â”€ 06-mcp-integration/
â”œâ”€â”€ 07-multi-template-project/
â”œâ”€â”€ shared/                       # Shared utilities
â”‚   â”œâ”€â”€ validation/
â”‚   â”œâ”€â”€ test-helpers/
â”‚   â””â”€â”€ common-templates/
â””â”€â”€ tests/
    â””â”€â”€ validate-all-examples.sh  # Test all examples
```

---

## Dependencies Matrix

| Example | AI Provider | RDF/SPARQL | MCP | Ollama | External APIs |
|---------|-------------|------------|-----|--------|---------------|
| 1       | âŒ          | âŒ         | âŒ  | âŒ     | âŒ            |
| 2       | âŒ          | âœ…         | âŒ  | âŒ     | âŒ            |
| 3       | âœ…          | âŒ         | âŒ  | âœ…     | Optional      |
| 4       | âœ…          | âŒ         | âŒ  | âœ…     | Optional      |
| 5       | âœ…          | âœ…         | âŒ  | âœ…     | Optional      |
| 6       | âœ…          | âœ…         | âœ…  | âœ…     | Optional      |
| 7       | âœ…          | âœ…         | âœ…  | âœ…     | Optional      |

---

## Implementation Roadmap

### Phase 1: Fundamentals (Week 1)
- [ ] Example 1: Basic Template Generation
- [ ] Example 2: RDF/SPARQL Integration
- [ ] Validation scripts for Examples 1-2
- [ ] Documentation for Examples 1-2

### Phase 2: AI-Powered (Week 2)
- [ ] Example 3: AI Template Creation
- [ ] Example 4: Source Code Analysis
- [ ] Validation scripts for Examples 3-4
- [ ] AI configuration examples

### Phase 3: Complete Workflows (Week 3)
- [ ] Example 5: Full Project Generation
- [ ] Example 6: MCP Integration
- [ ] Integration tests
- [ ] MCP client examples

### Phase 4: Advanced Patterns (Week 4)
- [ ] Example 7: Multi-Template Project
- [ ] Ultrathink orchestration examples
- [ ] System-level tests
- [ ] Production deployment guides

### Phase 5: Polish & Documentation (Week 5)
- [ ] Review all examples for consistency
- [ ] Create video walkthroughs
- [ ] Write troubleshooting guides
- [ ] Create example variations

---

## Quality Checklist

For each example:

**Functionality**:
- [ ] Runs successfully on fresh installation
- [ ] All commands execute without errors
- [ ] Generated output is valid
- [ ] Tests pass

**Documentation**:
- [ ] Clear learning objectives
- [ ] Step-by-step instructions
- [ ] Expected outputs documented
- [ ] Troubleshooting section

**Code Quality**:
- [ ] Templates are well-formatted
- [ ] Variables are clearly named
- [ ] Comments explain non-obvious parts
- [ ] Follows ggen best practices

**User Experience**:
- [ ] Progressive difficulty
- [ ] Teaches specific concepts
- [ ] Builds on previous examples
- [ ] Provides "aha!" moments

---

## Success Metrics

### Coverage
- âœ… All AI commands demonstrated
- âœ… All MCP tools covered
- âœ… RDF/SPARQL workflows shown
- âœ… Marketplace integration included
- âœ… Ultrathink orchestration demonstrated

### Educational Value
- 7 comprehensive examples
- Beginner to expert progression
- Real-world use cases
- Production-ready patterns

### Quality
- 100% examples run successfully
- All validation scripts pass
- Documentation complete
- Troubleshooting guides included

---

## Next Steps

1. **Review & Approve Architecture**: Get stakeholder sign-off
2. **Create Example Skeletons**: Set up directory structure
3. **Implement Phase 1**: Build fundamental examples
4. **Iterate Based on Feedback**: Refine based on user testing
5. **Expand to Advanced Examples**: Complete all 7 examples

---

## Appendix: Example Command Reference

### Basic Commands
```bash
# Template generation
ggen gen <template> --vars key=value
ggen gen <template> --vars-file vars.yaml

# AI generation
ggen ai generate --description "..." --output file.tmpl
ggen ai from-source --file source.rs --output template.tmpl
ggen ai project --spec project.yaml

# RDF/SPARQL
ggen graph load ontology.ttl
ggen graph query --query "SELECT ..."
ggen graph validate ontology.ttl

# MCP
ggen mcp start
ggen mcp list-tools

# Ultrathink
ggen ultrathink start
ggen ultrathink task --description "..."
ggen ultrathink status

# Marketplace
ggen search "rust api"
ggen add io.ggen.rust.api
ggen packs
```

### Advanced Commands
```bash
# Batch generation
ggen gen batch templates/*.tmpl --parallel

# Multi-file generation
ggen project gen --spec project.yaml

# With validation
ggen ai generate --description "..." --validate --max-iterations 3

# MCP with HTTP
ggen mcp start --transport http --port 8080

# Ultrathink orchestration
ggen ultrathink task --task-type code-generation --priority high
```

---

**Document Version**: 1.0.0
**Last Updated**: 2025-10-11
**Authors**: System Architecture Design Team
**Status**: Ready for Implementation
