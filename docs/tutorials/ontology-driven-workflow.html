<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ontology-Driven Workflow - ggen Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Language-agnostic generator for reproducible code projections">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ggen Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/seanchatmangpt/ggen" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/seanchatmangpt/ggen/edit/main/docs/src/src/tutorials/ontology-driven-workflow.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tutorial-build-a-blog-platform-in-30-minutes-with-ontology-driven-development"><a class="header" href="#tutorial-build-a-blog-platform-in-30-minutes-with-ontology-driven-development">Tutorial: Build a Blog Platform in 30 Minutes with Ontology-Driven Development</a></h1>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>In this tutorial, you'll experience the power of ontology-driven development by building a complete blog platform. Instead of writing models by hand, you'll define your domain once in RDF/OWL and automatically generate type-safe code for both backend and frontend.</p>
<p><strong>By the end, you'll have:</strong></p>
<ul>
<li>A semantic domain model (RDF ontology)</li>
<li>Type-safe Rust backend models</li>
<li>TypeScript frontend types</li>
<li>The ability to evolve your schema with confidence</li>
</ul>
<p><strong>Time required:</strong> 30 minutes</p>
<hr />
<h2 id="step-1-define-your-domain-model"><a class="header" href="#step-1-define-your-domain-model">Step 1: Define Your Domain Model</a></h2>
<p>The heart of ontology-driven development is the <strong>domain ontology</strong> - a semantic description of your application's concepts and their relationships.</p>
<h3 id="create-the-blog-ontology"><a class="header" href="#create-the-blog-ontology">Create the Blog Ontology</a></h3>
<p>Create a file <code>blog.ttl</code> with your domain model:</p>
<pre><code class="language-turtle">@prefix : &lt;http://example.org/blog#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

# Ontology declaration
: a owl:Ontology ;
    rdfs:label "Blog Platform Ontology" ;
    rdfs:comment "Domain model for a blog platform with users, posts, and comments" .

# Classes
:User a owl:Class ;
    rdfs:label "User" ;
    rdfs:comment "A registered user of the blog platform" .

:Post a owl:Class ;
    rdfs:label "Post" ;
    rdfs:comment "A blog post written by a user" .

:Comment a owl:Class ;
    rdfs:label "Comment" ;
    rdfs:comment "A comment on a blog post" .

# User properties
:email a owl:DatatypeProperty ;
    rdfs:label "email" ;
    rdfs:domain :User ;
    rdfs:range xsd:string ;
    rdfs:comment "User's email address (unique identifier)" .

:name a owl:DatatypeProperty ;
    rdfs:label "name" ;
    rdfs:domain :User ;
    rdfs:range xsd:string ;
    rdfs:comment "User's display name" .

:joinedAt a owl:DatatypeProperty ;
    rdfs:label "joined_at" ;
    rdfs:domain :User ;
    rdfs:range xsd:dateTime ;
    rdfs:comment "Timestamp when user registered" .

# Post properties
:title a owl:DatatypeProperty ;
    rdfs:label "title" ;
    rdfs:domain :Post ;
    rdfs:range xsd:string ;
    rdfs:comment "Post title" .

:content a owl:DatatypeProperty ;
    rdfs:label "content" ;
    rdfs:domain :Post ;
    rdfs:range xsd:string ;
    rdfs:comment "Post content (markdown)" .

:publishedAt a owl:DatatypeProperty ;
    rdfs:label "published_at" ;
    rdfs:domain :Post ;
    rdfs:range xsd:dateTime ;
    rdfs:comment "Publication timestamp" .

# Comment properties
:text a owl:DatatypeProperty ;
    rdfs:label "text" ;
    rdfs:domain :Comment ;
    rdfs:range xsd:string ;
    rdfs:comment "Comment text" .

:createdAt a owl:DatatypeProperty ;
    rdfs:label "created_at" ;
    rdfs:domain :Comment ;
    rdfs:range xsd:dateTime ;
    rdfs:comment "Comment creation timestamp" .

# Relationships
:hasAuthor a owl:ObjectProperty ;
    rdfs:label "has_author" ;
    rdfs:domain :Post ;
    rdfs:range :User ;
    rdfs:comment "Post author (User)" .

:hasPosts a owl:ObjectProperty ;
    rdfs:label "has_posts" ;
    rdfs:domain :User ;
    rdfs:range :Post ;
    owl:inverseOf :hasAuthor ;
    rdfs:comment "User's posts (one-to-many)" .

:hasComments a owl:ObjectProperty ;
    rdfs:label "has_comments" ;
    rdfs:domain :Post ;
    rdfs:range :Comment ;
    rdfs:comment "Post comments (one-to-many)" .

:commentAuthor a owl:ObjectProperty ;
    rdfs:label "comment_author" ;
    rdfs:domain :Comment ;
    rdfs:range :User ;
    rdfs:comment "Comment author" .
</code></pre>
<h3 id="understanding-the-ontology"><a class="header" href="#understanding-the-ontology">Understanding the Ontology</a></h3>
<p><strong>Key concepts:</strong></p>
<ol>
<li><strong>Classes</strong> (<code>owl:Class</code>) - Your domain entities: <code>User</code>, <code>Post</code>, <code>Comment</code></li>
<li><strong>Datatype Properties</strong> (<code>owl:DatatypeProperty</code>) - Scalar fields like <code>email</code>, <code>title</code>, <code>text</code></li>
<li><strong>Object Properties</strong> (<code>owl:ObjectProperty</code>) - Relationships between entities</li>
<li><strong>Ranges</strong> - Type constraints (e.g., <code>xsd:string</code>, <code>xsd:dateTime</code>)</li>
</ol>
<p><strong>Why RDF/OWL?</strong></p>
<ul>
<li>Machine-readable and validatable</li>
<li>Rich type system with inference</li>
<li>Standard format with powerful tooling</li>
<li>Single source of truth for all code generation</li>
</ul>
<hr />
<h2 id="step-2-generate-rust-backend-models"><a class="header" href="#step-2-generate-rust-backend-models">Step 2: Generate Rust Backend Models</a></h2>
<p>Now let's generate type-safe Rust models from the ontology.</p>
<h3 id="generate-command"><a class="header" href="#generate-command">Generate Command</a></h3>
<pre><code class="language-bash">ggen template generate-rdf \
  --ontology blog.ttl \
  --template rust-models \
  --output-dir src/models
</code></pre>
<h3 id="generated-code"><a class="header" href="#generated-code">Generated Code</a></h3>
<p><strong><code>src/models/user.rs</code>:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// A registered user of the blog platform
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    /// Unique identifier
    pub id: Uuid,

    /// User's email address (unique identifier)
    pub email: String,

    /// User's display name
    pub name: String,

    /// Timestamp when user registered
    pub joined_at: DateTime&lt;Utc&gt;,
}

impl User {
    pub fn new(email: String, name: String) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            email,
            name,
            joined_at: Utc::now(),
        }
    }
}

/// User with relationships
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserWithPosts {
    #[serde(flatten)]
    pub user: User,

    /// User's posts (one-to-many)
    pub posts: Vec&lt;super::post::Post&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong><code>src/models/post.rs</code>:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// A blog post written by a user
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Post {
    /// Unique identifier
    pub id: Uuid,

    /// Post title
    pub title: String,

    /// Post content (markdown)
    pub content: String,

    /// Publication timestamp
    pub published_at: DateTime&lt;Utc&gt;,

    /// Post author ID (foreign key)
    pub author_id: Uuid,
}

impl Post {
    pub fn new(title: String, content: String, author_id: Uuid) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            title,
            content,
            published_at: Utc::now(),
            author_id,
        }
    }
}

/// Post with relationships
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostWithRelations {
    #[serde(flatten)]
    pub post: Post,

    /// Post author (User)
    pub author: super::user::User,

    /// Post comments (one-to-many)
    pub comments: Vec&lt;super::comment::Comment&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong><code>src/models/comment.rs</code>:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// A comment on a blog post
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    /// Unique identifier
    pub id: Uuid,

    /// Comment text
    pub text: String,

    /// Comment creation timestamp
    pub created_at: DateTime&lt;Utc&gt;,

    /// Post ID (foreign key)
    pub post_id: Uuid,

    /// Author ID (foreign key)
    pub author_id: Uuid,
}

impl Comment {
    pub fn new(text: String, post_id: Uuid, author_id: Uuid) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            text,
            created_at: Utc::now(),
            post_id,
            author_id,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h3>
<p>The generator analyzed your ontology and created:</p>
<ol>
<li><strong>Type-safe structs</strong> with proper Rust types (<code>String</code>, <code>DateTime&lt;Utc&gt;</code>, <code>Uuid</code>)</li>
<li><strong>Serde integration</strong> for JSON serialization</li>
<li><strong>Documentation</strong> from RDF comments</li>
<li><strong>Relationship models</strong> (e.g., <code>UserWithPosts</code>, <code>PostWithRelations</code>)</li>
<li><strong>Constructors</strong> with sensible defaults</li>
</ol>
<p><strong>No hand-coding required!</strong></p>
<hr />
<h2 id="step-3-generate-typescript-frontend-types"><a class="header" href="#step-3-generate-typescript-frontend-types">Step 3: Generate TypeScript Frontend Types</a></h2>
<p>Now let's generate matching TypeScript types for the frontend.</p>
<h3 id="generate-command-1"><a class="header" href="#generate-command-1">Generate Command</a></h3>
<pre><code class="language-bash">ggen template generate-rdf \
  --ontology blog.ttl \
  --template typescript-models \
  --output-dir frontend/src/types
</code></pre>
<h3 id="generated-code-1"><a class="header" href="#generated-code-1">Generated Code</a></h3>
<p><strong><code>frontend/src/types/user.ts</code>:</strong></p>
<pre><code class="language-typescript">/**
 * A registered user of the blog platform
 */
export interface User {
  /** Unique identifier */
  id: string;

  /** User's email address (unique identifier) */
  email: string;

  /** User's display name */
  name: string;

  /** Timestamp when user registered */
  joined_at: string; // ISO 8601 datetime
}

/**
 * User with relationships
 */
export interface UserWithPosts extends User {
  /** User's posts (one-to-many) */
  posts: Post[];
}

/**
 * Create a new user
 */
export function createUser(
  email: string,
  name: string
): Omit&lt;User, 'id' | 'joined_at'&gt; {
  return { email, name };
}
</code></pre>
<p><strong><code>frontend/src/types/post.ts</code>:</strong></p>
<pre><code class="language-typescript">import type { User } from './user';
import type { Comment } from './comment';

/**
 * A blog post written by a user
 */
export interface Post {
  /** Unique identifier */
  id: string;

  /** Post title */
  title: string;

  /** Post content (markdown) */
  content: string;

  /** Publication timestamp */
  published_at: string; // ISO 8601 datetime

  /** Post author ID (foreign key) */
  author_id: string;
}

/**
 * Post with relationships
 */
export interface PostWithRelations extends Post {
  /** Post author (User) */
  author: User;

  /** Post comments (one-to-many) */
  comments: Comment[];
}

/**
 * Create a new post
 */
export function createPost(
  title: string,
  content: string,
  author_id: string
): Omit&lt;Post, 'id' | 'published_at'&gt; {
  return { title, content, author_id };
}
</code></pre>
<p><strong><code>frontend/src/types/comment.ts</code>:</strong></p>
<pre><code class="language-typescript">/**
 * A comment on a blog post
 */
export interface Comment {
  /** Unique identifier */
  id: string;

  /** Comment text */
  text: string;

  /** Comment creation timestamp */
  created_at: string; // ISO 8601 datetime

  /** Post ID (foreign key) */
  post_id: string;

  /** Author ID (foreign key) */
  author_id: string;
}

/**
 * Create a new comment
 */
export function createComment(
  text: string,
  post_id: string,
  author_id: string
): Omit&lt;Comment, 'id' | 'created_at'&gt; {
  return { text, post_id, author_id };
}
</code></pre>
<h3 id="perfect-type-alignment"><a class="header" href="#perfect-type-alignment">Perfect Type Alignment</a></h3>
<p><strong>Notice:</strong></p>
<ul>
<li>Field names match exactly (<code>email</code>, <code>title</code>, <code>text</code>)</li>
<li>Types align (Rust <code>DateTime&lt;Utc&gt;</code> → TypeScript <code>string</code> with ISO 8601)</li>
<li>Relationships mirror the backend</li>
<li>Factory functions for creating new entities</li>
</ul>
<p><strong>This means:</strong></p>
<ul>
<li>No type mismatches between frontend/backend</li>
<li>Refactor once, update everywhere</li>
<li>Compiler-verified API contracts</li>
</ul>
<hr />
<h2 id="step-4-evolve-your-schema"><a class="header" href="#step-4-evolve-your-schema">Step 4: Evolve Your Schema</a></h2>
<p>Requirements change. Let's add comment upvoting functionality.</p>
<h3 id="update-the-ontology"><a class="header" href="#update-the-ontology">Update the Ontology</a></h3>
<p>Add to <code>blog.ttl</code>:</p>
<pre><code class="language-turtle"># Comment upvotes property
:upvotes a owl:DatatypeProperty ;
    rdfs:label "upvotes" ;
    rdfs:domain :Comment ;
    rdfs:range xsd:integer ;
    rdfs:comment "Number of upvotes (likes)" .
</code></pre>
<h3 id="regenerate-everything"><a class="header" href="#regenerate-everything">Regenerate Everything</a></h3>
<pre><code class="language-bash"># Regenerate Rust models
ggen template generate-rdf \
  --ontology blog.ttl \
  --template rust-models \
  --output-dir src/models

# Regenerate TypeScript types
ggen template generate-rdf \
  --ontology blog.ttl \
  --template typescript-models \
  --output-dir frontend/src/types
</code></pre>
<h3 id="updated-code"><a class="header" href="#updated-code">Updated Code</a></h3>
<p><strong>Rust (<code>src/models/comment.rs</code>):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub id: Uuid,
    pub text: String,
    pub created_at: DateTime&lt;Utc&gt;,

    /// Number of upvotes (likes)
    pub upvotes: i32,  // ← NEW FIELD

    pub post_id: Uuid,
    pub author_id: Uuid,
}

impl Comment {
    pub fn new(text: String, post_id: Uuid, author_id: Uuid) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            text,
            created_at: Utc::now(),
            upvotes: 0,  // ← SENSIBLE DEFAULT
            post_id,
            author_id,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>TypeScript (<code>frontend/src/types/comment.ts</code>):</strong></p>
<pre><code class="language-typescript">export interface Comment {
  id: string;
  text: string;
  created_at: string;

  /** Number of upvotes (likes) */
  upvotes: number;  // ← NEW FIELD

  post_id: string;
  author_id: string;
}
</code></pre>
<h3 id="what-happened"><a class="header" href="#what-happened">What Happened?</a></h3>
<ol>
<li><strong>Single ontology change</strong> propagated to all generated code</li>
<li><strong>Type safety preserved</strong> - compilers catch any missing updates</li>
<li><strong>Default values</strong> added automatically (<code>upvotes: 0</code>)</li>
<li><strong>Documentation</strong> synced from RDF comments</li>
</ol>
<p><strong>No manual synchronization needed!</strong></p>
<hr />
<h2 id="step-5-validate-with-sparql-queries"><a class="header" href="#step-5-validate-with-sparql-queries">Step 5: Validate with SPARQL Queries</a></h2>
<p>Use SPARQL to query and validate your ontology.</p>
<h3 id="query-all-posts"><a class="header" href="#query-all-posts">Query All Posts</a></h3>
<pre><code class="language-bash">ggen graph query blog.ttl --sparql "
  PREFIX : &lt;http://example.org/blog#&gt;
  SELECT ?post ?title WHERE {
    ?post a :Post ;
          :title ?title .
  }
"
</code></pre>
<h3 id="find-users-with-posts"><a class="header" href="#find-users-with-posts">Find Users with Posts</a></h3>
<pre><code class="language-bash">ggen graph query blog.ttl --sparql "
  PREFIX : &lt;http://example.org/blog#&gt;
  SELECT ?user ?name (COUNT(?post) as ?post_count) WHERE {
    ?user a :User ;
          :name ?name ;
          :hasPosts ?post .
  }
  GROUP BY ?user ?name
"
</code></pre>
<h3 id="validate-comment-schema"><a class="header" href="#validate-comment-schema">Validate Comment Schema</a></h3>
<pre><code class="language-bash">ggen graph query blog.ttl --sparql "
  PREFIX : &lt;http://example.org/blog#&gt;
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

  SELECT ?property ?label ?range WHERE {
    ?property rdfs:domain :Comment ;
              rdfs:label ?label ;
              rdfs:range ?range .
  }
"
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code>property                          label         range
http://example.org/blog#text      text          xsd:string
http://example.org/blog#createdAt created_at    xsd:dateTime
http://example.org/blog#upvotes   upvotes       xsd:integer
</code></pre>
<h3 id="visualize-the-ontology"><a class="header" href="#visualize-the-ontology">Visualize the Ontology</a></h3>
<p>Generate a visual graph:</p>
<pre><code class="language-bash">ggen graph visualize blog.ttl --format dot --output blog.dot
dot -Tpng blog.dot -o blog-graph.png
</code></pre>
<p>This creates a diagram showing:</p>
<ul>
<li>Classes (User, Post, Comment)</li>
<li>Properties (email, title, text, upvotes)</li>
<li>Relationships (hasAuthor, hasPosts, hasComments)</li>
</ul>
<hr />
<h2 id="step-6-add-database-migrations-bonus"><a class="header" href="#step-6-add-database-migrations-bonus">Step 6: Add Database Migrations (Bonus)</a></h2>
<p>Since your schema is machine-readable, you can generate database migrations too.</p>
<h3 id="generate-sql-schema"><a class="header" href="#generate-sql-schema">Generate SQL Schema</a></h3>
<pre><code class="language-bash">ggen template generate-rdf \
  --ontology blog.ttl \
  --template sql-schema \
  --output-dir migrations
</code></pre>
<p><strong>Generated <code>migrations/001_create_blog_schema.sql</code>:</strong></p>
<pre><code class="language-sql">-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);

-- Posts table
CREATE TABLE posts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    published_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_posts_author ON posts(author_id);
CREATE INDEX idx_posts_published_at ON posts(published_at DESC);

-- Comments table
CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    text TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    upvotes INTEGER NOT NULL DEFAULT 0,
    post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_comments_post ON comments(post_id);
CREATE INDEX idx_comments_author ON comments(author_id);
</code></pre>
<p><strong>Foreign keys, indexes, and constraints derived from the ontology!</strong></p>
<hr />
<h2 id="step-7-complete-api-integration"><a class="header" href="#step-7-complete-api-integration">Step 7: Complete API Integration</a></h2>
<p>Let's see how the generated models integrate into a real Rust API.</p>
<h3 id="axum-api-handler-rust"><a class="header" href="#axum-api-handler-rust">Axum API Handler (Rust)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{extract::Path, http::StatusCode, Json};
use uuid::Uuid;
use crate::models::{PostWithRelations, CreatePostRequest};

/// GET /posts/:id - Fetch post with author and comments
pub async fn get_post(
    Path(id): Path&lt;Uuid&gt;,
    db: DatabaseConnection,
) -&gt; Result&lt;Json&lt;PostWithRelations&gt;, StatusCode&gt; {
    let post = db
        .fetch_post_with_relations(id)
        .await
        .map_err(|_| StatusCode::NOT_FOUND)?;

    Ok(Json(post))
}

/// POST /posts - Create new post
pub async fn create_post(
    Json(req): Json&lt;CreatePostRequest&gt;,
    db: DatabaseConnection,
) -&gt; Result&lt;(StatusCode, Json&lt;Post&gt;), StatusCode&gt; {
    let post = Post::new(req.title, req.content, req.author_id);

    db.insert_post(&amp;post)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok((StatusCode::CREATED, Json(post)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="react-component-typescript"><a class="header" href="#react-component-typescript">React Component (TypeScript)</a></h3>
<pre><code class="language-typescript">import { useQuery } from '@tanstack/react-query';
import type { PostWithRelations } from '@/types/post';

function PostDetail({ postId }: { postId: string }) {
  const { data: post, isLoading } = useQuery({
    queryKey: ['post', postId],
    queryFn: async (): Promise&lt;PostWithRelations&gt; =&gt; {
      const res = await fetch(`/api/posts/${postId}`);
      return res.json();
    },
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!post) return &lt;div&gt;Post not found&lt;/div&gt;;

  return (
    &lt;article&gt;
      &lt;h1&gt;{post.title}&lt;/h1&gt;
      &lt;p className="author"&gt;By {post.author.name}&lt;/p&gt;
      &lt;div className="content"&gt;{post.content}&lt;/div&gt;

      &lt;section className="comments"&gt;
        &lt;h2&gt;Comments ({post.comments.length})&lt;/h2&gt;
        {post.comments.map(comment =&gt; (
          &lt;div key={comment.id}&gt;
            &lt;p&gt;{comment.text}&lt;/p&gt;
            &lt;span&gt;{comment.upvotes} upvotes&lt;/span&gt;
          &lt;/div&gt;
        ))}
      &lt;/section&gt;
    &lt;/article&gt;
  );
}
</code></pre>
<p><strong>Notice:</strong></p>
<ul>
<li>Types flow seamlessly from backend to frontend</li>
<li><code>PostWithRelations</code> includes <code>author</code> and <code>comments</code> automatically</li>
<li>TypeScript autocomplete works perfectly</li>
<li>No manual type definitions needed</li>
</ul>
<hr />
<h2 id="benefits-recap"><a class="header" href="#benefits-recap">Benefits Recap</a></h2>
<h3 id="1-single-source-of-truth"><a class="header" href="#1-single-source-of-truth">1. Single Source of Truth</a></h3>
<ul>
<li>Domain model defined once in <code>blog.ttl</code></li>
<li>All code generated from this source</li>
<li>Changes propagate automatically</li>
</ul>
<h3 id="2-type-safety-everywhere"><a class="header" href="#2-type-safety-everywhere">2. Type Safety Everywhere</a></h3>
<ul>
<li>Rust structs with proper types</li>
<li>TypeScript interfaces matching exactly</li>
<li>Compiler catches schema mismatches</li>
</ul>
<h3 id="3-effortless-evolution"><a class="header" href="#3-effortless-evolution">3. Effortless Evolution</a></h3>
<ul>
<li>Add field → Regenerate → Done</li>
<li>No manual synchronization</li>
<li>No risk of frontend/backend drift</li>
</ul>
<h3 id="4-validation--queries"><a class="header" href="#4-validation--queries">4. Validation &amp; Queries</a></h3>
<ul>
<li>SPARQL for semantic queries</li>
<li>Ontology reasoning for validation</li>
<li>Visual graphs for documentation</li>
</ul>
<h3 id="5-database-integration"><a class="header" href="#5-database-integration">5. Database Integration</a></h3>
<ul>
<li>SQL schemas generated automatically</li>
<li>Foreign keys from relationships</li>
<li>Indexes from query patterns</li>
</ul>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<h3 id="extend-the-ontology"><a class="header" href="#extend-the-ontology">Extend the Ontology</a></h3>
<p>Try adding these features yourself:</p>
<ol>
<li><strong>Tags:</strong> Add a <code>Tag</code> class and <code>hasTags</code> relationship for posts</li>
<li><strong>Drafts:</strong> Add a <code>status</code> property (draft/published) to posts</li>
<li><strong>Replies:</strong> Add <code>parentComment</code> for threaded comments</li>
<li><strong>Likes:</strong> Create a <code>Like</code> class linking users to posts</li>
</ol>
<h3 id="explore-templates"><a class="header" href="#explore-templates">Explore Templates</a></h3>
<p>ggen supports many RDF-to-code templates:</p>
<pre><code class="language-bash"># List all available templates
ggen template list --category rdf-generators

# Available templates:
# - rust-models (backend structs)
# - typescript-models (frontend types)
# - sql-schema (PostgreSQL)
# - graphql-schema (GraphQL types)
# - openapi-spec (REST API docs)
# - python-pydantic (Python models)
</code></pre>
<h3 id="integrate-with-your-stack"><a class="header" href="#integrate-with-your-stack">Integrate with Your Stack</a></h3>
<p>Generated models work with:</p>
<ul>
<li><strong>Backend:</strong> Axum, Actix-web, Rocket, Warp</li>
<li><strong>Frontend:</strong> React, Vue, Svelte, Angular</li>
<li><strong>Database:</strong> PostgreSQL, MySQL, SQLite, MongoDB</li>
<li><strong>API:</strong> REST, GraphQL, gRPC</li>
</ul>
<h3 id="learn-more"><a class="header" href="#learn-more">Learn More</a></h3>
<ul>
<li><a href="../reference/rdf-ontologies.html">RDF/OWL Guide</a></li>
<li><a href="../reference/template-system.html">Template System</a></li>
<li><a href="../reference/graph-commands.html">Graph Commands</a></li>
<li><a href="../reference/sparql-queries.html">SPARQL Tutorial</a></li>
</ul>
<hr />
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>You've just experienced <strong>ontology-driven development</strong>:</p>
<ol>
<li>✅ Defined a blog platform in 100 lines of RDF</li>
<li>✅ Generated type-safe Rust models automatically</li>
<li>✅ Generated matching TypeScript types</li>
<li>✅ Evolved the schema with a single change</li>
<li>✅ Validated with SPARQL queries</li>
<li>✅ Generated database migrations</li>
</ol>
<p><strong>Traditional approach:</strong> Write models in Rust, duplicate in TypeScript, manually sync databases, pray nothing breaks.</p>
<p><strong>Ontology-driven approach:</strong> Define once, generate everywhere, evolve with confidence.</p>
<p><strong>Welcome to the future of code generation.</strong></p>
<hr />
<p><strong>Questions?</strong> Check the <a href="../faq.html">FAQ</a> or open an issue on <a href="https://github.com/ggen-project/ggen">GitHub</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concepts/frontmatter.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../guides/templates.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concepts/frontmatter.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../guides/templates.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
