# KNHKS Cursor Rules - 80/20 Production-Ready Code Standards

## Core Principle: No Placeholders, Real Implementations

All code must be production-ready with proper error handling. Focus on critical path implementations that provide 80% of value.

## Prohibited Patterns ❌

1. **Placeholders** - No "In production, this would..." comments
2. **TODOs** - No TODO comments except clearly documented future enhancements
3. **Unhandled errors** - No `unwrap()`, `expect()`, or panics in production code
4. **Stubs** - No functions that always succeed without implementation
5. **Simulated behavior** - Use real libraries when available (rdkafka, reqwest, etc.)

## Required Patterns ✅

1. **Real library integrations** - Use actual dependencies when available
2. **Error handling** - `Result<T, E>` for all fallible operations
3. **Feature gating** - `#[cfg(feature = "...")]` for optional dependencies
4. **Input validation** - Validate all inputs, enforce guard constraints (max_run_len ≤ 8)

## Critical Best Practices

### Security
- Validate all inputs before processing
- Never hardcode credentials or secrets
- Enforce guard constraints (max_run_len ≤ 8, max_batch_size, etc.)

### Performance
- Zero-copy when possible (references over clones)
- Maintain ≤8 tick budget for hot path operations
- Use SoA layout for SIMD (64-byte alignment)

### Error Handling
- Use `Result<T, E>` for all fallible operations
- Never use `unwrap()` or `expect()` in production code paths
- Provide context in error messages

### Resource Management
- Clean up resources in error paths
- Use RAII (Rust) or proper cleanup patterns
- Close connections, files, handles

### Testing
- Test all public APIs
- Test error paths and guard violations
- Test critical paths (aim for 80%+ coverage)

## Language-Specific Rules

### Rust
- `Result<T, E>` for fallible operations
- Feature gates: `#[cfg(feature = "...")]`
- Borrow when possible: `&[u8]` over `Vec<u8>`
- No `unwrap()` in production code paths

### C
- Return error codes: `int process(...)` with `-1` on error
- Validate inputs early: check NULL pointers, bounds
- Generate real span IDs: `knhks_generate_span_id()` not `0`
- Cleanup resources in error paths

### Erlang
- Proper gen_server error handling
- Validate state transitions
- Cleanup in terminate callbacks

## Code Review Checklist

- [ ] All functions have proper error handling
- [ ] All inputs are validated
- [ ] No `unwrap()` or `panic!()` in production paths
- [ ] Real implementations, not placeholders
- [ ] Feature-gated when dependencies are optional
- [ ] Tests cover critical paths
- [ ] Guard constraints enforced (max_run_len ≤ 8)
- [ ] Resources are properly cleaned up
- [ ] No secrets or credentials in code

## Examples

### BAD: Placeholder Implementation
```rust
impl Connector for KafkaConnector {
    fn fetch_delta(&mut self) -> Result<Delta, ConnectorError> {
        // TODO: Implement Kafka consumer
        Ok(Delta::empty())
    }
}
```

### GOOD: Real Implementation
```rust
impl Connector for KafkaConnector {
    fn fetch_delta(&mut self) -> Result<Delta, ConnectorError> {
        if self.state != KafkaConnectionState::Connected {
            return Err(ConnectorError::NetworkError(
                format!("Not connected: {:?}", self.state)
            ));
        }
        
        #[cfg(feature = "kafka")]
        {
            if let Some(ref consumer) = self.consumer {
                match consumer.recv() {
                    Ok(msg) => self.parse_message(&msg),
                    Err(e) => Err(ConnectorError::NetworkError(e.to_string())),
                }
            } else {
                Err(ConnectorError::NetworkError("Consumer not initialized".to_string()))
            }
        }
        
        #[cfg(not(feature = "kafka"))]
        {
            Err(ConnectorError::NetworkError("Kafka feature not enabled".to_string()))
        }
    }
}
```

### BAD: Unhandled Error
```rust
fn process(input: &str) -> u64 {
    input.parse().unwrap()
}
```

### GOOD: Proper Error Handling
```rust
fn process(input: &str) -> Result<u64, ProcessingError> {
    if input.is_empty() {
        return Err(ProcessingError::EmptyInput);
    }
    
    input.parse()
        .map_err(|e| ProcessingError::ParseFailed(e.to_string()))
}
```

### BAD: Missing Guard Validation
```rust
fn load(triples: &[Triple]) -> Result<SoAArrays> {
    let soa = SoAArrays::new();
    // Load triples without checking length
    Ok(soa)
}
```

### GOOD: Guard Validation
```rust
fn load(triples: &[Triple]) -> Result<SoAArrays, LoadError> {
    if triples.len() > 8 {
        return Err(LoadError::GuardViolation(
            format!("Triple count {} exceeds max_run_len 8", triples.len())
        ));
    }
    
    let mut soa = SoAArrays::new();
    for (i, triple) in triples.iter().enumerate() {
        soa.s[i] = triple.subject;
        soa.p[i] = triple.predicate;
        soa.o[i] = triple.object;
    }
    
    Ok(soa)
}
```

## Summary

**80/20 Focus**: Critical path implementations first, no placeholders, real error handling, proper validation, feature-gated dependencies.

**Production-Ready**: No placeholders or stubs, real implementations, comprehensive testing, proper resource management.
