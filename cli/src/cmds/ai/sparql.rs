//! Generate SPARQL queries using AI

use anyhow;
use clap::Args;
use ggen_ai::client::LlmClient;
use ggen_ai::{client::GenAiClient, LlmConfig, MockClient, SparqlGenerator};
use ggen_core::Graph;
use ggen_utils::error::Result;
use serde_json::json;
use std::fs;
use std::sync::Arc;

#[derive(Debug, Args)]
pub struct SparqlArgs {
    /// Description of the SPARQL query to generate
    #[arg(short, long)]
    pub description: String,

    /// RDF graph file to analyze for query generation
    #[arg(short, long)]
    pub graph: Option<String>,

    /// Output format (sparql, json, convert-json-to-sparql)
    #[arg(short, long, default_value = "sparql")]
    pub format: String,

    /// Output file path
    #[arg(short, long)]
    pub output: Option<String>,

    /// Use mock client for testing
    #[arg(long)]
    pub mock: bool,

    /// Model name to use
    #[arg(long)]
    pub model: Option<String>,

    /// Temperature for generation
    #[arg(long)]
    pub temperature: Option<f32>,

    /// Maximum tokens to generate
    #[arg(long)]
    pub max_tokens: Option<u32>,
}

pub async fn run(args: &SparqlArgs) -> Result<()> {
    println!("üîç Generating SPARQL query with AI...");
    println!("Description: {}", args.description);

    if let Some(graph_path) = &args.graph {
        println!("Graph file: {}", graph_path);
    }

    println!("Output format: {}", args.format);

    // Load RDF graph if provided
    let graph = if let Some(graph_path) = &args.graph {
        println!("üìä Loading RDF graph from: {}", graph_path);
        Graph::load_from_file(graph_path)
            .map_err(|e| ggen_utils::error::Error::new(&format!("Failed to load graph: {}", e)))?
    } else {
        println!("üìä Using empty graph for query generation");
        Graph::new().map_err(|e| {
            ggen_utils::error::Error::new(&format!("Failed to create empty graph: {}", e))
        })?
    };

    // Use global config for proper provider detection
    let global_config = ggen_ai::get_global_config();

    let client: Arc<dyn LlmClient> = if args.mock {
        println!("‚ÑπÔ∏è  Using mock client for testing");
        Arc::new(MockClient::with_response(
            "SELECT ?s ?p ?o WHERE { ?s ?p ?o }",
        ))
    } else {
        println!("‚ÑπÔ∏è  Using {} provider", global_config.provider_name());

        // Create client with proper configuration
        if let Some(model) = &args.model {
            // Use custom model if specified
            let llm_config = LlmConfig {
                model: model.clone(),
                max_tokens: args.max_tokens,
                temperature: args.temperature,
                top_p: Some(0.9),
                stop: None,
                extra: std::collections::HashMap::new(),
            };
            Arc::new(
                GenAiClient::new(llm_config)
                    .map_err(|e| ggen_utils::error::Error::from(anyhow::anyhow!(e.to_string())))?,
            )
        } else {
            // Use contextual client with auto-detection
            global_config
                .create_contextual_client()
                .map_err(|e| ggen_utils::error::Error::from(anyhow::anyhow!(e.to_string())))?
        }
    };

    let generator = SparqlGenerator::new(client);

    // Generate SPARQL query
    let sparql_query = generator
        .generate_query(&graph, &args.description)
        .await
        .map_err(|e| ggen_utils::error::Error::from(anyhow::anyhow!(e.to_string())))?;

    println!("‚úÖ SPARQL query generated successfully!");

    // Convert to requested format
    let output_content = match args.format.as_str() {
        "json" => {
            println!("üîÑ Converting SPARQL to JSON format...");

            // Create JSON representation of the SPARQL query
            let json_sparql = json!({
                "query": sparql_query.trim(),
                "description": args.description,
                "generated_at": chrono::Utc::now().to_rfc3339(),
                "graph_info": if args.graph.is_some() {
                    json!({
                        "source": args.graph
                    })
                } else {
                    json!(null)
                }
            });

            serde_json::to_string_pretty(&json_sparql).map_err(|e| {
                ggen_utils::error::Error::new(&format!("Failed to serialize JSON: {}", e))
            })?
        }
        "sparql" | _ => {
            println!("üìÑ Returning SPARQL format...");
            format!(
                "# Generated SPARQL Query\n\
                 # Description: {}\n\
                 # Generated by ggen-ai\n\
                 # Generated at: {}\n\
                 \n{}",
                args.description,
                chrono::Utc::now().to_rfc3339(),
                sparql_query.trim()
            )
        }
    };

    if let Some(output_path) = &args.output {
        fs::write(output_path, &output_content)?;
        println!("üìÅ Saved to: {}", output_path);
    } else {
        println!("üìÑ Generated SPARQL query:");
        println!("{}", output_content);
    }

    Ok(())
}
